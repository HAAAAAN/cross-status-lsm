[{"repo": "ChezScheme", "type": "elite", "title": "", "number of text": 338, "text": "  Thanks for finding and fixing this bug!  All the Windows mats passed! It compiles cleanly in Microsoft Visual Studio, and so far the ta6nt mats are passing.  Would this be clearer?\r\n\r\nP is of the form #(P1 ...  Pk Pe ellipsis S1 ... Sm), where ellipsis is the identifier ... and F is a vector of n elements with n >= k+m whose first k elements match P1 through Pk, whose next n-m elements each match Pe, and whose remaining m elements match S1 through Sm. Thanks! Second try:\r\n\r\nP is of the form #(P1 ... Pk Pe ellipsis S1 ... Sm), where ellipsis is the identifier ... and F is a vector of n elements with n >= k+m whose first k elements match P1 through Pk, whose next n-k-m elements each match Pe, and whose remaining m elements match S1 through Sm.  This pull request aims to help answer support questions like:\r\n1. what source did I build in this particular workarea?\r\n1. what source was used to build this installed binary?\r\n\r\nMy original stab at this exposed a `#%$scheme-revision` that we could get at via the repl. That was convenient at run time, but the extra rounds of bootstrapping made that approach irritating at compile time.\r\n\r\nI've since scaled back to the much simpler approach of recording minimal revision-control information in a `revision` file alongside the boot files. This seems to work well enough for my use cases.\r\n\r\nThe `update-revision` script could be extended for folks who mirror the git source in some other revision control system. The git attributes on `update-revision` insert the appropriate revision if folks export the source code via `git archive` or download a tarball or zip file from github.\r\n\r\nThe WiX updates are guesswork, but seemed to work.\r\n Thanks for looking this over, Bob. I updated the LOG and rebased.\r\n\r\nBefore merging anything from this branch, I'd like to know whether @dybvig is open to merging \r\nonly d0c9ad1a37adfa7c746a4ad1388816380654b905, or\r\n1. squashing in _variation 1_ 162c044d7a0e9d56b197d95119c6112d511aabb1, or\r\n2. squashing in _variation 2_ a8ba65329ae752886d7babedfc16cce13080729f, or\r\n3. squashing in both _variation 1_ and _variation 2_ with that base commit\r\n\r\n... or whether he wants no part of this. It has been really handy for our internal development.\r\n  The changes look good! I built the Windows versions and linked them against another library successfully. Please rebase onto master.  This pull request exposes a `library-search-handler` parameter to permit more control over the search for libraries during `import`, `compile-whole-library`, and `compile-whole-program`. Thanks for the quick feedback. I force-pushed changes to incorporate your comments.\r\n\r\nI exposed `default-library-search-handler` which turned out to be a good thing all around. It let me be more precise with `$oops`. It enlisted `check-prim-arg-errors` which caught me being lax in checking the library name. It may even have clarified the documentation.  Actually, it doesn't make sense for (/ 0 _x_), where _x_ is a floating-point number, to be anything other than 0, since a floating-point number is never true 0 (just very small on either side of 0) and never truly infinite (just possibly very large, i.e., the reciprocal of a very small number).  We got this wrong in R6RS.  We should correct it for the version of / exported by (chezscheme) and leave the broken behavior for (rnrs).  Thanks for mentioning this...I'll look into it and push a fix shortly. This should be fixed by [this commit](https://github.com/cisco/ChezScheme/commit/21c8b40bbe4431795824e48042112820872a1fe5).  Try displaying to `(console-output-port)` rather than the default `(current-output-port)`.  It could be that the current output port has been redirected at the point where the error occurs.  You might also want to use `display-condition` rather than display for the condition.  It's neither a bug nor a feature...`#0=#0#` (which shouldn't mean anything) was just a little joke I added a long time ago for those who trip over it.  I'm not sure anyone has before, and it's been over 30 years.  Internally, `#0=#0#` is referred to as the black hole, though I like Ouroboros better.\r\n\r\nClearly, the reader needs to be extended to handle mutually recursive cases like `'(#0=#1# #1=#0#)` for the next person who trips on it.  There's probably no hurry, though. :)  Just putting this into testit.scm fails:\r\n\r\n```\r\n(scheme-start\r\n  (lambda ()\r\n    (foreign-callable void () void)))\r\n```\r\n\r\nso it's something about evaluating a `foreign-callable` form at boot time. You suspicion that this is connected with static memory is correct.  When any code object is relocated into the static generation, its relocation table is dropped, since it won't ever need to be relocated again.  Each time a foreign-callable form is evaluated, however, a copy of the original code object is created with a pointer to the Scheme procedure to be invoked embedded in it.  The relocation table is needed both to find the proper location for the embedded pointer and because the freshly allocated code object might be relocated by the collector.  Since the static code object in your example is missing its relocation table, the code that creates the copy of the foreign-callable code object crashes.\r\n\r\nSolving this probably involves setting a flag on each foreign-callable code object to say its relocation table should not be dropped.  In the meantime, a workaround is to arrange for the foreign-callable form to be evaluated at boot time (before the relocation table has been dropped), not when `(scheme-start)` is invoked.   For example, the following variation of your example doesn't crash:\r\n\r\n```\r\n(top-level-program\r\n  (import (chezscheme))\r\n\r\n  (define code (foreign-callable (lambda ()\r\n                                   (display \"Hello world\\n\")\r\n                                   ) () void))\r\n\r\n  (define (main)\r\n    (display \"back from foreign-callable\\n\")\r\n    (lock-object code)\r\n    (foreign-callable-entry-point code)\r\n\r\n    (exit 0)\r\n    )\r\n  (scheme-start\r\n    (lambda ()\r\n      (main)))\r\n  )\r\n```\r\n This should be fixed by [this commit](https://github.com/cisco/ChezScheme/commit/71d3abba684e04b134720ea1bd9a8c847c38ac5f).  Thanks for the fix!  Thanks @Neowizard for reporting the error and @owaddell for the fix.  Thanks!  Thanks for the fix!  Thanks for the fix!  Thank you for this pull request!  Thanks for the suggestion, @mromyers.  I'll take a look at the slides when I get a chance, though I know how to go about saving the Chez Scheme heap from prior experience.\r\n\r\nA warning for anyone else considering working on saved heaps for Chez Scheme: The slides are as deep as we can go, unless there's a more detailed writeup.  Unless I'm mistaken, the Emacs source code is GPL'd, so even if someone just perused the code to gain knowledge of its workings before working on an implementation for Chez Scheme, that could taint our (permissive open-source) code.  I've just added a mention of --threads to BUILDING as requested.  Thanks for the pull request.  Can the code actually reference uninitialized values, i.e., is the chunk not fully initialized by the call that follows the getmem call?  If so, zero-filling is likely not an appropriate solution.  If not, I'd rather not introduce the extra overhead just to satisfy valgrind. Do you happen to know what is going on when it happens?  For example, does it happen when running a particular test in the mats?\r\n\r\nI've stared at copy() a bit and it looks like one possible culprit is the seginfo `trigger_empherons` field, which does seem to be referenced without being set.  Would you please try initializing it to NULL in `segment.c:initialize_seginfo` and see if that resolves the issue? Thanks for bringing this to my attention and for narrowing it down.  I've confirmed the issue and have a more surgical fix, which is to add the following two lines to `initialize_seginfo` in segment.c:\r\n```\r\n  si->sorted = 0;\r\n  si->trigger_ephemerons = NULL;\r\n```\r\nWith this fix, valgrind doesn't turn up any errors with the empty program or when rebuilding in the s directory or running the mats.\r\n\r\nWould you like to alter your pull request to replace zero-filling with these two lines?  If so, please also add a brief entry in LOG.\r\n  Many thanks to @stergiotis, all others who contributed, and especially to @mflatt for fixing the issues.  The semantics of the interaction environment support redefinition of (actually assignment of) variables, but the exported variables of a library are immutable both inside and outside of the library.  So it's not presently possible.  You could change the semantics with changes to the expander and possibly cp0.  Or you could work with the existing semantics, which allows entire libraries to be redefined, if you arrange to re-evaluate any code that was compiled against the redefined libraries. You can use `library-list` to get the set of loaded libraries and `library-requirements` to get a list of each library's dependencies.  With that you can build a dependence graph to determine the set of libraries that depend on a given library.   These changes look good, thanks!  I've pushed a fixed for the one typo not fixed by goober99's pull request (the missing connector between \"create\" and \"process\") so I'm closing this issue.  Thanks for the corrections!  The thread system itself isn't the slow part. The division operator makes a call to S_div, which allocates a ratnum. The allocation requires the global tc mutex when the current segment is exhausted. I don't know why this takes so long on both macOS and Windows. Replacing / with quotient resolves the problem by eliminating the allocation. Replacing / with cons also works.\r\n\r\n```\r\n(define (f x y)\r\n  (do ([i 1000000 (- i 1)])\r\n      [(= i 0)]\r\n    (/ x y)))\r\n\r\n(define (doit)\r\n  (let ([start (statistics)])\r\n    (f 1 2)\r\n    (sstats-difference (statistics) start)))\r\n\r\n(define (go n)\r\n  (display-string \"Regular:\\n\")\r\n  (sstats-print (doit) (current-output-port))\r\n  (flush-output-port)\r\n  (let ([m (make-mutex)]\r\n        [c (make-condition)])\r\n    (define (work)\r\n      (let ([s (doit)])\r\n        (with-mutex m\r\n          (display-string \"\\nThread:\\n\")\r\n          (sstats-print s (current-output-port))\r\n          (flush-output-port)\r\n          (set! n (- n 1))\r\n          (when (= n 0)\r\n            (condition-signal c)))))\r\n    (with-mutex m\r\n      (do ([i n (- i 1)]) [(= i 0)] (fork-thread work))\r\n      (condition-wait c m))))\r\n```\r\n I've been looking into this and have uncovered a couple of issues.  First, the call to '/' causes the allocation of a ratnum in number.c using thread_get_more_room.  thread_get_more_room is designed to allocate from the thread-local allocation pointer if space is available there, and it does for the first set of ratnums.  It does not, however, cause a new local allocation area to be created when the existing one is exhausted, so if no other allocation occurs, it performs a global allocation.  Importantly, particularly on OSX and possibly on Windows, is that this causes the tc mutex to be acquired on each call to '/'.   This leads to the second issue, which is that mutexes under heavy contention are much slower on OSX, and perhaps on Windows, than one would expect, as has been noted in other posts.  I don't know if we can do anything about the latter problem.  I tried setting the OSX-specific _PTHREAD_MUTEX_POLICY_FIRSTFIT, which is supposed to help matters, but this appears to result in deadlock, as has also been noted in other posts.  I will try to fix the former problem. I've [pushed a change](https://github.com/cisco/ChezScheme/commit/93dfa7674a95837e5a22bc622fecc50b0224f60d) to address the first issue described in my preceding note.  Exactly, and since the system does not generate the unique name until it's needed (by the repl in this case _after_ the call to time), time wouldn't show the elapsed time.\r\n\r\nTry this instead:\r\n(time (pretty-print (gensym))  Thanks for the helpful suggestion! I updated the instructions in 41eca9aeea5d036877d09f996414c1f9311ecdb8.  Thanks for posting this in case others run into the same thing.  Is git configured to use Windows line endings? If so, it may checkout configure with CRLF line endings. Great! I added a sentence about this in 1c3a605c6218303f651eec1a8afa5d0bc91337ee.  Thank you for pointing this out! The Windows version of Chez Scheme is not affected by this, and the Linux and Mac versions should be able to use uuid_generate to avoid it. I have a proposed update on branch rgburger/uuid, but I don't know how to configure the Travis CI server to find the 32-bit uuid-dev libraries on Linux. Any ideas? Thanks, that worked! This issue is fixed in 2fd3db68230d094a0d396348a8140a4d3693b120.  Merged and committed.  Thanks!  Thanks for fixing this!  If we make this change, then on non-X11 macOS systems, Chez Scheme's expression editor won't have pasteboard support. @akeep and I would prefer to see a change that supports the pasteboard even when X11 is not installed. Thanks, it would be great if you could unentangle the X11 clipboard and macOS pasteboard in the expression editor. Thanks, @akeep! @tison1, thank you for this pull request!  Thanks!  @dybvig What rules do we need to follow when updating the copyright year?  I don't have XQuartz installed, so I cannot compile Chez Scheme for macOS without modifying c/version.h to remove the LIBX11 definition for macOS. I would welcome a pull request that adds a check for X11/Xlib.h and allows systems without it to compile. @akeep, thanks!  @mflatt The a6nt `foreign.mo` foreign-callable clause 29 mat fails:\r\n```\r\n(eqv?\r\n  (let ()\r\n    (define-ftype foo (function (fixnum fixnum ptr) fixnum))\r\n    (define f\r\n      (lambda (n m k)\r\n        (if (fx= n 0)\r\n            (k m)\r\n            (if (fx= (fxmodulo n 10) 0)\r\n                (k (call/cc (lambda (k) (g (fx- n 1) (fx+ m 1) k))))\r\n                (g (fx- n 1) (fx+ m 1) k)))))\r\n    (define fptr (make-ftype-pointer foo f))\r\n    (define g (ftype-ref foo () fptr))\r\n    (let ([v ($with-exit-proc\r\n               (lambda (k) (f $stack-depth $base-value k)))])\r\n      (unlock-object\r\n        (foreign-callable-code-object (ftype-pointer-address fptr)))\r\n      v))\r\n  (+ $stack-depth $base-value))\r\nError in mat foreign-callable clause 29: \"invalid memory reference.  Some debugging context lost\" at line 2364, char 3 of foreign.ms\r\n```\r\n\r\nWhen run in isolation, this particular test passes. It seems to require a couple of the previous expressions. It passes on ta6nt, i3nt, and ti3nt.\r\n\r\nCommit https://github.com/cisco/ChezScheme/commit/aa1c2c4ec95c286a12730ea75588a18dd9fb9d59 triggered this failure on a6nt, but I don't think it caused it. When I cherry-pick this commit back to a branch from the foreign-procedure changes (de860f2f4c50eeda7e540b7b44fd7d0d1b7dad90), the `foreign.mo` mats pass. Immediately after those changes, it fails. I suspect some heap corruption in the foreign-procedure/callable code on 64-bit Windows. I get it by running `make foreign.mo` and then looking for the word `clause` in foreign.mo. I am using Visual Studio 2017 Version 15.7.1. I'm now using Visual Studio 2017 version 15.7.3 on Windows 10 version 1803.\r\n```\r\n$ git clean -fxd .\r\n$ ./configure -m=a6nt\r\n$ cd a6nt\r\n$ make\r\n$ cd mats\r\n$ make foreign.mo\r\n```\r\n\r\nI don't get the invalid memory reference if I compile in Debug mode. I don't get the invalid memory reference if I compile with /Os (optimize for space) instead of /Ox (optimize for speed). This may indicate a problem with the C code. No invalid memory references when compiled with Visual Studio 2015. Hmmm, we might be tickling a Visual Studio 2017 compiler bug here. The `volatile ptr tc` eliminates the invalid memory references for me. That was a great idea! I looked at the assembly output with various combinations of volatile. The one you recommend does not use rsp after setjmp except when it exits. I think we bumped into a bug with setjmp/longjmp and the MSVC compiler. It also worked for me when no variable was declared volatile. I recommend declaring both volatile. @mflatt Thank you very much for the fix! Now all the mats pass on all platforms. See commit https://github.com/cisco/ChezScheme/commit/c2d2467d48eea145455124343c8819dfb683c39e.  Thanks for the fix! Please use `VirtualProtect(p + si.dwPageSize, si.dwPageSize, PAGE_NOACCESS, &dummy)` in Windows. ```\r\nEXPORT void *malloc_at_boundary(int sz)\r\n{\r\n  SYSTEM_INFO si;\r\n  char *p;\r\n  DWORD dummy;\r\n  GetSystemInfo(&si);\r\n  p = VirtualAlloc(NULL, si.dwPageSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\r\n  VirtualProtect(p + si.dwPageSize, si.dwPageSize, PAGE_NOACCESS, &dummy);\r\n  return p + si.dwPageSize - sz;\r\n}\r\n``` Thanks, that makes sense. Thanks again for this fix!  @mflatt The a6nt `foreign.mo` mats fail earlier than the a6le mat shown above:\r\n```\r\n(eqv?\r\n  (let ()\r\n    (define-ftype foo (function (fixnum fixnum ptr) fixnum))\r\n    (define f\r\n      (lambda (n m k)\r\n        (if (fx= n 0)\r\n            (k m)\r\n            (if (fx= (fxmodulo n 10) 0)\r\n                (k (call/cc (lambda (k) (g (fx- n 1) (fx+ m 1) k))))\r\n                (g (fx- n 1) (fx+ m 1) k)))))\r\n    (define fptr (make-ftype-pointer foo f))\r\n    (define g (ftype-ref foo () fptr))\r\n    (let ([v ($with-exit-proc\r\n               (lambda (k) (f $stack-depth $base-value k)))])\r\n      (unlock-object\r\n        (foreign-callable-code-object (ftype-pointer-address fptr)))\r\n      v))\r\n  (+ $stack-depth $base-value))\r\nError in mat foreign-callable clause 29: \"invalid memory reference.  Some debugging context lost\" at line 2364, char 3 of foreign.ms\r\n```\r\n\r\nFor some reason, these mats pass for ta6nt. I hope that both of the mat failures shown in this issue have the same root cause.\r\n\r\nMy recent commit https://github.com/cisco/ChezScheme/commit/aa1c2c4ec95c286a12730ea75588a18dd9fb9d59 triggered this failure on a6nt, but I don't think it caused it. When I cherry-pick my commit back to a branch from the foreign-procedure changes (de860f2f4c50eeda7e540b7b44fd7d0d1b7dad90), the `foreign.mo` mats pass. Immediately after those changes, it fails. I suspect some heap corruption in the foreign-procedure/callable code. @mflatt If you'd like to have a stronger Windows version of `malloc_at_boundary` and `free_at_boundary`, you can call `VirtualAlloc` instead of `mmap`, `VirtualProtect` instead of `mprotect`, and `VirtualFree` instead of `munmap`. See `S_getpagesize()` in `c/windows.c` for the way to query the page size. Thanks for the quick fix! As expected, it did not fix the invalid memory reference on a6nt. There must be something else going on. Thanks for looking into it! The pull request fixed the main issue, thank you! I put the secondary issue into https://github.com/cisco/ChezScheme/issues/322.  Thanks for finding this inconsistency with the code in the examples folder. I updated the documentation to be in sync with the code and added 64-bit Linux to the machine-case. See https://github.com/cisco/ChezScheme/commit/5bdf715809e5847dfa0807216bcc6d0dac2f10ea. We update the web pages more frequently than stable releases. Since the last update was from March, I just checked in a new update. Thanks for pointing this out!  @dybvig To summarize, there are two bugs in the current code base. The C code has `S_get_scheme_arg(tc, 0)` instead of `S_get_scheme_arg(tc, 1)`. Once that is corrected, the return value is junk because the invoke code object doesn't save the scheme-arg registers. I propose a change that corrects the C code and the invoke code to save the scheme-arg registers. Will doing so break anything else? Fixed in commit https://github.com/cisco/ChezScheme/commit/7fd080903d96a1ef9ab79780bf73aa1619f33894.  The master branch ran into a [similar timeout on ti3osx](https://travis-ci.org/cisco/ChezScheme/builds/419879954), so I restarted the ta6osx tests.  I like the change, but I think there are a few things missing from the WIP change.\r\n\r\nIf you look at what we did for `visit-code` and `invoke-code`, we wrap the `on-reset` around the both invoking the appropriate thunk as well as doing the recursive processing on the invoke and/or visit requirements.  I think the `on-reset` for `import-library` should do the same.\r\n\r\nThe other thing you'll notice if you look at the `visit-code` is that we are also resetting the compile time environment, because it was possible to construct situations where part of the visit code thunk had run, leaving the compile-time environment in an inconsistent state.  It seems like this could also happen in the import code where exported identifiers are bound to indicate the they are either invoke (aka library-global) or visit identifiers and the module interface for the library is also added to the compile time environment.  If we really want to roll this back we may need to unset these in the compile time environment on import reset.  Unfortunately, that would require that we capture the exported invoke-time (aka revisit time) identifiers just as we do with the visit identifiers, so that we know what we are resetting.\r\n\r\nPart of the reason I didn't do this when I was working on changing this for the `visit-code` and `invoke-code` procedures was that I didn't think there was ever anything in the body of the import code thunk that could cause an error to be raised, since we were just setting bindings in the compile-time environment to constants (either #f or the interface module), but it sounds like there was something I missed in the potential generated code?\r\n\r\nI like the cleaned up error message, definitely better to see the library code error rather than an unknown module error when you were trying to import a library.  Yes the interpreter is part of the Chez Scheme system (and is tested as part of the automated tests).\r\n\r\nThe executable for both Chez Scheme and Petite Chez Scheme (the interpret) is the same, with the default names of `scheme` and `petite` where `petite` is a hard link to `scheme`.  If you look at the installed files with Chez Scheme you'll see that there is a `petite.boot` and `scheme.boot` when `petite` is run, only `petite.boot` is loaded.  This boot file contains the core Chez Scheme libraries and the interpreter.  When `scheme` is run, it loads both the `petite.boot` file and the `scheme.boot` file, and the `scheme.boot` file contains the compiler.\r\n\r\nIt is worth noting that both use the same C run time and the interpreter (as well as compiler for that matter) is written in Scheme, as are many of the basic Scheme libraries, with support from the run time.\r\n\r\nI'm not sure how the interpreter existing helps with making Chez Scheme embeddable on iOS, but I've not looked at the iOS constraints in a while.  Looks good, thanks for the edits!  The [Chez Scheme User's Guide](https://cisco.github.io/ChezScheme/csug9.5/libraries.html#./libraries:h2) indicates that `scheme-script` is equivalent to `scheme --program`. The use of _script_ in two different contexts is confusing. Thanks for this pull request!  I'm not an emacs user, so I'm not really sure what this tool is, or what you would need from Chez Scheme to support it.\r\n\r\nThe Chez Scheme documentation is written in [stex](https://github.com/dybvig/stex) an extension on LaTeX that generates pdf and html output, with the standard R6RS Scheme library documented in [The Scheme Programming Language](https://scheme.com/tspl4/), but is not part of the Chez Scheme source repository.  As @jltaylor-us mentioned, there is no module or library here, so I'm not sure what you mean by that.  However, the `file` command can be pretty useful in the debugger to figure out where the error occurred.  From your example:\r\n\r\n```\r\n% scheme --debug-on-exception --program /tmp/foo.scm\r\nException: attempt to apply non-procedure 1\r\ndebug> i\r\n#<continuation>                                                   : sl\r\n  continuation:          #<system continuation in ksrc>\r\n  procedure code:        (lambda () (letrec* ((...) (...)) ((...))))\r\n  call code:             (bar)\r\n#<continuation>                                                   : file\r\nline 5, character 5 of /tmp/foo.scm\r\n#<continuation>                                                   : \r\n```\r\n\r\n`file` tells you that this exception was thrown at line 5, column 5 of the file (which I put in `/tmp`).  I've merged #299, which as @jltaylor-us notes addresses the problem with gcc-8.  Thanks to @weinholt for the patch.\r\n\r\nSource pulled from GitHub should now build with gcc-8, and I've successfully tested on Fedora 28.  Normally, for any supported non-threaded build (like `i3osx`, `a6osx`,` i3le`, `a6le`, etc.) there would be an associated threaded version that starts with a `t` (like `ti3osx`, `ta6osx`, `ti3le`, `ta6le`, etc.).  It looks like when the arm32 port was done, the `tarm32le` version wasn't fully fleshed out.  I'm not sure why exactly, but I suspect at the time it was done (before it was open sourced) we didn't have a need for the threaded version.\r\n\r\nI wasn't involved in the original arm port, but it should be possible to add the threading support.  It will likely mean adding the missing instructions to support the threaded features (including recently added features), and adding the `Mf-tarm32le` and `tarm32le.def` files.  I think we could keep the `FMTBUFSIZE` slightly shorter, but when I computed a worst case for the format string that fails it was pretty close to 120 bytes long, though `gcc` seems to do a little more precise computation than I feared it was doing.  At any rate, I think 120 is okay for the buffer here.\r\n\r\nThanks for the update! From my reading it sounds like an error return value indicates a wide\ncharacter or other encoding problem in the format string, and since in the\nusage within this print out we know the characters are ascii, I'm not sure\nthose kinds of errors can occur here.  Are there other errors you are\nworried about us catching in this code?\n\n-andy:)\n\n\n\nOn May 23, 2018 at 2:35:43 AM, Saigut (notifications@github.com) wrote:\n\nThe valid return value of snprintf is '0 <= return value < buffer size'.\nBut in C code of Chez Scheme, it seems that all return value of snprintf\nhave not been properly checked.\n\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\n<https://github.com/cisco/ChezScheme/pull/299#issuecomment-391236282>, or mute\nthe thread\n<https://github.com/notifications/unsubscribe-auth/AAG5r26FDUPMKM8pcQqCg3-rxrQ8UreHks5t1QMzgaJpZM4Ty_Tc>\n.\n  In both cases this is not allowed because R6RS dictates that a library is:\r\n\r\n> A library definition must have the following form:\r\n> \r\n> ```\r\n> (library <library name>\r\n>   (export <export spec> ...)\r\n>   (import <import spec> ...)\r\n>   <library body>)\r\n> ```\r\n\r\nand continues to say that:\r\n\r\n> A <library body> is like a <body> (see section 11.3) except that a <library body>s need not include any expressions. It must have the following form:\r\n> \r\n> ```\r\n> <definition> ... <expression> ...\r\n> ```\r\n> When begin, let-syntax, or letrec-syntax forms occur in a top-level body prior to the first expression, they are spliced into the body; see section 11.4.7. Some or all of the body, including portions wrapped in begin, let-syntax, or letrec-syntax forms, may be specified by a syntactic abstraction (see section 9.2).\r\n\r\nFrom the [R6RS Spec, Chapter 7](http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-10.html#node_chap_7)\r\n\r\nIn this case the:\r\n\r\n```scheme\r\n  (record-writer (type-descriptor test-a)\r\n                 (lambda (r p wr) #f))\r\n```\r\n\r\nCall is an expression so it cannot proceed a definition.  There are a couple of ways to work around this.  Since you are using Chez Scheme's library you can use Chez Scheme's `module` form to wrap the expression:\r\n\r\n```scheme\r\n  (module ()\r\n     (record-writer (type-descriptor test-a)\r\n                    (lambda (r p wr) #f)))\r\n```\r\n\r\nA `module` is always a definition, even when it contains expressions.  You can also wrap a `define` around at (effectively defining it for effect).\r\n\r\n```scheme\r\n  (define ignore\r\n     (record-writer (type-descriptor test-a)\r\n                    (lambda (r p wr) #f)))\r\n```\r\n\r\nYou are also correct that the error message when you put the `define-record-type` exposes the fact that `define-record-type` is defined as a macro that expands into a set of definitions using the underlying procedural interface for the record system.  Since `define-record-type` is just a normal macro like any macro a user might define, the expander has to expand it to determine whether it is a definition or an expression.  You can also use `expand` at the repl to see this though, so I'm not sure how much it is really exposing.  Although it is worth noting that the `define` you see in the error message would have either been expanded into a top-level `set!` or part of a `letrec*` depending on context---`define`s are only treated as top-level set! at the top-level, within a body, such as inside a program, library, or the body of a lambda, it becomes a `letrec*`.  Hmm... I tried to reproduce this, but I didn't see the error you encountered.  I might expect something like that if you were running out of space, had some disk issue, or had some memory issue.\r\n\r\nHere's what I did to try to reproduce:\r\n\r\n1. Installed vagrant machine for Linux Mint 18.2: ``vagrant-fjp/mint-18.2 ``\r\n   ```\r\n   $ vagrant init vagrant-fjp/mint-18.2\r\n   $ vagrant up\r\n   $ vagrant ssh\r\n   ```\r\n\r\n1. Install the dependencies on Mint that I needed (I've gathered them up here, I discovered them experimentally):\r\n   ```\r\n   $ sudo apt install git build-essential libncurses-dev libx11-dev\r\n   ```\r\n\r\n1. Get Chez Scheme via ``git``:\r\n   ```\r\n   $ git clone https://github.com/cisco/ChezScheme cs\r\n   ```\r\n\r\n1. Configure and build:\r\n   ```\r\n   $ cd cs\r\n   $ ./configure\r\n   $ make\r\n   ```\r\n\r\n1. Run the tests (with output to ``Make.out``---using ``bash``):\r\n   ```\r\n   $ make test &> Make.out &\r\n   ```\r\n\r\n1. Check the mats output:\r\n   ```\r\n   $ cat a6le/mats/summary \r\n   -------- o=0 --------\r\n   -------- o=3 --------\r\n   -------- o=0 cp0=t cl=3 --------\r\n   -------- o=3 cp0=t cl=3 --------\r\n   -------- o=0 spi=t p=t --------\r\n   -------- o=3 spi=t p=t --------\r\n   -------- o=0 eval=interpret cl=6 --------\r\n   -------- o=3 eval=interpret cl=6 --------\r\n   -------- o=0 cp0=t eval=interpret --------\r\n   -------- o=3 cp0=t eval=interpret --------\r\n   -------- o=0 ehc=t eoc=f cl=9 --------\r\n   -------- o=3 ehc=t eval=interpret --------\r\n   ```\r\n\r\nJust for the record, here is what ``uname`` and ``gcc`` information:\r\n\r\n```\r\n$ uname -a\r\nLinux vagrant-VirtualBox 4.8.0-53-generic #56~16.04.1-Ubuntu SMP Tue May 16 01:18:56 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\r\n```\r\n\r\n```\r\n$ gcc --version\r\ngcc (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\r\nCopyright (C) 2015 Free Software Foundation, Inc.\r\nThis is free software; see the source for copying conditions.  There is NO\r\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n```  Thanks for the fix, the previous description was a bit confusing \ud83d\ude00   Hmm... I cannot reproduce the error you are seeing.\r\n\r\nI downloaded ``json.sc`` source, the ``exemple.sc`` source, put the ``json.sc`` file in the ``json`` directory and then did the following:\r\n\r\n```\r\n% scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (library-extensions (cons (cons \".sc\" \".so\") (library-extensions)))\r\n> (import (json json))\r\n> (load \"exemple.sc\")\r\n> y\r\n((\"1\" .\r\n      #(((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n          (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n          (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))\r\n        ((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n          (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n          (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))\r\n        ((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n          (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n          (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))))\r\n  (\"2\" .\r\n       #(((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))\r\n         ((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))\r\n         ((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))))\r\n  (\"3\" .\r\n       #(((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))\r\n         ((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5))))\r\n         ((\"1\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"2\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))\r\n           (\"3\" . #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))))))\r\n> (json-reduce y #t #t #t #t (lambda (x y) x))\r\n((\"1\" .\r\n      #(((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))\r\n        ((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))\r\n        ((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))))\r\n  (\"2\" .\r\n       #(((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))\r\n         ((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))\r\n         ((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))))\r\n  (\"3\" .\r\n       #(((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))\r\n         ((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2)))\r\n         ((\"1\" . #(0 1 2)) (\"2\" . #(0 1 2)) (\"3\" . #(0 1 2))))))\r\n```\r\n\r\nI even tried adding an extra ``#t``:\r\n\r\n```\r\n> (json-reduce y #t #t #t #t #t (lambda (x y) x))\r\n((\"1\" .\r\n      #(((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n          (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n          (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))\r\n        ((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n          (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n          (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))\r\n        ((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n          (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n          (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))))\r\n  (\"2\" .\r\n       #(((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))\r\n         ((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))\r\n         ((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))))\r\n  (\"3\" .\r\n       #(((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))\r\n         ((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4))))\r\n         ((\"1\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"2\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))\r\n           (\"3\" . #(#(0 1 2 3 4) #(0 1 2 3 4) #(0 1 2 3 4)))))))\r\n ```\r\n\r\nYou might try expanding the macro to see if the code you are generating is the same as what you expected. Ugh.  That is what I get for trying to do more than one thing at once.  Sorry.\r\n\r\nSo, the failure happens because one of the ``lambda`` expressions generated by the macro is called with a single argument (I changed my copy of ``json.sc`` to export ``reduce`` and not ``json-reduce`` so that I could run this on the command line):\r\n\r\n```scheme\r\n% scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (library-extensions (cons (cons \".sc\" \".so\") (library-extensions)))\r\n> (import (json))\r\nException: library (json) not found\r\nType (debug) to enter the debugger.\r\n> (import (json json))\r\n> (load \"json/exemple.sc\")\r\n> (define-syntax json-reduce\r\n    (lambda (x)\r\n      (syntax-case x ()\r\n        ((_ j v1 p) #'(reduce j v1 p))\r\n        ((_ j v1 v2 p) #'(json-reduce j v1 (lambda (x y) (json-reduce y v2 (lambda (n m)(p (cons n x) m))))))\r\n        ((_ j v1 v2 v3 p ...) #'(json-reduce j v1 v2 (lambda (x y) (json-reduce y v3 (lambda (n m)(p (cons n x) m)))) ...)))))\r\n> (json-reduce y #t #t #t #t  (lambda (x y) x))\r\nException: incorrect number of arguments to #<procedure>\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nNow we can look at this in the debugger:\r\n\r\n```scheme\r\n> (debug)\r\ndebug> i \r\n#<continuation in l>                                              : s\r\n  continuation:          #<continuation in l>\r\n  procedure code:        (lambda (x v p) (if (null? x) (quote ()) ...))\r\n  call code:             (v (caar x))\r\n  frame and free variables:\r\n  0. x:                  ((\"1\" . #(...)) (\"2\" . #(...)) ...)\r\n  1. v:                  #<procedure>\r\n  2. p:                  #<procedure>\r\n#<continuation in l>                                              : file\r\nline 303, character 41 of json/json.sc\r\n#<continuation in l>                                              : \r\n```\r\n\r\nSo, looks like line 303, character 41 of my modified (one line longer at the start with the ``reduce`` export) at the start:\r\n\r\n```\r\n299                         ((procedure? v)\r\n300                             (let l ((x x)(v v)(p p))\r\n301                                 (if (null? x)\r\n302                                     '()\r\n303                                     (if (v (caar x))   ; <== right here the procedure v is called with one arg\r\n304                                         (cons (cons (caar x) (p (caar x) (cdar x)))(l (cdr x) v p))\r\n305                                         (cons (cons (caar x) (cdar x)) (l (cdr x) v p ))))))\r\n```\r\n\r\nSo, what happened?  We can look at the expansion of the macro with ``expand``:\r\n\r\n```scheme\r\n> (print-gensym 'pretty)\r\n> (expand '(json-reduce y #t #t #t #t  (lambda (x y) x)))\r\n(begin\r\n  (#3%$invoke-library '(json json) '() '#:json)\r\n  (reduce\r\n    y\r\n    #t\r\n    (lambda (#:x #:y)\r\n      (reduce\r\n        #:y\r\n        #t\r\n        (lambda (#:n #:m)\r\n          (let ([#:x (#2%cons #:n #:x)] [#:y #:m])\r\n            (reduce                    ;; <== This is the call to reduce that fails.\r\n              #:y\r\n              (lambda (#:x #:y)  ;; <== This is the lambda expression that is called, it expects 2 arguments, but only gets one.\r\n                (reduce\r\n                  #:y\r\n                  #t\r\n                  (lambda (#:n #:m) (#t (#2%cons #:n #:x) #:m))))\r\n              (lambda (#:n #:m)\r\n                (let ([#:x (#2%cons #:n #:x)] [#:y #:m])\r\n                  (reduce\r\n                    #:y\r\n                    #t\r\n                    (lambda (#:n #:m)\r\n                      (let ([#:x (#2%cons #:n #:x)] [#:y #:m])\r\n                        #:x))))))))))))\r\n```\r\n\r\nSo, it looks like the macro is not produce the code you intended.  A good tool for looking at this is ``trace-define-syntax``:\r\n\r\n```scheme\r\n> (trace-define-syntax json-reduce\r\n    (lambda (x)\r\n      (syntax-case x ()\r\n        ((_ j v1 p) #'(reduce j v1 p))\r\n        ((_ j v1 v2 p) #'(json-reduce j v1 (lambda (x y) (json-reduce y v2 (lambda (n m)(p (cons n x) m))))))\r\n        ((_ j v1 v2 v3 p ...) #'(json-reduce j v1 v2 (lambda (x y) (json-reduce y v3 (lambda (n m)(p (cons n x) m)))) ...)))))\r\n> (expand '(json-reduce y #t #t #t #t  (lambda (x y) x)))\r\n|(json-reduce (json-reduce y #t #t #t #t (lambda (x y) x)))\r\n|(json-reduce y #t #t (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n   (lambda (x y)\r\n     (json-reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m)))))\r\n```\r\nJust to interject, it looks like things are already starting to go wrong here, because ``json-reduce`` matched:\r\n``y`` => ``j``\r\n``v1`` => ``#t``\r\n``v2`` => ``#t``\r\n``v3`` => ``#t``\r\n``(p ...)`` => ``(#t (lambda (x y) x))``\r\n\r\nLet's keep going:\r\n\r\n```scheme\r\n|(json-reduce\r\n   (json-reduce y #t #t (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n     (lambda (x y)\r\n       (json-reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m))))))\r\n|(json-reduce\r\n   y\r\n   #t\r\n   #t\r\n   (lambda (x y)\r\n     (json-reduce\r\n       y\r\n       (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n       (lambda (n m)\r\n         ((lambda (x y)\r\n            (json-reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n           (cons n x)\r\n           m)))))\r\n|(json-reduce\r\n   (json-reduce\r\n     y\r\n     #t\r\n     #t\r\n     (lambda (x y)\r\n       (json-reduce\r\n         y\r\n         (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n         (lambda (n m)\r\n           ((lambda (x y)\r\n              (json-reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n             (cons n x)\r\n             m))))))\r\n```\r\n\r\nNow we have our ``json-reduce`` with the ``y``, ``(lambda (x y) ---)``, ``(lambda (n m) ---)`` arguments produced, and well it just goes on from there: \r\n\r\n```scheme\r\n|(json-reduce\r\n   y\r\n   #t\r\n   (lambda (x y)\r\n     (json-reduce\r\n       y\r\n       #t\r\n       (lambda (n m)\r\n         ((lambda (x y)\r\n            (json-reduce\r\n              y\r\n              (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n              (lambda (n m)\r\n                ((lambda (x y)\r\n                   (json-reduce\r\n                     y\r\n                     #t\r\n                     (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n                  (cons n x)\r\n                  m))))\r\n           (cons n x)\r\n           m)))))\r\n|(json-reduce\r\n   (json-reduce\r\n     y\r\n     #t\r\n     (lambda (x y)\r\n       (json-reduce\r\n         y\r\n         #t\r\n         (lambda (n m)\r\n           ((lambda (x y)\r\n              (json-reduce\r\n                y\r\n                (lambda (x y)\r\n                  (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n                (lambda (n m)\r\n                  ((lambda (x y)\r\n                     (json-reduce\r\n                       y\r\n                       #t\r\n                       (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n                    (cons n x)\r\n                    m))))\r\n             (cons n x)\r\n             m))))))\r\n|(reduce\r\n   y\r\n   #t\r\n   (lambda (x y)\r\n     (json-reduce\r\n       y\r\n       #t\r\n       (lambda (n m)\r\n         ((lambda (x y)\r\n            (json-reduce\r\n              y\r\n              (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n              (lambda (n m)\r\n                ((lambda (x y)\r\n                   (json-reduce\r\n                     y\r\n                     #t\r\n                     (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n                  (cons n x)\r\n                  m))))\r\n           (cons n x)\r\n           m)))))\r\n|(json-reduce\r\n   (json-reduce\r\n     y\r\n     #t\r\n     (lambda (n m)\r\n       ((lambda (x y)\r\n          (json-reduce\r\n            y\r\n            (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n            (lambda (n m)\r\n              ((lambda (x y)\r\n                 (json-reduce\r\n                   y\r\n                   #t\r\n                   (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n                (cons n x)\r\n                m))))\r\n         (cons n x)\r\n         m))))\r\n|(reduce\r\n   y\r\n   #t\r\n   (lambda (n m)\r\n     ((lambda (x y)\r\n        (json-reduce\r\n          y\r\n          (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n          (lambda (n m)\r\n            ((lambda (x y)\r\n               (json-reduce\r\n                 y\r\n                 #t\r\n                 (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n              (cons n x)\r\n              m))))\r\n       (cons n x)\r\n       m)))\r\n|(json-reduce\r\n   (json-reduce\r\n     y\r\n     (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n     (lambda (n m)\r\n       ((lambda (x y)\r\n          (json-reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n         (cons n x)\r\n         m))))\r\n|(reduce\r\n   y\r\n   (lambda (x y) (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n   (lambda (n m)\r\n     ((lambda (x y)\r\n        (json-reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n       (cons n x)\r\n       m)))\r\n|(json-reduce (json-reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m))))\r\n|(reduce y #t (lambda (n m) ((lambda (x y) x) (cons n x) m)))\r\n|(json-reduce (json-reduce y #t (lambda (n m) (#t (cons n x) m))))\r\n|(reduce y #t (lambda (n m) (#t (cons n x) m)))\r\n(begin\r\n  (#3%$invoke-library '(json json) '() '#:json)\r\n  (reduce\r\n    y\r\n    #t\r\n    (lambda (#:x #:y)\r\n      (reduce\r\n        #:y\r\n        #t\r\n        (lambda (#:n #:m)\r\n          (let ([#:x (#2%cons #:n #:x)] [#:y #:m])\r\n            (reduce\r\n              #:y\r\n              (lambda (#:x #:y)\r\n                (reduce\r\n                  #:y\r\n                  #t\r\n                  (lambda (#:n #:m) (#t (#2%cons #:n #:x) #:m))))\r\n              (lambda (#:n #:m)\r\n                (let ([#:x (#2%cons #:n #:x)] [#:y #:m])\r\n                  (reduce\r\n                    #:y\r\n                    #t\r\n                    (lambda (#:n #:m)\r\n                      (let ([#:x (#2%cons #:n #:x)] [#:y #:m])\r\n                        #:x))))))))))))\r\n>\r\n```\r\n\r\nAll of that said, the last clause in the ``define-syntax`` is where things go wrong.  I think maybe instead of matching ``(_ j v1 v2 v3 p ...)``, you might want to match ``(_ j v1 v2 v3 ... p)``, that way you get ``p`` bound to your ``lambda`` expression and ``v3 ...`` bound to any additional items.  You'll also need to change the body of that clause to use ``v3 ...`` instead of ``p ...``:\r\n\r\n```scheme\r\n> (define-syntax json-reduce\r\n    (lambda (x)\r\n      (syntax-case x ()\r\n        ((_ j v1 p) #'(reduce j v1 p))\r\n        ((_ j v1 v2 p) #'(json-reduce j v1 (lambda (x y) (json-reduce y v2 (lambda (n m)(p (cons n x) m))))))\r\n        ((_ j v1 v2 v3 ... p) #'(json-reduce j v1 v2 (lambda (x y) (json-reduce y v3 ... (lambda (n m)(p (cons n x) m)))))))))\r\n```\r\n\r\nThis seems to work much better:\r\n\r\n```scheme\r\n> (json-reduce y #t #t #t #t  (lambda (x y) x))\r\n((\"1\" .\r\n      #(((\"1\" .\r\n              #(((0 . \"1\") 0 . \"1\") ((1 . \"1\") 0 . \"1\")\r\n                ((2 . \"1\") 0 . \"1\")))\r\n          (\"2\" .\r\n               #(((0 . \"2\") 0 . \"1\") ((1 . \"2\") 0 . \"1\")\r\n                 ((2 . \"2\") 0 . \"1\")))\r\n          (\"3\" .\r\n               #(((0 . \"3\") 0 . \"1\") ((1 . \"3\") 0 . \"1\")\r\n                 ((2 . \"3\") 0 . \"1\"))))\r\n        ((\"1\" .\r\n              #(((0 . \"1\") 1 . \"1\") ((1 . \"1\") 1 . \"1\")\r\n                ((2 . \"1\") 1 . \"1\")))\r\n          (\"2\" .\r\n               #(((0 . \"2\") 1 . \"1\") ((1 . \"2\") 1 . \"1\")\r\n                 ((2 . \"2\") 1 . \"1\")))\r\n          (\"3\" .\r\n               #(((0 . \"3\") 1 . \"1\") ((1 . \"3\") 1 . \"1\")\r\n                 ((2 . \"3\") 1 . \"1\"))))\r\n        ((\"1\" .\r\n              #(((0 . \"1\") 2 . \"1\") ((1 . \"1\") 2 . \"1\")\r\n                ((2 . \"1\") 2 . \"1\")))\r\n          (\"2\" .\r\n               #(((0 . \"2\") 2 . \"1\") ((1 . \"2\") 2 . \"1\")\r\n                 ((2 . \"2\") 2 . \"1\")))\r\n          (\"3\" .\r\n               #(((0 . \"3\") 2 . \"1\") ((1 . \"3\") 2 . \"1\")\r\n                 ((2 . \"3\") 2 . \"1\"))))))\r\n  (\"2\" .\r\n       #(((\"1\" .\r\n               #(((0 . \"1\") 0 . \"2\") ((1 . \"1\") 0 . \"2\")\r\n                 ((2 . \"1\") 0 . \"2\")))\r\n           (\"2\" .\r\n                #(((0 . \"2\") 0 . \"2\") ((1 . \"2\") 0 . \"2\")\r\n                  ((2 . \"2\") 0 . \"2\")))\r\n           (\"3\" .\r\n                #(((0 . \"3\") 0 . \"2\") ((1 . \"3\") 0 . \"2\")\r\n                  ((2 . \"3\") 0 . \"2\"))))\r\n         ((\"1\" .\r\n               #(((0 . \"1\") 1 . \"2\") ((1 . \"1\") 1 . \"2\")\r\n                 ((2 . \"1\") 1 . \"2\")))\r\n           (\"2\" .\r\n                #(((0 . \"2\") 1 . \"2\") ((1 . \"2\") 1 . \"2\")\r\n                  ((2 . \"2\") 1 . \"2\")))\r\n           (\"3\" .\r\n                #(((0 . \"3\") 1 . \"2\") ((1 . \"3\") 1 . \"2\")\r\n                  ((2 . \"3\") 1 . \"2\"))))\r\n         ((\"1\" .\r\n               #(((0 . \"1\") 2 . \"2\") ((1 . \"1\") 2 . \"2\")\r\n                 ((2 . \"1\") 2 . \"2\")))\r\n           (\"2\" .\r\n                #(((0 . \"2\") 2 . \"2\") ((1 . \"2\") 2 . \"2\")\r\n                  ((2 . \"2\") 2 . \"2\")))\r\n           (\"3\" .\r\n                #(((0 . \"3\") 2 . \"2\") ((1 . \"3\") 2 . \"2\")\r\n                  ((2 . \"3\") 2 . \"2\"))))))\r\n  (\"3\" .\r\n       #(((\"1\" .\r\n               #(((0 . \"1\") 0 . \"3\") ((1 . \"1\") 0 . \"3\")\r\n                 ((2 . \"1\") 0 . \"3\")))\r\n           (\"2\" .\r\n                #(((0 . \"2\") 0 . \"3\") ((1 . \"2\") 0 . \"3\")\r\n                  ((2 . \"2\") 0 . \"3\")))\r\n           (\"3\" .\r\n                #(((0 . \"3\") 0 . \"3\") ((1 . \"3\") 0 . \"3\")\r\n                  ((2 . \"3\") 0 . \"3\"))))\r\n         ((\"1\" .\r\n               #(((0 . \"1\") 1 . \"3\") ((1 . \"1\") 1 . \"3\")\r\n                 ((2 . \"1\") 1 . \"3\")))\r\n           (\"2\" .\r\n                #(((0 . \"2\") 1 . \"3\") ((1 . \"2\") 1 . \"3\")\r\n                  ((2 . \"2\") 1 . \"3\")))\r\n           (\"3\" .\r\n                #(((0 . \"3\") 1 . \"3\") ((1 . \"3\") 1 . \"3\")\r\n                  ((2 . \"3\") 1 . \"3\"))))\r\n         ((\"1\" .\r\n               #(((0 . \"1\") 2 . \"3\") ((1 . \"1\") 2 . \"3\")\r\n                 ((2 . \"1\") 2 . \"3\")))\r\n           (\"2\" .\r\n                #(((0 . \"2\") 2 . \"3\") ((1 . \"2\") 2 . \"3\")\r\n                  ((2 . \"2\") 2 . \"3\")))\r\n           (\"3\" .\r\n                #(((0 . \"3\") 2 . \"3\") ((1 . \"3\") 2 . \"3\")\r\n                  ((2 . \"3\") 2 . \"3\")))))))\r\n```\r\n\r\nOf course, if you really want to be concise, you can do this in two clauses, and avoid expanding into ``json-reduce`` in the outer-most part of the recursive step.\r\n  Commit https://github.com/cisco/ChezScheme/commit/aa1c2c4ec95c286a12730ea75588a18dd9fb9d59 should fix this. Please re-open this issue if it does not.  @ye-Zhiqiu Unfortunately, GMP's license is incompatible with Chez Scheme's license.  As @dybvig mentioned in Issue #14:\r\n\r\n> Using gmp would indeed speed up programs that operate on large numbers, particularly programs that multiply and divide very large numbers. Licensing is the primary issue blocking us from using it. Another is that our own, different representation of bignums is baked into the compiler and run-time system in a couple of ways.\r\n\r\nWe are open to alternative suggestions, I know there was a group involved in Issue #14 that was starting to look into this, but I've not heard if they've come to any conclusions. Again from #14, if I may quote myself:\r\n\r\n>As we think about trying to improve the bignum implementation in Chez, it might be interesting to take a look at the Glasgow Haskell Compiler (GHC) work around the same issue: https://ghc.haskell.org/trac/ghc/wiki/ReplacingGMPNotes.\r\n>\r\n> They started from a different point, in that GHC had been using the GNU MP, but there were uses of GHC for whom the LGPL licensing of GNU MP was problematic (see: https://ghc.haskell.org/trac/ghc/ticket/601). They experimented with a number of other fast arbitrary precision libraries with more permissive licenses, as well as creating a \"fast enough\" implementation in Haskell. One (or more) of these more permissively licensed libraries might be an interesting option for improving Chez's bignum performance. As of 7 years ago (when the GHC community went through this exercise), there were quite a few interesting trade offs in performance given the libraries available at the time. I found an additional library, [bigz](https://sourceforge.net/projects/bigz/), listed on the [wikipedia arbitrary precision page](https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software). Since it has been 7 years since the GHC community did these experiments, it is probably worth evaluating the options again.\r\n\r\nI would recommend comparing some of the available options, would be a good starting point to choosing a new bignum implementation.  [bsdnt](https://github.com/wbhart/bsdnt) is a fine place to start.  I would note that [LibBF](https://bellard.org/libbf/) is a library for arbitrary precision floating point numbers, so it is not appropriate for the bignum implementation, which is for integers.  Chez Scheme does not currently have arbitrary precision floating point support. @yezhiqiu1998 No worries, you are right that Chez Scheme is not as fast as it could be at bignum math.  The bignum support is pretty baked in though, so we wouldn't be able to get around the requirements of LGPL's licensing if we used it.\r\n\r\nAs @nosefouratyou noted, there are some more liberally licensed alternatives that might be good alternatives to our current implementation.  It looks like the group that had been taking a look at this in #14 did not get to a place where they had something they wanted to share.\r\n\r\nHopefully, I'll get a little free time to look at some of this stuff at some point.  There are always things to improve in a compiler :)  Thanks.  I have updated the sources and pushed new html/pdf files to the project page.  Thanks for the corrections, @ocyzl.   I've updated the online version at [https://www.scheme.com/tspl4/](https://www.scheme.com/tspl4/) and the errata at [https://www.scheme.com/tspl4-errata.html](https://www.scheme.com/tspl4-errata.html).  If you'd like the errata to acknowledge you by name rather than by github handle, let me know.\r\n\r\n@ecraven, I do not have permission from MIT Press to put the sources online. I've updated TSPL (and in the case of the standard-input-port entry, CSUG) and added errata entries for the tspl fixes (all but the \"Stra\u00dfe\" issue, since that was an html formatting problem).  Thanks for the corrections!  You should not run any Scheme code or touch any unlocked Scheme objects after deactivating and before reactivating.  If I understand the proposed solution, it would require calling `Sdeactivate_thread`, and returning to Scheme to call the blocking foreign procedure, which would violate this restriction.\r\n\r\nI believe pull request #267 is intended to address this issue.  I'm not sure from your example what the problem you are running into is.\r\n\r\nI created a library ``t.c`` based on the test code in your example:\r\n\r\n```c\r\ntypedef char* (*res)(char* request_header, char* path_info, char* payload); \r\n\r\nres res_get;\r\n\r\nint handle_request(res response_get)\r\n{\r\n  res_get = response_get;\r\n\r\n  return 0;\r\n}\r\n\r\nchar* call_request(char* request_header, char* path_info, char* query_string)\r\n{\r\n  return res_get(request_header, path_info, query_string);\r\n}\r\n```\r\n\r\nThen I compiled it (on macOS):\r\n\r\n```\r\ngcc -dynamiclib -o t.dylib t.c\r\n```\r\n\r\nAnd finally, I loaded it and called it from the Chez Scheme repl (again based on your example, though I didn't see the ``handle_request`` definition in the email I got from GitHub:\r\n\r\n```\r\n% scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (load-shared-object \"./t.dylib\")\r\n> (define res\r\n    (lambda (f)\r\n      (let ([code (foreign-callable f (string string string) string)])\r\n        (lock-object code)\r\n        (foreign-callable-entry-point code))))\r\n> (define handle-request (foreign-procedure \"handle_request\" (void*) int))\r\n> (define call-request (foreign-procedure \"call_request\" (string string string) string))\r\n> (define foo (lambda (a b c) (string-append c \"::\" b \"::\" a)))\r\n> (handle-request (res foo))\r\n0\r\n> (call-request \"this\" \"is\" \"test\")\r\n\"test::is::this\"\r\n```\r\n\r\nSo, maybe the example will be helpful.\r\n\r\n-andy:) I'm not sure I understand exactly what code is leading to the problem.  Maybe you could post a more complete example with the igropyr code?  Or if it is too long, you could put a snippet of the ``httpc.c`` change that causes the error to occur?  Hmm... I tried to reproduce this, but I wasn't able to.  I've occasionally seen something like this if I had built a different version first, though I've had trouble reproducing it, even when I've had it happen to me.  Thanks.  I have updated the current CSUG sources and pushed new html/pdf files to the project page.    FYI, I used void* rather than iptr in the foreign-procedure declaration and left out the (CB) cast.  I think this is a good change, since map and for-each should check to make sure the first argument is a procedure except at optimize-level 3.  A couple of notes:\r\n\r\n- you can use void-rec instead of building a call to void\r\n- (not (eq? ctxt 'effect)) should be (not (eq? (app-ctxt ctxt) 'effect))\r\n\r\nI see the latter was a preexisting issue. This looks good, and good catch on lines 3628 and 3633.  Please add a couple of error? mats for each of map and for-each with one and more than one empty-list argument so someone who attempts to add back the special case in cp0 or elsewhere will see that it is not appropriate.  Plus please mention `#2%for-each` as well as `#2%map` in the LOG entry.  It's analogous though not quite the same.  In this case there's no safe place for the user program to lock the temporary bytevector.  The Scheme caller can't lock it, since it doesn't have access to it, and the C callee can't lock it, since it doesn't get control until after the thread is deactivated.  So the implementation should either reject string arguments when `__thread` is used or lock the temporary bytevector, regardless of whether we extend automatic (though possibly optional) locking to all arguments that need to be locked.\r\n\r\nI think the `__thread` convention is a great idea, by the way. @mflatt, I've had a chance to look through the code a bit, and for the most part I think it looks good, but there are few small things I think we should fix.\r\n\r\nI ran the mats for ti3osx, ta6osx, a6osx, and i3osx.  I noticed a couple of things in the tests you added with the non-threaded version of the mats.  The added error producing tests at the start of the ``collect-safe`` mat in ``foriegn.ms`` do not raise an exception, because the ``__collect_safe`` convention is being discarded before we check the arguments.  Even though the ``__collect_safe`` convention doesn't have any effect, I think we should consider having it raise the same errors in both threaded and non-threaded versions.\r\n\r\nI also noticed, in running the mats, that the checking is done after the original types have been filter and this leads to a bit of a confusing error message when ``string`` or ``wstring`` types are used.  For example:\r\n\r\n```\r\n(foreign-procedure __collect_safe \"unknown\" (string) void)\r\n```\r\n\r\nproduces\r\n\r\n```\r\nException in foreign-procedure: utf-8 argument not allowed with __collect_safe procedure\r\n```\r\n\r\ninstead of\r\n\r\n```\r\nException in foreign-procedure: string argument not allowed with __collect_safe procedure\r\n```\r\n\r\nIt might be nice to do this checking before the filtering is done, or pass ``$make-foreign-callable`` and ``$make-foreign-procedure`` the mapping between the original and filtered types, so it can use th original type when it raises errors.\r\n\r\nOn the language side, I noticed you changed ``convention?`` in ``base-langs.ss`` instead of changing the ``Lsrc`` language.  I'd recommend changing the ``Expr``s:\r\n\r\n```\r\n(foreign conv name e (arg-type* ...) result-type)\r\n(fcallable conv e (arg-type* ...) result-type)\r\n```\r\nto\r\n\r\n```\r\n(foreign (conv ...) name e (arg-type* ...) result-type)\r\n(fcallable (conv ...) e (arg-type* ...) result-type)\r\n```\r\n\r\nAdmittedly, this is a bit of a pain and you'll need to bump ``Lsrc``'s nongenerative id. I ran through the exercise myself to see how bad the change was, and it does require going through: ``syntax.ss``, ``cpnanopass.ss``, ``cpcommonize.ss``, ``base-lang.ss``, ``cp0.ss``, ``cpcheck.ss``, ``cpvalid.ss``, ``interpret.ss``, ``cpletrec.ss``, and ``cprep.ss``.  The changes are pretty small and are caught by during compilation, so it was a pretty straightforward change.  The exercise proved to be worth it (for me at least), because I found a place in ``cpcommonize.ss`` where we were doing an ``eq?`` comparison on the conventions, which now needs to be ``equal?``.\r\n\r\nI see you also caught a spurious ``convention?`` definition in ``np-languages.ss`` that is not used anywhere, we should probably remove that while we're making these changes.\r\n\r\nI noticed you've also updated the documentation (thanks!) and I've got a couple of comments here too:\r\n\r\n1. We might want to call out the usefulness of ``__collect_safe`` for blocking I/O calls, since before you added this, we didn't have a good story around that short of wrapping the C calls in a C function that deactivated and reactivated.\r\n1. I think we should consider listing out the types that are not allowed instead of saying ... ``utf-8`` through ``utf-32be``, for consistency in other places where we refer to lists of types in the prose.\r\n1. I wasn't sure wha was meant by \"Parameter types other than ``scheme-object`` through ``utf-32be`` are converted to equivalent foreign representations and consequently they can be retained indefinitely in foreign variables...  it seems like ``utf-32be`` is not something that can be retained indefinitely, did you mean ``u32*``?  In this context I'm also wondering if we should be talking about what types need to be locked when using ``__collect_safe`` (for instance ``scheme-object``, ``u8*``, ``u16*`` etc. need to be locked, while ``fixnum``, ``integer-8``, ``integer-16`` etc., do not need to be locked.\r\n\r\nFinally, I took a look through the ``x86_64.ss`` version of the assembler changes to support this, and things there look okay to me, though I'm admittedly a little less fresh on this code than @dybvig is.\r\n\r\nThanks again for the pull request!  Also, I like ``__collect_safe`` better than ``__thread_safe`` for the ``foreign-procedure``, I think it is a bit more descriptive.\r\n @mflatt No problem.  I've pushed my changes on a branch at [pr/267](https://github.com/cisco/ChezScheme/tree/pr/267) with those changes. Thanks for the changes @mflatt, I've gone ahead and rebuilt the boot files and merged your changes!  This is somewhat philosophical, in that Chez Scheme seeks to provide the tools for building things like a network programming library, not to be a programming environment that includes everything plus the kitchen sink.\r\n\r\nThe foreign function interface provides the tools needed to write a network programming library, and there is an example of using it to do socket programming in the examples directory (see [socket.ss](https://github.com/cisco/ChezScheme/blob/master/examples/socket.ss) and [csocket.c](https://github.com/cisco/ChezScheme/blob/master/examples/csocket.c) in the [example](https://github.com/cisco/ChezScheme/tree/master/examples) directory).\r\n\r\nThere are also libraries that have already been written for this including: @arcfide's [chez-sockets](https://github.com/arcfide/chez-sockets) library, @evilbinary's [scheme-lib](https://github.com/evilbinary/scheme-lib) that supports a wide variety of FFI-based features, and @becls' [swish-win](https://github.com/becls/swish-win) and [swish](https://github.com/becls/swish) which provide a framework for writing Scheme programs with Erlang-style concurrency and supports network programming (amongst other things) for Windows or *nix operating systems.\r\n\r\n  It is worth noting that the ``scheme`` and ``petite`` are actually the same binary, and both do (roughly) the same thing at startup.\r\n\r\nWhen you start ``scheme`` (or ``petite``), after looking through the command line arguments and determining where the boot file(s) are, it loads the boot file(s), then runs a maximum generation collection into the static generation, since the core library is not touched during normal garbage collection.\r\n\r\nLoading the boot files consists of uncompressing, reading the fasl-format binary, and executing the expressions in the boot file, which set-up the top-level environment that Chez Scheme programs (including the REPL) execute from.\r\n\r\nIn the case of ``scheme`` this loads both the ``petite.boot`` which contains the core library and interpreter and ``scheme.boot`` which contains the compiler.  In the case of ``petite`` it only loads ``petite.boot``, and this does load faster, since it both executes less code and requires less time to collect, since there is less in the Scheme heap when it is called.\r\n\r\nSo, that is what it is doing during that first ~0.10s to ~0.20s.  Could it be faster?  Possibly.  We could break the boot file into smaller pieces.  For instance, the ``petite.boot`` file contains things like the expression editor code and the interpreter, which you do not need if you are just executing a pre-compiled Scheme program, and not using the REPL or ``eval``.  We have talked, in the past, about breaking this down into smaller piece so that, for instance, if you are running a small script it could be run against a ``minuscule`` Scheme session that doesn't bother loading the expression editor or maybe even the interpreter.\r\n\r\nAll of that said, for me ``petite`` loads in ``0.10s`` on my Mac (compared with ``0.17s`` for full Chez Scheme, so I'd probably start by having any script I wanted to run fast pre-compiled and use ``petite`` as the session entry point.  It is not really possible to evaluate arbitrary expressions within the environment of a library.  That is because once the library is loaded, its environment can no longer be changed, so there is not really anyway to execute code within that environment.  You'll need to export any identifier you want to use, though it is worth noting that Chez Scheme includes a local ``export`` form, so you can write versions of ``define``, ``define-syntax``, etc. that export the identifiers defined by these forms.  Another alternative, though it will slightly change how things are evaluated, is to comment out the ``library`` form around your expressions and load this file as a script using ``load``.  This simply dumps the identifiers into the top-level environment used by the REPL.  This will not benefit from some of the checking that the ``library`` form causes, like ensuring that identifiers are bound.  So, use that approach with caution.\r\n\r\nThe cyclic dependency problem you are seeing is very likely because there was an error that occurred when the run-time code of the library was invoked.  Import cannot correct this because import sees that the library is already loaded into the system and assumes things are good to go. You can force a library to be re-loaded by using ``load-library`` first and then using import to import the newly loaded library.\r\n\r\nFor instance, say we have the following library:\r\n\r\n```scheme\r\n(library (test)\r\n  (export foo)\r\n  (import (chezscheme))\r\n\r\n  (define foo\r\n    (lambda (x)\r\n      (+ x 5)))\r\n\r\n  (errorf 'test \"fail somewhere along the way\"))\r\n```\r\n\r\nNote that this library can be imported, but when the run-time code is invoked, it raises an error with the message ``\"fail somewhere along the way\"`` before it is able to finish the invocation.  This runs afoul of Chez's cyclic library checking, which replaces the thunk representing the run-time code with a flag to indicate it is currently being invoked, and when something causes it to attempt to invoke this code again, the flag is still set, resulting in the error:\r\n\r\n```\r\n% scheme --libdirs /tmp\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (import (test))\r\n> (foo 5)\r\nException in test: fail somewhere along the way\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nNote that we do not attempt to invoke the run-time code until the identifier ``foo`` from the library is referenced, so we do not see the error until then.  Now that the error has been raised, interrupting the library invocation, attempting to reference ``foo`` again will lead to the library being invoked again, and we will see the cyclical load error.\r\n\r\n```\r\n> (foo 5)\r\nException: cyclic dependency involving invocation of library (test)\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nIf we correct the library, commenting out the (in this case) obvious error, ``import`` will not help us, because ``import`` sees this library as already loaded:\r\n\r\n```\r\n> (import (test))\r\n> (foo 5)\r\nException: cyclic dependency involving invocation of library (test)\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nThat said, we can use ``load-library`` to reload the library, clearing the flag and re-reading the library from the specified file:\r\n\r\n```\r\n> (load-library \"/tmp/test.sls\")\r\n```\r\n\r\nHowever, this does not replace the old version of the libraries identifiers in the current REPL environment, and if we try to invoke ``foo`` again, it will tell us so:\r\n\r\n```\r\n> (foo 5)\r\nException: compiled program requires different compilation instance of (test) from one already loaded\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nWe can, however, re-import the ``(test)`` library and the new version will be visible:\r\n\r\n```\r\n> (import (test))\r\n> (foo 5)\r\n10\r\n```\r\n\r\nIt is worth noting that ``load-library`` will not clear libraries that depended on this library, and those may still be executing against the old code.\r\n  Chez Scheme does not support r7rs at this time and there is no ``define-library`` in Chez.  Perhaps what you saw is ``define-library-entry`` which is an internal macro used in the file ``library.ss`` for populating some metadata for core-library routines. There are currently no plans to support R7RS.  You could use the R6RS standard ``make-custom-binary-input/output-port`` documented in [Section 7.5 Opening Custom Ports](https://www.scheme.com/tspl4/io.html#./io:s41) of The Scheme Programming Language.\r\n\r\nThere is an example of its use in ``socket.ss`` in the Chez Scheme ``examples`` directory: [ChezScheme/examples/socket.ss](https://github.com/cisco/ChezScheme/blob/master/examples/socket.ss)  Actually, as the comment above ``max-put-copy`` indicates the is the maximum amount a bytevector put operation will copy from the supplied bytevector to the port's buffer.  This is used in the``*-put-some`` procedures.\r\n\r\nThe parameter ``custom-port-buffer-size`` controls the size of the buffer in custom ports.  It looks like it defaults to 128 bytes, but you could set it to whatever you like.  I think the only limitation over what ``make-input/output-port`` allows is that you cannot set a different size for the input and output buffers. Yes, that part is a bummer.  Unfortunately, I think the R6RS ports are assumed to be synchronous.  So the idea is that if you have something like a socket, which might receive more data, but there is currently no data available, the ``read!`` method would simply wait until more data was available, or the socket is closed.\r\n\r\nIf you want to do asynchronous input of course, you need a way to say, there is no data available now, but there might be later (effectively ``EAGAIN`` from C's ``read`` procedure when it is set to be asynchronous.\r\n\r\nHave you considered using the ``open-fd-input/output-port``.  I've used this with asynchronous pipes (created with the unix ``pipe`` procedure as a foreign call), by using the ``set-port-nonblocking!`` procedure on the created ``fd`` port. Yes, I agree we probably need to add something to support nonblocking custom binary ports better.  I think we need to decide if the best way to handle this is to add a ``make-binary-input/output-port`` following the pre-R6RS Chez Scheme ``make-input/output-port`` or we extend the R6RS ``make-custom-binary-input/output-port``.\r\n\r\nI'll discuss this with other maintainers before I make any changes, but I think it is a worthwhile addition.  Another approach to this is to use the foreign data facilities described in [Section 4.5 Foreign Data](http://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:h5) of the Chez Scheme users guide.  This is actually the standard way to communicate data back and forth with foreign procedures.  \r\n\r\nBecause allocation occurs outside the Scheme heap, you no longer need to lock and unlock it, though you are responsible for freeing it.  One way to employ the garbage collector to help with that is to use an ``ftype-pointer`` object to wrap the pointer and then put a guardian on the ``ftype-pointer`` object, and when the guardian indicates the ``ftype-pointer`` object would be freed, free the corresponding foreign data. The \"array\" you are allocating is effectively just a byte array, and you can access it similar to the way you access the bytevector.  The ``foreign-ref`` and ``foreign-set!`` provide you the same sort of access you have with the various bytevector ref and set! procedures.  You could also copy the foreign data into a bytevector if that is what you wanted to do.  Just to follow up on what @jltaylor-us mentioned, there are a couple of challenges with having multiple versions of the same library loaded.\r\n\r\nFirst, different versions of the same library might use different underlying representations for the data they operate on (in fact, different compilation instances of the same version of the library may also have this property).  If the two libraries are completely isolated, that might be okay, however if data created by one version of the library can flow to the other version of the library, the program will have unexpected errors.\r\n\r\nSecond, a library might expect that its state is unique, either because it connects to an external resource that it expects to have the only handle on, or because it is maintaining internal state to ensure uniqueness of data produced by the library.  In both cases, loading multiple versions of the library would result in multiple versions of this state being loaded, which also has the potential to cause unexpected errors in the final program.\r\n\r\nIn both of these cases the errors are likely to be the kind that are not immediately obvious to someone using the the library or program that results in multiple versions of the same library being loaded.\r\n\r\nSo it is a bit conservative, but I suspect this was some of the reasoning behind the R6RS prohibition on loading multiple versions of the same library.  Hey @mflatt,\r\n\r\nThese changes look good.  I think we should consider using ``who`` in place of the explicit ``'odd?``, ``'even?``, ``'flodd?``, and ``'fleven?``.  Your changes make use of these correctly, but I noticed when looking through the context of the expected error diffs that ``(flodd? 3.2)`` is raising the error: ``Exception in odd?: 3.2 is not an integer`` in stead of ``Exception in flodd?: 3.2 is not an integer`` because it explicitly has ``'odd?`` where it should have ``'flodd?`` or ``who`` in the ``nonifnteger-integer`` error call. Thanks for the changes and the ``who``!  Hey All,\r\n\r\nI know I'm a little late to the party, but this seemed like a fun thing to hack a little on now that Christmas is done and the rest of my extended family is asleep.\r\n\r\n@soegaard to answer the simplest question first, Chez Scheme does not have a specialized ``flvector`` or ``f64vector``.  You can get something similar by using a ``bytevector`` along with the ``bytevector-ieee-double-native-ref`` and ``bytevector-ieee-double-native-set!`` operators defined as part of R6RS scheme.  This similarly can be used for single floating point and various signed and unsigned integers.  I gave that a try, but I'll talk more about that in a second.\r\n\r\nBefore getting too deep into this it is worth noting that you are testing one of Chez Scheme's known weaknesses for performance, namely floating point.  Floating point numbers are boxed in Chez Scheme, meaning that every floating point operation requires unboxing and the results are immediately boxed.  So, if you have something like:\r\n\r\n```scheme\r\n(fl* (fl* a b) c)\r\n```\r\n\r\n``a`` will be unboxed into a floating-point register (SSE on x86 family), ``b`` will be unboxed (this happens as part the SSE floating point add on x86 family), the unboxed values will be added, the result will be boxed, the result will be immediately unboxed, ``c`` will be unboxed (again this happens as part of the SSE floating point add on x86 family), the unboxed values will be added, and the final result will be boxed.\r\n\r\nI've not used Go, but it would surprise me if it was doing all of this boxing and unboxing, and in Chez it is something I'd like to fix, but it has not been high enough priority, and we have not necessarily had all of the information we needed to make it really profitable to do so.\r\n\r\nOkay, on to the main event, making this code perform better.\r\n\r\nAs a base line, I started from the code https://github.com/go-interpreter/chezgo/blob/master/matrix.ss with the version tag: b8469d5.\r\n\r\nTo get a baseline I compiled this library (after renaming the file ``my-matrix.ss`` so that it would match the library name: ``(my-matrix)`` at ``optimize-level`` 3, ``debug-level`` 0, then ran it in a separate session (I did this for all of the testing):\r\n\r\n```\r\n% scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (parameterize ([optimize-level 3]\r\n                 [debug-level 0])\r\n    (compile-library \"my-matrix.ss\" \"my-matrix.so\"))\r\ncompiling my-matrix.ss with output to my-matrix.so\r\n```\r\n\r\nThen I ran the code in a separate session. Three runs averaged 1804.73 msec:\r\n\r\n```\r\n% scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (import (my-matrix))\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 1837 msec\r\n500 x 500 matrix multiply in Chez took 1844 msec\r\n500 x 500 matrix multiply in Chez took 1836 msec\r\n500 x 500 matrix multiply in Chez took 1795 msec\r\n500 x 500 matrix multiply in Chez took 1775 msec\r\n500 x 500 matrix multiply in Chez took 1793 msec\r\n500 x 500 matrix multiply in Chez took 1841 msec\r\n500 x 500 matrix multiply in Chez took 1925 msec\r\n500 x 500 matrix multiply in Chez took 1898 msec\r\n500 x 500 matrix multiply in Chez took 1842 msec\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 1748 msec\r\n500 x 500 matrix multiply in Chez took 1806 msec\r\n500 x 500 matrix multiply in Chez took 1795 msec\r\n500 x 500 matrix multiply in Chez took 1798 msec\r\n500 x 500 matrix multiply in Chez took 1758 msec\r\n500 x 500 matrix multiply in Chez took 1813 msec\r\n500 x 500 matrix multiply in Chez took 1762 msec\r\n500 x 500 matrix multiply in Chez took 1788 msec\r\n500 x 500 matrix multiply in Chez took 1803 msec\r\n500 x 500 matrix multiply in Chez took 1832 msec\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 1802 msec\r\n500 x 500 matrix multiply in Chez took 1772 msec\r\n500 x 500 matrix multiply in Chez took 1793 msec\r\n500 x 500 matrix multiply in Chez took 1806 msec\r\n500 x 500 matrix multiply in Chez took 1738 msec\r\n500 x 500 matrix multiply in Chez took 1821 msec\r\n500 x 500 matrix multiply in Chez took 1767 msec\r\n500 x 500 matrix multiply in Chez took 1759 msec\r\n500 x 500 matrix multiply in Chez took 1802 msec\r\n500 x 500 matrix multiply in Chez took 1793 msec\r\n```\r\n\r\nThe first change I made was to make all of the operators type-specific.  So, +, =, <, etc. became either fx+, fx=, fx<, etc. or fl+, fl=, fl<, etc.  I also noticed that the ``mul`` function was checking for ``number?`` instead of ``flonum?`` so I added checks for ``flonum?``.  I also discovered that the matrix sometimes contained floating point numbers and sometimes contained fixnum 0.  I changed this so that the matrix always contained 0.  See gist: https://gist.github.com/akeep/ed6ce4e9df466aaab6b623b7d5655c12\r\n\r\nThis reduced the average to: 1538.4 ms (14.76% improvement).  Getting the types right and using the most specific operators definitely helps:\r\n\r\n```\r\n% scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (import (my-matrix))\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 1508 msec\r\n500 x 500 matrix multiply in Chez took 1556 msec\r\n500 x 500 matrix multiply in Chez took 1516 msec\r\n500 x 500 matrix multiply in Chez took 1571 msec\r\n500 x 500 matrix multiply in Chez took 1563 msec\r\n500 x 500 matrix multiply in Chez took 1522 msec\r\n500 x 500 matrix multiply in Chez took 1540 msec\r\n500 x 500 matrix multiply in Chez took 1553 msec\r\n500 x 500 matrix multiply in Chez took 1513 msec\r\n500 x 500 matrix multiply in Chez took 1525 msec\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 1534 msec\r\n500 x 500 matrix multiply in Chez took 1532 msec\r\n500 x 500 matrix multiply in Chez took 1524 msec\r\n500 x 500 matrix multiply in Chez took 1516 msec\r\n500 x 500 matrix multiply in Chez took 1535 msec\r\n500 x 500 matrix multiply in Chez took 1534 msec\r\n500 x 500 matrix multiply in Chez took 1512 msec\r\n500 x 500 matrix multiply in Chez took 1587 msec\r\n500 x 500 matrix multiply in Chez took 1555 msec\r\n500 x 500 matrix multiply in Chez took 1562 msec\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 1541 msec\r\n500 x 500 matrix multiply in Chez took 1542 msec\r\n500 x 500 matrix multiply in Chez took 1565 msec\r\n500 x 500 matrix multiply in Chez took 1528 msec\r\n500 x 500 matrix multiply in Chez took 1527 msec\r\n500 x 500 matrix multiply in Chez took 1569 msec\r\n500 x 500 matrix multiply in Chez took 1514 msec\r\n500 x 500 matrix multiply in Chez took 1539 msec\r\n500 x 500 matrix multiply in Chez took 1531 msec\r\n500 x 500 matrix multiply in Chez took 1538 msec\r\n```\r\n\r\nThe next change I made had a much more dramatic impact.  I noticed some code that looked very un-Schemely to me, and I could not for the life of me figure out why it was needed:\r\n\r\n```scheme\r\n                  (set! tot (vector-ref ith-output-row j))\r\n                  (set! tot (+ tot\r\n                               (fl* (vector-ref ith-input-row k)\r\n                                  (vector-ref kth-input-row j))))\r\n                  (vector-set! ith-output-row j tot))))))))\r\n```\r\n\r\nThis is lines 97-101 in the original file.  We set a variable to a value, we update that value then we set the result into a vector.  We could obviously do the same with a local variable bindings and shadowing:\r\n\r\n```scheme\r\n(let ([tot (vector-ref ith-output-row j)])\r\n  (let ([tot (+ tot\r\n                (fl* (vector-ref ith-input-row k)\r\n                     (vector-ref kth-input-row j)))])\r\n    (vector-set! its-output-row j tot)))\r\n```\r\n\r\nBut really there's no need to have the variables in there at all, and we could just change this into:\r\n\r\n```scheme\r\n                  (vector-set! ith-output-row j\r\n                               (fl+ (vector-ref ith-output-row j)\r\n                               (fl* (vector-ref ith-input-row k)\r\n                                  (vector-ref kth-input-row j)))))))))))\r\n```\r\n\r\n(Note I've moved to the version with the ``+`` replaced with ``fl+``).  You can see this change at gist: https://gist.github.com/akeep/a59918cc1a4eeffb34452617335b3062\r\n\r\nThis brought the average run time down to 646.33 ms (a 57.99% improvement over the previous code, and a  64.19% improvement over the original).\r\n\r\n```\r\n% scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (import (my-matrix))\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 617 msec\r\n500 x 500 matrix multiply in Chez took 641 msec\r\n500 x 500 matrix multiply in Chez took 621 msec\r\n500 x 500 matrix multiply in Chez took 659 msec\r\n500 x 500 matrix multiply in Chez took 643 msec\r\n500 x 500 matrix multiply in Chez took 652 msec\r\n500 x 500 matrix multiply in Chez took 641 msec\r\n500 x 500 matrix multiply in Chez took 641 msec\r\n500 x 500 matrix multiply in Chez took 642 msec\r\n500 x 500 matrix multiply in Chez took 660 msec\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 635 msec\r\n500 x 500 matrix multiply in Chez took 649 msec\r\n500 x 500 matrix multiply in Chez took 663 msec\r\n500 x 500 matrix multiply in Chez took 649 msec\r\n500 x 500 matrix multiply in Chez took 637 msec\r\n500 x 500 matrix multiply in Chez took 641 msec\r\n500 x 500 matrix multiply in Chez took 635 msec\r\n500 x 500 matrix multiply in Chez took 642 msec\r\n500 x 500 matrix multiply in Chez took 660 msec\r\n500 x 500 matrix multiply in Chez took 651 msec\r\n> (run-bench)\r\n500 x 500 matrix multiply in Chez took 643 msec\r\n500 x 500 matrix multiply in Chez took 654 msec\r\n500 x 500 matrix multiply in Chez took 667 msec\r\n500 x 500 matrix multiply in Chez took 651 msec\r\n500 x 500 matrix multiply in Chez took 662 msec\r\n500 x 500 matrix multiply in Chez took 643 msec\r\n500 x 500 matrix multiply in Chez took 647 msec\r\n500 x 500 matrix multiply in Chez took 645 msec\r\n500 x 500 matrix multiply in Chez took 651 msec\r\n500 x 500 matrix multiply in Chez took 648 msec\r\n```\r\n\r\nThis was about the best I could get.\r\n\r\nI also made a version of this code that removed all of the ``set!`` and fixed the ``sanity`` check so that it was using floating point numbers in the matrix, but I'm afraid I did not save this code.  It did not make a difference in performance, since that was not code being tested in the benchmark. \r\n\r\nI tried two other experiments using ``bytevector``s with ``bytevector-ieee-double-native-ref`` and ``bytevector-ieee-double-native-set!``, the first, wrapping a record containing the number of rows and number of columns over a flat byte vector that was accessed in column-major fashion.  After some tweaking, this averaged out to 1327.867 msec, so better than the initial update, but not better than removing the ``set!``, see gist: https://gist.github.com/akeep/a6e28aaf3f014b5d4089864ffa6252c3\r\n\r\nI also tried creating a ``vector`` of ``bytevector``s for the matrix, sort of a hybrid approach.  This was better, but not good enough to beat the straight up ``vector`` of ``vector``s version.  In this case the average was: 682.77 msec.  See gist: https://gist.github.com/akeep/a2583f0d1231d5d665137145c3e9dec3\r\n\r\nI suspect the ``bytevector-ieee-double-native-ref`` and ``bytevector-ieee-double-native-set!`` could use some improvement to be able to compete, but it might lead to better cache behavior.  Very likely this is again the boxing and unboxing rearing its ugly head.\r\n\r\nThe biggest impact seemed to be removing the ``set!``.  To understand why this is such a problem, it is important to realize that in Chez Scheme assigned variables (i.e. those used with ``set!``) have a bit of heap space allocated to them.  Effectively:\r\n\r\n```scheme\r\n(let ([x 5])\r\n  (set! x (* x 5))\r\n  x)\r\n```\r\nbecomes\r\n\r\n```scheme\r\n(let ([x (box 5)])\r\n  (set-box! x (* (unbox x) 5))\r\n  (unbox x))\r\n```\r\n\r\nThis indirection is created because if ``x`` is captured by more than one procedure, they all need to see the same value for ``x`` and when ``x`` is assigned the new value must be visible to all the procedures.  This can also impact performance of the garbage collector, which needs to check reverse-generational links when the box is set.\r\n\r\nIn this example all of that extra effort was superfluous since ``tot`` is really just used as a temporary.\r\n\r\nAnyway, we're still not as fast as Go for this example, and with the boxing and unboxing of floats, we probably won't be, but it would be interesting to see how much further we could push this with some additional compiler support. I think my goal would be to improve (or really allow for) handling of the raw floating point values as a first step, seeing if the existing byte vector implementation can be bent to serve for the purpose of a specific type vector.  There is the potential for additional benefits for handling of other raw types if we can come up with a clever, but simple way to do this.\r\n\r\nI suspect part of the problem with the byte vector version of the code is that it is immediately boxing the extracted value, and an f64vector would effectively need to do the same, so that is not really going to help without addressing the broader issue.\r\n\r\nAll of that said, like the other Chez Scheme maintainers, this is mostly a spare time activity for me, unless I have some particular justification for spending work time on it, and this isn't currently a high-priority, so we'll have to see how the year unfolds. Internally, Chez Scheme represents everything as a tagged pointer.  There are a few categories of things (fixnums, characters, constants like null, ``#t``, and ``#f``) that do not require heap allocation, because the tag indicates that the value is stored within the tagged pointer.\r\n\r\nFor everything else, heap allocation is required.  A byte vector, of course, allows you to store raw data, but once you extract that data into a scheme tagged pointer, you need to allocate space on the heap for it.  The value you get back from the reference is a tagged pointer whose tag indicates it is a floating point number.  By itself, an f64vector type would have the same problem, namely, we'd need to allocate space for that value to live as its own value.\r\n\r\nYou might wonder why you cannot just have the tagged pointer point to where the value already exists in memory, since in both cases we know the value is already in the form we need it in.  However, the garbage collector (which is a copying collector) would need to be in on the game, because we would have pointers pointing into the middle of objects.  These pointers would need to be updated when the main object moved, and it would also need to prevent the original object from being collected if there is no longer a live reference to that object.  We don't currently have support for something like this in the collector.\r\n\r\nAdditionally, in the case of both a byte vector and the f64vector, both of which would need to be mutable for your purposes, we'd need to make it clear that the variable being held onto could potentially change value through another instruction setting the location.\r\n\r\nIn general, Chez Scheme's operators operate on the tagged pointer representation and are expected to return tagged pointer representations, with a handful of exceptions.  The ``ftype`` system which is a syntactic layer to make interacting with structured foreign data easier, internally maintains a raw pointer type for computing memory offsets and the like, and it is possible we could do something similar for floating point values.\r\n\r\nAnother concern with raw values floating around is how they impact the garbage collector.  We currently maintain a live-pointer mask for each frame on the stack which forms the root set for the collector.  In general the live pointer mask indicates what must be maintained across non-tail calls, and any element on the frame not covered by the mask could be replaced with random garbage without causing problems.  We would need to subtly change the meaning of the live pointer mask, since we would potentially have valid raw data stored where the live pointer mask indicates they are not live pointers (and we wouldn't want them to marked as live pointers, since the raw data might be interpreted incorrectly by the garbage collector).\r\n\r\nIn addition, I would like to be able to take advantage of the floating point registers that exist on most modern processors to allow us to keep floating point values in registers for longer stretches when there are going to be multiple floating point operations in sequence on them, rather than reading them from memory,  doing the operation, then writing them back to memory only to read them again at the start of the next operation.  This might not make a big impact for your particular use case, but I do think the \"kernel\" of your matrix multiple would have better code generated there if we could get something like this implemented.\r\n\r\nIf you are interested in seeing what Chez Scheme does now, you can see the assembly code generated by setting the ``$assembly-output`` parameter to ``#t`` or a textual output port.  (``#t`` indicates it should be output to standard out).  You'll need to use the ``#%`` prefix to use this, as it is a \"hidden\" primitive in Chez Scheme:\r\n\r\n```\r\n> (#%$assembly-output)       ;=> #f\r\n> (#%$assembly-output #t)\r\n```  I can't reproduce this problem. Is your TZ environment variable set? If so, unset it and try again. I was just looking at this a few minutes ago.  When I changed my time zone to Europe (Berlin), I was able to reproduce the error.  I tried setting the TZ environment variable to 'Europe/Berlin', but that didn't seem to help. Thanks, I'm now able to reproduce the behavior on my Windows 10 machine by setting my time zone to UTC-03:00 City of Buenos Aires. The bug is called by the use of difftime in S_mktime, which cannot take a negative time_t value. See https://msdn.microsoft.com/en-us/library/3wbd7281.aspx. Fixed in commit https://github.com/cisco/ChezScheme/commit/4748dad50c7f0e9b3ba002c27990d4c88c0189fc. I removed the incorrect use of difftime on all platforms and tested against a6le, a6nt, a6osx, and i3nt.  The difference here is actually an expected one.  Without consulting with Kent, I'm not exactly sure why this difference exists when, as you've shown it doesn't need to, other than avoiding special casing every little think in cp0, which may be why he didn't go down this road in the first place.\r\n\r\nThe reason it doesn't fail on Linux (and shouldn't on Windows either) is that the way the expected errors are handled, there is a main expected errors file, and then there are patches for different settings.  Linux is (and Windows should) patch the expected errors with the corrected set.\r\n\r\nSo, that is the explanation.  Before we decide we want to go down this road, I'd like to double check with Kent.  I know this is not the only instance of differences when cp0 is turned off, and doing this across the board might require a fair amount of special casing. @gus-massa The problem occurs when you have an optimize level 2 call to ``map`` in a program that is otherwise compiled at optimize level 3.\r\n\r\nYou can see this by setting Chez Scheme to optimize level 3, turning off compile-interpret-simple, and then executing ``#2%map``:\r\n\r\n```\r\n% ../bin/scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (optimize-level 3)\r\n> (compile-interpret-simple #f)\r\n> (#2%map 3 '(1 2 3))\r\nException: invalid memory reference.  Some debugging context lost\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nThis is happening because ``(#2%map 3 '(1 2 3))`` is expanding into ``(#2%list (3 1) (3 2) (3 3))`` and when the calls to ``3`` are compiled at optimize-level 3, the procedure checking code is not being written at the call sites:\r\n\r\n```\r\n> (expand/optimize '(#2%map 3 '(1 2 3)))\r\n(#2%list (3 1) (3 2) (3 3))\r\n```\r\n\r\nYour change ends up addressing this (even though that this not what it was intended to fix).  It is possible that we could make this change stricter and only do this when the compiler is currently running at optimize level 3 and we are optimizing the optimize level 2 version of ``map``.\r\n So, I think this works as expected.  When you compile your example program at optimize-level 2, you get an error, when you compile it at optimize-level 3, you do not, this is exactly the same behavior you would see if cp0 was not being run, which is the goal.\r\n\r\nThe change you made should change the behavior when you are compiling a program at optimize-level 3, but you've explicitly called the optimize-level 2 version of ``map``:\r\n\r\n```\r\n% ../bin/scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (optimize-level 3)\r\n> (define (f p b)\r\n   (unbox b)\r\n   (#2%map p (if (box? b) '() '(1 2 3)))\r\n   (list p (procedure? p)))\r\n> (f 7 (box 0)) ;==> (7 #t)\r\nException in map: 7 is not a procedure\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nAnyway, I think these changes look okay, I'm in the process of testing through things and making sure we've got the expected error and patch files set up correctly.  I'll also be adding some tests to the mats for this.  Thanks for finding this! It's corrected in commit https://github.com/cisco/ChezScheme/commit/abb991bcd87f64eeae9a3848959191a4da5d6542.  Both ``vector-fill!`` and ``substring-fill!`` return an unspecified value (which is why they are marked void).  The fact that they happen to return a ``vector`` and ``string`` (respectively) is accidental, and I think if there is code that depends upon it, we should probably change that code, but I think the signatures are actually correct in ``primdata.ss``\r\n\r\nIf these two signatures are leading to bugs, let me know and I'll take a look into what is causing the problem.\r\n\r\nThe rest to these changes look good. Just a quick update on this.  I've committed a change to ``vector-fill!`` and ``substring-fill!`` that corrects their output to return ``void`` in keeping with their documented behavior. @gus-massa Good catch on the ``substring-fill!`` test, I'm not sure why my own testing didn't turn that up.\r\n\r\nI think the change to ``unget-{u8,char}`` makes sense.  Perhaps at some point we'll have to extend the little type system to express ``u8`` + ``eof-object``, ``char`` + ``eof-object``, etc.  since this does come up relatively frequently in the I/O functions, if it turns out to be profitable anyway.  Thanks for this pull request!  Looks good, thanks!  Thank you for finding and fixing these typos!  I think the problem here is unrelated to Chez Scheme.\r\n\r\nFrom the ``recv`` documentation:\r\n\r\n> If no messages are available at the socket, the receive call waits for a message to arrive, unless the socket is nonblocking (see fcntl(2)) in which case the value -1 is returned and the external variable errno set to EAGAIN.  The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the socket-level options SO_RCVLOWAT and SO_RCVTIMEO described in getsockopt(2).\r\n\r\nI tested this out by using ``fcntl`` to get the flags currently set on the accepted socket (command ``F_GETFL``), and found that the socket descriptor returned is not marked as non-blocking, which is why ``recv`` and ``send`` and blocking.  You should be able to get the behavior you want by using ``fcntl`` with ``F_SETFL`` on the socket descriptor returned by ``accept``.  (Note that if you set it on the original socket descriptor from ``socket``, the accept will not block, it will simply return an error message if no connections have been requested.)  @mflatt, how do I compile this branch? I get `Error in $lookup-library-entry: entry ~s uninitialized\r\n(150)`\r\n Thanks, that worked! If you have a recent Chez Scheme installed, you can do this from the particular workarea:\r\n```\r\nmake -C s all patchfile=patch Scheme=scheme SCHEMEHEAPDIRS=/usr/lib/csv%v/%m:/usr/local/lib/csv%v/%m\r\nmake\r\n``` Thanks for this pull request!  The release tar ball is created directly from the git repository directory (wth submodules) excluding the hidden (``.git*`` and ``.travis*``) files and directories.\r\n\r\nOne way to do this is to do the following:\r\n\r\n1. Make sure you have a clean git checkout with the submodules checked out.  You can clone the repository with ``--recursive`` to have it clone the submodules as well, or you can run ``git submodule update --init`` after you clone to get the directories.\r\n1. If you want to make the tar ball on a specific version, checkout the version (for instance if you want to make a v9.5 tar ball: ``git checkout tags/v9.5`` (you can create a branch when you do this by also doing ``-b <branch name>``)\r\n1. Use git to clean the directory (this will delete everything that is not part of the git repository, so be careful with this): ``git clean -xdf``, **Remember: this will delete everything not in the git repo!**\r\n1. Create a staging directory, this will be the base of your tar ball: ``mkdir /tmp/csv9.5``\r\n1. Use rsync, excluding the hidden files: ``rsync -arv --exclude '.git*' --exclude '.travis*' ChezScheme/ /tmp/csv9.5``  (Note: the trailing ``/`` after the git directory is significant.)\r\n1. Optionally, remove any boot files you don't want to include: ``rm -rf /tmp/csv9.5/boot/<mt>/* ...`` (Note: these could also be excluded with rsync.)\r\n1. Build the tar ball from the ``/tmp`` directory: ``cd /tmp && tar czvf my-csv9.5.tar.gz csv9.5``\r\n\r\nYou could also add additional boot files if you wanted to create a binary with a different mix of boot files.  Note that the directories listed here are suggestions only.\r\n\r\nAlternatively, you could grab the ``csv9.5.tar.gz``, extract the contents, remove the boot files you don't want, then create your new tar ball from that directory.\r\n  Again you are seeing hard links which reflect the names you chose to call your Chez Scheme executables.  ``petite-chez.boot`` is a hard link to ``petite.boot`` and ``chez.boot`` is a hard link to ``scheme.boot``.  These hard links are needed because as I explained in #221 when you run ``chez`` it will look for a boot file called ``chez.boot`` and when you execute ``petite-chez`` it will look for a boot file called ``petite-chez.boot``.  Internally though, ``chez.boot`` will still be looking for a file called ``petite.boot``, so these are simply hard linked to avoid changing the underlying generation of the boot files. The only part of the build process that is aware of the installation names is the installation step, so effectively the ``scheme.boot`` has already been built with a requirement on ``petite.boot``, so at the very least the ``petite.boot`` file must be there for your system to work.  This is true, but ``petite`` and ``scheme-script`` are just hard links to ``scheme`` that cause it to operate in slightly different modes.\r\n\r\nWhen ``scheme`` detects that it has been run as ``scheme-script`` it uses the first command line argument to determine the scheme script to run and makes all other command line arguments available to the script through the ``(command-line)`` and ``(command-line-arguments)``.   ``scheme-script`` is equivalent to ``scheme --program`` and command line arguments intended for the use in the scheme script can also be passed after ``--``, though this is not needed when using ``--program``.\r\n\r\nIn the case of ``petite``, the ``scheme`` executable decides on which boot file(s) to attempt to load based on the name the executable was run as (unless the boot files are explicitly specified with the ``-b`` command line argument.  Normally, we build two boot files: ``petite.boot`` and ``scheme.boot``.  ``petite.boot`` contains all of the basic scheme libraries and REPL support, including the expression editor.  ``scheme.boot`` contains the scheme compiler.  When the executable name is ``scheme`` it attempts to load the ``scheme.boot`` file, which lists the ``petite.boot`` as a dependency.  When the executable is ``petite`` it loads the ``petite.boot`` only.\r\n\r\nPetite Chez is still useful because it allows for a smaller memory footprint when running scheme programs, and can be used a smaller run time for a precompiled scheme program.  Yeah, Chez treats ``~@:`` and ``~:@`` the same in the format code, so I think this is doing the:\r\n\r\n> ``~:@(`` converts every lowercase character to the corresponding uppercase character.\r\n\r\nversion of the conversion from the Common Lisp formatted output specification.  Looks good, thanks!  Hmmm... I tried to reproduce this on a CentOS 7 VM today (I couldn't find the 7.2 iso anymore, it looked like CentOS has moved to just providing one version 7 VM), but I wasn't able to reproduce.  It built fine for me.\r\n\r\nSome things to try:\r\n\r\n1. Make sure you don't have a ``SCHEMEHEAPDIRS``, ``CHEZSCHEMELIBDIRS``, ``CHEZSCHEMELIBEXTS`` defined\r\n2. Try to do a ``make distclean`` and then configure and build again.\r\n\r\nSomething that can happen is if the C run time and Scheme boot files have different expectations around how they should communicate, you can end up with some pretty serious problems, like the invalid memory reference.  This is part of the reason for making sure your ``SCHEMEHEAPDIRS`` is not set, if it is, you might end up with the new C run time trying to load the old ``*.boot`` files.  The debugger is actually an inspector of the current continuation (effectively the chain of stack frames for the non-tail calls leading to the failure) from where the failure occurred.  This means that local variables that are still in scope will be visible in the debugger (since they are part of the continuation).  In your example there is only a tail call, so the current continuation does not contain a local variable.\r\n\r\nIn cases where you are debugging a compiled file (as opposed to at the REPL), you can also ask the debugger to print out a file location which can help to identify where the error occurred, and what variable might be involved. In general you cannot construct a helper function that ensures a local variable is on the stack for an arbitrary function when an exception occurs.\r\n\r\nIn your example, the function being called does not have a stack on the frame, since it is at the tail of the computation.  You can force a frame to be created by capturing the current continuation with ``call/cc``, and you can even use this with the inspector to look at the current continuation.  (In fact this is how the debugger works, it allows you to walk the continuation.)\r\n\r\nStarting from your example you could do something like:\r\n\r\n```\r\n> (define f (lambda (x) (call/cc (lambda (k) (inspect k))) (+ 1 x)))\r\n> (f \"a\")\r\n#<continuation in f>                                              : s\r\n  continuation:          #<system continuation in new-cafe>\r\n  procedure code:        (lambda (x) (call/cc (lambda (...) (...))) (+ 1 x))\r\n  call code:             (call/cc (lambda (k) (inspect k)))\r\n  frame and free variables:\r\n  0. x:                  \"a\"\r\n#<continuation in f>                                              : q\r\n\r\nException in +: \"a\" is not a number\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nNow you can see that ``x`` is on the frame.  It is worth noting that if ``x`` was not referenced after the ``call/cc`` expression in the code, it would not be represented there, because it would not be needed across the non-tail call.\r\n\r\nYou can also inspect the variable value directly, by simply passing it to inspect:\r\n\r\n```\r\n> (define f (lambda (x) (inspect x) (+ 1 x)))\r\n> (f \"a\")\r\n\"a\"                                                               : q\r\n\r\nException in +: \"a\" is not a number\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nSometimes it can be helpful to generate a pair with name:\r\n\r\n```\r\n> (define f (lambda (x) (inspect (cons 'x x)) (+ 1 x)))\r\n> (f \"a\")\r\n(x . \"a\")                                                         : s\r\n  car:                   x\r\n  cdr:                   \"a\"\r\n(x . \"a\")                                                         : q\r\n\r\nException in +: \"a\" is not a number\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nHope that helps!  I haven't taken enough time to look at this yet, but generally speaking, this is a great addition.  Rather than wait until I have had a chance to finish going over the code in detail, I thought I'd provide a quick bit of additional feedback now.\r\n\r\nThe feedback regards the syntax of foreign-procedure / foreign-callable argument and return types.  For ftype pointers (rather than ftype values), Andy and I used `(* `_ftype-name_`)` to leave open the possibility of later using just _ftype-name_ for ftype values.  Do you think this would work, and is it a good idea?\r\n\r\nBase ftype names like `int` that conflict with primitive argument and return type names would be a problem, so we'd probably have to disallow their use except by way of an alias.  In other words, we'd probably have to go with the primitive type rather than the (base) ftype in case of a name conflict.   I see what you mean about `&` in the return type highlighting the interface change.\r\n\r\nWhile I can see why you might want plain `NSUInteger` to indicate that the argument is or can be a simple integer rather than an ftype pointer, I don't know why you'd expect it.  When I declare an argument or return type to be an ftype, regardless of any decorations, I would expect the the argument or return value to be an ftype pointer.\r\n\r\nIn any case, I don't have a strong feeling one way or another about the change in syntax, so I'm okay leaving it as is. @ecraven, I'm in the process of reviewing the implementation and expect to be able to pull it when I'm done, possibly with minor corrections.  It wouldn't hurt to have another pair of eyes on it, though. Now that the `foreign-callable` code object performs a non-tail call rather than a tail call to the C call helper, it has become necessary to lock the code object before the code runs and not unlock it until after it returns, due to the possibility of a garbage collection in the invoked Scheme routine.\r\n\r\nFor example, the mat on line 2011 of foreign.ms needs to call `lock-object` on Fcons, something like:\r\n\r\n```\r\n(equal?\r\n  (let ()\r\n    (define Sinvoke2\r\n      (foreign-procedure \"Sinvoke2\"\r\n        (scheme-object scheme-object iptr)\r\n        scheme-object))\r\n    (define Fcons\r\n      (foreign-callable\r\n        (lambda (x y)\r\n          (collect)\r\n          (let ([ls (make-list 20000 #\\z)])\r\n            (collect)\r\n            (collect)\r\n            (collect)\r\n            (collect)\r\n            (collect)\r\n            (cons (length ls) (cons x y))))\r\n        (scheme-object iptr)\r\n        scheme-object))\r\n    (define (go)\r\n      (dynamic-wind\r\n        (lambda () (lock-object Fcons))\r\n        (lambda () (Sinvoke2 Fcons 4 5))\r\n        (lambda () (unlock-object Fcons))))\r\n    (go))\r\n  '(20000 4 . 5))\r\n```\r\n\r\nIt's a bit tricky to get this to fail reliably without the call to `lock-object`, but the following variant results in an invalid memory reference for me on both 32- and 64-bit Linux.\r\n\r\n```\r\n(load-shared-object \"../mats/foreign1.so\")\r\n(parameterize ([collect-request-handler void])\r\n  (define Sinvoke2\r\n    (eval\r\n      '(foreign-procedure \"Sinvoke2\"\r\n         (scheme-object scheme-object iptr)\r\n         scheme-object)))\r\n  (define Fcons\r\n    (eval\r\n      `(foreign-callable\r\n         (lambda (x y)\r\n           (collect)\r\n           (let ([ls (map (lambda (x) (make-vector 200 x)) (make-list 100))])\r\n             (collect)\r\n             (collect)\r\n             (collect)\r\n             (collect)\r\n             (cons (length ls) (cons x y))))\r\n         (scheme-object iptr)\r\n         scheme-object)))\r\n  (let loop ()\r\n    (let ([got (dynamic-wind\r\n                 (lambda () void #;(lock-object Fcons))\r\n                 (lambda () (Sinvoke2 Fcons 4 5))\r\n                 (lambda () void #;(unlock-object Fcons)))]\r\n          [expected '(100 4 . 5)])\r\n      (unless (equal? got expected)\r\n        (errorf #f \"expected ~s, got ~s\\n\" expected got)))\r\n    (loop)))\r\n```\r\n That's a good idea.  It should probably be unlocked automatically even when a call returns to some lower point on the stack, i.e., when there is a continuation invocation that causes an outer call into Scheme to return.  This might involve storing something extra in the cchain. Unfortunately, this ends up unlocking only one of the two code objects, resulting not only in one of the code objects being locked forever but also building up the locked object list and greatly slowing collection..  The basic problem is that the extra (dummy) CCHAIN element needs to be on top of the one stored in the frame, rather than below.  Fixing this also obviates the call to Sunlock_object in S_call_help.  The patch below seems to fix the problem.\r\n\r\n```\r\n*** ../../c/schlib.c\t2018-03-09 16:55:22.000000000 -0500\r\n--- ./schlib.c\t2018-03-09 18:42:10.000000000 -0500\r\n***************\r\n*** 219,238 ****\r\n      jb = CREATEJMPBUF();\r\n      if (jb == NULL)\r\n        S_error_abort(\"unable to allocate memory for jump buffer\");\r\n! \r\n      if (lock_ts) {\r\n        /* Lock a code object passed in TS, which is a more immediate\r\n           caller whose return address is on the C stack */\r\n        callable_code = TS(tc);\r\n        Slock_object(callable_code);\r\n!       CCHAIN(tc) = Scons(Scons(jb, TS(tc)), Scons(Scons(NULL, code), CCHAIN(tc)));\r\n      } else {\r\n        callable_code = NULL;\r\n-       CCHAIN(tc) = Scons(Scons(jb, code), CCHAIN(tc));\r\n      }\r\n  \r\n-     FRAME(tc, -1) = CCHAIN(tc);\r\n- \r\n      switch (SETJMP(jb)) {\r\n          case 0: /* first time */\r\n              S_generic_invoke(tc, S_G.invoke_code_object);\r\n--- 219,235 ----\r\n      jb = CREATEJMPBUF();\r\n      if (jb == NULL)\r\n        S_error_abort(\"unable to allocate memory for jump buffer\");\r\n!     FRAME(tc, -1) = CCHAIN(tc) = Scons(Scons(jb, code), CCHAIN(tc));\r\n      if (lock_ts) {\r\n        /* Lock a code object passed in TS, which is a more immediate\r\n           caller whose return address is on the C stack */\r\n        callable_code = TS(tc);\r\n        Slock_object(callable_code);\r\n!       CCHAIN(tc) = Scons(Scons(NULL, TS(tc)), CCHAIN(tc));\r\n      } else {\r\n        callable_code = NULL;\r\n      }\r\n  \r\n      switch (SETJMP(jb)) {\r\n          case 0: /* first time */\r\n              S_generic_invoke(tc, S_G.invoke_code_object);\r\n***************\r\n*** 245,255 ****\r\n          case 1: { /* normal return */\r\n              ptr yp = CCHAIN(tc);\r\n              FREEJMPBUF(CAAR(yp));\r\n!             if (lock_ts) {\r\n!               Sunlock_object(callable_code);\r\n!               CCHAIN(tc) = Scdr(Scdr(yp));\r\n!             } else\r\n!               CCHAIN(tc) = Scdr(yp);\r\n              break;\r\n          }\r\n          default:\r\n--- 242,248 ----\r\n          case 1: { /* normal return */\r\n              ptr yp = CCHAIN(tc);\r\n              FREEJMPBUF(CAAR(yp));\r\n!             CCHAIN(tc) = Scdr(yp);\r\n              break;\r\n          }\r\n          default:\r\n``` We should probably expose an foreign entry for the mats to use to check the number of locked objects and check it in various places during the mat run. _We should probably expose an foreign entry for the mats to use to check the number of locked objects and check it in various places during the mat run._\r\n\r\nWell, of course we already had something that returns a list of the locked objects to test `lock-object` and `unlock-object` in misc.ms, so I've put it to use in foreign.ms.\r\n\r\nThis turned up an interesting issue that predates this pull request but that this pull request exacerbates slightly, which is that erroring out of a procedure called via foreign-callable leaves the topmost `CCHAIN` element(s) on the `CCHAIN` stack and leaves the code object(s) locked.  I have not yet determined how to address this.\r\n\r\nI don't see any other problems with the pull request.  @mflatt, I would prefer that you update LOG and release_notes.stex so I can do a clean pull.  I'm happy to rebuild the boot files, or you can also include them.  Thanks for all of your efforts on this. The last change exposed another problem whereby `do_error` could pass `LONGJMP` a null jump buffer from one of the dummy `CCHAIN` entries, so I modified the `CCHAIN` entry to include a pair of code objects and eliminated the dummy entries.  `do_error` should probably be invoking a more specific entry rather than whatever happens to be first in the `CCHAIN`, and I'll look at that when I try to address the issue mentioned above in which `CCHAIN` entries are not getting cleaned up when a `foreign-callable` routine raises an exception.  Yes, it is unfortunate that ``:`` was chosen as a way to do this, since some file systems seem to have trouble with ``:``.  It is worth noting that most modern file systems allow ``:`` in file names.  Windows seems to be the hold out, although the [Windows Filesystem Character Set](https://msdn.microsoft.com/en-us/library/windows/desktop/dd317748%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396) page does not list ``:`` as a restriction, in testing it seems the DOS command shell does restrict this, though the cygwin and bash interfaces support it.\r\n\r\nAll of that said, I'm not a huge fan of the solution you've outlined here.  Part of the problem is that it makes assumptions about the underlying file system that are overly restrictive in almost every case.  Unicode characters, including spaces, punctuation, etc. are allowed on many operating systems and a translation that restricts to the character ranges ``a-z``, ``A-Z``, ``0-9``, and ``-`` seems extremely overly restrictive.  Especially considering ``_`` is also a commonly used file name element.\r\n\r\nOne possible solution is to expose a hook to how the file name is generated from the path to allow people to decide how restrictive they want the file system translation to be.\r\n\r\nRight now that library search is already a fairly complicated processes since it looks through the cartesian product of the library directories and extensions, and searches for matching pairs of source and binary libraries, optionally recompiling libraries if the source code of the library (or it's dependencies) has changed since the last time the library was compiled.\r\n\r\nI'd have to think some about how this would plug in to the system and how this should be exposed.  Sorry I did not get this in before the release.  The ``\\INSERTREVISIONMONTHSPACEYEAR`` tag in there was something that needed to be replaced by hand when the documents are generated.  I have replaced this with a little code to put the current month and year in the corresponding place in the document and it should build without needing the hand editing as of commit 1febe9b. Thanks for the reminder @marcomaggi, I've added the finished documents and intermediate files to the ``.gitignore`` As far as an ``install-docs`` rule in the makefile, the current ``install`` writes these documents to ``/tmp`` in preparation for putting them online.  So, before we add an ``install-docs`` we probably need to decide where these should go.\r\n\r\nFor unix-like operating systems I think putting these in ``/usr/share/csv<version_number>`` or ``/usr/local/share/csv<version_number>`` is probably the natural default for these (we could put this under the ``installprefix`` directory and add an ``installdocsuffix`` for controlling this under the ``installprefix`` as we do with  the manual pages.\r\n\r\nI'm not sure about Windows INSTALL, though for cygwin we could certainly follow the same convention.  Nice work! It builds fine with Bash/WSL. Please squash and rebase the two commits, and I'll merge it into master.  I installed [Git Large File Storage](https://git-lfs.github.com/), and it integrated seamlessly with git.\r\n\r\nI then ran `git lfs migrate import --include=\"*.boot\" --include-ref=refs/heads/master` to rewrite the master branch using LFS.\r\n\r\nI pushed the result to https://github.com/burgerrg/ChezScheme.\r\n\r\nRunning git clone on this repository downloaded a mere 40 MB and still allows me to go back in time and retrieve the boot files.\r\n\r\n@akeep, does TravisCI work with GitHub's large file support? It looks as though it's supported by default on Linux machines, but requires an install for macOS. I followed the example and got it to work on macOS, but it broke all the Linux builds because they don't have Homebrew. I figured out how to get it to work by updating .travis.yml with the following:\r\n```\r\nbefore_install:\r\n- if [ $TRAVIS_OS_NAME = osx ]; then brew install git-lfs; fi\r\n- if [ $TRAVIS_OS_NAME = osx ]; then git lfs install; fi\r\nbefore_script:\r\n- if [ $TRAVIS_OS_NAME = osx ]; then git lfs pull; fi\r\n```\r\n\r\nI didn't do anything about GitHub authentication, and it seems to be working. Installing git-lfs is easy on Linux, macOS, and Windows. The documentation online is easy to follow.\r\n\r\nWhat other things should we investigate to determine if we want to use git-lfs for Chez Scheme? I deleted my copy because it exceeded the 1 GB GitHub LFS free limit.  Thanks, Peter! Would you please add a line to LOG indicating that you changed c/vs.bat, and squash the 2 commits into one? Some of the mat failures are because you don't have iconv.dll in the bin/%m folder. I use https://github.com/win-iconv/win-iconv to build one for i3nt and a6nt. The directory-list failures with ~ depend on code in c/io.c. It uses HOMEDRIVE and HOMEPATH. Perhaps that code should use USERPROFILE instead? I installed Visual Studio 2017 BuildTools, and the a6nt machine passed the mats (o=0 and o=3).  Thanks for pointing this out! It should be fixed in commit f6780ec692e89cf8f5d55734b351b840e9321333.  Michael Adams created a type-recovery algorithm and implemented it for Chez Scheme as part of his dissertation research, with help from Andy Keep and others, but I never took the time to put it into the release stream, which would have involved fleshing out the primdata information, among other things.  Before incorporating another solution, it would be nice to give that work a close look.  [This paper](https://michaeldadams.org/papers/fast_flow_sensitive_cfa/paper-2011-oopsla.pdf) describes the algorithm.\r\n Hey @gus-massa,\r\n\r\nThanks for all your work on this!\r\n\r\nIt looks like this pull request is not quite ready to go though, because when I run the Chez Scheme unit tests I end up with a variety of failures.  I would note that you should not need to change the ``.travis.yml`` file to get things working, if your boot files are up to date.\r\n\r\nTwo types of errors I saw\r\n--------------------------\r\n\r\nI saw two types of unit test failures when running the ``mats``. \r\n\r\nFirst, there are a few places where the output of ``cp0`` is tested and the ``$cptypes`` pass improves on the output by using unsafe primitives in place of the type-checking version.  These (if you think they are correct) you should go ahead and update.  As part of the review process, these changes will be looked at as well.\r\n\r\nSecond, there are places where the changes in the PR are leading to some errors in the ``mats``.  The ``sint-list->bytevector`` procedure is incorrectly optimized when compiling the Chez Scheme libraries, and this is leading a handful to tests related to it to fail, and there are places where a specific error was expected and there is now an ``invalid memory reference`` error.\r\n\r\nI spent some time looking into the ``sint-list->bytevector`` problem, and I was able to isolate it to an erroneous optimization that is getting rid of a loop in the case of a list of 16-bit signed integers.  The original ``bytevector.ss`` file is a little big to operate on, so I managed to pair it down to a smaller test that demonstrates the problem:\r\n\r\n```scheme\r\n(define $s16-native-list->bytevector\r\n  (lambda (ls)\r\n    (let ((v (make-bytevector (fx* (length ls) 2))))\r\n      (let loop ((ls ls) (i 0))\r\n        (unless (null? ls)\r\n          (let ((k (car ls)))\r\n            (unless (and (fixnum? k) (fx<= -32768 k 32767)) (errorf #f \"invalid value ~s\" k))\r\n            (bytevector-s16-native-set! v i k))\r\n          (loop (cdr ls) (fx+ i 2))))\r\n      v)))\r\n```\r\n\r\nWhen I run ``expand/optimize`` on this with the current Chez Scheme from the git-repo, 2d1d3ad, I get the following:\r\n\r\n```scheme\r\n(begin\r\n  (set! $s16-native-list->bytevector\r\n    (lambda (ls.0)\r\n      (let ((v.1 (#2%make-bytevector (#2%fx* 2 (#2%length ls.0)))))\r\n        ((letrec ((loop.2 (lambda (ls.3 i.4)\r\n                            (if (#2%null? ls.3)\r\n                                (#2%void)\r\n                                (begin\r\n                                  (let ((k.5 (#2%car ls.3)))\r\n                                    (if (if (#2%fixnum? k.5)\r\n                                            (#2%fx<= -32768 k.5 32767)\r\n                                            #f)\r\n                                        (#2%void)\r\n                                        (#2%errorf #f \"invalid value ~s\" k.5))\r\n                                    (#2%bytevector-s16-native-set! v.1 i.4 k.5))\r\n                                  (loop.2 (#2%cdr ls.3) (#2%fx+ 2 i.4)))))))\r\n           loop.2)\r\n          ls.0 0)\r\n        v.1)))\r\n  (#2%void))\r\n```\r\n\r\nHowever, when I run ``expand/optimize`` on this with the current Chez Scheme patched with your changes, it (incorrectly) optimizes away the loop:\r\n\r\n```scheme\r\n(begin\r\n  (set! $s16-native-list->bytevector\r\n    (lambda (ls.0)\r\n      (let ((v.1 (#2%make-bytevector (#2%fx* 2 (#2%length ls.0)))))\r\n        (if (#2%null? ls.0)\r\n            (#2%void)\r\n            (let ((k.2 (#2%car ls.0)))\r\n              (if (if (#2%fixnum? k.2) (#3%fx<= -32768 k.2 32767) #f)\r\n                  (#2%void)\r\n                  (#2%errorf #f \"invalid value ~s\" k.2))\r\n              (#2%bytevector-s16-native-set! v.1 0 k.2)))\r\n        v.1)))\r\n  (#2%void))\r\n```\r\n\r\nI also verified it was ``cptypes`` making the change by switching up ``run-cp0`` with the following:\r\n\r\n```scheme\r\n(run-cp0\r\n  (let ()\r\n    (define (echo msg x)\r\n      (display msg)\r\n      (newline)\r\n      (pretty-print (#%$uncprep x))\r\n      x)\r\n    (lambda (cp0 x)\r\n      (let* ((x (#%$cp0 (echo \"original input\" x)))\r\n             (x (#%$cptypes (echo \"output of cp0 (1)\" x)))\r\n             (x (#%$cpletrec (echo \"output of cptypes (1)\" x)))\r\n             (x (#%$cp0 (echo \"output of cpletrec (1)\" x)))\r\n             (x (#%$cptypes (echo \"output of cp0 (2)\" x)))\r\n             (x (#%$cpletrec (echo \"output of cptypes (2)\" x))))\r\n        (cp0 (echo \"output of cpletrec (2)\" x))))))\r\n```\r\n\r\nThis printed out (amongst other things):\r\n\r\n```scheme\r\n---\r\noutput of cp0 (1)\r\n(begin\r\n  (set! $s16-native-list->bytevector\r\n    (lambda (ls.6)\r\n      (let ((v.7 (#2%make-bytevector (#2%fx* 2 (#2%length ls.6)))))\r\n        ((letrec ((loop.8 (lambda (ls.9 i.10)\r\n                            (if (#2%null? ls.9)\r\n                                (#2%void)\r\n                                (begin\r\n                                  (let ((k.11 (#2%car ls.9)))\r\n                                    (if (if (#2%fixnum? k.11)\r\n                                            (#2%fx<= -32768 k.11 32767)\r\n                                            #f)\r\n                                        (#2%void)\r\n                                        (#2%errorf #f \"invalid value ~s\" k.11))\r\n                                    (#2%bytevector-s16-native-set! v.7 i.10 k.11))\r\n                                  (loop.8 (#2%cdr ls.9) (#2%fx+ 2 i.10)))))))\r\n           loop.8)\r\n          ls.6 0)\r\n        v.7)))\r\n  (#2%void))\r\noutput of cptypes (1)\r\n(begin\r\n  (set! $s16-native-list->bytevector\r\n    (lambda (ls.6)\r\n      (let ((v.7 (#2%make-bytevector (#2%fx* 2 (#2%length ls.6)))))\r\n        ((letrec ((loop.8 (lambda (ls.9 i.10)\r\n                            (if (#2%null? ls.9)\r\n                                (#2%void)\r\n                                (let ([k.11 (#2%car ls.9)])\r\n                                  (if (if (#2%fixnum? k.11)\r\n                                          (#3%fx<= -32768 k.11 32767)\r\n                                          #f)\r\n                                      (#2%void)\r\n                                      (#2%errorf #f \"invalid value ~s\" k.11))\r\n                                  (#2%bytevector-s16-native-set! v.7 i.10 k.11))))))\r\n           loop.8)\r\n          ls.6 0)\r\n        v.7)))\r\n  (#2%void))\r\n---\r\n```\r\n\r\nYou'll notice the recursive call to ``loop.8`` was eliminated.  My suspicion (though I've not tracked this through the ``cptypes`` code) is that the something with the merge points around the ``(unless (and (fixnum? k) (fx<= -32768 k 32767)) (errorf ---))`` is merging to ``bottom`` when it should not be, or the ``pred-implies?`` is incorrectly identifying the result as bottom, which is causing it not to generate the `loop`` call in the output.  I could be wrong though, there could be something more subtle going on here, and it is worth noting that similar shaped code for the 32-bit signed integer does not manifest the same problem.\r\n\r\nA bug like this might also be what is causing the ``invalid memory`` exceptions I'm seeing.\r\n\r\nA note on style\r\n----------------\r\n\r\nI noticed it looks like you are using a ``box`` to represent an input/output parameter.  Instead of using boxes I recommend using multiple-value returns.  The advantage is that you avoid allocation, since (in the worst case) multiple-value returns are handled similar to a function call, and in the best case, it is possible for the multiple-value consumer to be pushed with in the multiple-value producer (see: [An Efficient Implementation of Multiple Return Values in Scheme](https://www.cs.indiana.edu/~dyb/pubs/mrvs.pdf) by Ashley & Dybvig).\r\n\r\nA note on asymptotic behavior\r\n--------------------------------\r\n\r\nLike @samth, I'm a little concerned about the potential for _O(n^2)_ behavior, traditionally we've tried to keep optimizations to _O(n log n)_, only allowing for _O(n^2)_ passes where it was required for correctness.  That said, if we can get this into shape, we can do some testing to see how deeply nested the ``if`` expressions have to get before we really start to see performance degradation in the compiler, and in the worst case, we can always cut off the analysis if we discover we are going down a path that is going to lead to bad performance.  In practice, as you've said, we may find we rarely hit the limit.\r\n\r\nLet me know if you'd like help on this, and thanks again for the work you've already put in!\r\n\r\n That all sounds good, thanks again for all of your hard work on this!\r\n\r\nAs the first real consumer of the signature data in ``primdata.ss``, I'm afraid you've ended up being the tester for that data.\r\n\r\nI'm not a windows user, but you might consider putting in an issue about the problems you've run into running the tests there, as this is something that should be possible, and there are windows users in the Chez Scheme community that might be able to help out. @gus-massa, try https://github.com/win-iconv/win-iconv to make an iconv.dll that works on Windows. I use this for x86 and x64. @gus-massa I agree that looks pretty hairy, but I would approach this a little differently.\r\n\r\nFirst, instead of using map and generating a list of lists, then mapping over the lists, I'd probably consider either building a loop to do this in place, or I'd write a multi-valued map macro that allowed for specification for the base-case null list values.  In this case though, the nanopass framework can help out, because it can already create the multi-valued map for you:\r\n\r\n```scheme\r\n[(call ,preinfo ,pr ,[e* r* t* t-t* f-t*])\r\n (let ([types (something-with types e* r*)])\r\n   (values `(call ,preinfo ,pr ,e* ...)\r\n           #f\r\n           (fold-left (lambda (types t) (pred-env-interset types t)) types t*)\r\n           #f #f))]\r\n```\r\n\r\nIf you take a peak at ``cpnanopas.ss``, you'll also see places where we've written custom loops, or extracted that into a function when we were going to use that several times. Hi @gus-massa,\r\n\r\nSorry it has taken me so long to get back to you.  I found a few bugs in testing and ended up fixing them myself as I was reviewing and experimenting a bit with the code.  Unfortunately, I was unable to push the changes directly into this pull request, so I have them up on a GitHub desktop created branch called [pr/192](https://github.com/cisco/ChezScheme/tree/pr/192).\r\n\r\nBefore I get into the list of the things that I changed (and where), there were a few things that I did not do, that are minor changes we still might want to consider.\r\n\r\nIn the ``fxmap`` code, it looks like ``$empty`` is probably a singleton and we might get away with an ever so slightly faster ``eq?`` check using the singleton instead of using ``$empty?``  (It is even possible to force the ``$empty`` record protocol to produce a singleton, but that is likely overkill.\r\n\r\nIn the ``cptypes`` code:\r\n---------------------------\r\nWe might consider making $record/rtd $record/ref lists into records... it is both more space efficient (2 words for the record instead of 4 for 2 pairs) and more performance efficient when checking for membership.\r\n\r\nI think there are still a handful of places where we can avoid doing multiple ``car``/``cadr``/etc. calls on the same object.  Less important for ``car``/``cdr``, but for ``cadr``, etc. slightly more important since we're walking multiple pointers repeatedly doing that.\r\n\r\nThe primitive call handling is a bit complicated, and I'm wondering if it is worth it to follow the ``cp0`` example of creating handlers for the primitives.  There may be some code we can communize in here, and I think it might clean things up a bit, though we are sort of on the borderline of needing more complicated handling.\r\n\r\nOn the performance side, I suspect there is still quadratic behavior lurking in here somewhere, but with the changes you've made I suspect it would be very difficult to construct the program that exposed this.  Part of the reason I say this is that the merging of ``fxmap``s has a linear worst case, and the handling of call arguments also does a linear walk over the items bound in the types maps when the ``pred-env-rebase`` function is called.\r\n\r\nThat said, I'm happy enough with where the performance is on this.  I think you've done a lot of good things to curtail the cases where we might run into trouble, and it doesn't seem to impact the compile time much if at all on my mac, though I've not done any formal benchmarking of it.\r\n\r\nSo, onto the changes I've made on my branch:\r\n\r\nRemoved ``counter`` field from ``prelex``, using the ``operand`` field instead to provide the index into the ``fxmap``.  This follows other uses within the compiler where we use the ``operand`` field as a little place for state that is used within a single pass.  This has a few advantages.  First, it keeps the record a little smaller.  Second, it means that the ``prelex`` numbering can start from ``0`` for each compilation unit, which should help keep the numbers for the ``fxmap`` a  bit smaller in longer running sessions with multiple calls to the compiler.  Finally, it avoids adding to the burden of the ``tc-mutex``, since the ``counter`` is now a local variable bound within the pass and it is safe for us to set the ``prelex``es, since only the instance of the pass holding this block of code has a handle on it.  As part of this change ``prelex-counter`` is now defined in ``cptypes`` and the ``operand`` is cleared after the variables go out of scope.\r\n```\r\n  base-lang.ss, cptypes.ss\r\n```\r\n\r\nFixed the ``highest-set-bit`` function in ``fxmap`` so that it will work in the 32-bit versions of Chez Scheme.  The ``fxsrl`` by 32 raises an exception in the 32-bit compiler, and was leading to tests to fail in 32-bit mode.\r\n```\r\n  fxmap.ss\r\n```\r\n\r\nRestructured ``predicate-implies?`` so that it uses committed choice instead of uncommitted choice in comparing ``x`` and ``y``.  Basically, this means, instead of doing:\r\n```\r\n(or (and (predicate-1? x) (predicate-1? y) ---)\r\n     (and (predicate-2? x) (predicate-2? y) ---)\r\n     ...)\r\n```\r\nwe now do:\r\n```\r\n(cond\r\n  [(predicate-1? x) (and (predicate-1? y) ---)]\r\n  [(predicate-2? x) (and (predicate-2? y) ---)]\r\n  ...)\r\n```\r\nThis avoids running predicates on ``x`` that we know will fail because an earlier predicate matches, generally getting out of the ``predicate-implies?`` faster.  This did require a little restructuring, because in some cases ``x`` was dominant and in other cases ``y`` was dominant.  This is now restructured with ``y`` dominate, after the ``eq?`` and ``x 'bottom`` check.\r\n```\r\n  cptypes.ss\r\n```\r\n\r\nReplaced ``let-values`` calls with cata-morphism syntax, including removal of ``map`` calls that built up a list of values that then needed to be separated out with ``(map car ...)`` ``(map cadr ...)`` etc. calls.  This avoid building up structures we don't need, since the nanopass framework will generate a mutltivalued ``map`` for these situations.\r\n```\r\n  cptypes.ss\r\n```\r\n\r\nThe ``if`` clause in ``cptypes/raw`` now uses ``types1`` (the result of the recursive call\r\non ``e1``) in place of the incoming ``types`` value when processing the ``e2`` or ``e3`` expressions in the cases where ``e1`` is known statically to produce either a false or non-false value.\r\n```\r\n  cptypes.ss\r\n```\r\n\r\nFixed a bug with directly-applied variable-arity lambda.  The original code marked all directly-applied variable arity lambda's as producing bottom, because it was checking for the interface to be equal to the number of arguments.  However, variable arity functions are represented with a negative number.  For instance, the original code would transform the expression:\r\n```\r\n(begin\r\n  ((lambda (a . b) (set! t (cons* b a t))) 'a 'b 'c)\r\n  t)\r\n```\r\nto\r\n```\r\n((lambda (a . b) (set! t (cons* b a t))) 'a 'b 'c)\r\n```\r\nanticipating that the call would raise an error, however, it is a perfectly valid (if some what unusual) expression.  I ended up adding tests that run ``cptypes`` without ``cp0`` to get this type of expression to ``cptypes``, so we can test it.  The code also chooses the correct clause from a ``case-lambda`` with multiple clauses.\r\n```\r\n  cptypes.ss\r\n```\r\n\r\nFixed ``make-time``, ``time-second-set!``, and ``time-second`` to indicate that second can be an ``exact-integer``, since it is not really restricted to the fixnum range (and in fact we even test this fact in the mats on 32-bit machines).\r\n```\r\n  primdata.ss\r\n```\r\n\r\n\r\nChanged check of ``prelex-was-assigned`` (which is not reliably set on the input to any given pass) with ``prelex-assigned``, which should always have an accurate, if conservative, value in it.\r\n```\r\n  cptypes.ss\r\n```\r\n\r\nAdded ``enable-type-recovery`` parameter to allow the type recover to be turned on and off (defaults to on), and added ``cptype`` to the ``cp0`` not run path that runs ``cpletrec``, so that ``cptypes`` can be run independent of ``cp0``.  This is helpful for testing and allows us to benefit from type recovery, even in cases where we do not want ``cp0`` to do anything that would re-arrange the input code\r\n```\r\n  compile.ss, front.ss, primdata.ss\r\n```\r\n\r\nStylistic changes, mostly for consistency with other parts of the compiler, though I'm not married to these changes if you'd really prefer to keep things the way the are.\r\n1. clauses of define-record type now use parenthesis instead of square brackets.\r\n2. indented by 2 spaces where things were only indented by one space\r\n3. define, let, define-pass, nanopass pass productions clauses, now use\r\n   parenthesis for outer markers instead of square brackets.\r\n```\r\n  fxmap.ss, cptypes.ss\r\n ```\r\n\r\nSorry for the changes being written to a branch, there is probably a better way for us to collaborate on this code, but sadly I'm not as experienced with the GitHub tooling as I probably should be and didn't want to spend the whole evening searching for a better solution.\r\n\r\nThanks again for all your hard work on this, let me know what you think and how you'd like to proceed.\r\n\r\n-andy:)\r\n One thing I almost forgot, I have not yet updated the documentation to add the ``enable-type-reccovery`` to CSUG, but we'll need to do that as well before we add pull in these changes. > ## About the ideas for changes:\r\n> * change ($empty? x) -> (eq? x <singleton>)\r\n>\r\n> OK. I'm only worry about the possibility in the future of reusing fxmap.ss in another pass (like cp0) and getting a different \"singleton\". This would be a problem is the fxmaps are somehow stored and shared. This problem is too hypothetical, so it can be solved with a comment in the file with a warning for the future.\r\n\r\nActually, you are already treating this as a singleton in places, where you return ``empty-fxmap`` in ``fxmap-remoe`` and ``fxmap-remove/base`` and when you initialize ``pred-env-empty``, it is treated as potentially different only in ``fxmap-for-each/diff``\r\n\r\n> There are three lines in cptypes.ss that have a #;CHECK reminder/warning. These are parts that I think that are correct, but I'm not sure. (For example, the clause for immutable-list in cptypes/raw.) I think that you already looked at the code and thought it was fine, but can you take another look at them so I remove the reminder/warning?\r\n\r\nThe ``immutable-list`` and ``cte-optimization-lock`` look good to me.  ``immutable-list`` is a special case that allows for ``cp0`` to look inside a list it knows was constructed during expansion of some internal syntax when we know there is no way it could be modified, so we can treat it as constant without doing any escape analysis on it.\r\n\r\nThe ``predicate-implies?`` check is a good question.  Obviously, ``eq?`` is the safest check here, though I think ``eqv?`` is also safe enough.  In theory, I believe that these are quoted constants which should not mutated, though Chez Scheme does not prevent this mutation.  That said, I think I'd rather stick with ``eqv?`` right now, unless we find some places where we think this is being overly conservative.  If we do loosen it up, we may also want to consider checking for record equality, which r6rs ``equal?`` does not do. \r\n Sounds good.  If the recursion is now within ``cptypes`` and the body expression is just a call to ``Expr``, then all of the cata-morphisms can have the ``cptypes :`` removed.  This will cause ``Expr`` to recur to ``Expr`` directly for the cata-morphisms.  It probably won't have a measurable impact on performance, but it does simplify the code a bit.\r\n\r\nI agree on the ``eqv?``, I think getting the numeric equivalence is worthwhile. Cool.  I'll can rebuild the boot files after merging this in to a local copy of master.\r\n\r\nWe should get the LOG and CSUG changes pulled in too if we can.  I can take a look at this over the weekend, and hopefully get things put together.\r\n\r\nJust so I understand, it sounds like the things you checked in on this pull request are up to date, with the exception of the LOG and CSUG changes.  As far as the travis changes, I've actually re-done how travis checks things on master and it should be doing the checking correctly now, though it will still run afoul of the changes that invalid the boot files. It took me a bit more effort than I expected to get the boot files built, but I managed to get these built and tested.\r\n\r\nUnfortunately, in testing I ran into what looks like it might be an unexpected error.  I was testing on `a6osx`, `i3osx`, `ti3osx`, and `ta6osx`, and ran into a strange bug on one of the runs of `ta6osx`.\r\n\r\nI'm getting the error: `pred-env-union/base: ` when running one of the threaded tests.  My suspicion is that something is getting fouled up with all the threads running (there is a call to `eval` in the thread test, which is invoking the `cptypes` pass:\r\n\r\n```scheme\r\n219     (define (pred-env-union/from from base types new-base)\r\n220       ; Calculate the union of types and from, and intersect it with new-base\r\n221       ; Iterate over the difference of from and base.\r\n222       (let ([ret new-base])\r\n223         (fxmap-for-each/diff (lambda (key x y)\r\n224                                (let ([z (fxmap-ref types key #f)])\r\n225                                  ;x-> from\r\n226                                  ;y-> base\r\n227                                  ;z-> types\r\n228                                  (set! ret (pred-env-add/key ret key (pred-union x z)))))\r\n229                              (lambda (key x)\r\n230                                (let ([z (fxmap-ref types key #f)])\r\n231                                  ;x-> from\r\n232                                  ;z-> types\r\n233                                  (set! ret (pred-env-add/key ret key (pred-union x z)))))\r\n234                              (lambda (key x) (error 'pred-env-union/base \"\") (void))\r\n235                              from\r\n236                               base)\r\n237           ret))\r\n```\r\n\r\nIt looks like line `234`, in this test is getting something unexpected, but I have not yet figured out why, nor do I have a good way to reproduce this quite yet.\r\n\r\nThe fact that this only showed up in one machine type of the two that run the thread tests and then only in one of the twelve runs of this tells me that something intermittent (and well buried) is going on in this code, so it might take some effort to ferret it out.\r\n\r\nJust FYI, we should update this error message to use `$oops` (or `$impoops` if you think this should be impossible) with a `who` argument like `compiler-internal` and a little bit more meaningful error message to give us some kind of indication as to what might have failed.  We try to stick to using `$oops` or `$impoops` inside the compiler, though I noticed a few `error` or `error` calls have leaked in from place to place.\r\n\r\nThe actual error I saw was in the following summary from a `ta6osx` run, the three errors are all in a row and the second one is almost certainly the result of the first, though the third one may or may not be related:\r\n\r\n```\r\n% cat ../mats/summary\r\n-------- o=0 --------\r\n-------- o=3 --------\r\n-------- o=0 cp0=t cl=3 --------\r\n-------- o=3 cp0=t cl=3 --------\r\n-------- o=0 spi=t p=t --------\r\n-------- o=3 spi=t p=t --------\r\n-------- o=0 eval=interpret cl=6 --------\r\n-------- o=3 eval=interpret cl=6 --------\r\n-------- o=0 cp0=t eval=interpret --------\r\n-------- o=3 cp0=t eval=interpret --------\r\n0a1,3\r\n> thread.mo:Error in mat thread clause 57: \"pred-env-union/base: \" at line 982, char 3 of thread.ms\r\n> thread.mo:Error in mat thread clause 58: \"extra threads running (#<thread 913> #<thread 912> #<thread 911> #<thread 910> #<thread 909> #<thread 908> ...)\" at line 1035, char 3 of thread.ms\r\n> thread.mo:Bug in mat thread clause 59 at line 1036, char 3 of thread.ms\r\n-------- o=0 ehc=t eoc=f cl=9 --------\r\n-------- o=3 ehc=t eval=interpret --------\r\n``` Oh, almost forgot.  I'll continue to poke at this a bit, but any insight you can provide would be helpful.\r\n\r\nThanks! I believe the only place more than one compiler session should have its hands on the same prelex is as part of the `$cte-optimization-info` related to a symbol or as part of the box in the `cte-optimization-loc`.  `cp0`, depends on this being true for more than just the `prelex-operand` info, it is also modifying the `prelex-name`, which is uses to replace incoming `prelex` records with new `prelex` record.  `cpnanopass` also relies on this when it replaces the `prelex` with `uvar` records.  So, if we can have multiple compiler sessions running simultaneously with their hands on the same `prelex` I would expect these places to also be a problem, though the nature of race conditions is that they might not show up very often, so it is possible we've just not had quite the right conditions to expose this.\r\n\r\nAll of that said, we should be able to look into this and check for it by putting in some auxiliary information in the `cptypes` pass to identify a `prelex` we are seeing for the first time that already has its `prelex-operand` set.  We've certainly had cases where we were allowing a single `prelex` record to be used at more then one binding form within the system, which led to some problems.\r\n\r\nOne other thing worth noting on this is that `prelex` records are created as part of the expander process, and each compiler session runs its own expander, so it is creating new `prelex` records for the code it produces.  In order for multiple sessions to have a handle on the same `prelex` it would need to be the case that output from a single expander session got sent to multiple compiler instances.  The only way I know of that this can happen is from a code fragment being inlined from the `cte-optimization-loc` box (aka the cross-library optimization information) from another library, which I don't think we should be seeing here, but that is definitely worth looking in to.\r\n\r\nIt might be a few of days before I get a chance to spend much time on this again, but hopefully we can get a reproducible, which will make me more confident in our fix :)\r\n\r\nOne question I did have in the `fxmap` code is why you decided to have the merge function run by side-effect instead of constructing the output functionally?  Was this just to try to optimize around the O(m + n) worst case of the merge function? Sorry that I've been a little slow getting back to this, work was a bit hectic and it has taken me a little bit of time to get back to this.\r\n\r\nJust to make sure I understand, the differences currently in this PR are with your changes that seem to run without error across the board, but if I take a look at your branch: [17-5-Types-Pass-Error](https://github.com/gus-massa/ChezScheme/commits/17-5-Types-Pass-Error) it will fail reliably in the threaded tests.\r\n\r\nIs your suspicion that the changes in the current PR still have the bug, but have chased it into hiding?\r\n\r\nI've made some changes in a local copy of this to match recent commits, merged master into this set of changes, and I'm currently running all the tests in `a6osx`, `i3osx`, `ta6osx`, and `ti3osx` on my mac.\r\n\r\nSo far this seems to be running along fine, but if we think there are still bugs hiding at the intersection of the `prelex-counter` code changes and the threaded versions, I can try to dig into that a bit (though I'm not sure if I'll have a chance to finish it up this week, and I'm traveling over the long weekend).\r\n\r\nThanks for continuing to push this along, I feel like we're really close to getting this in. I had a little time today to experiment with the [17-5-Types-Pass-Error](https://github.com/gus-massa/ChezScheme/commits/17-5-Types-Pass-Error) branch and you are not testing what you think you are testing.\r\n\r\nThe problem with the test is that the counter and hash table are effectively being allocated only once, instead of each time cptypes is run.  Since cptypes is run multiple times it is actually the same thread that is seeing the same prelex across multiple invocations of cptypes.  When I looked at the test my first thought was that I wanted to have proof that it was, in fact, different threads that were being the same prelex, so instead of storing just the index in the prelex-operand flag, I had it store a pair of the count and the thread-id (from `get-thread-id`).  When I ran this, I had the error message include the thread id as part of the result.  What I saw was that it was the same thread id that had both assigned the prelex and was now re-assigning the prelex.\r\n\r\nThe updated `prelex-counter` code:\r\n\r\n```scheme\r\n  (define prelex-counter\r\n    (let ()\r\n      (define count 0)\r\n      (define known (make-eq-hashtable))\r\n      (lambda (x)\r\n        (when (prelex-operand x)\r\n          (let ([k (eq-hashtable-ref known (car (prelex-operand x)) #f)])\r\n            (if k\r\n              (unless (eq? x k)\r\n                (newline)\r\n                (printf \"matting !!! [cptypes] duplicated prelex counter with ~s and ~s [~s (on thread: ~s)] ~s (on thread: ~s)\" x k (car (prelex-operand x)) (cdr (prelex-operand x)) count (get-thread-id))\r\n                (newline) \r\n                ($impoops 'cptypes \"duplicated prelex counter with ~s and ~s [~s (on thread: ~s)] ~s (on thread: ~s)\" x k (car (prelex-operand x)) (cdr (prelex-operand x)) count (get-thread-id)))\r\n              (begin\r\n                (newline)\r\n                (printf \"matting !!! [cptypes] unexpected prelex counter with ~s [~s (on thread: ~s)] ~s (on thread: ~s)\" x (car (prelex-operand x)) (cdr (prelex-operand x)) count (get-thread-id))\r\n                (newline)\r\n                ($impoops 'cptypes \"unexpected prelex counter with ~s [~s (on thread: ~s)] ~s (on thread: ~s)\" x (car (prelex-operand x)) (cdr (prelex-operand x)) count (get-thread-id))))))\r\n        (or (let ([p (prelex-operand x)])\r\n              (and p (car p)))\r\n            (let ([c count])\r\n              (set! count (fx+ count 1))\r\n              (prelex-operand-set! x (cons c (get-thread-id)))\r\n              (eq-hashtable-set! known c x)\r\n              c)))))\r\n```\r\n\r\nOne run of compiling the `thread.mo` mats for instance showed (amongst other some cascading thread errors):\r\n\r\n```\r\nError in mat thread clause 57: \"cptypes: duplicated prelex counter with ignore and ignore [3631 (on thread: 4141)] 3986 (on thread: 4141)\" at line 982, char 3 of thread.ms\r\nError in mat thread clause 59: \"cptypes: duplicated prelex counter with tmp and x [5177 (on thread: 4161)] 5295 (on thread: 4161)\" at line 1036, char 3 of thread.ms\r\n```\r\n\r\nIn both cases the setter and the detection were on the same thread (`4141` in the first case `4161` in the second case).\r\n\r\nOne way to avoid this problem is to move the creation of the hash table and the counter within the pass (probably I should have done this when I changed `prelex-counter` in the first place, since the intention was for count to start at 0 for each case).  I ended up moving the ``define-pass`` line up above the `prelex-counter` definition along with all of the other function definitions in the code.  This required a bit of re-giggering of the code since `pred-env-empty` was no longer in scope.\r\n\r\nYou can see the update and the diff in this [gist](https://gist.github.com/akeep/37db1369a87bfdf7cd55aaba2619446c).\r\n\r\nSo, I'm going to see if I'm going to pull some of the changes in the gist into my current copy of this and give it a try running the full Chez Scheme bully tests to see if I can get the error to occur, if it survives the bully tests I'm going to be tempted to merge this, though I may also ask for a second opinion on where we ended up.\r\n\r\nThanks again!  @gus-massa I think you should be able to test this by disabling cp0, since we now run the cptypes pass as part of the block with cpletrec so that it runs regardless of if cp0 is on or not.  (Actually, I made this change for exactly this reason.)\r\n\r\nI've also discussed this pass a bit with @dybvig, partially to verify my assumptions around how we are using the prelex in the cptypes pass.  As part of our conversation he asked if you had tried writing this up in a paper.  We both agree that this can be helpful in checking the reasoning on the path, and I think it would help @dybvig and I to better understand exactly what is going on in the pass.  I feel like I have a decent general understanding, but there are still some parts, particularly around the type environment maintenance, that I don't fully grok yet.\r\n\r\nAs I mentioned I'm traveling this weekend (in fact I was supposed to be on a plane right now, but we're currently delayed do to maintenance issues with the plane), so it will probably be Wednesday evening before I get much time to look at this again.  Looks good, thanks.  Thanks!\r\n\r\nI agree that guardians should be handled using the trigger mechanism even though chains might be rare.\r\n\r\nsweep() is probably not the right tool to use to process the contents of the objects guarded by an ordered guardian.  I believe there are at least three problems that might result:\r\n\r\n- Weak-pair car fields are not processed by sweep(), so objects reachable from the car field will not be ordered properly, and cycles through the car field will not prevent the weak pair from being finalized.\r\n\r\n- The processing of ephemeron pairs is deferred via add_ephemeron_to_pending().  I haven't traced this through, but this might cause a problem similar to the problem with weak pairs.\r\n\r\n- In general, cycles leading back to the object passed to sweep() will cause the object to be forwarded out from under sweep().  That is, the first two fields of the object being swept will be overwritten with the forward marker and forwarding address.  In some cases where this might cause harm, it happens not to do so; for example, if the car field of a (regular) pair points to the pair, relocating the car causes the pair's fields to be overwritten, but because the cdr field is now a pointer to the new-space pair, relocating the cdr field causes no harm.  In the case of code objects, overwriting the first two fields can cause the wrong length to be passed to S_record_code_mod().  While the latter issue is easily fixed by grabbing the length early, the situation is inherently fragile.\r\n\r\nIt might be possible to solve the weak-pair and ephemeron-pair problems with a specialized version of sweep(), though I believe that if a weak or ephemeron has already been forwarded, we'll still have to sweep it.  The other problem seems trickier.  We could solve it by copying guarded objects before sweeping them, but that's an unfortunate bit of extra run-time overhead.\r\n  This change makes sense to me; otherwise, the `pariah` form is worthless unless cp0 is disabled.  Please fix any mats that break as a result of the change, if any, and (particularly if there aren't any that break) add new tests that verify the change has the desired effect.  Please also add a LOG entry.  Don't bother rebuilding boot files, however.  Thanks for the pull request, but `void` doesn't take any arguments, so it doesn't make sense for the optimizer to discard them.  Are you proposing that `void` should be modified generally to accept any number of arguments and ignore them?  If so, more would need to be changed than cp0, and before additional changes are made, I'd like to know why it's desirable.  `values` can already be used for this purpose in many cases, and of course there's always `begin` or `(lambda r (void))`.\r\n\r\nIncidentally, the result of an argument expression evaluating to other than one value is unspecified, and the compiler often chooses not to verify that an argument expression evaluates to exactly one value when no further processing of the value is required, e.g., when the value is unused or when the entire call evaluates to the value, as in `(cons* (values 2 3))`, so if the optimization made sense at optimization level 3, it would make sense at other optimization levels.  This looks good to me, though with the pull of #170 the make files are out of date, and my attempt to fix the conflicts lost the record of your commits.  Would you please update the files so I can do a clean pull?  It looks like we might be using an 8-byte memory read where we should be using a 4-byte read to extract a flonum exponent, and this can sometimes run beyond accessible memory.  I'll take a deeper look and try to fix it. @burgerrg: I have a fix for this ready to push.  I'm holding off for now in case you're planning to pull the date-dst? request so @samth need not rebase again. Fixed with [this commit](https://github.com/cisco/ChezScheme/commit/97bd75bcedbcf32b77c59615a638ea1528ebe26b).  Good change, thanks.  Generally speaking, it's not necessary to commit new boot files if the changes don't affect compilation.  For example, a change in an error message or a change in the definition of a primitive in prims.ss would not require new boot files.  A change to primdata.ss would typically affect compilation, but the output type is not presently used for anything, if I'm not mistaken.  I'm tempted to make this fully backward-incompatible by having every source object record line and column information in addition to file-position information.  This would add overhead to the reader, which I don't think is a big deal since it doesn't tend to be a bottleneck on compilation, at least, and it would increase the size of every source object.  We could probably mitigate the latter with some careful encoding.  For example, we could combine bfp, beginning line, and beginning column in a single fixnum when they are small enough, and we could do the same for efp, ending line, and ending column except represent them as offsets from the bfp, starting line, and starting column to reduce the chance we'd have to resort to a larger encoding.  If this is too much of a compatibility hit we could make the line and column information optional.  _If this is too much of a compatibility hit we could make the line and column information optional._\r\n\r\nI guess that's what you've already done. :)  Though I would be tempted to require line and column for both bfp and efp or for neither, have source-object-bfp and source-object-efp return simple positions, and add source-object-{b,e}{l,c} procedures that return beginning and ending line and column, all or none of which can be false.   Source objects with line and column information could be represented by a subtype of the existing source objects. I've been looking over the source-location PR and have to admit `record-source-lines-and-columns` and all it entails aren't really to my liking.  In the interface, I don't like the rather indirect interaction of the `record-source-lines-and-columns` parameter, selected calls to `make-source-file-descriptor`, and `make-source object`, nor do I like the need to prune the table explicitly.  In the implementation, putting the table in the source-file descriptor (sfd) rather than, say, associating it with the sfd via a weak hashtable, is problematic because it's too easy for the table to get written along with the sfd to an object file, as will currently happen with `compile-file` and `compile-library`, which read, compile, and write the object file one expression at a time.  Also, line breaks can be determined properly in general only via a transcoded text port, so `make-source-file-descriptor` needs to do an additional pass (separate from the checksum computation) through the file's contents to create the table.\r\n\r\nThe existing (pre-PR) implementation has two major benefits, which are low read-time overhead and low storage overhead, requiring as it does only the maintenance and storage of the bfp and efp.  It has one major issue, which is large overhead when multiple calls to `locate-source` are made for the same file, since `locate-source` opens and scans the file twice on each call.  It also has a couple of minor issues: the file might not be available by the time `locate-source` is called, and the current transcoder might have changed.\r\n\r\nSetting aside the `record-source-lines-and-columns` parameter and all it entails, your solution potentially addresses both the major and minor issues, since it allows programs such as the reader to compute the line and column information in the same pass as it computes the file positions.  On the other hand, doing so loses the major benefits of low read-time and storage overhead.\r\n\r\nWhat would you think about having `locate-source` create and cache (via a weak hashtable) the position-to-line table instead as a way of avoiding multiple rereadings of the source file?  Because sfds might last indefinitely via pointers from compiled code, we could have each maximum-generation collection clear the cache of any tables that haven't been used since the last maximum-generation collection.  This would address the major issue without adding read-time or storage overhead, and it's a completely transparent change with no new primitives or incompatibilities.  It would not address the minor issues.\r\n\r\nIf you really need to be able to determine and store lines and columns at read time in some cases, e.g., you're reading something other than a file and can't use a similar cache, or you need to be able to report line and column information for files that aren't present at `locate-source` time, we could allow bfp and efp to be represented as integers or records, as the PR does, and also modify `locate-source` to create and cache the position-to-line tables to handle cases where the information isn't supplied.\r\n\r\nIn either case, I would leave out `record-source-lines-and-columns` and the related changes.\r\n Though I like the simplicity of the current mechanism, and I have some qualms about the potential performance hit to the reader, I can go along with allowing the optional use of file-position records in place of simple file positions in source objects as well as adding and using the current-make-source-object parameter (which I believe you mean rather than current-make-syntax-object).\r\n\r\nI still think locate-source (actually $locate-source) should handle caching internally, and there are better ways to prevent trolling through the filesystem at run time, so I'd prefer to add caching to $locate-source and not add the current-locate-source parameter.  More on my rational in my responses to your comments below.\r\n\r\n_This implementation does not add caching for locate-source. I don't know how to do that and remain consistent with the idea that locate-source tells you whether the source file has changed._\r\n\r\nI don't share your concern with this.  There's already a window between when the file is opened and the two scans (to compute the CRC and locate the line and column) are complete, during which the file might change on disk.  If we prune the table fairly quickly, the window is not that much larger.  Also note the check is gone completely if the line and column are computed at compile time since by design the updated locate-source doesn't bother to find the file and check the CRC.\r\n\r\n_I worry about system operations trolling through the filesystem in a final application._\r\n\r\nYou make it sound so nefarious. :)  Seriously, since this most commonly happens only when the application errors out without having set an appropriate exception handler, how worrisome is it?  Also, via current-make-source-object, one can ensure that all source-object positions are file position records, in which case $locate-source won't do the trolling anyway.  One can also limit trolling by setting source-directories and library-directories before calling anything that might end up in $locate-source. Having to ask for the current directory among the parameters to check if the cache is still valid is a big hit, depending on the O/S.  It makes me wonder if we aren't better off changing the interface to make caching explicit, perhaps along the lines you suggested earlier, or perhaps by changing the interface to locate-source.  For example, `make-source-locator` might take an sfd and return a source locator (i.e., a representation of the cache), and `locate-source` might optionally accept a source locator in place of an sfd. I think it works, and it doesn't require source objects to contain a source-file locator, but it does push the responsibility of maintaining the cache onto the `locate-source` caller.  That was the effect I was going for, because it doesn't change the behavior of `locate-source`, and the caller should know better its tolerance for changes that might affect the search.  On the other hand, it is inconvenient, and a way to achieve a similar effect would be an optional _okay-to-cache?_ argument to `locate-source` to say it's okay to cache (unconditionally).  For most applications, this would be the desired behavior.\r\n\r\nIncidentally, checking `current-directory` and the other parameters is insufficient as well as expensive, because it doesn't catch changes in the filesystem that effectively relocate source files.  `current-directory` can also fail due to lack of permissions or even fail to return due to cycles in the file system, though such situations are rare.\r\n\r\nAlthough it's impossible to make the cache truly transparent due to various race conditions, we could come pretty close by recording the file modification time and having `$locate-source` go through the motions of locating the source file using the same algorithm as `$open-source-file` but stop short of opening the file and computing the checksum and instead compare the file modification time.   I prefer the optional _okay-to-cache?_ argument to locate-source, however.\r\n Using a tc parameter for `current-make-source-object` might help, but the replacement of inline allocation with an anonymous procedure call is probably the bigger hit. Right.  That's where it gets inconvenient.  The `let-values` macro, or perhaps the expander operating on its behalf, would have to maintain a mapping from sfds to locator objects.  That's why I prefer the _okay-to-cache?_ flag. Thanks.  Is it necessary to represent the line explicitly in the position->line table?  That is, isn't the vector index the same as the line number, so can't the table just be a vector of positions, so that v[0] is the position of line 0, v[1] the position of line 1, etc.? I like what you did with `$make-source-object`.  Maybe we should take it a step further and combine it with your idea for using a tc parameter:\r\n\r\n- new tc parameter: `$current-mso` initially #f\r\n- `(current-make-source-object)` returns `(or ($current-mso) make-source-object)`\r\n- `(current-make-source-object p)` sets `$current-mso` to `(if (eq? p make-source-object) #f p)` after verifying p is a procedure\r\n- `$make-source-object` becomes a macro defined in read.ss that, if `($current-mso)` is #f, calls `%make-source`; otherwise calls `($current-mso)`\r\n\r\nThat should eliminate most of the read overhead when `current-make-source-object` has its default value. I think I'd prefer to have `(current-locate-source)` take exactly the same arguments as `locate-source` and to push the logic that looks for the existence of the source-object start line+column into the caller.  If that doesn't seem reasonable, I agree `current-locate-source` is misnamed, and there ought to be a name for its default value that one can call directly or use to reset the parameter. Here are some possible shorter alternatives to locate-source-object-source:\r\n\r\n- source-object-location\r\n- source-location\r\n- determine-source-location\r\n- determine-location\r\n\r\nI would be tempted to leave out the use-cache? argument and have the default procedure pass locate-source #t for the argument. Agreed.   I'm okay with the current names. I have reviewed the latest code changes in detail, and I have a few final suggestions.\r\n\r\n(1) The `current-mso` thread-context field needs to be relocated by `sweep_thread` (gc.c), so add:\r\n```\r\nrelocate(&CURRENTMSO(tc))\r\n```\r\nafter\r\n```\r\nrelocate(&SFD(tc))\r\n```\r\n\r\n(2) When called from `$display-condition` rather than `$make-source-oops`, `$display-condition` should probably pass `(current-locate-source-object-source)` `#f` for the `use-cache?` argument.  The `$display-condition` prefix? argument already distinguishes the calls from `display-condition` and `$make-source-oops`, though before it is also used to determine the value of `use-cache?`, it should probably be renamed.\r\n\r\n(3) I would change `source-object-bfl` and `source-object-bfc` to `source-object-line` and `source-object-col` (or `source-object-column`).  I don't think anyone would be surprised that these are the beginning line and column.\r\n\r\n(4) I would rewrite the loop in the read.ss definition of `binary-search` from:\r\n```\r\n(let loop ([lo 0] [hi (vector-length table)])\r\n  (let* ([mid (fxsra (fx+ lo hi) 1)]\r\n         [pos (vector-ref table mid)])\r\n    (cond\r\n      [(fx= (fx+ 1 lo) hi)\r\n       (values name\r\n               hi\r\n               (fx+ 1 (fx- fp pos)))]\r\n      [(< fp pos) (loop lo mid)]\r\n      [else (loop mid hi)])))\r\n```\r\nto\r\n```\r\n(let loop ([lo 0] [hi (vector-length table)])\r\n  (if (fx= (fx+ 1 lo) hi)\r\n      (values name\r\n              hi\r\n              (fx+ 1 (fx- fp (vector-ref table lo))))\r\n      (let ([mid (fxsra (fx+ lo hi) 1)])\r\n        (if (< fp (vector-ref table mid))\r\n            (loop lo mid)\r\n            (loop mid hi)))))\r\n```\r\nboth to avoid the computation of mid in the base case and to avoid implicit reliance on the fact that mid is the same as lo in that case.\r\n\r\n(5) The optional third argument to `$source-file-descriptor` in the syntax.ss definition of `include` can be omitted, since `#t` is the default value, and this an unnecessary change to the code.\r\n  The destination-length computation in `bytevector-compress` seems at best zlib-version-specific.  Can the `compressBound` function be used in place of the computation?  Did you consider recording the length with the compressed data so `bytevector-uncompress` need not take the length as an argument?  It seems like a reasonably small amount of overhead to include a 64-bit length at the front of the compressed bytevector. Looks pretty good.   A few minor comments:\r\n\r\n- It might be nice for `bytevector-uncompress` to verify that the embedded length is valid using `is_valid_zlib_length`.   I'm thinking of the case where a compressed bytevector is created on one type of machine and uncompressed on another with a smaller uLong size.  (I like that you've already hardcoded the size and endianness to facilitate cross-machine-type compression/decompression.)\r\n\r\n- It might also be nice for `bytevector-uncompress` to complain if the length returned by `$bytevector-uncompress` isn't the same as the recorded uncompressed length, rather than truncating in the case where the length is shorter.\r\n\r\n- It would be nice to get the source bytevector into the error messages / condition irritants list as an aid to debugging.\r\n\r\n- Instead of defining `uncompressed-length-length` to be 8, it would be better to use `(ftype-sizeof integer-64)` or `(ftype-sizeof iptr)`.\r\n\r\n- In the CSUG description of `bytevector-compress` I would stick the word `new` in the returns clause and remove the first paragraph of the description.  I would remove `, for example,` from the second paragraph.  In both new CSUG entries, the first `\\var{bytevector}` in the returns clause should just be `bytevector`.\r\n\r\nI can make these changes after pulling, if you prefer.\r\n  I don't experience this problem with `configure --threads; make` in the current repo.  It's possible you happened to pull when the boot files were out-of-date relative to the source, which could cause this problem.  Thanks.  These optimizations look sound and useful.  I suggest a few adjustments:\r\n\r\n1. Add a length check for the `inline-lists` quoted-list case to avoid turning a small amount of code into code proportional to the size of a long list.  The code uses 4 as the maximum size for this purpose elsewhere.  You could relax this if a call to `list` is also present, though it's probably not worth the effort.\r\n\r\n2. The safe-assert condition on line 3730 is guaranteed only if n isn't the result of a call to `list` without arguments, e.g., it isn't guaranteed if the list arguments to for-each are `(list)` and `e`.  Now, `(list)` should have been reduced to `(quote ())` by the cp0 handler for `list` before it arrives here, but since cp0 isn't guaranteed to reach a fixed point, we should count only on what the local cases guarantee.  A simple way around this would be to check for `(list)` as well as `null-rec?` in the first cond clause or to have `null-rec?` check for `(list)` with an appropriate comment about why we have it do so.\r\n\r\n3. It would be nice to verify that side effects are preserved and aren't improperly interleaved when a constant list is involved by adding a mat similar to the one on line 1192 of 4.ms.  It looks like we have no such tests for `for-each`, so adding similar tests for it would be nice.\r\n\r\n4. cp0.ss indentation: add a space at the front of lines 3595-3600 and 3602-3603, and remove the extra space at the front of line 3609.  You might as well remove the (preexisting) extra space at the front of lines 3624-3626.  (Actually, you can eliminate the `begin` wrapper and remove three spaces from the remaining lines.)\r\n `for-each` does guarantee left-to-right order of evaluation---it's one of its primary charms.   `map`, however, does not.\r\n\r\nIt's appropriate that you do not check the `for-each` return value.  Most Chez Scheme primitives that return an unspecified value actually return void; `for-each` doesn't always, because it usually returns the value of the last call to maintain proper treatment of tail recursion. Since receiving clarification of the `for-each` left-to-right application requirement, have you checked to make sure the new optimizations preserve the order and the new tests verify it?  If so, I think we're ready to go, though I'll give it a once over before pulling.  Please remove the boot files from the pull request---I'll create and push them myself. One of the mats was failing due to an order-of-evaluation problem, so I've reverted cp0.ss for now.  I see the problem and will patch it up soon.  After spending a lot of time over the past couple of weeks trying to benchmark the system w/ and w/o support for ephemerons, I've come to the conclusion there isn't enough difference to matter.  Or there is and the benchmarks aren't consistently showing it.  I was initially getting statistically significant increases in gc time and overall cpu time of around 5% and 2%, but they have disappeared with my latest timings on a different machine.  C'est la benchmarking vie.\r\n\r\nI'm interested in trying the simpler implementation I outlined in an earlier note, just to see what that costs, but I don't have time to run the experiment.  Maybe I will sometime after the current implementation has been pulled.\r\n\r\nHere are some suggestions for the current implementation:\r\n\r\n- Use FORCEINLINE (defined in segment.h, which is included into gc.c by the include of system.h) for check_trigger_ephemerons, lest some C compiler think the better of it.\r\n\r\n- Declare all of the static functions on top, as is the convention.  I think the only ones missing right now are check_pending_ephemeron and check_trigger_ephemerons.  I don't know if FORCEINLINE will cause problems on the latter.\r\n\r\n- Have sweep and sweep_space place ephemerons whose keys have not yet been reached directly onto the trigger ephemeron list of the key's segment and also onto the global trigger_ephemerons list.  (check_dirty_ephemeron already does this.)  Then eliminate the pending_ephemerons variable and uses of it.  (Perhaps I've missed something and this won't work or isn't a good idea.)\r\n\r\n- Have clear_trigger_ephemerons identity ephemerons to be bwp'd by checking the key's space rather then by checking to see whether the trigger_next field is #t.\r\n\r\n- Externally link ephemerons on the segment and global trigger lists, and eliminate both extra fields from the ephemeron representation.  This also obviates the special case for ephemerons in size_object.\r\n\r\n- Have trigger_ephemerons be a list of lists of ephemerons rather than a simple list of ephemerons to avoid the list traversal in add_trigger_ephemerons_to_repending.\r\n\r\nI can attempt any or all of these after doing the pull, if you prefer, but please update LOG, update the boot files, and revert patch.ss so I can do a clean pull, since I haven't figured out how not to take credit for the changes when doing a command-line pull.\r\n <i>I didn't make the third change. I think the indirection through pending_ephemerons makes the GC perform less work in the common case ...</i>\r\n\r\nFair enough.  Is there a reason why `check_dirty_ephemeron` should not also put the ephemeron on `pending_ephemerons` rather than on the trigger lists? That's what I was thinking.  I'm testing the change now and will commit it unless I run into a problem.  Nice find! fxarithmetic-shift-left also gives the wrong error who (fxsll) when the arguments are not fixnums. The logic in library.ss for fxsll and fxarithmetic-shift-left needs to corrected. @dybvig, the documentation of fxsll and fxarithmetic-shift-left aren't in sync. fxsll allows fixnum-width shifts, whereas fxarithmetic-shift-left doesn't. fxarithmetic-shift-left doesn't mention an exception on overflow. What would you like me to change?  Nice find! The enum-set-indexer code in enum.ss needs to check that the variable is a symbol before calling symbol-hashtable-ref with it.  I don't know that we have any particular plans to work on this right now, but we would certainly welcome the effort if someone wanted to take the lead on the porting work.  Kent, I've got a possible fix on rgburger/threads. Thanks, I'll make those two edits and push to master.  Chez Scheme's default scheme-start procedure treats each argument as a filename to load. If you want different behavior, you'll need to specify a scheme-start procedure. Another option is to use the --script argument to Chez Scheme. Suppose script.ss has the following in it: `(pretty-print (command-line))`\r\n\r\nThen chez --script script.ss -- --flag 1 will print:\r\n`(\"script.ss\" \"--\" \"--flag\" \"1\")`  The storage for mutex and condition objects allocated by malloc in c/thread.c is never freed. What would it take to place them under the garbage collector's control? Perhaps a guardian like file-guardian that detects when they're no longer used? And we'll have to be careful about the places where the c code is called with the raw addresses and the wrapper Scheme object is no longer referenced. I have a proposed fix on branch rgburger/threads. @dybvig or @akeep, what do you think? I added a $keep-live primitive to keep the mutex and condition Scheme records live across calls that deactivate the thread (mutex-acquire and condition-wait), and then keep track of the inaccessible mutexes and conditions with guardians that get cleaned out with $close-resurrected-mutexes&conditions. We could change the Scheme condition and mutex records to use a mutable addr and set it to 0 when the C data structure is freed. It would then be easy to detect this situation and report an exception. Shall I make that change? I've made the changes and added a mat for this case. Is there anything else?  This looks like a CRLF line ending problem. Are you using Cygwin's git? Is it configured to use CRLF line endings? If so, configure it not to change the line endings.  You've picked one of the trickier records to update.\r\n\r\nOften, the solution is simply to change the uid, i.e., in\r\n\r\n```\r\n(define-record-type primref\r\n  (nongenerative #{primref a0xltlrcpeygsahopkplcn-2})\r\n  (sealed #t)\r\n  (fields name flags arity signatures))\r\n```\r\n\r\nchange `a0xltlrcpeygsahopkplcn-2` to `a0xltlrcpeygsahopkplcn-3`.  (You might want to check first to make sure the new name isn't used elsewhere.)\r\n\r\nThis resolves the \"mismatched record type\" error.  In this case, however, you immediately get another problem, which is an unrecognized record error in $uncprep.\r\n\r\nSuch errors typically result from old instances floating around that code expecting new instances trips on.  They can often be resolved by using the `update-record-type` macro, which is defined in cmacros.ss.  For example:\r\n\r\n```\r\n(update-record-type (primref make-primref primref?) (primref-name primref-flags primref-arity primref-signatures) ()\r\n  ; old record definition, with stub for missing accessor\r\n  (begin\r\n    (define-record-type primref\r\n      (nongenerative #{primref a0xltlrcpeygsahopkplcn-2})\r\n      (sealed #t)\r\n      (fields name flags arity))\r\n    (define (primref-signatures x) 'signature))\r\n  ; new record definition, with stub for missing accessor\r\n  (define-record-type primref\r\n    (nongenerative #{primref a0xltlrcpeygsahopkplcn-3})\r\n    (sealed #t)\r\n    (fields name flags arity signatures))\r\n)\r\n```\r\n\r\nIn this case, however, the error results from new instances tripping up old code.  To get around this requires a bit of work, starting with building one system that understands but doesn't create instances of the new record type, using it to bootstrap a new system that understands and creates instances of the new record type, then using it to bootstrap a system that understands only the new record type.  To make life easier if you make mistakes or need to adjust your changes, you should actually bootstrap the first from one that deals only with the old record type.  (By the same token, to make life harder you can try to do all of these steps in the same workarea, and you might succeed if you get everything right the first time.)  Assuming you're on an OS X system, here's the complete process:\r\n\r\n1. Create a fresh copy of the repository.  WARNING: if you choose not to clone a new copy, make sure your existing copy is free from any of the related changes before starting.\r\n\r\n```\r\ngit clone <path to branch> chezscheme\r\ncd chezscheme\r\n```\r\n\r\n2. Build an untouched base system for bootsrapping.\r\n\r\n```\r\nconfigure --workarea=understands-only-old\r\nmake\r\n```\r\n\r\n3. Next build a system that understands the new record type but doesn't create instances of it yet, using a different workarea.  WARNING: don't forget to make a local copy of the files you edit on this and the other steps.  Don't edit the root-directory copies, or you'll find it difficult to retrace your steps if you need to make changes.\r\n\r\n```\r\nworkarea a6osx understands-new-creates-old\r\npushd understands-new-creates-old/s\r\ncp ../../s/primref.ss .\r\nedit s/primref.ss (Edit 1 below)\r\nmake -f Mf-cross m=a6osx xm=a6osx base=../../understands-only-old\r\n(cd ../c; make)\r\npopd\r\n```\r\n\r\n4. Next build a system that understands and creates instances of the new record type:\r\n\r\n```\r\nworkarea a6osx understands-new-creates-new\r\npushd understands-new-creates-new/s\r\ncp ../../s/primref.ss ../../s/primvars.ss .\r\nedit s/primref.ss and s/primvars.ss (Edit 2 below)\r\nmake -f Mf-cross m=a6osx xm=a6osx base=../../understands-new-creates-old\r\n(cd ../c; make)\r\npopd\r\n```\r\n\r\n5. Finally build a system that understands only the new record type, bootstrapping itself at the end:\r\n\r\n```\r\nworkarea a6osx understands-only-new\r\npushd understands-only-new/s\r\ncp ../../s/primref.ss ../../s/primvars.ss .\r\nedit s/primref.ss and s/primvars.ss (Edit 3 below)\r\nmake -f Mf-cross m=a6osx xm=a6osx base=../../understands-new-creates-new\r\n(cd ../c; make)\r\nmake allx\r\npopd\r\n```\r\n\r\nEdit 1 (primref.ss only):\r\n\r\nThe first edit replaces the existing record definition of `primref` with one that understands both old and new record types but creates old ones.  It abuses the `update-record-type` macro by swapping \"old\" and \"new\" roles, since `update-record-type` exports the new maker and we want the old.\r\n\r\n```\r\n(update-record-type (primref make-primref primref?) (primref-name primref-flags primref-arity primref-signatures) ()\r\n  ; new record definition, with stub for missing accessor\r\n  (define-record-type primref\r\n    (nongenerative #{primref a0xltlrcpeygsahopkplcn-3})\r\n    (sealed #t)\r\n    (fields name flags arity signatures))\r\n  ; old record definition, with stub for missing accessor\r\n  (begin\r\n    (define-record-type primref\r\n      (nongenerative #{primref a0xltlrcpeygsahopkplcn-2})\r\n      (sealed #t)\r\n      (fields name flags arity))\r\n    (define (primref-signatures x) 'signature))\r\n)\r\n```\r\n\r\nEdit 2 (primref.ss and primvars.ss both):\r\n\r\nThis edit to primref.ss simply puts the `update-record-type` forms in the \"proper\" order:\r\n\r\n```\r\n(update-record-type (primref make-primref primref?) (primref-name primref-flags primref-arity primref-signatures) ()\r\n  ; old record definition, with stub for missing accessor\r\n  (begin\r\n    (define-record-type primref\r\n      (nongenerative #{primref a0xltlrcpeygsahopkplcn-2})\r\n      (sealed #t)\r\n      (fields name flags arity))\r\n    (define (primref-signatures x) 'signature))\r\n  ; new record definition, with stub for missing accessor\r\n  (define-record-type primref\r\n    (nongenerative #{primref a0xltlrcpeygsahopkplcn-3})\r\n    (sealed #t)\r\n    (fields name flags arity signatures))\r\n)\r\n```\r\n\r\nFor primvars.ss, make the changes you already made.\r\n\r\nEdit 3 (primref.ss and primvars.ss both): \r\n\r\nThis edit removes the `update-recordd-type` form leaving only the new definition in place:\r\n\r\n```\r\n(define-record-type primref\r\n  (nongenerative #{primref a0xltlrcpeygsahopkplcn-3})\r\n  (sealed #t)\r\n  (fields name flags arity signatures))\r\n```\r\n\r\nFor primvars.ss, again make the changes you already made.\r\n\r\nYou can start again at Step 3 if you need to modify the new record type definition.  At some point, if you want to commit and push the changes, you'll need to get the final local copies back to the root directory.  You can use `checkin understands-only-new` to do that or simply copy the files you've modified (including the boot files) into the proper root source directory.\r\n  The change in representation your proposal lays out doesn't actually limit the lengths of vectors, since the high-order bit of the type/length field was previously always zero.  It also doesn't actually require mutators to do a separate mutability check, since they can mask in and check the mutable bit when they check the type.\r\n\r\nIt does limit the lengths of strings and bytevectors, and the main question is whether this is acceptable on 32-bit machines.  The prospect doesn't bother me as much as it once would have, because we have the 64-bit option.  How much longer will we care about 32-bit machines, anyway?\r\n\r\nI would indeed want to extend the immutability option to fxvectors for consistency, which would be easy.  Ideally, I would also want to extend it to pairs, which would not be easy following the path you've proposed, since there's no place in the pair itself to store a mutable bit.\r\n\r\nHere is a different proposal that supports an immutability option for all types of objects, including pairs; while it doesn't reduce lengths, it does waste space, particularly for smaller objects, on 32-bit machines:\r\n\r\n- align objects on 16-byte rather than just 8-byte boundaries,\r\n\r\n- use the extra primary tag bit as a mutable flag, and\r\n\r\n- add an `immutable` procedure, which for an input value _x_ returns a value _y_ that is like _x_ except that, if the object to which _x_ refers can be mutated directly through _x_, it cannot be mutated directly through _y_.\r\n\r\nThat way mutability would be a capability of the pointer rather than an inherent property of the object itself, and an object remains mutable through the original pointer.  Is this sufficient for Racket's purposes, or can Racket be modified to make it sufficient?\r\n\r\nOn 64-bit machines, most objects (all but flonums) are already aligned on 16-byte boundaries, so the hit here is again significant only on 32-bit machines.\r\n\r\nAligning pairs on 16-bytes boundaries on 32-bit machines is a particularly big waste, since it effectively doubles the size of a list.  If we're willing to steal an extra primary code for pairs, say from symbols, we could leave pairs aligned on 8-byte boundaries on 32-bit machines and still be able to distinguish mutable from immutable pairs.  For example, we could give pairs primary type codes `#b110` (immutable) and `#b111` (mutable), so that after isolating the type bits, pair? would check to see if the result is 6 or greater, and mutable-pair? would check to see if the result is exactly 7.\r\n\r\nClosures and flonums could remain aligned on 8-byte boundaries on 32-bit machines, since they are already immutable.\r\n\r\nOf course, this doesn't reduce the waste for other small objects, like boxes, ratnums, small strings, small vectors, small bytevectors, and small record instances. Never mind my alternative proposal---it adds unacceptable overhead to object field accesses, which would have to mask off the mutable bit.  Of course I didn't think of that until walking away from the keyboard and letting my mind clear. The thing to do with vectors is to handle them more like strings, bytevectors, and fxvectors, i.e., put the immutable bit near the low end with the type tag.  There's no advantage to putting the immutable bit at the top, and it makes the mask larger, resulting in larger instructions, especially on 64-bit machines.  Vectors were being treated differently just to take advantage of the fact that the length could be a plain fixnum, which will no longer be the case.\r\n\r\nTo make this feasible, I'm working on a set of changes now intended to reduce the special handling of vectors to no more than a few cases, which will be flagged by meta-asserts.  Assuming I catch all of the cases, it should be relatively straightforward to treat vectors more like the others.\r\n\r\nImmutable boxes would be easy to support with a bit in the tag field.  Pairs are the troublemakers. With [this commit](https://github.com/cisco/ChezScheme/commit/564542d32bbae6b33cef808613238d5a4a2a8ee2), I've weeded out the special handling of vectors in the compiler and run-time system, commonized more of the string/fxvector/bytevector/vector code in the compiler, and tested with alternative type-vector, mask-vector, and vector-length-offset settings (`#b100`, `#b111`, 3 on a 32-bit build; `#b1000`, `#b1111`, 4) on a 64-bit build.  All seems to work, but I reverted the settings for vectors back to the fixnum type, mask, and offset, since that gives us shorter instruction sequences for some vector operations---for now.  For separate mutable and immutable vectors, you'll want to use the top type bit as the immutable bit (or you'll get a failing idiot check on start-up about vector type/length fields not looking like fixnums), so just what I listed above for immutable vectors, and for mutable vectors, use type `#b000` on 32-bit builds and `#b0000` on 64-bit builds. If you're happy with the more restricted interface that doesn't alter objects in place, that's fine with me, but it does prevent one from defining a cyclic structure using mutation then marking all of the pieces immutable.  Also, if the public Scheme feature copies the object, I'd prefer the public C feature do so as well, especially since we might come up with an implementation that doesn't involve mutation someday.\r\n\r\nIs it appropriate to mark the empty vector, bytevector, string, and fxvector immutable from the start?\r\n\r\nTo the question about boxes: \"yes\".  Try to find a bit within the first 8, however, so the tag check remains a byte comparison.\r\n\r\nI don't understand the problem you have with bootstrapping.  Please explain further.\r\n\r\nI believe `maximum-vector-length` should still be the same as `most-positive-fixnum`; if so, you appear to have gone too far on changes related to that.\r\n\r\n`copy()` in gc.c can now put immutable vectors (and boxes) into `space_pure`.  Woe be unto the programmer who decides `#3%vector-set!` is a useful way to work around immutability.\r\n\r\nKent I'd be tempted to add `make-reader-graph` or in this one case allow the Racket implementation of `make-reader-graph` access the imperative routines in from the system module, rather than commit to a public imperative interface.\r\n\r\nAdapting the language to the contract system seems rather backward, but okay.  Rather than allocating a fresh immutable empty vector (etc.) each time, I would create one at startup, like the mutable empty vector so that `eq?` returns `#t` when passed immutable empty vectors, just as it does for mutable empty vectors.\r\n\r\nTo cure the unbound variable errors, add stub definitions to patch.ss, e.g., `(define (vector-immutable? x) #f)`.   Back out the definitions once bootstrapped. I just looked at the code a bit and have a few small suggestions.\r\n\r\nWhen `(fx>= n 0)` is followed by `(fx<= n ---)`, this can be replaced by the single test `($fxu< n (fx+ --- 1))` if `(fx+ --- 1)` is a fixnum.  so the two tests at the start of `make-bytevector` in bytevector.ss:\r\n```\r\n(unless (and (fixnum? n) (fx>= n 0)) ($oops who \"~s is not a nonnegative fixnum\" n))\r\n(unless (fx<= n (constant maximum-bytevector-length)) ($oops who \"~s is too large\" n)) \r\n```\r\ncan be replaced with:\r\n```\r\n(meta-assert (< (constant maximum-bytevector-length) (constant most-positive-fixnum)))\r\n(unless (and (fixnum? n) ($fxu< n (fx+ (constant maximum-bytevector-length) 1)))\r\n  ($oops who \"invalid bytevector length ~s\" n))\r\n```\r\n\r\n(vector-immutable? vector) (etc.)\r\n  - forces `(and (vector? v) (not (vector-immutable? v)))` or the equivalent before doing `vector-set!`.\r\n  - can we replace it with `(mutable-vector? x)`, which returns #t iff x is a vector and x is mutable?\r\n  - if we keep `vector-immutable?`, `np-simplify-if` should optimize `(and (vector? v) (not (vector-immutable? v)))` pattern as it does, e.g., `(and (port? p) (binary-port? p))` and we should use that pattern in our checks, e.g., in bytevector-copy and `bytevector-fill!`.\r\n\r\nIt looks like bytevector-s64-native-ref got the set! treatment by mistake.\r\n\r\nThe new `always-immutable-flag` constant doesn't seem to be used.\r\n\r\nI wouldn't mind a single \"not an immutable XXX\" condition message in place of the dual \"not an XXX\" and \"immutable\" messages being produced in various places, and it would simplify the code.  I don't mind the way it is, either, if that's preferable to you.\r\n\r\nIt's difficult for me to be sure from the github view, but it looks like cond might not be formatted consistently with other code (one space indentation instead of two before clauses)\r\n Instead of publishing the immmutable empty vector (etc.) via a foreign procedure, I would put it into a new immutable-empty-vector slot into the thread context (look for `fxlength-bv` in cmacros.ss and `FXLENGTHBV` in scheme.c and gc.c) where it can be accessed efficiently via `($tc-field 'immutable-empty-vector ($tc))`.  `faslin` can also reference it from there using IMMUTABLEEMPTYVECTOR(tc), so there's no need to put it into `S_G` as well.\r\n\r\nOr what if `mutable-vector?` and `immutable-vector?` both return true for the empty vector?\r\n\r\nAdding an extra local to `bytevector=?` should be fine and seems necessary.  To be on the safe side, we could look at the generated code (make library.asm) and see if the compiler has spilled something we'd rather it not and prevent it from doing so, if necessary, by using specific registers.\r\n\r\nLibrary entries must be declared in cmacros.ss.  Look for `unbox` and add a similar line for `set-box!`. Okay, having heard no objections, I'll proceed with the merge.  Expect a few minor changes as I go over the code and check the compiler output.  I'll let you know before I change anything major. Using the command-line instructions to merge while adding some of my own modifications seems to have left github unaware that the branch was merged, so I'm closing this pull request explicitly.  The implementation of (even one-argument) `record-equal+hash` is not thread-safe due to the side effects of path compression, thus neither are `equal?` and `equal-hash`.  This is a show stopper.  Another concern I have is that `record-equal+hash` does not do path compression when no ancestor has been given equal and hash procedures.\r\n\r\nI checked the existing `record-writer` implementation, and it has one of the same thread-safety issues.  While that aspect of its implementation is easily repaired, its use of an eq hashtable for recording record writers has the downside of holding onto an rtd in the common case where the associated record-writer procedure points back to the rtd, as you pointed out via email.  Since the `record-writer` and `record-equal+hash` mechanisms are related, we should continue to look for a better common solution for both.\r\n\r\nThough some might be moot, I'll address the issues you raised:\r\n\r\n- In place of `putprop`, `getprop`, and `remprop`, use `$sputprop`, `$sgetprop`, and `$sremprop`, which manipulate the symbol's \"system\" property list.  That way the properties can't conflict with user properties.\r\n\r\n- You should be able to remove the pair from the interface (and implementation) by comparing the equal procedures rather than the pairs.  Another possibility would be to compare the rtds at which the most specific equal+hash record is found.\r\n\r\n- I would be tempted to add an optional (or non-optional) boolean argument to your `record-equal+hash` accessor to say whether to follow the inheritance chain.  (This would require a switch to separate accessor/setter procedures.)\r\n\r\n- I don't use emacs and so can't help you with a editing mode, but yes we would prefer that the code be indented similarly throughout.  That said, no indentation problems jumped out at me in your changes.\r\n\r\nAlso, rather than assign the outer `i` in `equal-hash`, please bind and assign a local `next-i`, like you've done with `next-k` in `equal?`, to localize the effect.  Please use `define-record-type` in place of `define-record`, with `(nongenerative)` and `(sealed #t)` clauses, and mark only the inheritors field mutable. Ah,  I missed the installation of the empty record.\r\n\r\nUsing `with-tc-mutex` as you suggest should work except where it interferes with other calls to `$sputprop`.  There are only a handful of places where `$sputprop` is used at run time, and we can wrap them in `with-tc-mutex` forms as well.\r\n\r\nReturning the rtd as well as the procedures (as multiple return values, I assume, now that the pair is gone) is a good solution.\r\n\r\nBTW, using `set-who!` rather than `set!` for `record-equal+hash` would allow the quoted occurrences of `record-equal+hash` to be replaced with `who`, which is shorter and safer. Yes, any call to `$sputprop` might be a problem.  I would not put the `with-tc-mutex` wrapper in `$sputprop`, however, since the wrapper might more appropriately be placed around a larger section of code at the call site, or might already be there.\r\n\r\nWe should also wrap run-time calls to `$sremprop`.\r\n\r\nAs property lists are currently implemented, `$sgetprop` is thread-safe even in the presence of concurrent calls to `$sputprop` on the same symbol and even the same key.  That's unlikely to change.  Although, as you say, you can't set! the integer register directly to the floating-point register, the integer register should still be assigned via set! for the benefit of the register allocator, so in place of `(inline ,(make-info-loadfl fpreg) ,%move-double ,ireg)` you might have `(set! ,ireg (inline ,(make-info-loadfl fpreg) ,%get-double))` where %get-double is a \"value\" version of %move-double.  It looks like you're already including ireg in the list of live registers, which is good. Looks good to me.  Thanks!  This is a model pull request, complete with LOG entry, release note, user's guide entry, and appropriate tests.\r\n\r\nI suggest renaming `date-isdst` to something with a `?` on the end, e.g., `date-dst?` or `date-daylight-savings-time?`.\r\n\r\nLooking at `S_mktime` (in stats.c), it appears `tm_isdst` is sometimes set to 1; if so, dates created by `make-date`, which calls `S_mktime`, _can_ have isdst set.  The setting of tm_isdst presumably depends on the current locale; if so, tests and examples should take this into account somehow.  In particular, tests should not fail if run in a different locale.\r\n\r\nHave you verified that isdst is computed correctly under Windows?  The code within `ifdef win32` ... `endif` in `S_mktime` has me wondering. The referenced man page goes on to say that `tm_isdst` is set \"regardless of its initial value\" to a positive value or 0, but unhelpfully doesn't say how the value is affected by the supplied `tm_isdst` value.\r\n\r\nThe MacOS page also mentions that negative values for `tm_isdst` forces it to guess the time zone.  Yet a quick experiment on my Mac shows that, with an initial value of 0 rather than -1, it sets `tm_isdst` non-zero for July 1, 2017 but not January 1, 2017.  So there appears to be some correction going on.  I didn't get into it far enough to determine if an incorrect initial `tm_isdst` value also causes other fields to be adjusted when the `tm_isdst` value is corrected.\r\n\r\nThis all leads me to believe you might be right that we should be setting `tm_isdst` to -1 before calling `mktime`. You're right that the `ifdef` block for win32 doesn't modify `tm_isdst`; the question is whether it should. To run just date.ms, cd into the workarea's mat directory and run 'make date.mo' (removing date.mo first if necessary), then grep for errors, bugs, etc., using `egrep \"Bug|Error|invalid memory\" date.mo`.  To run an even smaller set,  you can create a temporary .ms file. That would probably be best.  I suggest adding an optional boolean argument at the end of the argument list.  The three states would be not present (corresponding to `tm_isdst` = -1), present and `#t` (1), and present and `#f` (0). Sounds like the win32 code is wrong and should be removed, per your earlier suggestion. `make patches` can be used after a mat run to update the relevant patch files, once you've verified there are no actual errors.  `make just-reports` can be used to verify that the patches were made correctly, without rerunning the mats. I generally update the patch files lazily as I need them.  If you want to be eager about it, running `make allx bullyx` in the workarea mats directory generates a more complete set of error files than just `make allx`.  The `bullyx` target takes a long time to run, so it's not run by default. Merged manually along with fix for issue #182.  This is a great question that highlights the lack of sufficient documentation for the implementation of Chez Scheme.  Someday I'd like to rectify this.  In the meantime, there are a number of papers that describe with more or less precision and more or less accuracy the implementation of various subsystems and features.   Most of these are linked from [http://www.cs.indiana.edu/chezscheme/pubs/](http://www.cs.indiana.edu/chezscheme/pubs/).  \r\n\r\nChez Scheme does not employ a byte-code representation.  The compiler generates machine code directly, either in memory or to disk (via `compile-file` and related procedures).  Nor does Chez Scheme have a VM in the sense of a program that interprets byte code.  It does have a run-time architecture that dictates the structure of objects, the heap, stacks, thread contexts, etc.  The generated machine code directly manipulates elements of the run-time architecture in cooperation with the storage manager and other parts of the run-time system, just as one would expect the code generated by a JIT compiler for JVM code to do.\r\n\r\nSome of the papers mentioned above describe how elements of Chez Scheme's run-time architecture are (or once were) structured and manipulated, and most of the structure is codified in s/cmacros.ss and c/globals.h, but the architecture is otherwise undocumented. It would be interesting to try using LLVM  as an alternative back end for the compiler, but it's not something we've really thought about.  Hi @rashadkm,\r\n\r\nThanks for reporting this.  I've not had a chance to commit a fix, but the file that needs to be changed is the ``a6ob.def`` in the ``s`` directory of the Chez Scheme repository.\r\n\r\nIn that file, you'll find a ``define-constant`` line that looks like the following:\r\n\r\n```\r\n(define-constant time-t-bits 32)\r\n```\r\n\r\nThis needs to be changed to:\r\n\r\n```\r\n(define-constant time-t-bits 64)\r\n```\r\n\r\nOnce you've made that change, you'll need to rebuild the boot file from a linux machine (which will also rebuild the ``equates.h`` and ``scheme.h`` files), and move this back onto your OpenBSD build machine.\r\n\r\nUnfortunately just changing the ``equates.h`` file doesn't help, since the size of the ``time_t_bits`` has been compiled into the ``petite.boot`` and ``scheme.boot`` files to be 32-bits.\r\n\r\nI'll try to get together a fix this evening, but hopefully this will get you up and running.\r\n\r\nThanks for the bug report!\r\n-andy:)   Thanks for the pull request.  What problem with the current configure / make process does this address?  Unless you've identified something that doesn't work that can't reasonably be solved with the existing process, I'm not inclined to add support for a new one.  Thanks for the updates!\r\n\r\nI'll try to get this merged this weekend. I got a chance to run the tests tonight, and everything looks good!  Thanks again, and thanks for updating the LOG file.  If you want to tackle this, you'll need to study and understand the code for handling `foreign-procedure` and `foreign-callable` in syntax.ss, cpnanopass.ss, and (for starters) one of the machine-dependent files like x86.ss.  You'll also need to learn how the calling conventions for a particular target (architecture and O/S) dictate structs be passed and returned.  For documentation on calling conventions, look for an _Application Binary Interface_ description, at least on Unix-based systems.  Also look at the output of 'cc -S testfile.c\", where testfile.c contains various C examples passing and returning structs with and without other arguments.  You can use these examples for testing later.  Once you understand how the compiler handles non-struct values as well as the calling conventions for struct values, you'll be ready to start modifying the expander and compiler.  Once you get struct values working and well tested (via tests added to foreign.ms) on one target, the others should be relatively straightforward.  You should be able to get help here or on the mailing list from @akeep, @cfrisz, and me with specific questions if you get stuck on particular issues.  While you'll be charting new ground, we all have experience with the compiler's handling of `foreign-procedure` and `foreign-callable`.  You are correct that this is a bug with the build process.\r\n\r\nIt looks like we are setting the ``library-directories`` explicitly with ``--libdirs`` in part of the build process, but not in all of the places we need to do this.\r\n\r\nThe problem you are seeing manifest is essentially happening because we are trying to find the [nanopass framework](https://github.com/nanopass/nanopass-framework-scheme) during the compilation process, which we've compiled into the local directory, and if you have ``CHEZSCHEMELIBDIRS`` set to something that does not include the local directory, it cannot find it.\r\n\r\nShould be fairly simple to fix once I get a few minutes of spare time.  For the record, Chez Scheme no longer has support for sparc or sparc64 processors, though it could be ported to support it again.\r\n\r\nWhen we re-wrote the compiler between versions 8.x and 9.0, we completely replaced the old code generator and left out support for some of the older platforms.\r\n\r\nAs you note, however, we do support Solaris on x86 and x86_64.  @jltaylor-us is correct as to why this doesn't work.  The `string` foreign type is really just a convenience for converting from a Scheme string into a C string (which is allocated in at a different memory location from the string).\n\nIn general when you have a pointer type that you want to get back, you have to pass in a pointer to some allocated space.  For instance, you can use `foreign-alloc` to allocate space outside of the Scheme heap to pass to the C procedure to use for its return.  You could handle all the marshaling yourself (as I have in this code example) or use a mix of `string` for arguments that are _input_ arguments and foreign allocated space for things that are _output_ arguments.  Remember, when you use `foreign-alloc` you also need to use `foreign-free` to free it, similar to C's malloc.\n\n``` racket\n(define strcpy\n  ;; define foreign procedure\n  (let ([$strcpy (foreign-procedure \"strcpy\" (void* void*) void*)])\n    (lambda (str)\n      (let ([fsize (fx* (ftype-sizeof char) (fx+ (string-length str) 1))])\n        ;; allocate foreign space for source and destination\n        (let ([src (foreign-alloc fsize)]\n              [dst (foreign-alloc fsize)])\n          ;; marshall Scheme string into C string\n          (do ([i 0 (fx+ i 1)])\n            ((fx= i (string-length str)))\n            (foreign-set! 'char src i (string-ref str i)))\n          ;; call strcpy\n          (let ([dst-also ($strcpy dst src)])\n            ;; check that our result was what we expected\n            (unless (= dst-also dst) (errorf 'strcpy \"returned unexpected destination pointer\"))\n            ;; marshall C string into Scheme string\n            (let ([dst-str (let f ([i 0])\n                             (let ([c (foreign-ref 'char dst i)])\n                               (if (char=? c #\\nul)\n                                   (make-string i)\n                                   (let ([dst-str (f (fx+ i 1))])\n                                     (string-set! dst-str i c)\n                                     dst-str))))])\n              ;; free our foreign allocated memory\n              (foreign-free src)\n              (foreign-free dst)\n              ;; return the string\n              dst-str)))))))\n```\n\nThis works as you might expect:\n\n``` racket\n> (strcpy \"foo\") ;=> \"foo\"\n```\n\nHowever, it is a bit verbose.  Following from the corrected version of the example, which @jltaylor-us pointed out is checked into the examples repository, you can use the `u8*` type to pass a Scheme allocated byte vector that C can write into.  You could re-implement the solution above, as follows:\n\n``` racket\n(define strcpy2\n  (let ([$strcpy (foreign-procedure \"strcpy\" (u8* u8*) void*)])\n    (lambda (str)\n      (let ([dst (make-bytevector (string-length str))])\n        ($strcpy dst (string->utf8 str))\n        (bytevector->string dst (native-transcoder))))))\n```\n\nThis is quite a bit simpler, but is a bit of a cheat, since technically we should be ensuring our byte vector is null terminated before we pass it in, and we should be providing a byte vector with space for the null terminator, but if we do that we also will need to trim off the final null character of the string.  The `u8*` is something that can be used in general to provide Scheme allocated space to C, but should be used with a bit of caution, since a misbehaved C function could write all over the Scheme heap starting from that pointer if you are not careful.\n\nAs far as the documentation, we should clean that up by making use of the example code from the repository.\n The problem here is not the foreign function interface, you are calling `bytevector-copy!` with the arguments in the wrong order.  From http://scheme.com/tspl4/objects.html#./objects:s247:\n\n``` scheme\n(bytevector-copy! src src-start dst dst-start n) \n```\n\nYou have your source and destination reversed.\n  No, this is expected behavior.  (import (b)) makes the exports from library\n(b) available, but it does not cause any code to run.  The library\ninitialization code, in this case, setting the definition of foo and\nresetting the value of box a, are not done until the one of the\nnon-syntactic exports is actually accessed.\n\nIn R6RS Scheme, there is no guarantee of when or how many times\ninitialization code will be run.  In Chez, we endeavor to run it only once,\nthe first time an export of the library is referenced in a given Scheme\nsession, other implementations, like Racket's R6RS implementation for\ninstance, runs the initialization code for each phase the library is\nreferenced in, effectively this could cause a to be set and reset over the\ncourse of the library load.\n\nIn Chez, there are three phases for an library: import, visit, and invoke\n(also known as revisit).  Import, which happens when the library is\nimported, (import (b)), only sets up the bindings in Chez's syntactic\nenvironment, visit, which happens the first time an exported macro is\nreferenced, sets up the syntactic transformers and the compile-time\nenvironment, and invoke, which happens the first time a non-macro export is\nreferenced, sets up the values of the definitions and runs initialization\ncode.\n\nIn general, if you have initialization code you'd like to run at a\nparticular point, it is best to simply wrap that initialization code in a\nfunction and call it explicitly.\n\n(library (b)\n  (export foo a)\n  (import (scheme) (a))\n\n  (define (foo) (display 'hello-world))\n\n  (define (initialize-b) (set-box! a #t)))\n\n-andy:)\n\nOn November 13, 2016 at 4:37:26 PM, rain-1 (notifications@github.com) wrote:\n\nHello!\n\nI found something strange when working on an extensible pattern matcher in\nChez. Here's a minimal test case:\n\n> (library (a)\n>     (export a)\n>     (import (scheme))\n\n```\n(define a (box #f)))\n```\n\n(library (b)\n    (export foo a)\n    (import (scheme) (a))\n\n```\n(define (foo) (display 'hello-world))\n\n(set-box! a #t))\n```\n\n> (import (b))\n> a\n> #&#f\n> (foo)\n> hello-world\n> a\n> #&#t\n\nIs this the correct behavior?\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/cisco/ChezScheme/issues/116, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAG5rw0DcrZt2v-6eDqoV5ZjLMpDbP9Vks5q94MGgaJpZM4Kwz7z\n.\n  I was getting ready to incorporate this change, but I started thinking about this in depth, and I was wondering what the situation is where two expressions could have the same starting file position and different ending file positions?\r\n\r\nPart of what I'm wondering is if ignoring the end file position is actually an optimization recognizing that the beginning file position is already unique.\r\n\r\nDo you have an example? Yes, that makes sense.  I should have read the title more carefully :)\r\n\r\nThanks for the clarification!\r\n\r\n-andy:)  Thank you!\n  Thanks for the pull request, this looks like a really good start at a port to Dragonfly BSD.\n\nI do have a couple of requests.\n1. Please add an Mf-a6df and Mf-ta6df to the mats directory.  The mats directory is where our unit tests live, and part of how we test Chez Scheme to make sure all of its parts are working is to run make all, make allx, or make bullyx in the mats directory.  I'd like to make sure that Chez Scheme on Dragonfly BSD can pass the allx mats before we merge this pull request.\n2. When we make changes to Chez Scheme we update the LOG file in the base directory of the repository.  Please add a log entry.\n\nI also have a separate question:  Does the 64-bit version of Dragonfly BSD support a 32-bit tool-chain?  Or is there a 32-bit version of the DragonFly BSD OS?  If so, we should consider adding an i3df and ti3df for 32-bit support.\n  Good thought, but all other things aren't equal in this case.  The loop is indeed intentionally unrolled, and I just measured the benefit of the unrolling on an Intel i7-4790k cpu, a6le build, running 'make all' in the 's' directory to be about a 6-7% reduction in cp0 running time.  The overall compile-time reduction is a modest 1% or so.  If you want to repeat my test, run `make all pps=t | egrep '^cp0|^TOTAL'` a dozen or so times with and without the change.  Cpu time is in the 3rd column.\n\nIt usually pays to optimize environment lookup.\n I'm going to go ahead and close this PR, since there are performance reasons for the unrolled loop.\n  Thanks for the fix (and the LOG entry)\n  You'll need to capture a continuation that can be invoked by the exception handler.  One way would be to define a function that grabs the continuation and parameterizes the base exception handler, during the call to `eval`, to something that invokes that continuation after `debug` returns,  An easier solution would be to have the function use `guard`.\n\nIf you want `debug` to do anything but print \"Nothing to debug.\" and exit, your exception handler should set the `debug-condition` parameter before calling `debug`.\n  Please add an appropriate entry to LOG describing the changes.\n\nI haven't had time yet to look over the changes.  What is the purpose of Mf-embed.  Where are the files installed?  Do you differentiate the library install location based on whether it's a 32-bit build or a 64-bit build?\n  For the most part, R6RS tries to remain representation-agnostic to allow a wide variety of implementation choices for inexact arithmetic.  One choice is to use arbitrary-precision inexact arithmetic in which all finite numbers are representable, albeit imprecisely, and in which +inf.0 and -inf.0 represent only non-finite numbers.\n\nAn implementation may, however, choose to treat finite numbers as +inf.0 and -inf.0 if they are out of that implementation's representable range.  The exact zero value of (\\* 0 +inf.0) derives from that choice: in such an implementation, +inf.0 and -inf.0 most often represent out-of-range finite numbers, and multiplying such numbers by exact 0 should produce exact 0.\n\nA program needing infinities that never represent mere out-of-range finite numbers isn't well served by this.  My guess is such programs aren't common, aren't well-served anyway by a single pair of infinities representing all cardinalities, and might even require some form of symbolic arithmetic.\n What's wrong here is that `(/ 1.0 0)` evaluates to `+inf.0.`  It should be an error or at least `+nan.0` since (a) it is division by exact zero, not something arbitrarily close to zero, and (b) the sign is indeterminate since exact 0 is neither positive nor negative.  R6RS, however, requires (/ 1.0 0) to return +inf.0 under the assumption that 0 is first converted to +0.0.\n\n`+inf.0`and `-inf.0` shouldn't be used when something \"went wrong\", as in this example.\n Should -0.0 also be treated as 0?\n And what is the value of (/ 1.0 -0.0)?\n Your third note back claims it's problematic for `(* 0 +inf.0)` to give a different result from `(* 0.0 +inf.0)` when `(= 0 0.0)` evaluates to #t.  By the same logic, it's equally problematic for `(/ 1.0 0)` to give a different result from `(/ 1.0 -0.0)` when `(= 0 -0.0)` evaluates to #t, yet that's what your second and first notes back require.  So your interpretation is problematic or your logic is flawed.  In this issue, your logic is flawed: numeric equality is inherently imprecise when inexact numbers are involved and does not imply identical behavior.  There are many cases where the behavior of numerically equal numbers can differ.  For example, `(= 10 10.0)` => #t, but `(= (/ 1 10) (/ 1 10.0))` => #f.\n\nYour interpretation has a flaw as well, because R6RS calculations treat `0.0` differently from `0` in more than the one case you brought up originally, precisely because 0 is exactly 0 and 0.0 is not.  A trivial example is that `(- 0)` => `0` while `(- 0.0)` => `-0.0`.  A particularly relevant example is that `(/ 1 0)` raises an exception while `(/ 1 0.0)` does not.  Also, as has been [observed recently](https://github.com/cisco/ChezScheme/issues/95), an inexact zero imaginary part makes a complex number non-real, while an exact zero imaginary part does not.  This difference shows up in calculations, too, e.g., `(cos 0.0+0i)` = `(cos 0.0)` => `1.0` while `(cos 0.0+0.0i)` => `1.0-0.0`.\n\nThe possibility of other interpretations aside, I remain comfortable with the interpretation that `+0.0` and `-0.0` are close to but not quite zero and `+inf.0` and `-inf+0` are large but not quite infinity.  My preference for this interpretation reflects (a) the fact that `+inf.0` and `-inf.0` can arise through overflow or through underflow followed by division and (b) my suspicion that they arise this way much more often than through the intentional introduction of a true infinity.  So I remain convinced that, in Chez Scheme, `(* 0 <any number>)` should continue to evaluate to `0`, which R6RS allows, and `(/ <any number> 0)` should raise an exception, which R6RS does not allow---though I'm tempted to arrange for the version of `/` exported from the `(chezscheme)` library to do so.\n  [This commit](https://github.com/cisco/ChezScheme/commit/50aa8b34774a9e65e96481ae329a3f329fad7aca) should fix the problem.  I would rather have pulled your fix but as you pointed out your change was not the correct fix.\n  While tempting, adding instructions for installing XQuartz would be inconsistent unless we provide similar instructions for other things upon which we depend, such as the required package files for various flavors of Linux or the required tools for various versions of Windows.  This is a slippery slope with no clear stopping point, and I'd prefer in any case not to take on the responsibility of maintaining correct instructions for other packages as things change.\n  The intent is for `guard` not to ruin a continuable exception by using `raise` to re-raise an exception that might have been raised by `raise-continuable`.  It's not to convert a `raise` into a `raise-continuable`.  When you use `raise`, you get to assume it will never return.\n\nTo your point about the utility of `raise-continuable`, it's useful for issuing warnings (including via `warning`, `warningf`), i.e., raising non-fatal exceptions, while allowing the dynamic context the opportunity to display them, treat them as errors, or ignore them.  One can also use it to allow the dynamic context more control over what the code raising the exception should do.  For example, a library routine might raise a continuable exception when it can't find a required file and allow the dynamic context to supply one, possibly by querying the user.\n  Thanks for working on this.  It would be nice to have Chez Scheme available via macports.\n\nHonoring the CC variable (preferably at configure time, ala CFLAGS, CPPFLAGS, and LDFLAGS) seems like a reasonable and straightforward change to make.  Feel free to make the change yourself and put in a pull request or let me know if you'd prefer we do it.\n\nThe complaints about zlib in the ticket are due to a couple of misunderstandings.  First, we link statically against libz.a, so the install location for the dynamic library is irrelevant.  Second, X11 is required by the expression editor, not by zlib.  So I would push back on this so we don't have to hook the configure / build process to support other mechanisms for including zlib.\n\nThat begs the question about the X11 include files.  The reason why they're needed by the expression editor is covered in the discussion of [issue 9](https://github.com/cisco/ChezScheme/issues/9).  The macports version should support use under X11 if possible.  If compiling against the X11 libraries is not possible, we'll have to provide a way to build without X11 and leave Xquartz users with a choice between using macports to install Chez Scheme or getting full functionality.\n  @dybvig, do you think we should add Sstring_utf8, or update S_string to process UTF-8? I don't see any cases in the C code that use an 8-bit encoding other than UTF-8. Commit https://github.com/cisco/ChezScheme/commit/aa1c2c4ec95c286a12730ea75588a18dd9fb9d59 addresses this issue. The command-line arguments and environment variables are now processed for Unicode. I added `Sstring_utf8` to the `scheme.h` interface to make it convenient to create Unicode Scheme strings from C.  The inspector shows only what's currently in the continuation, i.e., the calls that still remain to be returned from, and this is often insufficient.  You might find [this document](http://www.cs.indiana.edu/chezscheme/debug/) useful for general debugging tips.  For unbound identifiers, the best advice I can give you is to (re)structure your code into libraries and top-level programs.  Library and program scopes are self-contained, and you get compile-time errors identifying the location of unbound identifiers.  If that's not practical, you can always grep for unbound identifier with relatively unique names, and if the uses aren't obviously unbound, rename one at a time (or half of them at a time, if there are a lot) to something you know to be bound and see if you can narrow it down that way..\n  Having used ulimit on other operating systems to deal with this sort of problem, I can understand the frustration of dealing with an operating system or shell that doesn't provide such a mechanism, but I'm not excited about adding a mechanism to Chez Scheme, first because it's otherwise unnecessary, and second because it would necessarily be incomplete, in that it wouldn't be appropriate to track all allocation by a process, just the allocation for which Chez Scheme is directly responsible.  A quick web search turned up a couple of third-party tools you might be able use for this purpose, and not only for Scheme programs.\n  The `malloc` result should definitely be checked, because `memcpy` might do worse than crash the system when passed a null pointer.  It should be fine for `S_create_thread_object` to call `S_error` to report a `malloc` failure when `S_create_thread_object` is called from the parent thread via `S_fork_thread`, but it's worth thinking about what happens when `S_create_thread_object` is called from the child thread via `Sactivate_thread`.  Nothing good, probably, because `Sactivate_thread` sets the thread context to the base thread's context, which the new thread has no business using.  `Sactivate_thread` should probably set the thread context to null rather than the base thread context before calling `S_create_thread_object`, with the latter taking the parent thread context as an argument, and with `do_error` in schsig.c going the `errors_to_console` route when the thread context is null.  Then `S_create_thread_object` can use `S_error` to report a `malloc` failure.  We'd need to make sure `S_create_thread_object` can't lead to other references to the thread context that will fail if it's set to null.\n Those should also be addressed.  I will fix these when I get the chance but will be just as happy if someone beats me to it.\n  There are a couple of issues here.  One issue is whether some of the built-in subsystems or individual features should be moved from core into external libraries.  That will have to wait until there's a good repository for Chez Scheme libraries and a good mechanism for accessing it.  Even with that, some things that could theoretically move out won't because they support other things in the core or can be implemented more efficiently within the core.\n\nThe other issue is whether the `(chezscheme)` library should continue to export everything in the core.  The `(chezscheme)` library is useful when one just wants to write code and doesn't want to figure out which libraries are needed to access to a built-in binding.  To serve that purpose, it needs to remain universal and so must export not only all current bindings but also all future (core) bindings.\n\nIn any case, defining additional libraries that export the (core) bindings of individual subsystems is a fine idea; for example, an additional library for the SRFI 19 time-and-date procedures could be useful.\n\nThe nanopass library is not a good example, incidentally, since it defines bindings that aren't built in and, more importantly, is and always has been a separate project and code base.\n  No, short of disassembling the code that dispatches on argument count.\n  It's probably possible.  Doing so would likely involve modifying both the machine-independent and machine-dependent handling of these forms.\n  This looks about right.  Please make the following changes: (1) Condition the deactivate_thread and reactivate_thread calls on DISABLECOUNT(tc) == FIX(0).  Disabling interrupts _should_ prevent automatic collections.  (2) Move the declaration of tc to the top of the function body.  (The assignment can remain where it is.)  Some C compilers don't like inline declarations, so we avoid them generally.  (3) Add a LOG entry describing the change.  You'll should pull the latest version from master so you are modifying the current copy of LOG.\n  That's correct.  The c-coded boot-file loader has no way to talk with the Scheme-coded library manager.  One way to fix this would be to switch from the C-coded loader to the Scheme-coded loader once the latter is in place.  It might also be possible to have the C-coded loader invoke Scheme-coded library-manager procedures. I don't know whether there are other issues with compiled libraries in boot files.\n  Indeed.  In fact, there were more substantial changes, which somehow escaped mention in the release notes.  I've rectified that and updated system.stex.\n  Extending the existing `ftype-ref` and `ftype-set!` forms to work for bytevectors would add dispatch overhead to the generated code and increase the code size.  A better option might be to add bytevector-specific versions of the forms.  I would be inclined to limit those versions to operate on scalar fields and not to support a bytevector version of `ftype-&ref` to avoid issues with pointers into and out of bytevectors.\n  It seems like this issue is resolved, so I'm closing it.\n  There is an uninstall target in Mf-install, but it only echos instructions, and I don't think it handles scheme-script. I'll look into this. I added an uninstall target in 4e5831fc0220ceede934f1d300b588129f770783. Yes, thank you!  configure considers a machine type $m available if the file boot/$m/scheme.boot is present, so you first need to create that boot file.  To get the required boot and header files in place, try the instructions given in BUILDING in the second paragraph under 'make bootfiles'.\n  No.  I got caught up discussing the colors and the color-assignment algorithm with a data visualization expert (Rachael Brady) in our group at Cisco.  For colors, she has suggested adding a dedicated color for executed once (to go along with the existing dedicated not-profiled and profiled-but-not-executed colors) and trying different shades of blue for all of the others except the highest-count group, which would get something like red or yellow, so only the latter really stands out.  I was going to play with that before committing your changes, but I haven't had a chance yet to do so.\n Michael, I'm finally getting around to this, and I would like to merge the changes you made without making any additional changes (yet, at least).  The only thing stopping me right now is a LOG entry.  If you wouldn't mind, please update your repo and append an appropriate entry to LOG, possibly crafted from the commit-log text.\n\nAlso, Rachael seemed to like the lighter background, and I don't really have a preference, so if you also prefer the lighter background,  you should go ahead and commit that.\n I don't have an opinion about the CSS changes you suggest.  Since I've heard no objections from others, I'd say go it if you're so inclined.\n  I'm closing this pull request pending completion of a more complete update.\n [This commit](https://github.com/cisco/ChezScheme/commit/603019ea82afda1926462214576ef92df15e43c8) adds a `print-extended-identifier` parameter that, when #t, causes the printer to print `{` and `}` and other extended identifiers, like `1+`, without escapes.\n  Have you looked into using the \"wide\" version of ncurses (ncursesw)?  If it works, it should simplify the input side; plus I'm not sure the non-wide ncurses will even deliver multibyte input characters.\n Thanks for the pointer to the comment.  I had forgotten curses getch.required that we go full screen.\n  The .gitignore file should use /Makefile instead of Makefile, just as you suggested. Thanks so much for finding this!\n Fixed in commit 7097480fb77931ea9bc47849d555a6295cf659d7.\n  Yes, the windows build is a bit rickety, but it actually was recently tested and working.  Part of the trick (as noted in the BUILDING document) is that you need to put the ChezScheme directory on a shared file system (for example on a samba share) and mount it from Windows.  This lets the Linux side of the build do its part (running configure and setting up symlinks and the like) and the Windows side see it as though it was a just a normal file system.\n\nIt is suboptimal, but it was recently tested.  Our setup for testing has been a Windows VM running on an older Fedora 13 machine, with the chezscheme directory hosted on the Fedora machine and Windows mounting the directory through samba.\n @metab0t No, the symlinks are only needed for the build process.  Once things are complete you can copy the contents of the bin and boot directories (which are now the files that have been produced by the Windows C and Chez Scheme compilers).\n  Commit e44a209f27f8670c23a1d402b3f968eaa10cad29 adds support for MinGW/MSYS builds of Chez Scheme on Windows. We still use the Microsoft C compiler. The Travis continuous integration server now uses a variant of MSYS_NT to build and test the Windows versions of Chez Scheme.  Thanks for the the (and related) fixes!\n  @NalaGinrut You can disable the collector using the `collection-request-handler` (from the 8.4 version of CSUG, chapter 13---http://scheme.com/csug8/smgmt.html#./smgmt:s16):\n\n> Automatic collection may be disabled by setting collect-request-handler to a procedure that does nothing, e.g.:\n> \n> ```\n> (collect-request-handler void)\n> ```\n\nHowever, as the collection time is fairly small I would hazard to guess it is actually the bignum arithmetic that is killing this.  I suspect we'll have to improve the bignum operations in number.c to improve the results of this. \n As we think about trying to improve the bignum implementation in Chez, it might be interesting to take a look at the Glasgow Haskell Compiler (GHC) work around the same issue: https://ghc.haskell.org/trac/ghc/wiki/ReplacingGMPNotes.\n\nThey started from a different point, in that GHC had been using the GNU MP, but there were uses of GHC for whom the LGPL licensing of GNU MP was problematic (see: https://ghc.haskell.org/trac/ghc/ticket/601).  They experimented with a number of other fast arbitrary precision libraries with more permissive licenses, as well as creating a \"fast enough\" implementation in Haskell.  One (or more) of these more permissively licensed libraries might be an interesting option for improving Chez's bignum performance.  As of 7 years ago (when the GHC community went through this exercise), there were quite a few interesting trade offs in performance given the libraries available at the time.  I found an additional library, [bigz](https://sourceforge.net/projects/bigz/), listed on the [wikipedia arbitrary precision page](https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software).  Since it has been 7 years since the GHC community did these experiments, it is probably worth evaluating the options again.\n\n@hyln9 I'll have to look at the DCE as a separate issue.\n  @johnwcowan I'm happy to bless this with the caveat that I've not been much of an IRC user over the last 20 or so years, but I will try to drop in from time to time, if that is acceptable.\n Sounds good.  I definitely bless it then.  I did drop in for a bit last night, and I will try to make some effort to drop in from time to time.  Do you need anything beyond me saying it is blessed to make it official?  (Do you need me to send anything to freenode.net for instance?)\n\nIf not, feel free to consider this matter blessed and we can close this out.\n Done.\n\n--\u00a0\nAndy Keep\nSent with Airmail\n\nOn April 29, 2016 at 10:46:12 AM, johnwcowan (notifications@github.com) wrote:\n\nThat barfed. It's /msg nickserv register password email-address\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n  I can reproduce the time problem on my Mac OS X install by changing my timezone.  I've not had a chance to look and see if this is just a bad test (because it is dependent on timezone) or if we are producing the wrong results.\n As a test to my hypothesis, is there anyone with their time zone set to Eastern Daylight Time (EDT) who is seeing this bug?\n @adamsmd Actually, that is helpful.  I know the current committers (including myself) are on Eastern Time, and I think the problem is that we're printing a UTC time using the machines current locale.  Basically, the test needs to be updated to make sure that the printed string is consistent regardless of locale.\n\nI'll try to fix this up tonight when I get home from work.\n It turned out there was a simple fix for the time-utc->date test, we simply needed to pass the optional timezone offset to time-utc->date in the test.  This should be correct in commit 74563ef.\n\nI'm going to close this issue, because I think @dybvig has already addressed the file system issue, but feel free to reopen if something is still broken.\n", "text_all_count": 34398, "text_word_token": ["Thanks", "for", "finding", "and", "fix", "this", "bug", "All", "the", "Windows", "mats", "pass", "It", "compiles", "cleanly", "in", "Microsoft", "Visual", "Studio", "and", "so", "far", "the", "ta", "NUMBER", "nt", "mats", "be", "passing", "NUMBER", "Would", "this", "be", "clearer", "P", "be", "of", "the", "form", "P", "NUMBER", "NUMBER", "Pk", "Pe", "ellipsis", "S", "NUMBER", "NUMBER", "Sm", "where", "ellipsis", "be", "the", "identifier", "NUMBER", "and", "F", "be", "a", "vector", "of", "n", "elements", "with", "n", "k", "m", "whose", "first", "k", "elements", "match", "P", "NUMBER", "through", "Pk", "whose", "next", "n", "m", "elements", "each", "match", "Pe", "and", "whose", "remaining", "m", "elements", "match", "S", "NUMBER", "through", "Sm", "NUMBER", "Thanks", "Second", "try", "P", "be", "of", "the", "form", "P", "NUMBER", "NUMBER", "Pk", "Pe", "ellipsis", "S", "NUMBER", "NUMBER", "Sm", "where", "ellipsis", "be", "the", "identifier", "NUMBER", "and", "F", "be", "a", "vector", "of", "n", "elements", "with", "n", "k", "m", "whose", "first", "k", "elements", "match", "P", "NUMBER", "through", "Pk", "whose", "next", "n", "k", "m", "elements", "each", "match", "Pe", "and", "whose", "remaining", "m", "elements", "match", "S", "NUMBER", "through", "Sm", "NUMBER", "This", "pull", "request", "aims", "to", "help", "answer", "support", "question", "like", "NUMBER", "what", "source", "did", "I", "build", "in", "this", "particular", "workarea", "NUMBER", "what", "source", "was", "use", "to", "build", "this", "install", "binary", "My", "original", "stab", "at", "this", "expose", "a", "scheme", "revision", "that", "we", "could", "get", "at", "via", "the", "repl", "NUMBER", "That", "was", "convenient", "at", "run", "time", "but", "the", "extra", "rounds", "of", "bootstrapping", "made", "that", "approach", "irritating", "at", "compile", "time", "NUMBER", "I", "ve", "since", "scaled", "back", "to", "the", "much", "simpler", "approach", "of", "recording", "minimal", "revision", "control", "information", "in", "a", "revision", "file", "alongside", "the", "boot", "file", "NUMBER", "This", "seems", "to", "work", "well", "enough", "for", "my", "use", "cases", "NUMBER", "The", "update", "revision", "script", "could", "be", "extend", "for", "folks", "who", "mirror", "the", "git", "source", "in", "some", "other", "revision", "control", "system", "NUMBER", "The", "git", "attributes", "on", "update", "revision", "insert", "the", "appropriate", "revision", "if", "folks", "export", "the", "source", "code", "via", "git", "archive", "or", "download", "a", "tarball", "or", "zip", "file", "from", "github", "NUMBER", "The", "WiX", "update", "be", "guesswork", "but", "seem", "to", "work", "NUMBER", "Thanks", "for", "looking", "this", "over", "Bob", "NUMBER", "I", "update", "the", "LOG", "and", "rebased", "NUMBER", "Before", "merge", "anything", "from", "this", "branch", "I", "d", "like", "to", "know", "whether", "dybvig", "be", "open", "to", "merge", "only", "d", "NUMBER", "c", "NUMBER", "ad", "NUMBER", "a", "NUMBER", "adfa", "NUMBER", "c", "NUMBER", "a", "NUMBER", "ad", "NUMBER", "b", "NUMBER", "or", "NUMBER", "squashing", "in", "_variation", "NUMBER", "_", "NUMBER", "c", "NUMBER", "d", "NUMBER", "a", "NUMBER", "e", "NUMBER", "d", "NUMBER", "b", "NUMBER", "d", "NUMBER", "c", "NUMBER", "d", "NUMBER", "aabb", "NUMBER", "or", "NUMBER", "squashing", "in", "_variation", "NUMBER", "_", "a", "NUMBER", "ba", "NUMBER", "ae", "NUMBER", "d", "NUMBER", "babedfc", "NUMBER", "cce", "NUMBER", "f", "or", "NUMBER", "squashing", "in", "both", "_variation", "NUMBER", "_", "and", "_variation", "NUMBER", "_", "with", "that", "base", "commit", "NUMBER", "or", "whether", "he", "wants", "no", "part", "of", "this", "NUMBER", "It", "has", "be", "really", "handy", "for", "our", "internal", "development", "NUMBER", "The", "change", "look", "good", "I", "build", "the", "Windows", "version", "and", "linked", "them", "against", "another", "library", "successfully", "NUMBER", "Please", "rebase", "onto", "master", "NUMBER", "This", "pull", "request", "exposes", "a", "library", "search", "handler", "parameter", "to", "permit", "more", "control", "over", "the", "search", "for", "libraries", "during", "import", "compile", "whole", "library", "and", "compile", "whole", "program", "NUMBER", "Thanks", "for", "the", "quick", "feedback", "NUMBER", "I", "force", "push", "change", "to", "incorporate", "your", "comments", "NUMBER", "I", "expose", "default", "library", "search", "handler", "which", "turned", "out", "to", "be", "a", "good", "thing", "all", "around", "NUMBER", "It", "let", "me", "be", "more", "precise", "with", "oops", "NUMBER", "It", "enlisted", "check", "prim", "arg", "error", "which", "caught", "me", "be", "lax", "in", "checking", "the", "library", "name", "NUMBER", "It", "may", "even", "have", "clarified", "the", "documentation", "NUMBER", "Actually", "it", "doesn", "t", "make", "sense", "for", "NUMBER", "_x_", "where", "_x_", "be", "a", "floating", "point", "number", "to", "be", "anything", "other", "than", "NUMBER", "since", "a", "floating", "point", "number", "be", "never", "true", "NUMBER", "just", "very", "small", "on", "either", "side", "of", "NUMBER", "and", "never", "truly", "infinite", "just", "possibly", "very", "large", "i", "NUMBER", "e", "NUMBER", "the", "reciprocal", "of", "a", "very", "small", "number", "NUMBER", "We", "get", "this", "wrong", "in", "R", "NUMBER", "RS", "NUMBER", "We", "should", "correct", "it", "for", "the", "version", "of", "export", "by", "chezscheme", "and", "leave", "the", "broken", "behavior", "for", "rnrs", "NUMBER", "Thanks", "for", "mentioning", "this", "NUMBER", "I", "ll", "look", "into", "it", "and", "push", "a", "fix", "shortly", "NUMBER", "This", "should", "be", "fix", "by", "this", "commit", "LINK", "NUMBER", "Try", "display", "to", "console", "output", "port", "rather", "than", "the", "default", "current", "output", "port", "NUMBER", "It", "could", "be", "that", "the", "current", "output", "port", "has", "be", "redirected", "at", "the", "point", "where", "the", "error", "occur", "NUMBER", "You", "might", "also", "want", "to", "use", "display", "condition", "rather", "than", "display", "for", "the", "condition", "NUMBER", "It", "s", "neither", "a", "bug", "nor", "a", "feature", "NUMBER", "NUMBER", "NUMBER", "which", "shouldn", "t", "mean", "anything", "was", "just", "a", "little", "joke", "I", "add", "a", "long", "time", "ago", "for", "those", "who", "trip", "over", "it", "NUMBER", "I", "m", "not", "sure", "anyone", "has", "before", "and", "it", "s", "be", "over", "NUMBER", "years", "NUMBER", "Internally", "NUMBER", "NUMBER", "be", "referred", "to", "as", "the", "black", "hole", "though", "I", "like", "Ouroboros", "better", "NUMBER", "Clearly", "the", "reader", "needs", "to", "be", "extend", "to", "handle", "mutually", "recursive", "cases", "like", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "for", "the", "next", "person", "who", "trips", "on", "it", "NUMBER", "There", "s", "probably", "no", "hurry", "though", "NUMBER", "Just", "putting", "this", "into", "testit", "NUMBER", "scm", "fail", "scheme", "start", "lambda", "foreign", "callable", "void", "void", "so", "it", "s", "something", "about", "evaluating", "a", "foreign", "callable", "form", "at", "boot", "time", "NUMBER", "You", "suspicion", "that", "this", "be", "connected", "with", "static", "memory", "be", "correct", "NUMBER", "When", "any", "code", "object", "be", "relocated", "into", "the", "static", "generation", "its", "relocation", "table", "be", "drop", "since", "it", "won", "t", "ever", "need", "to", "be", "relocated", "again", "NUMBER", "Each", "time", "a", "foreign", "callable", "form", "be", "evaluated", "however", "a", "copy", "of", "the", "original", "code", "object", "be", "created", "with", "a", "pointer", "to", "the", "Scheme", "procedure", "to", "be", "invoked", "embedded", "in", "it", "NUMBER", "The", "relocation", "table", "be", "needed", "both", "to", "find", "the", "proper", "location", "for", "the", "embedded", "pointer", "and", "because", "the", "freshly", "allocated", "code", "object", "might", "be", "relocated", "by", "the", "collector", "NUMBER", "Since", "the", "static", "code", "object", "in", "your", "example", "be", "miss", "its", "relocation", "table", "the", "code", "that", "creates", "the", "copy", "of", "the", "foreign", "callable", "code", "object", "crashes", "NUMBER", "Solving", "this", "probably", "involves", "setting", "a", "flag", "on", "each", "foreign", "callable", "code", "object", "to", "say", "its", "relocation", "table", "should", "not", "be", "drop", "NUMBER", "In", "the", "meantime", "a", "workaround", "be", "to", "arrange", "for", "the", "foreign", "callable", "form", "to", "be", "evaluated", "at", "boot", "time", "before", "the", "relocation", "table", "has", "be", "drop", "not", "when", "scheme", "start", "be", "invoked", "NUMBER", "For", "example", "the", "following", "variation", "of", "your", "example", "doesn", "t", "crash", "top", "level", "program", "import", "chezscheme", "define", "code", "foreign", "callable", "lambda", "display", "Hello", "world", "n", "void", "define", "main", "display", "back", "from", "foreign", "callable", "n", "lock", "object", "code", "foreign", "callable", "entry", "point", "code", "exit", "NUMBER", "scheme", "start", "lambda", "main", "This", "should", "be", "fix", "by", "this", "commit", "LINK", "NUMBER", "Thanks", "for", "the", "fix", "Thanks", "Neowizard", "for", "report", "the", "error", "and", "owaddell", "for", "the", "fix", "NUMBER", "Thanks", "Thanks", "for", "the", "fix", "Thanks", "for", "the", "fix", "Thank", "you", "for", "this", "pull", "request", "Thanks", "for", "the", "suggestion", "mromyers", "NUMBER", "I", "ll", "take", "a", "look", "at", "the", "slides", "when", "I", "get", "a", "chance", "though", "I", "know", "how", "to", "go", "about", "saving", "the", "Chez", "Scheme", "heap", "from", "prior", "experience", "NUMBER", "A", "warning", "for", "anyone", "else", "considering", "work", "on", "saved", "heaps", "for", "Chez", "Scheme", "The", "slides", "be", "as", "deep", "as", "we", "can", "go", "unless", "there", "s", "a", "more", "detailed", "writeup", "NUMBER", "Unless", "I", "m", "mistaken", "the", "Emacs", "source", "code", "be", "GPL", "d", "so", "even", "if", "someone", "just", "perused", "the", "code", "to", "gain", "knowledge", "of", "its", "workings", "before", "work", "on", "an", "implementation", "for", "Chez", "Scheme", "that", "could", "taint", "our", "permissive", "open", "source", "code", "NUMBER", "I", "ve", "just", "add", "a", "mention", "of", "threads", "to", "BUILDING", "as", "request", "NUMBER", "Thanks", "for", "the", "pull", "request", "NUMBER", "Can", "the", "code", "actually", "reference", "uninitialized", "values", "i", "NUMBER", "e", "NUMBER", "be", "the", "chunk", "not", "fully", "initialized", "by", "the", "call", "that", "follows", "the", "getmem", "call", "If", "so", "zero", "filling", "be", "likely", "not", "an", "appropriate", "solution", "NUMBER", "If", "not", "I", "d", "rather", "not", "introduce", "the", "extra", "overhead", "just", "to", "satisfy", "valgrind", "NUMBER", "Do", "you", "happen", "to", "know", "what", "be", "going", "on", "when", "it", "happens", "For", "example", "do", "it", "happen", "when", "run", "a", "particular", "test", "in", "the", "mats", "I", "ve", "stared", "at", "copy", "a", "bit", "and", "it", "looks", "like", "one", "possible", "culprit", "be", "the", "seginfo", "trigger_empherons", "field", "which", "do", "seem", "to", "be", "referenced", "without", "be", "set", "NUMBER", "Would", "you", "please", "try", "initializing", "it", "to", "NULL", "in", "segment", "NUMBER", "c", "initialize_seginfo", "and", "see", "if", "that", "resolve", "the", "issue", "Thanks", "for", "bringing", "this", "to", "my", "attention", "and", "for", "narrowing", "it", "down", "NUMBER", "I", "ve", "confirmed", "the", "issue", "and", "have", "a", "more", "surgical", "fix", "which", "be", "to", "add", "the", "following", "two", "lines", "to", "initialize_seginfo", "in", "segment", "NUMBER", "c", "si", "sorted", "NUMBER", "si", "trigger_ephemerons", "NULL", "With", "this", "fix", "valgrind", "doesn", "t", "turn", "up", "any", "error", "with", "the", "empty", "program", "or", "when", "rebuilding", "in", "the", "s", "directory", "or", "run", "the", "mats", "NUMBER", "Would", "you", "like", "to", "alter", "your", "pull", "request", "to", "replace", "zero", "filling", "with", "these", "two", "lines", "If", "so", "please", "also", "add", "a", "brief", "entry", "in", "LOG", "NUMBER", "Many", "thanks", "to", "stergiotis", "all", "others", "who", "contributed", "and", "especially", "to", "mflatt", "for", "fix", "the", "issue", "NUMBER", "The", "semantics", "of", "the", "interaction", "environment", "support", "redefinition", "of", "actually", "assignment", "of", "variables", "but", "the", "export", "variables", "of", "a", "library", "be", "immutable", "both", "inside", "and", "outside", "of", "the", "library", "NUMBER", "So", "it", "s", "not", "presently", "possible", "NUMBER", "You", "could", "change", "the", "semantics", "with", "change", "to", "the", "expander", "and", "possibly", "cp", "NUMBER", "Or", "you", "could", "work", "with", "the", "exist", "semantics", "which", "allows", "entire", "libraries", "to", "be", "redefined", "if", "you", "arrange", "to", "re", "evaluate", "any", "code", "that", "was", "compiled", "against", "the", "redefined", "libraries", "NUMBER", "You", "can", "use", "library", "list", "to", "get", "the", "set", "of", "loaded", "libraries", "and", "library", "requirements", "to", "get", "a", "list", "of", "each", "library", "s", "dependencies", "NUMBER", "With", "that", "you", "can", "build", "a", "dependence", "graph", "to", "determine", "the", "set", "of", "libraries", "that", "depend", "on", "a", "given", "library", "NUMBER", "These", "change", "look", "good", "thanks", "I", "ve", "push", "a", "fix", "for", "the", "one", "typo", "not", "fix", "by", "goober", "NUMBER", "s", "pull", "request", "the", "miss", "connector", "between", "create", "and", "process", "so", "I", "m", "closing", "this", "issue", "NUMBER", "Thanks", "for", "the", "corrections", "The", "thread", "system", "itself", "isn", "t", "the", "slow", "part", "NUMBER", "The", "division", "operator", "makes", "a", "call", "to", "S_div", "which", "allocates", "a", "ratnum", "NUMBER", "The", "allocation", "requires", "the", "global", "tc", "mutex", "when", "the", "current", "segment", "be", "exhausted", "NUMBER", "I", "don", "t", "know", "why", "this", "takes", "so", "long", "on", "both", "macOS", "and", "Windows", "NUMBER", "Replacing", "with", "quotient", "resolve", "the", "problem", "by", "eliminating", "the", "allocation", "NUMBER", "Replacing", "with", "cons", "also", "works", "NUMBER", "define", "f", "x", "y", "do", "i", "NUMBER", "i", "NUMBER", "i", "NUMBER", "x", "y", "define", "doit", "let", "start", "statistics", "f", "NUMBER", "NUMBER", "sstats", "difference", "statistics", "start", "define", "go", "n", "display", "string", "Regular", "n", "sstats", "print", "doit", "current", "output", "port", "flush", "output", "port", "let", "m", "make", "mutex", "c", "make", "condition", "define", "work", "let", "s", "doit", "with", "mutex", "m", "display", "string", "nThread", "n", "sstats", "print", "s", "current", "output", "port", "flush", "output", "port", "set", "n", "n", "NUMBER", "when", "n", "NUMBER", "condition", "signal", "c", "with", "mutex", "m", "do", "i", "n", "i", "NUMBER", "i", "NUMBER", "fork", "thread", "work", "condition", "wait", "c", "m", "I", "ve", "be", "looking", "into", "this", "and", "have", "uncovered", "a", "couple", "of", "issue", "NUMBER", "First", "the", "call", "to", "causes", "the", "allocation", "of", "a", "ratnum", "in", "number", "NUMBER", "c", "use", "thread_get_more_room", "NUMBER", "thread_get_more_room", "be", "designed", "to", "allocate", "from", "the", "thread", "local", "allocation", "pointer", "if", "space", "be", "available", "there", "and", "it", "do", "for", "the", "first", "set", "of", "ratnums", "NUMBER", "It", "do", "not", "however", "cause", "a", "new", "local", "allocation", "area", "to", "be", "created", "when", "the", "exist", "one", "be", "exhausted", "so", "if", "no", "other", "allocation", "occur", "it", "performs", "a", "global", "allocation", "NUMBER", "Importantly", "particularly", "on", "OSX", "and", "possibly", "on", "Windows", "be", "that", "this", "causes", "the", "tc", "mutex", "to", "be", "acquired", "on", "each", "call", "to", "NUMBER", "This", "leads", "to", "the", "second", "issue", "which", "be", "that", "mutexes", "under", "heavy", "contention", "be", "much", "slower", "on", "OSX", "and", "perhaps", "on", "Windows", "than", "one", "would", "expect", "as", "has", "be", "noted", "in", "other", "posts", "NUMBER", "I", "don", "t", "know", "if", "we", "can", "do", "anything", "about", "the", "latter", "problem", "NUMBER", "I", "tried", "setting", "the", "OSX", "specific", "_PTHREAD_MUTEX_POLICY_FIRSTFIT", "which", "be", "supposed", "to", "help", "matters", "but", "this", "appears", "to", "result", "in", "deadlock", "as", "has", "also", "be", "noted", "in", "other", "posts", "NUMBER", "I", "will", "try", "to", "fix", "the", "former", "problem", "NUMBER", "I", "ve", "push", "a", "change", "LINK", "to", "address", "the", "first", "issue", "describe", "in", "my", "preceding", "note", "NUMBER", "Exactly", "and", "since", "the", "system", "do", "not", "generate", "the", "unique", "name", "until", "it", "s", "needed", "by", "the", "repl", "in", "this", "case", "_after_", "the", "call", "to", "time", "time", "wouldn", "t", "show", "the", "elapse", "time", "NUMBER", "Try", "this", "instead", "time", "pretty", "print", "gensym", "Thanks", "for", "the", "helpful", "suggestion", "I", "update", "the", "instructions", "in", "NUMBER", "eca", "NUMBER", "aeea", "NUMBER", "d", "NUMBER", "d", "NUMBER", "f", "NUMBER", "c", "NUMBER", "f", "NUMBER", "ecdb", "NUMBER", "Thanks", "for", "posting", "this", "in", "case", "others", "run", "into", "the", "same", "thing", "NUMBER", "Is", "git", "configured", "to", "use", "Windows", "line", "endings", "If", "so", "it", "may", "checkout", "configure", "with", "CRLF", "line", "endings", "NUMBER", "Great", "I", "add", "a", "sentence", "about", "this", "in", "NUMBER", "c", "NUMBER", "a", "NUMBER", "c", "NUMBER", "f", "NUMBER", "eec", "NUMBER", "a", "NUMBER", "afa", "NUMBER", "d", "NUMBER", "bc", "NUMBER", "ee", "NUMBER", "Thank", "you", "for", "point", "this", "out", "The", "Windows", "version", "of", "Chez", "Scheme", "be", "not", "affected", "by", "this", "and", "the", "Linux", "and", "Mac", "version", "should", "be", "able", "to", "use", "uuid_generate", "to", "avoid", "it", "NUMBER", "I", "have", "a", "propose", "update", "on", "branch", "rgburger", "uuid", "but", "I", "don", "t", "know", "how", "to", "configure", "the", "Travis", "CI", "server", "to", "find", "the", "NUMBER", "bit", "uuid", "dev", "libraries", "on", "Linux", "NUMBER", "Any", "ideas", "Thanks", "that", "worked", "This", "issue", "be", "fix", "in", "NUMBER", "fd", "NUMBER", "db", "NUMBER", "d", "NUMBER", "a", "NUMBER", "d", "NUMBER", "a", "NUMBER", "a", "NUMBER", "d", "NUMBER", "b", "NUMBER", "Merged", "and", "commit", "NUMBER", "Thanks", "Thanks", "for", "fix", "this", "If", "we", "make", "this", "change", "then", "on", "non", "X", "NUMBER", "macOS", "systems", "Chez", "Scheme", "s", "expression", "editor", "won", "t", "have", "pasteboard", "support", "NUMBER", "akeep", "and", "I", "would", "prefer", "to", "see", "a", "change", "that", "support", "the", "pasteboard", "even", "when", "X", "NUMBER", "be", "not", "install", "NUMBER", "Thanks", "it", "would", "be", "great", "if", "you", "could", "unentangle", "the", "X", "NUMBER", "clipboard", "and", "macOS", "pasteboard", "in", "the", "expression", "editor", "NUMBER", "Thanks", "akeep", "tison", "NUMBER", "thank", "you", "for", "this", "pull", "request", "Thanks", "dybvig", "What", "rules", "do", "we", "need", "to", "follow", "when", "update", "the", "copyright", "year", "I", "don", "t", "have", "XQuartz", "install", "so", "I", "cannot", "compile", "Chez", "Scheme", "for", "macOS", "without", "modifying", "c", "version", "NUMBER", "h", "to", "remove", "the", "LIBX", "NUMBER", "definition", "for", "macOS", "NUMBER", "I", "would", "welcome", "a", "pull", "request", "that", "add", "a", "check", "for", "X", "NUMBER", "Xlib", "NUMBER", "h", "and", "allows", "systems", "without", "it", "to", "compile", "NUMBER", "akeep", "thanks", "mflatt", "The", "a", "NUMBER", "nt", "foreign", "NUMBER", "mo", "foreign", "callable", "clause", "NUMBER", "mat", "fail", "eqv", "let", "define", "ftype", "foo", "function", "fixnum", "fixnum", "ptr", "fixnum", "define", "f", "lambda", "n", "m", "k", "if", "fx", "n", "NUMBER", "k", "m", "if", "fx", "fxmodulo", "n", "NUMBER", "NUMBER", "k", "call", "cc", "lambda", "k", "g", "fx", "n", "NUMBER", "fx", "m", "NUMBER", "k", "g", "fx", "n", "NUMBER", "fx", "m", "NUMBER", "k", "define", "fptr", "make", "ftype", "pointer", "foo", "f", "define", "g", "ftype", "ref", "foo", "fptr", "let", "v", "with", "exit", "proc", "lambda", "k", "f", "stack", "depth", "base", "value", "k", "unlock", "object", "foreign", "callable", "code", "object", "ftype", "pointer", "address", "fptr", "v", "stack", "depth", "base", "value", "Error", "in", "mat", "foreign", "callable", "clause", "NUMBER", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "at", "line", "NUMBER", "char", "NUMBER", "of", "foreign", "NUMBER", "ms", "When", "run", "in", "isolation", "this", "particular", "test", "pass", "NUMBER", "It", "seems", "to", "require", "a", "couple", "of", "the", "previous", "expressions", "NUMBER", "It", "pass", "on", "ta", "NUMBER", "nt", "i", "NUMBER", "nt", "and", "ti", "NUMBER", "nt", "NUMBER", "Commit", "LINK", "triggered", "this", "failure", "on", "a", "NUMBER", "nt", "but", "I", "don", "t", "think", "it", "cause", "it", "NUMBER", "When", "I", "cherry", "pick", "this", "commit", "back", "to", "a", "branch", "from", "the", "foreign", "procedure", "change", "de", "NUMBER", "f", "NUMBER", "f", "NUMBER", "c", "NUMBER", "eeda", "NUMBER", "e", "NUMBER", "b", "NUMBER", "b", "NUMBER", "fd", "NUMBER", "d", "NUMBER", "d", "NUMBER", "b", "NUMBER", "dad", "NUMBER", "the", "foreign", "NUMBER", "mo", "mats", "pass", "NUMBER", "Immediately", "after", "those", "change", "it", "fail", "NUMBER", "I", "suspect", "some", "heap", "corruption", "in", "the", "foreign", "procedure", "callable", "code", "on", "NUMBER", "bit", "Windows", "NUMBER", "I", "get", "it", "by", "run", "make", "foreign", "NUMBER", "mo", "and", "then", "looking", "for", "the", "word", "clause", "in", "foreign", "NUMBER", "mo", "NUMBER", "I", "be", "use", "Visual", "Studio", "NUMBER", "Version", "NUMBER", "I", "m", "now", "use", "Visual", "Studio", "NUMBER", "version", "NUMBER", "on", "Windows", "NUMBER", "version", "NUMBER", "git", "clean", "fxd", "NUMBER", "NUMBER", "configure", "m", "a", "NUMBER", "nt", "cd", "a", "NUMBER", "nt", "make", "cd", "mats", "make", "foreign", "NUMBER", "mo", "I", "don", "t", "get", "the", "invalid", "memory", "reference", "if", "I", "compile", "in", "Debug", "mode", "NUMBER", "I", "don", "t", "get", "the", "invalid", "memory", "reference", "if", "I", "compile", "with", "Os", "optimize", "for", "space", "instead", "of", "Ox", "optimize", "for", "speed", "NUMBER", "This", "may", "indicate", "a", "problem", "with", "the", "C", "code", "NUMBER", "No", "invalid", "memory", "references", "when", "compiled", "with", "Visual", "Studio", "NUMBER", "Hmmm", "we", "might", "be", "tickling", "a", "Visual", "Studio", "NUMBER", "compiler", "bug", "here", "NUMBER", "The", "volatile", "ptr", "tc", "eliminates", "the", "invalid", "memory", "references", "for", "me", "NUMBER", "That", "was", "a", "great", "idea", "I", "looked", "at", "the", "assembly", "output", "with", "various", "combinations", "of", "volatile", "NUMBER", "The", "one", "you", "recommend", "do", "not", "use", "rsp", "after", "setjmp", "except", "when", "it", "exits", "NUMBER", "I", "think", "we", "bump", "into", "a", "bug", "with", "setjmp", "longjmp", "and", "the", "MSVC", "compiler", "NUMBER", "It", "also", "worked", "for", "me", "when", "no", "variable", "was", "declared", "volatile", "NUMBER", "I", "recommend", "declaring", "both", "volatile", "NUMBER", "mflatt", "Thank", "you", "very", "much", "for", "the", "fix", "Now", "all", "the", "mats", "pass", "on", "all", "platforms", "NUMBER", "See", "commit", "LINK", "Thanks", "for", "the", "fix", "Please", "use", "VirtualProtect", "p", "si", "NUMBER", "dwPageSize", "si", "NUMBER", "dwPageSize", "PAGE_NOACCESS", "dummy", "in", "Windows", "NUMBER", "EXPORT", "void", "malloc_at_boundary", "int", "sz", "SYSTEM_INFO", "si", "char", "p", "DWORD", "dummy", "GetSystemInfo", "si", "p", "VirtualAlloc", "NULL", "si", "NUMBER", "dwPageSize", "MEM_COMMIT", "MEM_RESERVE", "PAGE_READWRITE", "VirtualProtect", "p", "si", "NUMBER", "dwPageSize", "si", "NUMBER", "dwPageSize", "PAGE_NOACCESS", "dummy", "return", "p", "si", "NUMBER", "dwPageSize", "sz", "Thanks", "that", "makes", "sense", "NUMBER", "Thanks", "again", "for", "this", "fix", "mflatt", "The", "a", "NUMBER", "nt", "foreign", "NUMBER", "mo", "mats", "fail", "earlier", "than", "the", "a", "NUMBER", "le", "mat", "shown", "above", "eqv", "let", "define", "ftype", "foo", "function", "fixnum", "fixnum", "ptr", "fixnum", "define", "f", "lambda", "n", "m", "k", "if", "fx", "n", "NUMBER", "k", "m", "if", "fx", "fxmodulo", "n", "NUMBER", "NUMBER", "k", "call", "cc", "lambda", "k", "g", "fx", "n", "NUMBER", "fx", "m", "NUMBER", "k", "g", "fx", "n", "NUMBER", "fx", "m", "NUMBER", "k", "define", "fptr", "make", "ftype", "pointer", "foo", "f", "define", "g", "ftype", "ref", "foo", "fptr", "let", "v", "with", "exit", "proc", "lambda", "k", "f", "stack", "depth", "base", "value", "k", "unlock", "object", "foreign", "callable", "code", "object", "ftype", "pointer", "address", "fptr", "v", "stack", "depth", "base", "value", "Error", "in", "mat", "foreign", "callable", "clause", "NUMBER", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "at", "line", "NUMBER", "char", "NUMBER", "of", "foreign", "NUMBER", "ms", "For", "some", "reason", "these", "mats", "pass", "for", "ta", "NUMBER", "nt", "NUMBER", "I", "hope", "that", "both", "of", "the", "mat", "failures", "shown", "in", "this", "issue", "have", "the", "same", "root", "cause", "NUMBER", "My", "recent", "commit", "LINK", "triggered", "this", "failure", "on", "a", "NUMBER", "nt", "but", "I", "don", "t", "think", "it", "cause", "it", "NUMBER", "When", "I", "cherry", "pick", "my", "commit", "back", "to", "a", "branch", "from", "the", "foreign", "procedure", "change", "de", "NUMBER", "f", "NUMBER", "f", "NUMBER", "c", "NUMBER", "eeda", "NUMBER", "e", "NUMBER", "b", "NUMBER", "b", "NUMBER", "fd", "NUMBER", "d", "NUMBER", "d", "NUMBER", "b", "NUMBER", "dad", "NUMBER", "the", "foreign", "NUMBER", "mo", "mats", "pass", "NUMBER", "Immediately", "after", "those", "change", "it", "fail", "NUMBER", "I", "suspect", "some", "heap", "corruption", "in", "the", "foreign", "procedure", "callable", "code", "NUMBER", "mflatt", "If", "you", "d", "like", "to", "have", "a", "stronger", "Windows", "version", "of", "malloc_at_boundary", "and", "free_at_boundary", "you", "can", "call", "VirtualAlloc", "instead", "of", "mmap", "VirtualProtect", "instead", "of", "mprotect", "and", "VirtualFree", "instead", "of", "munmap", "NUMBER", "See", "S_getpagesize", "in", "c", "windows", "NUMBER", "c", "for", "the", "way", "to", "query", "the", "page", "size", "NUMBER", "Thanks", "for", "the", "quick", "fix", "As", "expected", "it", "did", "not", "fix", "the", "invalid", "memory", "reference", "on", "a", "NUMBER", "nt", "NUMBER", "There", "must", "be", "something", "else", "going", "on", "NUMBER", "Thanks", "for", "looking", "into", "it", "The", "pull", "request", "fix", "the", "main", "issue", "thank", "you", "I", "put", "the", "secondary", "issue", "into", "LINK", "Thanks", "for", "finding", "this", "inconsistency", "with", "the", "code", "in", "the", "examples", "folder", "NUMBER", "I", "update", "the", "documentation", "to", "be", "in", "sync", "with", "the", "code", "and", "add", "NUMBER", "bit", "Linux", "to", "the", "machine", "case", "NUMBER", "See", "LINK", "We", "update", "the", "web", "pages", "more", "frequently", "than", "stable", "release", "NUMBER", "Since", "the", "last", "update", "was", "from", "March", "I", "just", "checked", "in", "a", "new", "update", "NUMBER", "Thanks", "for", "point", "this", "out", "dybvig", "To", "summarize", "there", "be", "two", "bug", "in", "the", "current", "code", "base", "NUMBER", "The", "C", "code", "has", "S_get_scheme_arg", "tc", "NUMBER", "instead", "of", "S_get_scheme_arg", "tc", "NUMBER", "NUMBER", "Once", "that", "be", "correct", "the", "return", "value", "be", "junk", "because", "the", "invoke", "code", "object", "doesn", "t", "save", "the", "scheme", "arg", "registers", "NUMBER", "I", "propose", "a", "change", "that", "corrects", "the", "C", "code", "and", "the", "invoke", "code", "to", "save", "the", "scheme", "arg", "registers", "NUMBER", "Will", "doing", "so", "break", "anything", "else", "Fixed", "in", "commit", "LINK", "The", "master", "branch", "run", "into", "a", "similar", "timeout", "on", "ti", "NUMBER", "osx", "LINK", "ci", "NUMBER", "org", "cisco", "ChezScheme", "build", "NUMBER", "so", "I", "restarted", "the", "ta", "NUMBER", "osx", "test", "NUMBER", "I", "like", "the", "change", "but", "I", "think", "there", "be", "a", "few", "things", "miss", "from", "the", "WIP", "change", "NUMBER", "If", "you", "look", "at", "what", "we", "did", "for", "visit", "code", "and", "invoke", "code", "we", "wrap", "the", "on", "reset", "around", "the", "both", "invoking", "the", "appropriate", "thunk", "as", "well", "as", "doing", "the", "recursive", "processing", "on", "the", "invoke", "and", "or", "visit", "requirements", "NUMBER", "I", "think", "the", "on", "reset", "for", "import", "library", "should", "do", "the", "same", "NUMBER", "The", "other", "thing", "you", "ll", "notice", "if", "you", "look", "at", "the", "visit", "code", "be", "that", "we", "be", "also", "resetting", "the", "compile", "time", "environment", "because", "it", "was", "possible", "to", "construct", "situations", "where", "part", "of", "the", "visit", "code", "thunk", "had", "run", "leaving", "the", "compile", "time", "environment", "in", "an", "inconsistent", "state", "NUMBER", "It", "seems", "like", "this", "could", "also", "happen", "in", "the", "import", "code", "where", "export", "identifiers", "be", "bound", "to", "indicate", "the", "they", "be", "either", "invoke", "aka", "library", "global", "or", "visit", "identifiers", "and", "the", "module", "interface", "for", "the", "library", "be", "also", "add", "to", "the", "compile", "time", "environment", "NUMBER", "If", "we", "really", "want", "to", "roll", "this", "back", "we", "may", "need", "to", "unset", "these", "in", "the", "compile", "time", "environment", "on", "import", "reset", "NUMBER", "Unfortunately", "that", "would", "require", "that", "we", "capture", "the", "export", "invoke", "time", "aka", "revisit", "time", "identifiers", "just", "as", "we", "do", "with", "the", "visit", "identifiers", "so", "that", "we", "know", "what", "we", "be", "resetting", "NUMBER", "Part", "of", "the", "reason", "I", "didn", "t", "do", "this", "when", "I", "was", "work", "on", "change", "this", "for", "the", "visit", "code", "and", "invoke", "code", "procedures", "was", "that", "I", "didn", "t", "think", "there", "was", "ever", "anything", "in", "the", "body", "of", "the", "import", "code", "thunk", "that", "could", "cause", "an", "error", "to", "be", "raise", "since", "we", "were", "just", "setting", "bindings", "in", "the", "compile", "time", "environment", "to", "constants", "either", "f", "or", "the", "interface", "module", "but", "it", "sounds", "like", "there", "was", "something", "I", "miss", "in", "the", "potential", "generate", "code", "I", "like", "the", "cleaned", "up", "error", "message", "definitely", "better", "to", "see", "the", "library", "code", "error", "rather", "than", "an", "unknown", "module", "error", "when", "you", "were", "trying", "to", "import", "a", "library", "NUMBER", "Yes", "the", "interpreter", "be", "part", "of", "the", "Chez", "Scheme", "system", "and", "be", "test", "as", "part", "of", "the", "automate", "test", "NUMBER", "The", "executable", "for", "both", "Chez", "Scheme", "and", "Petite", "Chez", "Scheme", "the", "interpret", "be", "the", "same", "with", "the", "default", "names", "of", "scheme", "and", "petite", "where", "petite", "be", "a", "hard", "link", "to", "scheme", "NUMBER", "If", "you", "look", "at", "the", "install", "file", "with", "Chez", "Scheme", "you", "ll", "see", "that", "there", "be", "a", "petite", "NUMBER", "boot", "and", "scheme", "NUMBER", "boot", "when", "petite", "be", "run", "only", "petite", "NUMBER", "boot", "be", "loaded", "NUMBER", "This", "boot", "file", "contains", "the", "core", "Chez", "Scheme", "libraries", "and", "the", "interpreter", "NUMBER", "When", "scheme", "be", "run", "it", "loads", "both", "the", "petite", "NUMBER", "boot", "file", "and", "the", "scheme", "NUMBER", "boot", "file", "and", "the", "scheme", "NUMBER", "boot", "file", "contains", "the", "compiler", "NUMBER", "It", "be", "worth", "noting", "that", "both", "use", "the", "same", "C", "run", "time", "and", "the", "interpreter", "as", "well", "as", "compiler", "for", "that", "matter", "be", "write", "in", "Scheme", "as", "be", "many", "of", "the", "basic", "Scheme", "libraries", "with", "support", "from", "the", "run", "time", "NUMBER", "I", "m", "not", "sure", "how", "the", "interpreter", "exist", "helps", "with", "make", "Chez", "Scheme", "embeddable", "on", "iOS", "but", "I", "ve", "not", "looked", "at", "the", "iOS", "constraints", "in", "a", "while", "NUMBER", "Looks", "good", "thanks", "for", "the", "edits", "The", "Chez", "Scheme", "User", "s", "Guide", "LINK", "NUMBER", "libraries", "h", "NUMBER", "indicates", "that", "scheme", "script", "be", "equivalent", "to", "scheme", "program", "NUMBER", "The", "use", "of", "_script_", "in", "two", "different", "contexts", "be", "confusing", "NUMBER", "Thanks", "for", "this", "pull", "request", "I", "m", "not", "an", "emacs", "user", "so", "I", "m", "not", "really", "sure", "what", "this", "tool", "be", "or", "what", "you", "would", "need", "from", "Chez", "Scheme", "to", "support", "it", "NUMBER", "The", "Chez", "Scheme", "documentation", "be", "write", "in", "stex", "LINK", "an", "extension", "on", "LaTeX", "that", "generates", "pdf", "and", "html", "output", "with", "the", "standard", "R", "NUMBER", "RS", "Scheme", "library", "documented", "in", "The", "Scheme", "Programming", "Language", "LINK", "but", "be", "not", "part", "of", "the", "Chez", "Scheme", "source", "repository", "NUMBER", "As", "jltaylor", "us", "mention", "there", "be", "no", "module", "or", "library", "here", "so", "I", "m", "not", "sure", "what", "you", "mean", "by", "that", "NUMBER", "However", "the", "file", "command", "can", "be", "pretty", "useful", "in", "the", "debugger", "to", "figure", "out", "where", "the", "error", "occur", "NUMBER", "From", "your", "example", "scheme", "debug", "on", "exception", "program", "tmp", "foo", "NUMBER", "scm", "Exception", "attempt", "to", "apply", "non", "procedure", "NUMBER", "debug", "i", "TAG", "sl", "continuation", "TAG", "procedure", "code", "lambda", "letrec", "NUMBER", "NUMBER", "NUMBER", "call", "code", "bar", "TAG", "file", "line", "NUMBER", "character", "NUMBER", "of", "tmp", "foo", "NUMBER", "scm", "TAG", "file", "tells", "you", "that", "this", "exception", "was", "throw", "at", "line", "NUMBER", "column", "NUMBER", "of", "the", "file", "which", "I", "put", "in", "tmp", "NUMBER", "I", "ve", "merge", "NUMBER", "which", "as", "jltaylor", "us", "note", "address", "the", "problem", "with", "gcc", "NUMBER", "Thanks", "to", "weinholt", "for", "the", "patch", "NUMBER", "Source", "pull", "from", "GitHub", "should", "now", "build", "with", "gcc", "NUMBER", "and", "I", "ve", "successfully", "test", "on", "Fedora", "NUMBER", "Normally", "for", "any", "support", "non", "threaded", "build", "like", "i", "NUMBER", "osx", "a", "NUMBER", "osx", "i", "NUMBER", "le", "a", "NUMBER", "le", "etc", "NUMBER", "there", "would", "be", "an", "associated", "threaded", "version", "that", "starts", "with", "a", "t", "like", "ti", "NUMBER", "osx", "ta", "NUMBER", "osx", "ti", "NUMBER", "le", "ta", "NUMBER", "le", "etc", "NUMBER", "NUMBER", "It", "looks", "like", "when", "the", "arm", "NUMBER", "port", "was", "do", "the", "tarm", "NUMBER", "le", "version", "wasn", "t", "fully", "fleshed", "out", "NUMBER", "I", "m", "not", "sure", "why", "exactly", "but", "I", "suspect", "at", "the", "time", "it", "was", "do", "before", "it", "was", "open", "sourced", "we", "didn", "t", "have", "a", "need", "for", "the", "threaded", "version", "NUMBER", "I", "wasn", "t", "involved", "in", "the", "original", "arm", "port", "but", "it", "should", "be", "possible", "to", "add", "the", "threading", "support", "NUMBER", "It", "will", "likely", "mean", "add", "the", "miss", "instructions", "to", "support", "the", "threaded", "features", "including", "recently", "add", "features", "and", "add", "the", "Mf", "tarm", "NUMBER", "le", "and", "tarm", "NUMBER", "le", "NUMBER", "def", "file", "NUMBER", "I", "think", "we", "could", "keep", "the", "FMTBUFSIZE", "slightly", "shorter", "but", "when", "I", "computed", "a", "worst", "case", "for", "the", "format", "string", "that", "fail", "it", "was", "pretty", "close", "to", "NUMBER", "bytes", "long", "though", "gcc", "seems", "to", "do", "a", "little", "more", "precise", "computation", "than", "I", "feared", "it", "was", "doing", "NUMBER", "At", "any", "rate", "I", "think", "NUMBER", "be", "okay", "for", "the", "buffer", "here", "NUMBER", "Thanks", "for", "the", "update", "From", "my", "reading", "it", "sounds", "like", "an", "error", "return", "value", "indicates", "a", "wide", "character", "or", "other", "encoding", "problem", "in", "the", "format", "string", "and", "since", "in", "the", "usage", "within", "this", "print", "out", "we", "know", "the", "characters", "be", "ascii", "I", "m", "not", "sure", "those", "kinds", "of", "error", "can", "occur", "here", "NUMBER", "Are", "there", "other", "error", "you", "be", "worried", "about", "us", "catching", "in", "this", "code", "andy", "On", "May", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "NUMBER", "AM", "Saigut", "notifications", "github", "NUMBER", "com", "write", "The", "valid", "return", "value", "of", "snprintf", "be", "NUMBER", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "In", "both", "cases", "this", "be", "not", "allow", "because", "R", "NUMBER", "RS", "dictates", "that", "a", "library", "be", "A", "library", "definition", "must", "have", "the", "following", "form", "library", "TAG", "export", "TAG", "NUMBER", "import", "TAG", "NUMBER", "TAG", "and", "continues", "to", "say", "that", "A", "TAG", "be", "like", "a", "TAG", "see", "section", "NUMBER", "except", "that", "a", "TAG", "s", "need", "not", "include", "any", "expressions", "NUMBER", "It", "must", "have", "the", "following", "form", "TAG", "NUMBER", "TAG", "NUMBER", "When", "begin", "let", "syntax", "or", "letrec", "syntax", "form", "occur", "in", "a", "top", "level", "body", "prior", "to", "the", "first", "expression", "they", "be", "spliced", "into", "the", "body", "see", "section", "NUMBER", "Some", "or", "all", "of", "the", "body", "including", "portions", "wrapped", "in", "begin", "let", "syntax", "or", "letrec", "syntax", "form", "may", "be", "specified", "by", "a", "syntactic", "abstraction", "see", "section", "NUMBER", "NUMBER", "From", "the", "R", "NUMBER", "RS", "Spec", "Chapter", "NUMBER", "LINK", "Z", "H", "NUMBER", "html", "node_chap_", "NUMBER", "In", "this", "case", "the", "scheme", "record", "writer", "type", "descriptor", "test", "a", "lambda", "r", "p", "wr", "f", "Call", "be", "an", "expression", "so", "it", "cannot", "proceed", "a", "definition", "NUMBER", "There", "be", "a", "couple", "of", "ways", "to", "work", "around", "this", "NUMBER", "Since", "you", "be", "use", "Chez", "Scheme", "s", "library", "you", "can", "use", "Chez", "Scheme", "s", "module", "form", "to", "wrap", "the", "expression", "scheme", "module", "record", "writer", "type", "descriptor", "test", "a", "lambda", "r", "p", "wr", "f", "A", "module", "be", "always", "a", "definition", "even", "when", "it", "contains", "expressions", "NUMBER", "You", "can", "also", "wrap", "a", "define", "around", "at", "effectively", "defining", "it", "for", "effect", "NUMBER", "scheme", "define", "ignore", "record", "writer", "type", "descriptor", "test", "a", "lambda", "r", "p", "wr", "f", "You", "be", "also", "correct", "that", "the", "error", "message", "when", "you", "put", "the", "define", "record", "type", "exposes", "the", "fact", "that", "define", "record", "type", "be", "defined", "as", "a", "macro", "that", "expands", "into", "a", "set", "of", "definitions", "use", "the", "underlying", "procedural", "interface", "for", "the", "record", "system", "NUMBER", "Since", "define", "record", "type", "be", "just", "a", "normal", "macro", "like", "any", "macro", "a", "user", "might", "define", "the", "expander", "has", "to", "expand", "it", "to", "determine", "whether", "it", "be", "a", "definition", "or", "an", "expression", "NUMBER", "You", "can", "also", "use", "expand", "at", "the", "repl", "to", "see", "this", "though", "so", "I", "m", "not", "sure", "how", "much", "it", "be", "really", "exposing", "NUMBER", "Although", "it", "be", "worth", "noting", "that", "the", "define", "you", "see", "in", "the", "error", "message", "would", "have", "either", "be", "expanded", "into", "a", "top", "level", "set", "or", "part", "of", "a", "letrec", "depending", "on", "context", "define", "s", "be", "only", "treated", "as", "top", "level", "set", "at", "the", "top", "level", "within", "a", "body", "such", "as", "inside", "a", "program", "library", "or", "the", "body", "of", "a", "lambda", "it", "becomes", "a", "letrec", "NUMBER", "Hmm", "NUMBER", "I", "tried", "to", "reproduce", "this", "but", "I", "didn", "t", "see", "the", "error", "you", "encountered", "NUMBER", "I", "might", "expect", "something", "like", "that", "if", "you", "were", "run", "out", "of", "space", "had", "some", "disk", "issue", "or", "had", "some", "memory", "issue", "NUMBER", "Here", "s", "what", "I", "did", "to", "try", "to", "reproduce", "NUMBER", "Installed", "vagrant", "machine", "for", "Linux", "Mint", "NUMBER", "vagrant", "fjp", "mint", "NUMBER", "vagrant", "init", "vagrant", "fjp", "mint", "NUMBER", "vagrant", "up", "vagrant", "ssh", "NUMBER", "Install", "the", "dependencies", "on", "Mint", "that", "I", "needed", "I", "ve", "gathered", "them", "up", "here", "I", "discover", "them", "experimentally", "sudo", "apt", "install", "git", "build", "essential", "libncurses", "dev", "libx", "NUMBER", "dev", "NUMBER", "Get", "Chez", "Scheme", "via", "git", "git", "clone", "LINK", "cs", "NUMBER", "Configure", "and", "build", "cd", "cs", "NUMBER", "configure", "make", "NUMBER", "Run", "the", "test", "with", "output", "to", "Make", "NUMBER", "out", "use", "bash", "make", "test", "Make", "NUMBER", "out", "NUMBER", "Check", "the", "mats", "output", "cat", "a", "NUMBER", "le", "mats", "summary", "o", "NUMBER", "o", "NUMBER", "o", "NUMBER", "cp", "NUMBER", "t", "cl", "NUMBER", "o", "NUMBER", "cp", "NUMBER", "t", "cl", "NUMBER", "o", "NUMBER", "spi", "t", "p", "t", "o", "NUMBER", "spi", "t", "p", "t", "o", "NUMBER", "eval", "interpret", "cl", "NUMBER", "o", "NUMBER", "eval", "interpret", "cl", "NUMBER", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "o", "NUMBER", "ehc", "t", "eoc", "f", "cl", "NUMBER", "o", "NUMBER", "ehc", "t", "eval", "interpret", "Just", "for", "the", "record", "here", "be", "what", "uname", "and", "gcc", "information", "uname", "a", "Linux", "vagrant", "VirtualBox", "NUMBER", "NUMBER", "generic", "NUMBER", "NUMBER", "Ubuntu", "SMP", "Tue", "May", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "UTC", "NUMBER", "x", "NUMBER", "_", "NUMBER", "x", "NUMBER", "_", "NUMBER", "x", "NUMBER", "_", "NUMBER", "GNU", "Linux", "gcc", "version", "gcc", "Ubuntu", "NUMBER", "NUMBER", "ubuntu", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Copyright", "C", "NUMBER", "Free", "Software", "Foundation", "Inc", "NUMBER", "This", "be", "free", "software", "see", "the", "source", "for", "copying", "conditions", "NUMBER", "There", "be", "NO", "warranty", "not", "even", "for", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "NUMBER", "Thanks", "for", "the", "fix", "the", "previous", "description", "was", "a", "bit", "confusing", "Hmm", "NUMBER", "I", "cannot", "reproduce", "the", "error", "you", "be", "seeing", "NUMBER", "I", "downloaded", "json", "NUMBER", "sc", "source", "the", "exemple", "NUMBER", "sc", "source", "put", "the", "json", "NUMBER", "sc", "file", "in", "the", "json", "directory", "and", "then", "did", "the", "following", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "library", "extensions", "cons", "cons", "NUMBER", "sc", "NUMBER", "so", "library", "extensions", "import", "json", "json", "load", "exemple", "NUMBER", "sc", "y", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "json", "reduce", "y", "t", "t", "t", "t", "lambda", "x", "y", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "I", "even", "tried", "add", "an", "extra", "t", "json", "reduce", "y", "t", "t", "t", "t", "t", "lambda", "x", "y", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "You", "might", "try", "expanding", "the", "macro", "to", "see", "if", "the", "code", "you", "be", "generating", "be", "the", "same", "as", "what", "you", "expected", "NUMBER", "Ugh", "NUMBER", "That", "be", "what", "I", "get", "for", "trying", "to", "do", "more", "than", "one", "thing", "at", "once", "NUMBER", "Sorry", "NUMBER", "So", "the", "failure", "happens", "because", "one", "of", "the", "lambda", "expressions", "generate", "by", "the", "macro", "be", "call", "with", "a", "single", "argument", "I", "change", "my", "copy", "of", "json", "NUMBER", "sc", "to", "export", "reduce", "and", "not", "json", "reduce", "so", "that", "I", "could", "run", "this", "on", "the", "command", "line", "scheme", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "library", "extensions", "cons", "cons", "NUMBER", "sc", "NUMBER", "so", "library", "extensions", "import", "json", "Exception", "library", "json", "not", "find", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "import", "json", "json", "load", "json", "exemple", "NUMBER", "sc", "define", "syntax", "json", "reduce", "lambda", "x", "syntax", "case", "x", "_", "j", "v", "NUMBER", "p", "reduce", "j", "v", "NUMBER", "p", "_", "j", "v", "NUMBER", "v", "NUMBER", "p", "json", "reduce", "j", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "_", "j", "v", "NUMBER", "v", "NUMBER", "v", "NUMBER", "p", "NUMBER", "json", "reduce", "j", "v", "NUMBER", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "NUMBER", "json", "reduce", "y", "t", "t", "t", "t", "lambda", "x", "y", "x", "Exception", "incorrect", "number", "of", "argument", "to", "TAG", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "Now", "we", "can", "look", "at", "this", "in", "the", "debugger", "scheme", "debug", "debug", "i", "TAG", "s", "continuation", "TAG", "procedure", "code", "lambda", "x", "v", "p", "if", "null", "x", "quote", "NUMBER", "call", "code", "v", "caar", "x", "frame", "and", "free", "variables", "NUMBER", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "v", "TAG", "NUMBER", "p", "TAG", "TAG", "file", "line", "NUMBER", "character", "NUMBER", "of", "json", "json", "NUMBER", "sc", "TAG", "So", "looks", "like", "line", "NUMBER", "character", "NUMBER", "of", "my", "modify", "one", "line", "longer", "at", "the", "start", "with", "the", "reduce", "export", "at", "the", "start", "NUMBER", "procedure", "v", "NUMBER", "let", "l", "x", "x", "v", "v", "p", "p", "NUMBER", "if", "null", "x", "NUMBER", "NUMBER", "if", "v", "caar", "x", "TAG", "print", "gensym", "pretty", "expand", "json", "reduce", "y", "t", "t", "t", "t", "lambda", "x", "y", "x", "begin", "NUMBER", "invoke", "library", "json", "json", "json", "reduce", "y", "t", "lambda", "x", "y", "reduce", "y", "t", "lambda", "n", "m", "let", "x", "NUMBER", "cons", "n", "x", "y", "m", "reduce", "TAG", "trace", "define", "syntax", "json", "reduce", "lambda", "x", "syntax", "case", "x", "_", "j", "v", "NUMBER", "p", "reduce", "j", "v", "NUMBER", "p", "_", "j", "v", "NUMBER", "v", "NUMBER", "p", "json", "reduce", "j", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "_", "j", "v", "NUMBER", "v", "NUMBER", "v", "NUMBER", "p", "NUMBER", "json", "reduce", "j", "v", "NUMBER", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "NUMBER", "expand", "json", "reduce", "y", "t", "t", "t", "t", "lambda", "x", "y", "x", "json", "reduce", "json", "reduce", "y", "t", "t", "t", "t", "lambda", "x", "y", "x", "json", "reduce", "y", "t", "t", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "Just", "to", "interject", "it", "looks", "like", "things", "be", "already", "starting", "to", "go", "wrong", "here", "because", "json", "reduce", "matched", "y", "j", "v", "NUMBER", "t", "v", "NUMBER", "t", "v", "NUMBER", "t", "p", "NUMBER", "t", "lambda", "x", "y", "x", "Let", "s", "keep", "going", "scheme", "json", "reduce", "json", "reduce", "y", "t", "t", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "json", "reduce", "y", "t", "t", "lambda", "x", "y", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "json", "reduce", "json", "reduce", "y", "t", "t", "lambda", "x", "y", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "Now", "we", "have", "our", "json", "reduce", "with", "the", "y", "lambda", "x", "y", "lambda", "n", "m", "argument", "produced", "and", "well", "it", "just", "goes", "on", "from", "there", "scheme", "json", "reduce", "y", "t", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "cons", "n", "x", "m", "json", "reduce", "json", "reduce", "y", "t", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "cons", "n", "x", "m", "reduce", "y", "t", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "cons", "n", "x", "m", "json", "reduce", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "cons", "n", "x", "m", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "cons", "n", "x", "m", "json", "reduce", "json", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "reduce", "y", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "lambda", "n", "m", "lambda", "x", "y", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "cons", "n", "x", "m", "json", "reduce", "json", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "reduce", "y", "t", "lambda", "n", "m", "lambda", "x", "y", "x", "cons", "n", "x", "m", "json", "reduce", "json", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "reduce", "y", "t", "lambda", "n", "m", "t", "cons", "n", "x", "m", "begin", "NUMBER", "invoke", "library", "json", "json", "json", "reduce", "y", "t", "lambda", "x", "y", "reduce", "y", "t", "lambda", "n", "m", "let", "x", "NUMBER", "cons", "n", "x", "y", "m", "reduce", "y", "lambda", "x", "y", "reduce", "y", "t", "lambda", "n", "m", "t", "NUMBER", "cons", "n", "x", "m", "lambda", "n", "m", "let", "x", "NUMBER", "cons", "n", "x", "y", "m", "reduce", "y", "t", "lambda", "n", "m", "let", "x", "NUMBER", "cons", "n", "x", "y", "m", "x", "All", "of", "that", "said", "the", "last", "clause", "in", "the", "define", "syntax", "be", "where", "things", "go", "wrong", "NUMBER", "I", "think", "maybe", "instead", "of", "matching", "_", "j", "v", "NUMBER", "v", "NUMBER", "v", "NUMBER", "p", "NUMBER", "you", "might", "want", "to", "match", "_", "j", "v", "NUMBER", "v", "NUMBER", "v", "NUMBER", "NUMBER", "p", "that", "way", "you", "get", "p", "bound", "to", "your", "lambda", "expression", "and", "v", "NUMBER", "NUMBER", "bound", "to", "any", "additional", "items", "NUMBER", "You", "ll", "also", "need", "to", "change", "the", "body", "of", "that", "clause", "to", "use", "v", "NUMBER", "NUMBER", "instead", "of", "p", "NUMBER", "scheme", "define", "syntax", "json", "reduce", "lambda", "x", "syntax", "case", "x", "_", "j", "v", "NUMBER", "p", "reduce", "j", "v", "NUMBER", "p", "_", "j", "v", "NUMBER", "v", "NUMBER", "p", "json", "reduce", "j", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "_", "j", "v", "NUMBER", "v", "NUMBER", "v", "NUMBER", "NUMBER", "p", "json", "reduce", "j", "v", "NUMBER", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "This", "seems", "to", "work", "much", "better", "scheme", "json", "reduce", "y", "t", "t", "t", "t", "lambda", "x", "y", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Of", "course", "if", "you", "really", "want", "to", "be", "concise", "you", "can", "do", "this", "in", "two", "clauses", "and", "avoid", "expanding", "into", "json", "reduce", "in", "the", "outer", "most", "part", "of", "the", "recursive", "step", "NUMBER", "Commit", "LINK", "should", "fix", "this", "NUMBER", "Please", "re", "open", "this", "issue", "if", "it", "do", "not", "NUMBER", "ye", "Zhiqiu", "Unfortunately", "GMP", "s", "license", "be", "incompatible", "with", "Chez", "Scheme", "s", "license", "NUMBER", "As", "dybvig", "mention", "in", "Issue", "NUMBER", "Using", "gmp", "would", "indeed", "speed", "up", "program", "that", "operate", "on", "large", "numbers", "particularly", "program", "that", "multiply", "and", "divide", "very", "large", "numbers", "NUMBER", "Licensing", "be", "the", "primary", "issue", "blocking", "us", "from", "use", "it", "NUMBER", "Another", "be", "that", "our", "own", "different", "representation", "of", "bignums", "be", "baked", "into", "the", "compiler", "and", "run", "time", "system", "in", "a", "couple", "of", "ways", "NUMBER", "We", "be", "open", "to", "alternative", "suggestions", "I", "know", "there", "was", "a", "group", "involved", "in", "Issue", "NUMBER", "that", "was", "starting", "to", "look", "into", "this", "but", "I", "ve", "not", "heard", "if", "they", "ve", "come", "to", "any", "conclusions", "NUMBER", "Again", "from", "NUMBER", "if", "I", "may", "quote", "myself", "As", "we", "think", "about", "trying", "to", "improve", "the", "bignum", "implementation", "in", "Chez", "it", "might", "be", "interesting", "to", "take", "a", "look", "at", "the", "Glasgow", "Haskell", "Compiler", "GHC", "work", "around", "the", "same", "issue", "LINK", "They", "start", "from", "a", "different", "point", "in", "that", "GHC", "had", "be", "use", "the", "GNU", "MP", "but", "there", "were", "uses", "of", "GHC", "for", "whom", "the", "LGPL", "licensing", "of", "GNU", "MP", "was", "problematic", "see", "LINK", "NUMBER", "They", "experimented", "with", "a", "number", "of", "other", "fast", "arbitrary", "precision", "libraries", "with", "more", "permissive", "licenses", "as", "well", "as", "creating", "a", "fast", "enough", "implementation", "in", "Haskell", "NUMBER", "One", "or", "more", "of", "these", "more", "permissively", "licensed", "libraries", "might", "be", "an", "interesting", "option", "for", "improving", "Chez", "s", "bignum", "performance", "NUMBER", "As", "of", "NUMBER", "years", "ago", "when", "the", "GHC", "community", "went", "through", "this", "exercise", "there", "were", "quite", "a", "few", "interesting", "trade", "offs", "in", "performance", "given", "the", "libraries", "available", "at", "the", "time", "NUMBER", "I", "find", "an", "additional", "library", "bigz", "LINK", "listed", "on", "the", "wikipedia", "arbitrary", "precision", "page", "LINK", "_of_arbitrary", "precision_arithmetic_software", "NUMBER", "Since", "it", "has", "be", "NUMBER", "years", "since", "the", "GHC", "community", "did", "these", "experiments", "it", "be", "probably", "worth", "evaluating", "the", "options", "again", "NUMBER", "I", "would", "recommend", "comparing", "some", "of", "the", "available", "options", "would", "be", "a", "good", "starting", "point", "to", "choosing", "a", "new", "bignum", "implementation", "NUMBER", "bsdnt", "LINK", "be", "a", "fine", "place", "to", "start", "NUMBER", "I", "would", "note", "that", "LibBF", "LINK", "be", "a", "library", "for", "arbitrary", "precision", "floating", "point", "numbers", "so", "it", "be", "not", "appropriate", "for", "the", "bignum", "implementation", "which", "be", "for", "integers", "NUMBER", "Chez", "Scheme", "do", "not", "currently", "have", "arbitrary", "precision", "floating", "point", "support", "NUMBER", "yezhiqiu", "NUMBER", "No", "worries", "you", "be", "right", "that", "Chez", "Scheme", "be", "not", "as", "fast", "as", "it", "could", "be", "at", "bignum", "math", "NUMBER", "The", "bignum", "support", "be", "pretty", "baked", "in", "though", "so", "we", "wouldn", "t", "be", "able", "to", "get", "around", "the", "requirements", "of", "LGPL", "s", "licensing", "if", "we", "use", "it", "NUMBER", "As", "nosefouratyou", "noted", "there", "be", "some", "more", "liberally", "licensed", "alternatives", "that", "might", "be", "good", "alternatives", "to", "our", "current", "implementation", "NUMBER", "It", "looks", "like", "the", "group", "that", "had", "be", "taking", "a", "look", "at", "this", "in", "NUMBER", "did", "not", "get", "to", "a", "place", "where", "they", "had", "something", "they", "wanted", "to", "share", "NUMBER", "Hopefully", "I", "ll", "get", "a", "little", "free", "time", "to", "look", "at", "some", "of", "this", "stuff", "at", "some", "point", "NUMBER", "There", "be", "always", "things", "to", "improve", "in", "a", "compiler", "Thanks", "NUMBER", "I", "have", "update", "the", "sources", "and", "push", "new", "html", "pdf", "file", "to", "the", "project", "page", "NUMBER", "Thanks", "for", "the", "corrections", "ocyzl", "NUMBER", "I", "ve", "update", "the", "online", "version", "at", "LINK", "LINK", "and", "the", "errata", "at", "LINK", "errata", "NUMBER", "html", "LINK", "errata", "NUMBER", "html", "NUMBER", "If", "you", "d", "like", "the", "errata", "to", "acknowledge", "you", "by", "name", "rather", "than", "by", "github", "handle", "let", "me", "know", "NUMBER", "ecraven", "I", "do", "not", "have", "permission", "from", "MIT", "Press", "to", "put", "the", "sources", "online", "NUMBER", "I", "ve", "update", "TSPL", "and", "in", "the", "case", "of", "the", "standard", "input", "port", "entry", "CSUG", "and", "add", "errata", "entries", "for", "the", "tspl", "fix", "all", "but", "the", "Stra\u00dfe", "issue", "since", "that", "was", "an", "html", "format", "problem", "NUMBER", "Thanks", "for", "the", "corrections", "You", "should", "not", "run", "any", "Scheme", "code", "or", "touch", "any", "unlocked", "Scheme", "objects", "after", "deactivating", "and", "before", "reactivating", "NUMBER", "If", "I", "understand", "the", "propose", "solution", "it", "would", "require", "calling", "Sdeactivate_thread", "and", "returning", "to", "Scheme", "to", "call", "the", "blocking", "foreign", "procedure", "which", "would", "violate", "this", "restriction", "NUMBER", "I", "believe", "pull", "request", "NUMBER", "be", "intended", "to", "address", "this", "issue", "NUMBER", "I", "m", "not", "sure", "from", "your", "example", "what", "the", "problem", "you", "be", "run", "into", "be", "NUMBER", "I", "created", "a", "library", "t", "NUMBER", "c", "based", "on", "the", "test", "code", "in", "your", "example", "c", "typedef", "char", "res", "char", "request_header", "char", "path_info", "char", "payload", "res", "res_get", "int", "handle_request", "res", "response_get", "res_get", "response_get", "return", "NUMBER", "char", "call_request", "char", "request_header", "char", "path_info", "char", "query_string", "return", "res_get", "request_header", "path_info", "query_string", "Then", "I", "compiled", "it", "on", "macOS", "gcc", "dynamiclib", "o", "t", "NUMBER", "dylib", "t", "NUMBER", "c", "And", "finally", "I", "loaded", "it", "and", "call", "it", "from", "the", "Chez", "Scheme", "repl", "again", "based", "on", "your", "example", "though", "I", "didn", "t", "see", "the", "handle_request", "definition", "in", "the", "email", "I", "get", "from", "GitHub", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "load", "shared", "object", "NUMBER", "t", "NUMBER", "dylib", "define", "res", "lambda", "f", "let", "code", "foreign", "callable", "f", "string", "string", "string", "string", "lock", "object", "code", "foreign", "callable", "entry", "point", "code", "define", "handle", "request", "foreign", "procedure", "handle_request", "void", "int", "define", "call", "request", "foreign", "procedure", "call_request", "string", "string", "string", "string", "define", "foo", "lambda", "a", "b", "c", "string", "append", "c", "b", "a", "handle", "request", "res", "foo", "NUMBER", "call", "request", "this", "be", "test", "test", "be", "this", "So", "maybe", "the", "example", "will", "be", "helpful", "NUMBER", "andy", "I", "m", "not", "sure", "I", "understand", "exactly", "what", "code", "be", "leading", "to", "the", "problem", "NUMBER", "Maybe", "you", "could", "post", "a", "more", "complete", "example", "with", "the", "igropyr", "code", "Or", "if", "it", "be", "too", "long", "you", "could", "put", "a", "snippet", "of", "the", "httpc", "NUMBER", "c", "change", "that", "causes", "the", "error", "to", "occur", "Hmm", "NUMBER", "I", "tried", "to", "reproduce", "this", "but", "I", "wasn", "t", "able", "to", "NUMBER", "I", "ve", "occasionally", "seen", "something", "like", "this", "if", "I", "had", "build", "a", "different", "version", "first", "though", "I", "ve", "had", "trouble", "reproducing", "it", "even", "when", "I", "ve", "had", "it", "happen", "to", "me", "NUMBER", "Thanks", "NUMBER", "I", "have", "update", "the", "current", "CSUG", "sources", "and", "push", "new", "html", "pdf", "file", "to", "the", "project", "page", "NUMBER", "FYI", "I", "use", "void", "rather", "than", "iptr", "in", "the", "foreign", "procedure", "declaration", "and", "left", "out", "the", "CB", "cast", "NUMBER", "I", "think", "this", "be", "a", "good", "change", "since", "map", "and", "for", "each", "should", "check", "to", "make", "sure", "the", "first", "argument", "be", "a", "procedure", "except", "at", "optimize", "level", "NUMBER", "A", "couple", "of", "note", "you", "can", "use", "void", "rec", "instead", "of", "build", "a", "call", "to", "void", "not", "eq", "ctxt", "effect", "should", "be", "not", "eq", "app", "ctxt", "ctxt", "effect", "I", "see", "the", "latter", "was", "a", "preexisting", "issue", "NUMBER", "This", "looks", "good", "and", "good", "catch", "on", "lines", "NUMBER", "and", "NUMBER", "Please", "add", "a", "couple", "of", "error", "mats", "for", "each", "of", "map", "and", "for", "each", "with", "one", "and", "more", "than", "one", "empty", "list", "argument", "so", "someone", "who", "attempts", "to", "add", "back", "the", "special", "case", "in", "cp", "NUMBER", "or", "elsewhere", "will", "see", "that", "it", "be", "not", "appropriate", "NUMBER", "Plus", "please", "mention", "NUMBER", "for", "each", "as", "well", "as", "NUMBER", "map", "in", "the", "LOG", "entry", "NUMBER", "It", "s", "analogous", "though", "not", "quite", "the", "same", "NUMBER", "In", "this", "case", "there", "s", "no", "safe", "place", "for", "the", "user", "program", "to", "lock", "the", "temporary", "bytevector", "NUMBER", "The", "Scheme", "caller", "can", "t", "lock", "it", "since", "it", "doesn", "t", "have", "access", "to", "it", "and", "the", "C", "callee", "can", "t", "lock", "it", "since", "it", "doesn", "t", "get", "control", "until", "after", "the", "thread", "be", "deactivated", "NUMBER", "So", "the", "implementation", "should", "either", "reject", "string", "argument", "when", "__thread", "be", "use", "or", "lock", "the", "temporary", "bytevector", "regardless", "of", "whether", "we", "extend", "automatic", "though", "possibly", "optional", "locking", "to", "all", "argument", "that", "need", "to", "be", "locked", "NUMBER", "I", "think", "the", "__thread", "convention", "be", "a", "great", "idea", "by", "the", "way", "NUMBER", "mflatt", "I", "ve", "had", "a", "chance", "to", "look", "through", "the", "code", "a", "bit", "and", "for", "the", "most", "part", "I", "think", "it", "looks", "good", "but", "there", "be", "few", "small", "things", "I", "think", "we", "should", "fix", "NUMBER", "I", "run", "the", "mats", "for", "ti", "NUMBER", "osx", "ta", "NUMBER", "osx", "a", "NUMBER", "osx", "and", "i", "NUMBER", "osx", "NUMBER", "I", "notice", "a", "couple", "of", "things", "in", "the", "test", "you", "add", "with", "the", "non", "threaded", "version", "of", "the", "mats", "NUMBER", "The", "add", "error", "producing", "test", "at", "the", "start", "of", "the", "collect", "safe", "mat", "in", "foriegn", "NUMBER", "ms", "do", "not", "raise", "an", "exception", "because", "the", "__collect_safe", "convention", "be", "be", "discarded", "before", "we", "check", "the", "argument", "NUMBER", "Even", "though", "the", "__collect_safe", "convention", "doesn", "t", "have", "any", "effect", "I", "think", "we", "should", "consider", "having", "it", "raise", "the", "same", "error", "in", "both", "threaded", "and", "non", "threaded", "version", "NUMBER", "I", "also", "notice", "in", "run", "the", "mats", "that", "the", "checking", "be", "do", "after", "the", "original", "types", "have", "be", "filter", "and", "this", "leads", "to", "a", "bit", "of", "a", "confusing", "error", "message", "when", "string", "or", "wstring", "types", "be", "use", "NUMBER", "For", "example", "foreign", "procedure", "__collect_safe", "unknown", "string", "void", "produces", "Exception", "in", "foreign", "procedure", "utf", "NUMBER", "argument", "not", "allow", "with", "__collect_safe", "procedure", "instead", "of", "Exception", "in", "foreign", "procedure", "string", "argument", "not", "allow", "with", "__collect_safe", "procedure", "It", "might", "be", "nice", "to", "do", "this", "checking", "before", "the", "filtering", "be", "do", "or", "pass", "make", "foreign", "callable", "and", "make", "foreign", "procedure", "the", "mapping", "between", "the", "original", "and", "filtered", "types", "so", "it", "can", "use", "th", "original", "type", "when", "it", "raises", "error", "NUMBER", "On", "the", "language", "side", "I", "notice", "you", "change", "convention", "in", "base", "langs", "NUMBER", "ss", "instead", "of", "change", "the", "Lsrc", "language", "NUMBER", "I", "d", "recommend", "change", "the", "Expr", "s", "foreign", "conv", "name", "e", "arg", "type", "NUMBER", "result", "type", "fcallable", "conv", "e", "arg", "type", "NUMBER", "result", "type", "to", "foreign", "conv", "NUMBER", "name", "e", "arg", "type", "NUMBER", "result", "type", "fcallable", "conv", "NUMBER", "e", "arg", "type", "NUMBER", "result", "type", "Admittedly", "this", "be", "a", "bit", "of", "a", "pain", "and", "you", "ll", "need", "to", "bump", "Lsrc", "s", "nongenerative", "id", "NUMBER", "I", "run", "through", "the", "exercise", "myself", "to", "see", "how", "bad", "the", "change", "was", "and", "it", "do", "require", "going", "through", "syntax", "NUMBER", "ss", "cpnanopass", "NUMBER", "ss", "cpcommonize", "NUMBER", "ss", "base", "lang", "NUMBER", "ss", "cp", "NUMBER", "ss", "cpcheck", "NUMBER", "ss", "cpvalid", "NUMBER", "ss", "interpret", "NUMBER", "ss", "cpletrec", "NUMBER", "ss", "and", "cprep", "NUMBER", "ss", "NUMBER", "The", "change", "be", "pretty", "small", "and", "be", "caught", "by", "during", "compilation", "so", "it", "was", "a", "pretty", "straightforward", "change", "NUMBER", "The", "exercise", "proved", "to", "be", "worth", "it", "for", "me", "at", "least", "because", "I", "find", "a", "place", "in", "cpcommonize", "NUMBER", "ss", "where", "we", "were", "doing", "an", "eq", "comparison", "on", "the", "conventions", "which", "now", "needs", "to", "be", "equal", "NUMBER", "I", "see", "you", "also", "caught", "a", "spurious", "convention", "definition", "in", "np", "languages", "NUMBER", "ss", "that", "be", "not", "use", "anywhere", "we", "should", "probably", "remove", "that", "while", "we", "re", "make", "these", "change", "NUMBER", "I", "notice", "you", "ve", "also", "update", "the", "documentation", "thanks", "and", "I", "ve", "get", "a", "couple", "of", "comments", "here", "too", "NUMBER", "We", "might", "want", "to", "call", "out", "the", "usefulness", "of", "__collect_safe", "for", "blocking", "I", "O", "calls", "since", "before", "you", "add", "this", "we", "didn", "t", "have", "a", "good", "story", "around", "that", "short", "of", "wrapping", "the", "C", "calls", "in", "a", "C", "function", "that", "deactivated", "and", "reactivated", "NUMBER", "NUMBER", "I", "think", "we", "should", "consider", "listing", "out", "the", "types", "that", "be", "not", "allow", "instead", "of", "saying", "NUMBER", "utf", "NUMBER", "through", "utf", "NUMBER", "be", "for", "consistency", "in", "other", "places", "where", "we", "refer", "to", "lists", "of", "types", "in", "the", "prose", "NUMBER", "NUMBER", "I", "wasn", "t", "sure", "wha", "was", "meant", "by", "Parameter", "types", "other", "than", "scheme", "object", "through", "utf", "NUMBER", "be", "be", "converted", "to", "equivalent", "foreign", "representations", "and", "consequently", "they", "can", "be", "retained", "indefinitely", "in", "foreign", "variables", "NUMBER", "it", "seems", "like", "utf", "NUMBER", "be", "be", "not", "something", "that", "can", "be", "retained", "indefinitely", "did", "you", "mean", "u", "NUMBER", "In", "this", "context", "I", "m", "also", "wondering", "if", "we", "should", "be", "talking", "about", "what", "types", "need", "to", "be", "locked", "when", "use", "__collect_safe", "for", "instance", "scheme", "object", "u", "NUMBER", "u", "NUMBER", "etc", "NUMBER", "need", "to", "be", "locked", "while", "fixnum", "integer", "NUMBER", "integer", "NUMBER", "etc", "NUMBER", "do", "not", "need", "to", "be", "locked", "NUMBER", "Finally", "I", "took", "a", "look", "through", "the", "x", "NUMBER", "_", "NUMBER", "ss", "version", "of", "the", "assembler", "change", "to", "support", "this", "and", "things", "there", "look", "okay", "to", "me", "though", "I", "m", "admittedly", "a", "little", "less", "fresh", "on", "this", "code", "than", "dybvig", "be", "NUMBER", "Thanks", "again", "for", "the", "pull", "request", "Also", "I", "like", "__collect_safe", "better", "than", "__thread_safe", "for", "the", "foreign", "procedure", "I", "think", "it", "be", "a", "bit", "more", "descriptive", "NUMBER", "mflatt", "No", "problem", "NUMBER", "I", "ve", "push", "my", "change", "on", "a", "branch", "at", "pr", "NUMBER", "LINK", "with", "those", "change", "NUMBER", "Thanks", "for", "the", "change", "mflatt", "I", "ve", "gone", "ahead", "and", "rebuilt", "the", "boot", "file", "and", "merge", "your", "change", "This", "be", "somewhat", "philosophical", "in", "that", "Chez", "Scheme", "seeks", "to", "provide", "the", "tool", "for", "build", "things", "like", "a", "network", "programming", "library", "not", "to", "be", "a", "programming", "environment", "that", "include", "everything", "plus", "the", "kitchen", "sink", "NUMBER", "The", "foreign", "function", "interface", "provides", "the", "tool", "needed", "to", "write", "a", "network", "programming", "library", "and", "there", "be", "an", "example", "of", "use", "it", "to", "do", "socket", "programming", "in", "the", "examples", "directory", "see", "socket", "NUMBER", "ss", "LINK", "and", "csocket", "NUMBER", "c", "LINK", "in", "the", "example", "LINK", "directory", "NUMBER", "There", "be", "also", "libraries", "that", "have", "already", "be", "write", "for", "this", "including", "arcfide", "s", "chez", "sockets", "LINK", "sockets", "library", "evilbinary", "s", "scheme", "lib", "LINK", "lib", "that", "support", "a", "wide", "variety", "of", "FFI", "based", "features", "and", "becls", "swish", "win", "LINK", "win", "and", "swish", "LINK", "which", "provide", "a", "framework", "for", "write", "Scheme", "program", "with", "Erlang", "style", "concurrency", "and", "support", "network", "programming", "amongst", "other", "things", "for", "Windows", "or", "nix", "operate", "systems", "NUMBER", "It", "be", "worth", "noting", "that", "the", "scheme", "and", "petite", "be", "actually", "the", "same", "binary", "and", "both", "do", "roughly", "the", "same", "thing", "at", "startup", "NUMBER", "When", "you", "start", "scheme", "or", "petite", "after", "looking", "through", "the", "command", "line", "argument", "and", "determining", "where", "the", "boot", "file", "s", "be", "it", "loads", "the", "boot", "file", "s", "then", "runs", "a", "maximum", "generation", "collection", "into", "the", "static", "generation", "since", "the", "core", "library", "be", "not", "touched", "during", "normal", "garbage", "collection", "NUMBER", "Loading", "the", "boot", "file", "consists", "of", "uncompressing", "reading", "the", "fasl", "format", "binary", "and", "executing", "the", "expressions", "in", "the", "boot", "file", "which", "set", "up", "the", "top", "level", "environment", "that", "Chez", "Scheme", "program", "including", "the", "REPL", "execute", "from", "NUMBER", "In", "the", "case", "of", "scheme", "this", "loads", "both", "the", "petite", "NUMBER", "boot", "which", "contains", "the", "core", "library", "and", "interpreter", "and", "scheme", "NUMBER", "boot", "which", "contains", "the", "compiler", "NUMBER", "In", "the", "case", "of", "petite", "it", "only", "loads", "petite", "NUMBER", "boot", "and", "this", "do", "load", "faster", "since", "it", "both", "executes", "less", "code", "and", "requires", "less", "time", "to", "collect", "since", "there", "be", "less", "in", "the", "Scheme", "heap", "when", "it", "be", "call", "NUMBER", "So", "that", "be", "what", "it", "be", "doing", "during", "that", "first", "NUMBER", "s", "to", "NUMBER", "s", "NUMBER", "Could", "it", "be", "faster", "Possibly", "NUMBER", "We", "could", "break", "the", "boot", "file", "into", "smaller", "pieces", "NUMBER", "For", "instance", "the", "petite", "NUMBER", "boot", "file", "contains", "things", "like", "the", "expression", "editor", "code", "and", "the", "interpreter", "which", "you", "do", "not", "need", "if", "you", "be", "just", "executing", "a", "pre", "compiled", "Scheme", "program", "and", "not", "use", "the", "REPL", "or", "eval", "NUMBER", "We", "have", "talked", "in", "the", "past", "about", "breaking", "this", "down", "into", "smaller", "piece", "so", "that", "for", "instance", "if", "you", "be", "run", "a", "small", "script", "it", "could", "be", "run", "against", "a", "minuscule", "Scheme", "session", "that", "doesn", "t", "bother", "loading", "the", "expression", "editor", "or", "maybe", "even", "the", "interpreter", "NUMBER", "All", "of", "that", "said", "for", "me", "petite", "loads", "in", "NUMBER", "s", "on", "my", "Mac", "compared", "with", "NUMBER", "s", "for", "full", "Chez", "Scheme", "so", "I", "d", "probably", "start", "by", "having", "any", "script", "I", "wanted", "to", "run", "fast", "pre", "compiled", "and", "use", "petite", "as", "the", "session", "entry", "point", "NUMBER", "It", "be", "not", "really", "possible", "to", "evaluate", "arbitrary", "expressions", "within", "the", "environment", "of", "a", "library", "NUMBER", "That", "be", "because", "once", "the", "library", "be", "loaded", "its", "environment", "can", "no", "longer", "be", "change", "so", "there", "be", "not", "really", "anyway", "to", "execute", "code", "within", "that", "environment", "NUMBER", "You", "ll", "need", "to", "export", "any", "identifier", "you", "want", "to", "use", "though", "it", "be", "worth", "noting", "that", "Chez", "Scheme", "include", "a", "local", "export", "form", "so", "you", "can", "write", "version", "of", "define", "define", "syntax", "etc", "NUMBER", "that", "export", "the", "identifiers", "defined", "by", "these", "form", "NUMBER", "Another", "alternative", "though", "it", "will", "slightly", "change", "how", "things", "be", "evaluated", "be", "to", "comment", "out", "the", "library", "form", "around", "your", "expressions", "and", "load", "this", "file", "as", "a", "script", "use", "load", "NUMBER", "This", "simply", "dumps", "the", "identifiers", "into", "the", "top", "level", "environment", "use", "by", "the", "REPL", "NUMBER", "This", "will", "not", "benefit", "from", "some", "of", "the", "checking", "that", "the", "library", "form", "causes", "like", "ensuring", "that", "identifiers", "be", "bound", "NUMBER", "So", "use", "that", "approach", "with", "caution", "NUMBER", "The", "cyclic", "dependency", "problem", "you", "be", "seeing", "be", "very", "likely", "because", "there", "was", "an", "error", "that", "occur", "when", "the", "run", "time", "code", "of", "the", "library", "was", "invoked", "NUMBER", "Import", "cannot", "correct", "this", "because", "import", "sees", "that", "the", "library", "be", "already", "loaded", "into", "the", "system", "and", "assumes", "things", "be", "good", "to", "go", "NUMBER", "You", "can", "force", "a", "library", "to", "be", "re", "loaded", "by", "use", "load", "library", "first", "and", "then", "use", "import", "to", "import", "the", "newly", "loaded", "library", "NUMBER", "For", "instance", "say", "we", "have", "the", "following", "library", "scheme", "library", "test", "export", "foo", "import", "chezscheme", "define", "foo", "lambda", "x", "x", "NUMBER", "errorf", "test", "fail", "somewhere", "along", "the", "way", "Note", "that", "this", "library", "can", "be", "imported", "but", "when", "the", "run", "time", "code", "be", "invoked", "it", "raises", "an", "error", "with", "the", "message", "fail", "somewhere", "along", "the", "way", "before", "it", "be", "able", "to", "finish", "the", "invocation", "NUMBER", "This", "runs", "afoul", "of", "Chez", "s", "cyclic", "library", "checking", "which", "replaces", "the", "thunk", "representing", "the", "run", "time", "code", "with", "a", "flag", "to", "indicate", "it", "be", "currently", "be", "invoked", "and", "when", "something", "causes", "it", "to", "attempt", "to", "invoke", "this", "code", "again", "the", "flag", "be", "still", "set", "resulting", "in", "the", "error", "scheme", "libdirs", "tmp", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "import", "test", "foo", "NUMBER", "Exception", "in", "test", "fail", "somewhere", "along", "the", "way", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "Note", "that", "we", "do", "not", "attempt", "to", "invoke", "the", "run", "time", "code", "until", "the", "identifier", "foo", "from", "the", "library", "be", "referenced", "so", "we", "do", "not", "see", "the", "error", "until", "then", "NUMBER", "Now", "that", "the", "error", "has", "be", "raise", "interrupting", "the", "library", "invocation", "attempting", "to", "reference", "foo", "again", "will", "lead", "to", "the", "library", "be", "invoked", "again", "and", "we", "will", "see", "the", "cyclical", "load", "error", "NUMBER", "foo", "NUMBER", "Exception", "cyclic", "dependency", "involving", "invocation", "of", "library", "test", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "If", "we", "correct", "the", "library", "commenting", "out", "the", "in", "this", "case", "obvious", "error", "import", "will", "not", "help", "us", "because", "import", "sees", "this", "library", "as", "already", "loaded", "import", "test", "foo", "NUMBER", "Exception", "cyclic", "dependency", "involving", "invocation", "of", "library", "test", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "That", "said", "we", "can", "use", "load", "library", "to", "reload", "the", "library", "clearing", "the", "flag", "and", "re", "reading", "the", "library", "from", "the", "specified", "file", "load", "library", "tmp", "test", "NUMBER", "sls", "However", "this", "do", "not", "replace", "the", "old", "version", "of", "the", "libraries", "identifiers", "in", "the", "current", "REPL", "environment", "and", "if", "we", "try", "to", "invoke", "foo", "again", "it", "will", "tell", "us", "so", "foo", "NUMBER", "Exception", "compiled", "program", "requires", "different", "compilation", "instance", "of", "test", "from", "one", "already", "loaded", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "We", "can", "however", "re", "import", "the", "test", "library", "and", "the", "new", "version", "will", "be", "visible", "import", "test", "foo", "NUMBER", "NUMBER", "It", "be", "worth", "noting", "that", "load", "library", "will", "not", "clear", "libraries", "that", "depended", "on", "this", "library", "and", "those", "may", "still", "be", "executing", "against", "the", "old", "code", "NUMBER", "Chez", "Scheme", "do", "not", "support", "r", "NUMBER", "rs", "at", "this", "time", "and", "there", "be", "no", "define", "library", "in", "Chez", "NUMBER", "Perhaps", "what", "you", "saw", "be", "define", "library", "entry", "which", "be", "an", "internal", "macro", "use", "in", "the", "file", "library", "NUMBER", "ss", "for", "populating", "some", "metadata", "for", "core", "library", "routines", "NUMBER", "There", "be", "currently", "no", "plan", "to", "support", "R", "NUMBER", "RS", "NUMBER", "You", "could", "use", "the", "R", "NUMBER", "RS", "standard", "make", "custom", "binary", "input", "output", "port", "documented", "in", "Section", "NUMBER", "Opening", "Custom", "Ports", "LINK", "NUMBER", "io", "s", "NUMBER", "of", "The", "Scheme", "Programming", "Language", "NUMBER", "There", "be", "an", "example", "of", "its", "use", "in", "socket", "NUMBER", "ss", "in", "the", "Chez", "Scheme", "examples", "directory", "ChezScheme", "examples", "socket", "NUMBER", "ss", "LINK", "Actually", "as", "the", "comment", "above", "max", "put", "copy", "indicates", "the", "be", "the", "maximum", "amount", "a", "bytevector", "put", "operation", "will", "copy", "from", "the", "supplied", "bytevector", "to", "the", "port", "s", "buffer", "NUMBER", "This", "be", "use", "in", "the", "put", "some", "procedures", "NUMBER", "The", "parameter", "custom", "port", "buffer", "size", "controls", "the", "size", "of", "the", "buffer", "in", "custom", "ports", "NUMBER", "It", "looks", "like", "it", "defaults", "to", "NUMBER", "bytes", "but", "you", "could", "set", "it", "to", "whatever", "you", "like", "NUMBER", "I", "think", "the", "only", "limitation", "over", "what", "make", "input", "output", "port", "allows", "be", "that", "you", "cannot", "set", "a", "different", "size", "for", "the", "input", "and", "output", "buffers", "NUMBER", "Yes", "that", "part", "be", "a", "bummer", "NUMBER", "Unfortunately", "I", "think", "the", "R", "NUMBER", "RS", "ports", "be", "assumed", "to", "be", "synchronous", "NUMBER", "So", "the", "idea", "be", "that", "if", "you", "have", "something", "like", "a", "socket", "which", "might", "receive", "more", "data", "but", "there", "be", "currently", "no", "data", "available", "the", "read", "method", "would", "simply", "wait", "until", "more", "data", "was", "available", "or", "the", "socket", "be", "close", "NUMBER", "If", "you", "want", "to", "do", "asynchronous", "input", "of", "course", "you", "need", "a", "way", "to", "say", "there", "be", "no", "data", "available", "now", "but", "there", "might", "be", "later", "effectively", "EAGAIN", "from", "C", "s", "read", "procedure", "when", "it", "be", "set", "to", "be", "asynchronous", "NUMBER", "Have", "you", "considered", "use", "the", "open", "fd", "input", "output", "port", "NUMBER", "I", "ve", "use", "this", "with", "asynchronous", "pipes", "created", "with", "the", "unix", "pipe", "procedure", "as", "a", "foreign", "call", "by", "use", "the", "set", "port", "nonblocking", "procedure", "on", "the", "created", "fd", "port", "NUMBER", "Yes", "I", "agree", "we", "probably", "need", "to", "add", "something", "to", "support", "nonblocking", "custom", "binary", "ports", "better", "NUMBER", "I", "think", "we", "need", "to", "decide", "if", "the", "best", "way", "to", "handle", "this", "be", "to", "add", "a", "make", "binary", "input", "output", "port", "following", "the", "pre", "R", "NUMBER", "RS", "Chez", "Scheme", "make", "input", "output", "port", "or", "we", "extend", "the", "R", "NUMBER", "RS", "make", "custom", "binary", "input", "output", "port", "NUMBER", "I", "ll", "discuss", "this", "with", "other", "maintainers", "before", "I", "make", "any", "change", "but", "I", "think", "it", "be", "a", "worthwhile", "addition", "NUMBER", "Another", "approach", "to", "this", "be", "to", "use", "the", "foreign", "data", "facilities", "describe", "in", "Section", "NUMBER", "Foreign", "Data", "LINK", "NUMBER", "foreign", "h", "NUMBER", "of", "the", "Chez", "Scheme", "users", "guide", "NUMBER", "This", "be", "actually", "the", "standard", "way", "to", "communicate", "data", "back", "and", "forth", "with", "foreign", "procedures", "NUMBER", "Because", "allocation", "occur", "outside", "the", "Scheme", "heap", "you", "no", "longer", "need", "to", "lock", "and", "unlock", "it", "though", "you", "be", "responsible", "for", "freeing", "it", "NUMBER", "One", "way", "to", "employ", "the", "garbage", "collector", "to", "help", "with", "that", "be", "to", "use", "an", "ftype", "pointer", "object", "to", "wrap", "the", "pointer", "and", "then", "put", "a", "guardian", "on", "the", "ftype", "pointer", "object", "and", "when", "the", "guardian", "indicates", "the", "ftype", "pointer", "object", "would", "be", "freed", "free", "the", "corresponding", "foreign", "data", "NUMBER", "The", "array", "you", "be", "allocating", "be", "effectively", "just", "a", "byte", "array", "and", "you", "can", "access", "it", "similar", "to", "the", "way", "you", "access", "the", "bytevector", "NUMBER", "The", "foreign", "ref", "and", "foreign", "set", "provide", "you", "the", "same", "sort", "of", "access", "you", "have", "with", "the", "various", "bytevector", "ref", "and", "set", "procedures", "NUMBER", "You", "could", "also", "copy", "the", "foreign", "data", "into", "a", "bytevector", "if", "that", "be", "what", "you", "wanted", "to", "do", "NUMBER", "Just", "to", "follow", "up", "on", "what", "jltaylor", "us", "mention", "there", "be", "a", "couple", "of", "challenges", "with", "having", "multiple", "version", "of", "the", "same", "library", "loaded", "NUMBER", "First", "different", "version", "of", "the", "same", "library", "might", "use", "different", "underlying", "representations", "for", "the", "data", "they", "operate", "on", "in", "fact", "different", "compilation", "instances", "of", "the", "same", "version", "of", "the", "library", "may", "also", "have", "this", "property", "NUMBER", "If", "the", "two", "libraries", "be", "completely", "isolated", "that", "might", "be", "okay", "however", "if", "data", "created", "by", "one", "version", "of", "the", "library", "can", "flow", "to", "the", "other", "version", "of", "the", "library", "the", "program", "will", "have", "unexpect", "error", "NUMBER", "Second", "a", "library", "might", "expect", "that", "its", "state", "be", "unique", "either", "because", "it", "connects", "to", "an", "external", "resource", "that", "it", "expects", "to", "have", "the", "only", "handle", "on", "or", "because", "it", "be", "maintaining", "internal", "state", "to", "ensure", "uniqueness", "of", "data", "produced", "by", "the", "library", "NUMBER", "In", "both", "cases", "loading", "multiple", "version", "of", "the", "library", "would", "result", "in", "multiple", "version", "of", "this", "state", "be", "loaded", "which", "also", "has", "the", "potential", "to", "cause", "unexpect", "error", "in", "the", "final", "program", "NUMBER", "In", "both", "of", "these", "cases", "the", "error", "be", "likely", "to", "be", "the", "kind", "that", "be", "not", "immediately", "obvious", "to", "someone", "use", "the", "the", "library", "or", "program", "that", "results", "in", "multiple", "version", "of", "the", "same", "library", "be", "loaded", "NUMBER", "So", "it", "be", "a", "bit", "conservative", "but", "I", "suspect", "this", "was", "some", "of", "the", "reasoning", "behind", "the", "R", "NUMBER", "RS", "prohibition", "on", "loading", "multiple", "version", "of", "the", "same", "library", "NUMBER", "Hey", "mflatt", "These", "change", "look", "good", "NUMBER", "I", "think", "we", "should", "consider", "use", "who", "in", "place", "of", "the", "explicit", "odd", "even", "flodd", "and", "fleven", "NUMBER", "Your", "change", "make", "use", "of", "these", "correctly", "but", "I", "notice", "when", "looking", "through", "the", "context", "of", "the", "expected", "error", "diffs", "that", "flodd", "NUMBER", "be", "raising", "the", "error", "Exception", "in", "odd", "NUMBER", "be", "not", "an", "integer", "in", "stead", "of", "Exception", "in", "flodd", "NUMBER", "be", "not", "an", "integer", "because", "it", "explicitly", "has", "odd", "where", "it", "should", "have", "flodd", "or", "who", "in", "the", "nonifnteger", "integer", "error", "call", "NUMBER", "Thanks", "for", "the", "change", "and", "the", "who", "Hey", "All", "I", "know", "I", "m", "a", "little", "late", "to", "the", "party", "but", "this", "seem", "like", "a", "fun", "thing", "to", "hack", "a", "little", "on", "now", "that", "Christmas", "be", "do", "and", "the", "rest", "of", "my", "extend", "family", "be", "asleep", "NUMBER", "soegaard", "to", "answer", "the", "simplest", "question", "first", "Chez", "Scheme", "do", "not", "have", "a", "specialized", "flvector", "or", "f", "NUMBER", "vector", "NUMBER", "You", "can", "get", "something", "similar", "by", "use", "a", "bytevector", "along", "with", "the", "bytevector", "ieee", "double", "native", "ref", "and", "bytevector", "ieee", "double", "native", "set", "operators", "defined", "as", "part", "of", "R", "NUMBER", "RS", "scheme", "NUMBER", "This", "similarly", "can", "be", "use", "for", "single", "floating", "point", "and", "various", "sign", "and", "unsigned", "integers", "NUMBER", "I", "gave", "that", "a", "try", "but", "I", "ll", "talk", "more", "about", "that", "in", "a", "second", "NUMBER", "Before", "get", "too", "deep", "into", "this", "it", "be", "worth", "noting", "that", "you", "be", "test", "one", "of", "Chez", "Scheme", "s", "know", "weaknesses", "for", "performance", "namely", "floating", "point", "NUMBER", "Floating", "point", "numbers", "be", "boxed", "in", "Chez", "Scheme", "meaning", "that", "every", "floating", "point", "operation", "requires", "unboxing", "and", "the", "results", "be", "immediately", "boxed", "NUMBER", "So", "if", "you", "have", "something", "like", "scheme", "fl", "fl", "a", "b", "c", "a", "will", "be", "unboxed", "into", "a", "floating", "point", "register", "SSE", "on", "x", "NUMBER", "family", "b", "will", "be", "unboxed", "this", "happens", "as", "part", "the", "SSE", "floating", "point", "add", "on", "x", "NUMBER", "family", "the", "unboxed", "values", "will", "be", "add", "the", "result", "will", "be", "boxed", "the", "result", "will", "be", "immediately", "unboxed", "c", "will", "be", "unboxed", "again", "this", "happens", "as", "part", "of", "the", "SSE", "floating", "point", "add", "on", "x", "NUMBER", "family", "the", "unboxed", "values", "will", "be", "add", "and", "the", "final", "result", "will", "be", "boxed", "NUMBER", "I", "ve", "not", "use", "Go", "but", "it", "would", "surprise", "me", "if", "it", "was", "doing", "all", "of", "this", "boxing", "and", "unboxing", "and", "in", "Chez", "it", "be", "something", "I", "d", "like", "to", "fix", "but", "it", "has", "not", "be", "high", "enough", "priority", "and", "we", "have", "not", "necessarily", "had", "all", "of", "the", "information", "we", "needed", "to", "make", "it", "really", "profitable", "to", "do", "so", "NUMBER", "Okay", "on", "to", "the", "main", "event", "make", "this", "code", "perform", "better", "NUMBER", "As", "a", "base", "line", "I", "start", "from", "the", "code", "LINK", "interpreter", "chezgo", "blob", "master", "matrix", "NUMBER", "ss", "with", "the", "version", "tag", "b", "NUMBER", "d", "NUMBER", "To", "get", "a", "baseline", "I", "compiled", "this", "library", "after", "renaming", "the", "file", "my", "matrix", "NUMBER", "ss", "so", "that", "it", "would", "match", "the", "library", "name", "my", "matrix", "at", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "then", "run", "it", "in", "a", "separate", "session", "I", "did", "this", "for", "all", "of", "the", "test", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "parameterize", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "compile", "library", "my", "matrix", "NUMBER", "ss", "my", "matrix", "NUMBER", "so", "compile", "my", "matrix", "NUMBER", "ss", "with", "output", "to", "my", "matrix", "NUMBER", "so", "Then", "I", "run", "the", "code", "in", "a", "separate", "session", "NUMBER", "Three", "runs", "averaged", "NUMBER", "msec", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "import", "my", "matrix", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "The", "first", "change", "I", "made", "was", "to", "make", "all", "of", "the", "operators", "type", "specific", "NUMBER", "So", "TAG", "import", "my", "matrix", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "The", "next", "change", "I", "made", "had", "a", "much", "more", "dramatic", "impact", "NUMBER", "I", "notice", "some", "code", "that", "looked", "very", "un", "Schemely", "to", "me", "and", "I", "could", "not", "for", "the", "life", "of", "me", "figure", "out", "why", "it", "was", "needed", "scheme", "set", "tot", "vector", "ref", "ith", "output", "row", "j", "set", "tot", "tot", "fl", "vector", "ref", "ith", "input", "row", "k", "vector", "ref", "kth", "input", "row", "j", "vector", "set", "ith", "output", "row", "j", "tot", "This", "be", "lines", "NUMBER", "NUMBER", "in", "the", "original", "file", "NUMBER", "We", "set", "a", "variable", "to", "a", "value", "we", "update", "that", "value", "then", "we", "set", "the", "result", "into", "a", "vector", "NUMBER", "We", "could", "obviously", "do", "the", "same", "with", "a", "local", "variable", "bindings", "and", "shadowing", "scheme", "let", "tot", "vector", "ref", "ith", "output", "row", "j", "let", "tot", "tot", "fl", "vector", "ref", "ith", "input", "row", "k", "vector", "ref", "kth", "input", "row", "j", "vector", "set", "its", "output", "row", "j", "tot", "But", "really", "there", "s", "no", "need", "to", "have", "the", "variables", "in", "there", "at", "all", "and", "we", "could", "just", "change", "this", "into", "scheme", "vector", "set", "ith", "output", "row", "j", "fl", "vector", "ref", "ith", "output", "row", "j", "fl", "vector", "ref", "ith", "input", "row", "k", "vector", "ref", "kth", "input", "row", "j", "Note", "I", "ve", "moved", "to", "the", "version", "with", "the", "replaced", "with", "fl", "NUMBER", "You", "can", "see", "this", "change", "at", "gist", "LINK", "This", "brought", "the", "average", "run", "time", "down", "to", "NUMBER", "ms", "a", "NUMBER", "improvement", "over", "the", "previous", "code", "and", "a", "NUMBER", "improvement", "over", "the", "original", "NUMBER", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "import", "my", "matrix", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "run", "bench", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "NUMBER", "x", "NUMBER", "matrix", "multiply", "in", "Chez", "took", "NUMBER", "msec", "This", "was", "about", "the", "best", "I", "could", "get", "NUMBER", "I", "also", "made", "a", "version", "of", "this", "code", "that", "remove", "all", "of", "the", "set", "and", "fix", "the", "sanity", "check", "so", "that", "it", "was", "use", "floating", "point", "numbers", "in", "the", "matrix", "but", "I", "m", "afraid", "I", "did", "not", "save", "this", "code", "NUMBER", "It", "did", "not", "make", "a", "difference", "in", "performance", "since", "that", "was", "not", "code", "be", "test", "in", "the", "benchmark", "NUMBER", "I", "tried", "two", "other", "experiments", "use", "bytevector", "s", "with", "bytevector", "ieee", "double", "native", "ref", "and", "bytevector", "ieee", "double", "native", "set", "the", "first", "wrapping", "a", "record", "containing", "the", "number", "of", "rows", "and", "number", "of", "columns", "over", "a", "flat", "byte", "vector", "that", "was", "accessed", "in", "column", "major", "fashion", "NUMBER", "After", "some", "tweaking", "this", "averaged", "out", "to", "NUMBER", "msec", "so", "better", "than", "the", "initial", "update", "but", "not", "better", "than", "remove", "the", "set", "see", "gist", "LINK", "I", "also", "tried", "creating", "a", "vector", "of", "bytevector", "s", "for", "the", "matrix", "sort", "of", "a", "hybrid", "approach", "NUMBER", "This", "was", "better", "but", "not", "good", "enough", "to", "beat", "the", "straight", "up", "vector", "of", "vector", "s", "version", "NUMBER", "In", "this", "case", "the", "average", "was", "NUMBER", "msec", "NUMBER", "See", "gist", "LINK", "I", "suspect", "the", "bytevector", "ieee", "double", "native", "ref", "and", "bytevector", "ieee", "double", "native", "set", "could", "use", "some", "improvement", "to", "be", "able", "to", "compete", "but", "it", "might", "lead", "to", "better", "cache", "behavior", "NUMBER", "Very", "likely", "this", "be", "again", "the", "boxing", "and", "unboxing", "rearing", "its", "ugly", "head", "NUMBER", "The", "biggest", "impact", "seem", "to", "be", "remove", "the", "set", "NUMBER", "To", "understand", "why", "this", "be", "such", "a", "problem", "it", "be", "important", "to", "realize", "that", "in", "Chez", "Scheme", "assigned", "variables", "i", "NUMBER", "e", "NUMBER", "those", "use", "with", "set", "have", "a", "bit", "of", "heap", "space", "allocated", "to", "them", "NUMBER", "Effectively", "scheme", "let", "x", "NUMBER", "set", "x", "x", "NUMBER", "x", "becomes", "scheme", "let", "x", "box", "NUMBER", "set", "box", "x", "unbox", "x", "NUMBER", "unbox", "x", "This", "indirection", "be", "created", "because", "if", "x", "be", "captured", "by", "more", "than", "one", "procedure", "they", "all", "need", "to", "see", "the", "same", "value", "for", "x", "and", "when", "x", "be", "assigned", "the", "new", "value", "must", "be", "visible", "to", "all", "the", "procedures", "NUMBER", "This", "can", "also", "impact", "performance", "of", "the", "garbage", "collector", "which", "needs", "to", "check", "reverse", "generational", "links", "when", "the", "box", "be", "set", "NUMBER", "In", "this", "example", "all", "of", "that", "extra", "effort", "was", "superfluous", "since", "tot", "be", "really", "just", "use", "as", "a", "temporary", "NUMBER", "Anyway", "we", "re", "still", "not", "as", "fast", "as", "Go", "for", "this", "example", "and", "with", "the", "boxing", "and", "unboxing", "of", "floats", "we", "probably", "won", "t", "be", "but", "it", "would", "be", "interesting", "to", "see", "how", "much", "further", "we", "could", "push", "this", "with", "some", "additional", "compiler", "support", "NUMBER", "I", "think", "my", "goal", "would", "be", "to", "improve", "or", "really", "allow", "for", "handle", "of", "the", "raw", "floating", "point", "values", "as", "a", "first", "step", "seeing", "if", "the", "exist", "byte", "vector", "implementation", "can", "be", "bent", "to", "serve", "for", "the", "purpose", "of", "a", "specific", "type", "vector", "NUMBER", "There", "be", "the", "potential", "for", "additional", "benefits", "for", "handle", "of", "other", "raw", "types", "if", "we", "can", "come", "up", "with", "a", "clever", "but", "simple", "way", "to", "do", "this", "NUMBER", "I", "suspect", "part", "of", "the", "problem", "with", "the", "byte", "vector", "version", "of", "the", "code", "be", "that", "it", "be", "immediately", "boxing", "the", "extracted", "value", "and", "an", "f", "NUMBER", "vector", "would", "effectively", "need", "to", "do", "the", "same", "so", "that", "be", "not", "really", "going", "to", "help", "without", "addressing", "the", "broader", "issue", "NUMBER", "All", "of", "that", "said", "like", "the", "other", "Chez", "Scheme", "maintainers", "this", "be", "mostly", "a", "spare", "time", "activity", "for", "me", "unless", "I", "have", "some", "particular", "justification", "for", "spending", "work", "time", "on", "it", "and", "this", "isn", "t", "currently", "a", "high", "priority", "so", "we", "ll", "have", "to", "see", "how", "the", "year", "unfolds", "NUMBER", "Internally", "Chez", "Scheme", "represents", "everything", "as", "a", "tag", "pointer", "NUMBER", "There", "be", "a", "few", "categories", "of", "things", "fixnums", "characters", "constants", "like", "null", "t", "and", "f", "that", "do", "not", "require", "heap", "allocation", "because", "the", "tag", "indicates", "that", "the", "value", "be", "stored", "within", "the", "tag", "pointer", "NUMBER", "For", "everything", "else", "heap", "allocation", "be", "required", "NUMBER", "A", "byte", "vector", "of", "course", "allows", "you", "to", "store", "raw", "data", "but", "once", "you", "extract", "that", "data", "into", "a", "scheme", "tag", "pointer", "you", "need", "to", "allocate", "space", "on", "the", "heap", "for", "it", "NUMBER", "The", "value", "you", "get", "back", "from", "the", "reference", "be", "a", "tag", "pointer", "whose", "tag", "indicates", "it", "be", "a", "floating", "point", "number", "NUMBER", "By", "itself", "an", "f", "NUMBER", "vector", "type", "would", "have", "the", "same", "problem", "namely", "we", "d", "need", "to", "allocate", "space", "for", "that", "value", "to", "live", "as", "its", "own", "value", "NUMBER", "You", "might", "wonder", "why", "you", "cannot", "just", "have", "the", "tag", "pointer", "point", "to", "where", "the", "value", "already", "exists", "in", "memory", "since", "in", "both", "cases", "we", "know", "the", "value", "be", "already", "in", "the", "form", "we", "need", "it", "in", "NUMBER", "However", "the", "garbage", "collector", "which", "be", "a", "copying", "collector", "would", "need", "to", "be", "in", "on", "the", "game", "because", "we", "would", "have", "pointers", "point", "into", "the", "middle", "of", "objects", "NUMBER", "These", "pointers", "would", "need", "to", "be", "update", "when", "the", "main", "object", "moved", "and", "it", "would", "also", "need", "to", "prevent", "the", "original", "object", "from", "be", "collected", "if", "there", "be", "no", "longer", "a", "live", "reference", "to", "that", "object", "NUMBER", "We", "don", "t", "currently", "have", "support", "for", "something", "like", "this", "in", "the", "collector", "NUMBER", "Additionally", "in", "the", "case", "of", "both", "a", "byte", "vector", "and", "the", "f", "NUMBER", "vector", "both", "of", "which", "would", "need", "to", "be", "mutable", "for", "your", "purposes", "we", "d", "need", "to", "make", "it", "clear", "that", "the", "variable", "be", "held", "onto", "could", "potentially", "change", "value", "through", "another", "instruction", "setting", "the", "location", "NUMBER", "In", "general", "Chez", "Scheme", "s", "operators", "operate", "on", "the", "tag", "pointer", "representation", "and", "be", "expected", "to", "return", "tag", "pointer", "representations", "with", "a", "handful", "of", "exception", "NUMBER", "The", "ftype", "system", "which", "be", "a", "syntactic", "layer", "to", "make", "interacting", "with", "structured", "foreign", "data", "easier", "internally", "maintains", "a", "raw", "pointer", "type", "for", "computing", "memory", "offsets", "and", "the", "like", "and", "it", "be", "possible", "we", "could", "do", "something", "similar", "for", "floating", "point", "values", "NUMBER", "Another", "concern", "with", "raw", "values", "floating", "around", "be", "how", "they", "impact", "the", "garbage", "collector", "NUMBER", "We", "currently", "maintain", "a", "live", "pointer", "mask", "for", "each", "frame", "on", "the", "stack", "which", "form", "the", "root", "set", "for", "the", "collector", "NUMBER", "In", "general", "the", "live", "pointer", "mask", "indicates", "what", "must", "be", "maintained", "across", "non", "tail", "calls", "and", "any", "element", "on", "the", "frame", "not", "covered", "by", "the", "mask", "could", "be", "replaced", "with", "random", "garbage", "without", "cause", "problem", "NUMBER", "We", "would", "need", "to", "subtly", "change", "the", "meaning", "of", "the", "live", "pointer", "mask", "since", "we", "would", "potentially", "have", "valid", "raw", "data", "stored", "where", "the", "live", "pointer", "mask", "indicates", "they", "be", "not", "live", "pointers", "and", "we", "wouldn", "t", "want", "them", "to", "marked", "as", "live", "pointers", "since", "the", "raw", "data", "might", "be", "interpreted", "incorrectly", "by", "the", "garbage", "collector", "NUMBER", "In", "addition", "I", "would", "like", "to", "be", "able", "to", "take", "advantage", "of", "the", "floating", "point", "registers", "that", "exist", "on", "most", "modern", "processors", "to", "allow", "us", "to", "keep", "floating", "point", "values", "in", "registers", "for", "longer", "stretches", "when", "there", "be", "going", "to", "be", "multiple", "floating", "point", "operations", "in", "sequence", "on", "them", "rather", "than", "reading", "them", "from", "memory", "doing", "the", "operation", "then", "write", "them", "back", "to", "memory", "only", "to", "read", "them", "again", "at", "the", "start", "of", "the", "next", "operation", "NUMBER", "This", "might", "not", "make", "a", "big", "impact", "for", "your", "particular", "use", "case", "but", "I", "do", "think", "the", "kernel", "of", "your", "matrix", "multiple", "would", "have", "better", "code", "generate", "there", "if", "we", "could", "get", "something", "like", "this", "implement", "NUMBER", "If", "you", "be", "interested", "in", "seeing", "what", "Chez", "Scheme", "do", "now", "you", "can", "see", "the", "assembly", "code", "generate", "by", "setting", "the", "assembly", "output", "parameter", "to", "t", "or", "a", "textual", "output", "port", "NUMBER", "t", "indicates", "it", "should", "be", "output", "to", "standard", "out", "NUMBER", "You", "ll", "need", "to", "use", "the", "prefix", "to", "use", "this", "as", "it", "be", "a", "hidden", "primitive", "in", "Chez", "Scheme", "assembly", "output", "f", "assembly", "output", "t", "I", "can", "t", "reproduce", "this", "problem", "NUMBER", "Is", "your", "TZ", "environment", "variable", "set", "If", "so", "unset", "it", "and", "try", "again", "NUMBER", "I", "was", "just", "looking", "at", "this", "a", "few", "minutes", "ago", "NUMBER", "When", "I", "change", "my", "time", "zone", "to", "Europe", "Berlin", "I", "was", "able", "to", "reproduce", "the", "error", "NUMBER", "I", "tried", "setting", "the", "TZ", "environment", "variable", "to", "Europe", "Berlin", "but", "that", "didn", "t", "seem", "to", "help", "NUMBER", "Thanks", "I", "m", "now", "able", "to", "reproduce", "the", "behavior", "on", "my", "Windows", "NUMBER", "machine", "by", "setting", "my", "time", "zone", "to", "UTC", "NUMBER", "NUMBER", "City", "of", "Buenos", "Aires", "NUMBER", "The", "bug", "be", "call", "by", "the", "use", "of", "difftime", "in", "S_mktime", "which", "cannot", "take", "a", "negative", "time_t", "value", "NUMBER", "See", "LINK", "us", "library", "NUMBER", "wbd", "NUMBER", "aspx", "NUMBER", "Fixed", "in", "commit", "LINK", "I", "remove", "the", "incorrect", "use", "of", "difftime", "on", "all", "platforms", "and", "test", "against", "a", "NUMBER", "le", "a", "NUMBER", "nt", "a", "NUMBER", "osx", "and", "i", "NUMBER", "nt", "NUMBER", "The", "difference", "here", "be", "actually", "an", "expected", "one", "NUMBER", "Without", "consulting", "with", "Kent", "I", "m", "not", "exactly", "sure", "why", "this", "difference", "exists", "when", "as", "you", "ve", "shown", "it", "doesn", "t", "need", "to", "other", "than", "avoiding", "special", "casing", "every", "little", "think", "in", "cp", "NUMBER", "which", "may", "be", "why", "he", "didn", "t", "go", "down", "this", "road", "in", "the", "first", "place", "NUMBER", "The", "reason", "it", "doesn", "t", "fail", "on", "Linux", "and", "shouldn", "t", "on", "Windows", "either", "be", "that", "the", "way", "the", "expected", "error", "be", "handle", "there", "be", "a", "main", "expected", "error", "file", "and", "then", "there", "be", "patches", "for", "different", "settings", "NUMBER", "Linux", "be", "and", "Windows", "should", "patch", "the", "expected", "error", "with", "the", "correct", "set", "NUMBER", "So", "that", "be", "the", "explanation", "NUMBER", "Before", "we", "decide", "we", "want", "to", "go", "down", "this", "road", "I", "d", "like", "to", "double", "check", "with", "Kent", "NUMBER", "I", "know", "this", "be", "not", "the", "only", "instance", "of", "differences", "when", "cp", "NUMBER", "be", "turned", "off", "and", "doing", "this", "across", "the", "board", "might", "require", "a", "fair", "amount", "of", "special", "casing", "NUMBER", "gus", "massa", "The", "problem", "occur", "when", "you", "have", "an", "optimize", "level", "NUMBER", "call", "to", "map", "in", "a", "program", "that", "be", "otherwise", "compiled", "at", "optimize", "level", "NUMBER", "You", "can", "see", "this", "by", "setting", "Chez", "Scheme", "to", "optimize", "level", "NUMBER", "turning", "off", "compile", "interpret", "simple", "and", "then", "executing", "NUMBER", "map", "NUMBER", "bin", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "optimize", "level", "NUMBER", "compile", "interpret", "simple", "f", "NUMBER", "map", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Exception", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "This", "be", "happening", "because", "NUMBER", "map", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "be", "expanding", "into", "NUMBER", "list", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "and", "when", "the", "calls", "to", "NUMBER", "be", "compiled", "at", "optimize", "level", "NUMBER", "the", "procedure", "checking", "code", "be", "not", "be", "write", "at", "the", "call", "sites", "expand", "optimize", "NUMBER", "map", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "list", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Your", "change", "ends", "up", "addressing", "this", "even", "though", "that", "this", "not", "what", "it", "was", "intended", "to", "fix", "NUMBER", "It", "be", "possible", "that", "we", "could", "make", "this", "change", "stricter", "and", "only", "do", "this", "when", "the", "compiler", "be", "currently", "run", "at", "optimize", "level", "NUMBER", "and", "we", "be", "optimizing", "the", "optimize", "level", "NUMBER", "version", "of", "map", "NUMBER", "So", "I", "think", "this", "works", "as", "expected", "NUMBER", "When", "you", "compile", "your", "example", "program", "at", "optimize", "level", "NUMBER", "you", "get", "an", "error", "when", "you", "compile", "it", "at", "optimize", "level", "NUMBER", "you", "do", "not", "this", "be", "exactly", "the", "same", "behavior", "you", "would", "see", "if", "cp", "NUMBER", "was", "not", "be", "run", "which", "be", "the", "goal", "NUMBER", "The", "change", "you", "made", "should", "change", "the", "behavior", "when", "you", "be", "compile", "a", "program", "at", "optimize", "level", "NUMBER", "but", "you", "ve", "explicitly", "call", "the", "optimize", "level", "NUMBER", "version", "of", "map", "NUMBER", "bin", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "optimize", "level", "NUMBER", "define", "f", "p", "b", "unbox", "b", "NUMBER", "map", "p", "if", "box", "b", "NUMBER", "NUMBER", "NUMBER", "list", "p", "procedure", "p", "f", "NUMBER", "box", "NUMBER", "NUMBER", "t", "Exception", "in", "map", "NUMBER", "be", "not", "a", "procedure", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "Anyway", "I", "think", "these", "change", "look", "okay", "I", "m", "in", "the", "process", "of", "test", "through", "things", "and", "make", "sure", "we", "ve", "get", "the", "expected", "error", "and", "patch", "file", "set", "up", "correctly", "NUMBER", "I", "ll", "also", "be", "add", "some", "test", "to", "the", "mats", "for", "this", "NUMBER", "Thanks", "for", "finding", "this", "It", "s", "correct", "in", "commit", "LINK", "Both", "vector", "fill", "and", "substring", "fill", "return", "an", "unspecified", "value", "which", "be", "why", "they", "be", "marked", "void", "NUMBER", "The", "fact", "that", "they", "happen", "to", "return", "a", "vector", "and", "string", "respectively", "be", "accidental", "and", "I", "think", "if", "there", "be", "code", "that", "depends", "upon", "it", "we", "should", "probably", "change", "that", "code", "but", "I", "think", "the", "signatures", "be", "actually", "correct", "in", "primdata", "NUMBER", "ss", "If", "these", "two", "signatures", "be", "leading", "to", "bug", "let", "me", "know", "and", "I", "ll", "take", "a", "look", "into", "what", "be", "cause", "the", "problem", "NUMBER", "The", "rest", "to", "these", "change", "look", "good", "NUMBER", "Just", "a", "quick", "update", "on", "this", "NUMBER", "I", "ve", "commit", "a", "change", "to", "vector", "fill", "and", "substring", "fill", "that", "corrects", "their", "output", "to", "return", "void", "in", "keep", "with", "their", "documented", "behavior", "NUMBER", "gus", "massa", "Good", "catch", "on", "the", "substring", "fill", "test", "I", "m", "not", "sure", "why", "my", "own", "test", "didn", "t", "turn", "that", "up", "NUMBER", "I", "think", "the", "change", "to", "unget", "u", "NUMBER", "char", "makes", "sense", "NUMBER", "Perhaps", "at", "some", "point", "we", "ll", "have", "to", "extend", "the", "little", "type", "system", "to", "express", "u", "NUMBER", "eof", "object", "char", "eof", "object", "etc", "NUMBER", "since", "this", "do", "come", "up", "relatively", "frequently", "in", "the", "I", "O", "function", "if", "it", "turns", "out", "to", "be", "profitable", "anyway", "NUMBER", "Thanks", "for", "this", "pull", "request", "Looks", "good", "thanks", "Thank", "you", "for", "finding", "and", "fix", "these", "typo", "I", "think", "the", "problem", "here", "be", "unrelated", "to", "Chez", "Scheme", "NUMBER", "From", "the", "recv", "documentation", "If", "no", "message", "be", "available", "at", "the", "socket", "the", "receive", "call", "waits", "for", "a", "message", "to", "arrive", "unless", "the", "socket", "be", "nonblocking", "see", "fcntl", "NUMBER", "in", "which", "case", "the", "value", "NUMBER", "be", "returned", "and", "the", "external", "variable", "errno", "set", "to", "EAGAIN", "NUMBER", "The", "receive", "calls", "normally", "return", "any", "data", "available", "up", "to", "the", "request", "amount", "rather", "than", "waiting", "for", "receipt", "of", "the", "full", "amount", "request", "this", "behavior", "be", "affected", "by", "the", "socket", "level", "options", "SO_RCVLOWAT", "and", "SO_RCVTIMEO", "describe", "in", "getsockopt", "NUMBER", "NUMBER", "I", "test", "this", "out", "by", "use", "fcntl", "to", "get", "the", "flags", "currently", "set", "on", "the", "accepted", "socket", "command", "F_GETFL", "and", "find", "that", "the", "socket", "descriptor", "returned", "be", "not", "marked", "as", "non", "blocking", "which", "be", "why", "recv", "and", "send", "and", "blocking", "NUMBER", "You", "should", "be", "able", "to", "get", "the", "behavior", "you", "want", "by", "use", "fcntl", "with", "F_SETFL", "on", "the", "socket", "descriptor", "returned", "by", "accept", "NUMBER", "Note", "that", "if", "you", "set", "it", "on", "the", "original", "socket", "descriptor", "from", "socket", "the", "accept", "will", "not", "block", "it", "will", "simply", "return", "an", "error", "message", "if", "no", "connections", "have", "be", "request", "NUMBER", "mflatt", "how", "do", "I", "compile", "this", "branch", "I", "get", "Error", "in", "lookup", "library", "entry", "entry", "s", "uninitialized", "NUMBER", "Thanks", "that", "worked", "If", "you", "have", "a", "recent", "Chez", "Scheme", "install", "you", "can", "do", "this", "from", "the", "particular", "workarea", "make", "C", "s", "all", "patchfile", "patch", "Scheme", "scheme", "SCHEMEHEAPDIRS", "usr", "lib", "csv", "v", "m", "usr", "local", "lib", "csv", "v", "m", "make", "Thanks", "for", "this", "pull", "request", "The", "release", "tar", "ball", "be", "created", "directly", "from", "the", "git", "repository", "directory", "wth", "submodules", "excluding", "the", "hidden", "NUMBER", "git", "and", "NUMBER", "travis", "file", "and", "directories", "NUMBER", "One", "way", "to", "do", "this", "be", "to", "do", "the", "following", "NUMBER", "Make", "sure", "you", "have", "a", "clean", "git", "checkout", "with", "the", "submodules", "checked", "out", "NUMBER", "You", "can", "clone", "the", "repository", "with", "recursive", "to", "have", "it", "clone", "the", "submodules", "as", "well", "or", "you", "can", "run", "git", "submodule", "update", "init", "after", "you", "clone", "to", "get", "the", "directories", "NUMBER", "NUMBER", "If", "you", "want", "to", "make", "the", "tar", "ball", "on", "a", "specific", "version", "checkout", "the", "version", "for", "instance", "if", "you", "want", "to", "make", "a", "v", "NUMBER", "tar", "ball", "git", "checkout", "tags", "v", "NUMBER", "you", "can", "create", "a", "branch", "when", "you", "do", "this", "by", "also", "doing", "b", "TAG", "NUMBER", "Use", "git", "to", "clean", "the", "directory", "this", "will", "delete", "everything", "that", "be", "not", "part", "of", "the", "git", "repository", "so", "be", "careful", "with", "this", "git", "clean", "xdf", "Remember", "this", "will", "delete", "everything", "not", "in", "the", "git", "repo", "NUMBER", "Create", "a", "staging", "directory", "this", "will", "be", "the", "base", "of", "your", "tar", "ball", "mkdir", "tmp", "csv", "NUMBER", "NUMBER", "Use", "rsync", "excluding", "the", "hidden", "file", "rsync", "arv", "exclude", "NUMBER", "git", "exclude", "NUMBER", "travis", "ChezScheme", "tmp", "csv", "NUMBER", "Note", "the", "trail", "after", "the", "git", "directory", "be", "significant", "NUMBER", "NUMBER", "Optionally", "remove", "any", "boot", "file", "you", "don", "t", "want", "to", "include", "rm", "rf", "tmp", "csv", "NUMBER", "boot", "TAG", "NUMBER", "Note", "these", "could", "also", "be", "excluded", "with", "rsync", "NUMBER", "NUMBER", "Build", "the", "tar", "ball", "from", "the", "tmp", "directory", "cd", "tmp", "tar", "czvf", "my", "csv", "NUMBER", "tar", "NUMBER", "gz", "csv", "NUMBER", "You", "could", "also", "add", "additional", "boot", "file", "if", "you", "wanted", "to", "create", "a", "binary", "with", "a", "different", "mix", "of", "boot", "file", "NUMBER", "Note", "that", "the", "directories", "listed", "here", "be", "suggestions", "only", "NUMBER", "Alternatively", "you", "could", "grab", "the", "csv", "NUMBER", "tar", "NUMBER", "gz", "extract", "the", "contents", "remove", "the", "boot", "file", "you", "don", "t", "want", "then", "create", "your", "new", "tar", "ball", "from", "that", "directory", "NUMBER", "Again", "you", "be", "seeing", "hard", "links", "which", "reflect", "the", "names", "you", "chose", "to", "call", "your", "Chez", "Scheme", "executables", "NUMBER", "petite", "chez", "NUMBER", "boot", "be", "a", "hard", "link", "to", "petite", "NUMBER", "boot", "and", "chez", "NUMBER", "boot", "be", "a", "hard", "link", "to", "scheme", "NUMBER", "boot", "NUMBER", "These", "hard", "links", "be", "needed", "because", "as", "I", "explained", "in", "NUMBER", "when", "you", "run", "chez", "it", "will", "look", "for", "a", "boot", "file", "call", "chez", "NUMBER", "boot", "and", "when", "you", "execute", "petite", "chez", "it", "will", "look", "for", "a", "boot", "file", "call", "petite", "chez", "NUMBER", "boot", "NUMBER", "Internally", "though", "chez", "NUMBER", "boot", "will", "still", "be", "looking", "for", "a", "file", "call", "petite", "NUMBER", "boot", "so", "these", "be", "simply", "hard", "linked", "to", "avoid", "change", "the", "underlying", "generation", "of", "the", "boot", "file", "NUMBER", "The", "only", "part", "of", "the", "build", "process", "that", "be", "aware", "of", "the", "installation", "names", "be", "the", "installation", "step", "so", "effectively", "the", "scheme", "NUMBER", "boot", "has", "already", "be", "build", "with", "a", "requirement", "on", "petite", "NUMBER", "boot", "so", "at", "the", "very", "least", "the", "petite", "NUMBER", "boot", "file", "must", "be", "there", "for", "your", "system", "to", "work", "NUMBER", "This", "be", "true", "but", "petite", "and", "scheme", "script", "be", "just", "hard", "links", "to", "scheme", "that", "cause", "it", "to", "operate", "in", "slightly", "different", "modes", "NUMBER", "When", "scheme", "detects", "that", "it", "has", "be", "run", "as", "scheme", "script", "it", "uses", "the", "first", "command", "line", "argument", "to", "determine", "the", "scheme", "script", "to", "run", "and", "makes", "all", "other", "command", "line", "argument", "available", "to", "the", "script", "through", "the", "command", "line", "and", "command", "line", "argument", "NUMBER", "scheme", "script", "be", "equivalent", "to", "scheme", "program", "and", "command", "line", "argument", "intended", "for", "the", "use", "in", "the", "scheme", "script", "can", "also", "be", "pass", "after", "though", "this", "be", "not", "needed", "when", "use", "program", "NUMBER", "In", "the", "case", "of", "petite", "the", "scheme", "executable", "decides", "on", "which", "boot", "file", "s", "to", "attempt", "to", "load", "based", "on", "the", "name", "the", "executable", "was", "run", "as", "unless", "the", "boot", "file", "be", "explicitly", "specified", "with", "the", "b", "command", "line", "argument", "NUMBER", "Normally", "we", "build", "two", "boot", "file", "petite", "NUMBER", "boot", "and", "scheme", "NUMBER", "boot", "NUMBER", "petite", "NUMBER", "boot", "contains", "all", "of", "the", "basic", "scheme", "libraries", "and", "REPL", "support", "including", "the", "expression", "editor", "NUMBER", "scheme", "NUMBER", "boot", "contains", "the", "scheme", "compiler", "NUMBER", "When", "the", "executable", "name", "be", "scheme", "it", "attempts", "to", "load", "the", "scheme", "NUMBER", "boot", "file", "which", "lists", "the", "petite", "NUMBER", "boot", "as", "a", "dependency", "NUMBER", "When", "the", "executable", "be", "petite", "it", "loads", "the", "petite", "NUMBER", "boot", "only", "NUMBER", "Petite", "Chez", "be", "still", "useful", "because", "it", "allows", "for", "a", "smaller", "memory", "footprint", "when", "run", "scheme", "program", "and", "can", "be", "use", "a", "smaller", "run", "time", "for", "a", "precompiled", "scheme", "program", "NUMBER", "Yeah", "Chez", "treats", "and", "the", "same", "in", "the", "format", "code", "so", "I", "think", "this", "be", "doing", "the", "converts", "every", "lowercase", "character", "to", "the", "corresponding", "uppercase", "character", "NUMBER", "version", "of", "the", "conversion", "from", "the", "Common", "Lisp", "formatted", "output", "specification", "NUMBER", "Looks", "good", "thanks", "Hmmm", "NUMBER", "I", "tried", "to", "reproduce", "this", "on", "a", "CentOS", "NUMBER", "VM", "today", "I", "couldn", "t", "find", "the", "NUMBER", "iso", "anymore", "it", "looked", "like", "CentOS", "has", "moved", "to", "just", "provide", "one", "version", "NUMBER", "VM", "but", "I", "wasn", "t", "able", "to", "reproduce", "NUMBER", "It", "build", "fine", "for", "me", "NUMBER", "Some", "things", "to", "try", "NUMBER", "Make", "sure", "you", "don", "t", "have", "a", "SCHEMEHEAPDIRS", "CHEZSCHEMELIBDIRS", "CHEZSCHEMELIBEXTS", "defined", "NUMBER", "Try", "to", "do", "a", "make", "distclean", "and", "then", "configure", "and", "build", "again", "NUMBER", "Something", "that", "can", "happen", "be", "if", "the", "C", "run", "time", "and", "Scheme", "boot", "file", "have", "different", "expectations", "around", "how", "they", "should", "communicate", "you", "can", "end", "up", "with", "some", "pretty", "serious", "problem", "like", "the", "invalid", "memory", "reference", "NUMBER", "This", "be", "part", "of", "the", "reason", "for", "make", "sure", "your", "SCHEMEHEAPDIRS", "be", "not", "set", "if", "it", "be", "you", "might", "end", "up", "with", "the", "new", "C", "run", "time", "trying", "to", "load", "the", "old", "NUMBER", "boot", "file", "NUMBER", "The", "debugger", "be", "actually", "an", "inspector", "of", "the", "current", "continuation", "effectively", "the", "chain", "of", "stack", "frames", "for", "the", "non", "tail", "calls", "leading", "to", "the", "failure", "from", "where", "the", "failure", "occur", "NUMBER", "This", "means", "that", "local", "variables", "that", "be", "still", "in", "scope", "will", "be", "visible", "in", "the", "debugger", "since", "they", "be", "part", "of", "the", "continuation", "NUMBER", "In", "your", "example", "there", "be", "only", "a", "tail", "call", "so", "the", "current", "continuation", "do", "not", "contain", "a", "local", "variable", "NUMBER", "In", "cases", "where", "you", "be", "debugging", "a", "compiled", "file", "as", "oppose", "to", "at", "the", "REPL", "you", "can", "also", "ask", "the", "debugger", "to", "print", "out", "a", "file", "location", "which", "can", "help", "to", "identify", "where", "the", "error", "occur", "and", "what", "variable", "might", "be", "involved", "NUMBER", "In", "general", "you", "cannot", "construct", "a", "helper", "function", "that", "ensures", "a", "local", "variable", "be", "on", "the", "stack", "for", "an", "arbitrary", "function", "when", "an", "exception", "occur", "NUMBER", "In", "your", "example", "the", "function", "be", "call", "do", "not", "have", "a", "stack", "on", "the", "frame", "since", "it", "be", "at", "the", "tail", "of", "the", "computation", "NUMBER", "You", "can", "force", "a", "frame", "to", "be", "created", "by", "capturing", "the", "current", "continuation", "with", "call", "cc", "and", "you", "can", "even", "use", "this", "with", "the", "inspector", "to", "look", "at", "the", "current", "continuation", "NUMBER", "In", "fact", "this", "be", "how", "the", "debugger", "works", "it", "allows", "you", "to", "walk", "the", "continuation", "NUMBER", "Starting", "from", "your", "example", "you", "could", "do", "something", "like", "define", "f", "lambda", "x", "call", "cc", "lambda", "k", "inspect", "k", "NUMBER", "x", "f", "a", "TAG", "s", "continuation", "TAG", "procedure", "code", "lambda", "x", "call", "cc", "lambda", "NUMBER", "NUMBER", "NUMBER", "x", "call", "code", "call", "cc", "lambda", "k", "inspect", "k", "frame", "and", "free", "variables", "NUMBER", "x", "a", "TAG", "q", "Exception", "in", "a", "be", "not", "a", "number", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "Now", "you", "can", "see", "that", "x", "be", "on", "the", "frame", "NUMBER", "It", "be", "worth", "noting", "that", "if", "x", "was", "not", "referenced", "after", "the", "call", "cc", "expression", "in", "the", "code", "it", "would", "not", "be", "represented", "there", "because", "it", "would", "not", "be", "needed", "across", "the", "non", "tail", "call", "NUMBER", "You", "can", "also", "inspect", "the", "variable", "value", "directly", "by", "simply", "passing", "it", "to", "inspect", "define", "f", "lambda", "x", "inspect", "x", "NUMBER", "x", "f", "a", "a", "q", "Exception", "in", "a", "be", "not", "a", "number", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "Sometimes", "it", "can", "be", "helpful", "to", "generate", "a", "pair", "with", "name", "define", "f", "lambda", "x", "inspect", "cons", "x", "x", "NUMBER", "x", "f", "a", "x", "NUMBER", "a", "s", "car", "x", "cdr", "a", "x", "NUMBER", "a", "q", "Exception", "in", "a", "be", "not", "a", "number", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "Hope", "that", "helps", "I", "haven", "t", "taken", "enough", "time", "to", "look", "at", "this", "yet", "but", "generally", "speaking", "this", "be", "a", "great", "addition", "NUMBER", "Rather", "than", "wait", "until", "I", "have", "had", "a", "chance", "to", "finish", "going", "over", "the", "code", "in", "detail", "I", "thought", "I", "d", "provide", "a", "quick", "bit", "of", "additional", "feedback", "now", "NUMBER", "The", "feedback", "regards", "the", "syntax", "of", "foreign", "procedure", "foreign", "callable", "argument", "and", "return", "types", "NUMBER", "For", "ftype", "pointers", "rather", "than", "ftype", "values", "Andy", "and", "I", "use", "_ftype", "name_", "to", "leave", "open", "the", "possibility", "of", "later", "use", "just", "_ftype", "name_", "for", "ftype", "values", "NUMBER", "Do", "you", "think", "this", "would", "work", "and", "be", "it", "a", "good", "idea", "Base", "ftype", "names", "like", "int", "that", "conflict", "with", "primitive", "argument", "and", "return", "type", "names", "would", "be", "a", "problem", "so", "we", "d", "probably", "have", "to", "disallow", "their", "use", "except", "by", "way", "of", "an", "alias", "NUMBER", "In", "other", "words", "we", "d", "probably", "have", "to", "go", "with", "the", "primitive", "type", "rather", "than", "the", "base", "ftype", "in", "case", "of", "a", "name", "conflict", "NUMBER", "I", "see", "what", "you", "mean", "about", "in", "the", "return", "type", "highlight", "the", "interface", "change", "NUMBER", "While", "I", "can", "see", "why", "you", "might", "want", "plain", "NSUInteger", "to", "indicate", "that", "the", "argument", "be", "or", "can", "be", "a", "simple", "integer", "rather", "than", "an", "ftype", "pointer", "I", "don", "t", "know", "why", "you", "d", "expect", "it", "NUMBER", "When", "I", "declare", "an", "argument", "or", "return", "type", "to", "be", "an", "ftype", "regardless", "of", "any", "decorations", "I", "would", "expect", "the", "the", "argument", "or", "return", "value", "to", "be", "an", "ftype", "pointer", "NUMBER", "In", "any", "case", "I", "don", "t", "have", "a", "strong", "feeling", "one", "way", "or", "another", "about", "the", "change", "in", "syntax", "so", "I", "m", "okay", "leaving", "it", "as", "be", "NUMBER", "ecraven", "I", "m", "in", "the", "process", "of", "reviewing", "the", "implementation", "and", "expect", "to", "be", "able", "to", "pull", "it", "when", "I", "m", "do", "possibly", "with", "minor", "corrections", "NUMBER", "It", "wouldn", "t", "hurt", "to", "have", "another", "pair", "of", "eyes", "on", "it", "though", "NUMBER", "Now", "that", "the", "foreign", "callable", "code", "object", "performs", "a", "non", "tail", "call", "rather", "than", "a", "tail", "call", "to", "the", "C", "call", "helper", "it", "has", "become", "necessary", "to", "lock", "the", "code", "object", "before", "the", "code", "runs", "and", "not", "unlock", "it", "until", "after", "it", "returns", "due", "to", "the", "possibility", "of", "a", "garbage", "collection", "in", "the", "invoked", "Scheme", "routine", "NUMBER", "For", "example", "the", "mat", "on", "line", "NUMBER", "of", "foreign", "NUMBER", "ms", "needs", "to", "call", "lock", "object", "on", "Fcons", "something", "like", "equal", "let", "define", "Sinvoke", "NUMBER", "foreign", "procedure", "Sinvoke", "NUMBER", "scheme", "object", "scheme", "object", "iptr", "scheme", "object", "define", "Fcons", "foreign", "callable", "lambda", "x", "y", "collect", "let", "ls", "make", "list", "NUMBER", "z", "collect", "collect", "collect", "collect", "collect", "cons", "length", "ls", "cons", "x", "y", "scheme", "object", "iptr", "scheme", "object", "define", "go", "dynamic", "wind", "lambda", "lock", "object", "Fcons", "lambda", "Sinvoke", "NUMBER", "Fcons", "NUMBER", "NUMBER", "lambda", "unlock", "object", "Fcons", "go", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "It", "s", "a", "bit", "tricky", "to", "get", "this", "to", "fail", "reliably", "without", "the", "call", "to", "lock", "object", "but", "the", "following", "variant", "results", "in", "an", "invalid", "memory", "reference", "for", "me", "on", "both", "NUMBER", "and", "NUMBER", "bit", "Linux", "NUMBER", "load", "shared", "object", "NUMBER", "mats", "foreign", "NUMBER", "so", "parameterize", "collect", "request", "handler", "void", "define", "Sinvoke", "NUMBER", "eval", "foreign", "procedure", "Sinvoke", "NUMBER", "scheme", "object", "scheme", "object", "iptr", "scheme", "object", "define", "Fcons", "eval", "foreign", "callable", "lambda", "x", "y", "collect", "let", "ls", "map", "lambda", "x", "make", "vector", "NUMBER", "x", "make", "list", "NUMBER", "collect", "collect", "collect", "collect", "cons", "length", "ls", "cons", "x", "y", "scheme", "object", "iptr", "scheme", "object", "let", "loop", "let", "get", "dynamic", "wind", "lambda", "void", "lock", "object", "Fcons", "lambda", "Sinvoke", "NUMBER", "Fcons", "NUMBER", "NUMBER", "lambda", "void", "unlock", "object", "Fcons", "expected", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "unless", "equal", "get", "expected", "errorf", "f", "expected", "s", "get", "s", "n", "expected", "get", "loop", "That", "s", "a", "good", "idea", "NUMBER", "It", "should", "probably", "be", "unlocked", "automatically", "even", "when", "a", "call", "returns", "to", "some", "lower", "point", "on", "the", "stack", "i", "NUMBER", "e", "NUMBER", "when", "there", "be", "a", "continuation", "invocation", "that", "causes", "an", "outer", "call", "into", "Scheme", "to", "return", "NUMBER", "This", "might", "involve", "storing", "something", "extra", "in", "the", "cchain", "NUMBER", "Unfortunately", "this", "ends", "up", "unlocking", "only", "one", "of", "the", "two", "code", "objects", "resulting", "not", "only", "in", "one", "of", "the", "code", "objects", "be", "locked", "forever", "but", "also", "build", "up", "the", "locked", "object", "list", "and", "greatly", "slowing", "collection", "NUMBER", "The", "basic", "problem", "be", "that", "the", "extra", "dummy", "CCHAIN", "element", "needs", "to", "be", "on", "top", "of", "the", "one", "stored", "in", "the", "frame", "rather", "than", "below", "NUMBER", "Fixing", "this", "also", "obviates", "the", "call", "to", "Sunlock_object", "in", "S_call_help", "NUMBER", "The", "patch", "below", "seems", "to", "fix", "the", "problem", "NUMBER", "NUMBER", "NUMBER", "c", "schlib", "NUMBER", "c", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "schlib", "NUMBER", "c", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "jb", "CREATEJMPBUF", "if", "jb", "NULL", "S_error_abort", "unable", "to", "allocate", "memory", "for", "jump", "buffer", "if", "lock_ts", "Lock", "a", "code", "object", "pass", "in", "TS", "which", "be", "a", "more", "immediate", "caller", "whose", "return", "address", "be", "on", "the", "C", "stack", "callable_code", "TS", "tc", "Slock_object", "callable_code", "CCHAIN", "tc", "Scons", "Scons", "jb", "TS", "tc", "Scons", "Scons", "NULL", "code", "CCHAIN", "tc", "else", "callable_code", "NULL", "CCHAIN", "tc", "Scons", "Scons", "jb", "code", "CCHAIN", "tc", "FRAME", "tc", "NUMBER", "CCHAIN", "tc", "switch", "SETJMP", "jb", "case", "NUMBER", "first", "time", "S_generic_invoke", "tc", "S_G", "NUMBER", "invoke_code_object", "NUMBER", "NUMBER", "jb", "CREATEJMPBUF", "if", "jb", "NULL", "S_error_abort", "unable", "to", "allocate", "memory", "for", "jump", "buffer", "FRAME", "tc", "NUMBER", "CCHAIN", "tc", "Scons", "Scons", "jb", "code", "CCHAIN", "tc", "if", "lock_ts", "Lock", "a", "code", "object", "pass", "in", "TS", "which", "be", "a", "more", "immediate", "caller", "whose", "return", "address", "be", "on", "the", "C", "stack", "callable_code", "TS", "tc", "Slock_object", "callable_code", "CCHAIN", "tc", "Scons", "Scons", "NULL", "TS", "tc", "CCHAIN", "tc", "else", "callable_code", "NULL", "switch", "SETJMP", "jb", "case", "NUMBER", "first", "time", "S_generic_invoke", "tc", "S_G", "NUMBER", "invoke_code_object", "NUMBER", "NUMBER", "case", "NUMBER", "normal", "return", "ptr", "yp", "CCHAIN", "tc", "FREEJMPBUF", "CAAR", "yp", "if", "lock_ts", "Sunlock_object", "callable_code", "CCHAIN", "tc", "Scdr", "Scdr", "yp", "else", "CCHAIN", "tc", "Scdr", "yp", "break", "default", "NUMBER", "NUMBER", "case", "NUMBER", "normal", "return", "ptr", "yp", "CCHAIN", "tc", "FREEJMPBUF", "CAAR", "yp", "CCHAIN", "tc", "Scdr", "yp", "break", "default", "We", "should", "probably", "expose", "an", "foreign", "entry", "for", "the", "mats", "to", "use", "to", "check", "the", "number", "of", "locked", "objects", "and", "check", "it", "in", "various", "places", "during", "the", "mat", "run", "NUMBER", "_We", "should", "probably", "expose", "an", "foreign", "entry", "for", "the", "mats", "to", "use", "to", "check", "the", "number", "of", "locked", "objects", "and", "check", "it", "in", "various", "places", "during", "the", "mat", "run", "NUMBER", "_", "Well", "of", "course", "we", "already", "had", "something", "that", "returns", "a", "list", "of", "the", "locked", "objects", "to", "test", "lock", "object", "and", "unlock", "object", "in", "misc", "NUMBER", "ms", "so", "I", "ve", "put", "it", "to", "use", "in", "foreign", "NUMBER", "ms", "NUMBER", "This", "turned", "up", "an", "interesting", "issue", "that", "predates", "this", "pull", "request", "but", "that", "this", "pull", "request", "exacerbates", "slightly", "which", "be", "that", "error", "out", "of", "a", "procedure", "call", "via", "foreign", "callable", "leaves", "the", "topmost", "CCHAIN", "element", "s", "on", "the", "CCHAIN", "stack", "and", "leaves", "the", "code", "object", "s", "locked", "NUMBER", "I", "have", "not", "yet", "determined", "how", "to", "address", "this", "NUMBER", "I", "don", "t", "see", "any", "other", "problem", "with", "the", "pull", "request", "NUMBER", "mflatt", "I", "would", "prefer", "that", "you", "update", "LOG", "and", "release_notes", "NUMBER", "ex", "so", "I", "can", "do", "a", "clean", "pull", "NUMBER", "I", "m", "happy", "to", "rebuild", "the", "boot", "file", "or", "you", "can", "also", "include", "them", "NUMBER", "Thanks", "for", "all", "of", "your", "efforts", "on", "this", "NUMBER", "The", "last", "change", "expose", "another", "problem", "whereby", "do_error", "could", "pass", "LONGJMP", "a", "null", "jump", "buffer", "from", "one", "of", "the", "dummy", "CCHAIN", "entries", "so", "I", "modify", "the", "CCHAIN", "entry", "to", "include", "a", "pair", "of", "code", "objects", "and", "eliminated", "the", "dummy", "entries", "NUMBER", "do_error", "should", "probably", "be", "invoking", "a", "more", "specific", "entry", "rather", "than", "whatever", "happens", "to", "be", "first", "in", "the", "CCHAIN", "and", "I", "ll", "look", "at", "that", "when", "I", "try", "to", "address", "the", "issue", "mention", "above", "in", "which", "CCHAIN", "entries", "be", "not", "get", "cleaned", "up", "when", "a", "foreign", "callable", "routine", "raises", "an", "exception", "NUMBER", "Yes", "it", "be", "unfortunate", "that", "was", "chosen", "as", "a", "way", "to", "do", "this", "since", "some", "file", "systems", "seem", "to", "have", "trouble", "with", "NUMBER", "It", "be", "worth", "noting", "that", "most", "modern", "file", "systems", "allow", "in", "file", "names", "NUMBER", "Windows", "seems", "to", "be", "the", "hold", "out", "although", "the", "Windows", "Filesystem", "Character", "Set", "LINK", "us", "library", "windows", "desktop", "dd", "NUMBER", "NUMBER", "v", "vs", "NUMBER", "NUMBER", "aspx", "f", "NUMBER", "MSPPError", "NUMBER", "page", "do", "not", "list", "as", "a", "restriction", "in", "test", "it", "seems", "the", "DOS", "command", "shell", "do", "restrict", "this", "though", "the", "cygwin", "and", "bash", "interfaces", "support", "it", "NUMBER", "All", "of", "that", "said", "I", "m", "not", "a", "huge", "fan", "of", "the", "solution", "you", "ve", "outlined", "here", "NUMBER", "Part", "of", "the", "problem", "be", "that", "it", "makes", "assumptions", "about", "the", "underlying", "file", "system", "that", "be", "overly", "restrictive", "in", "almost", "every", "case", "NUMBER", "Unicode", "characters", "including", "spaces", "punctuation", "etc", "NUMBER", "be", "allow", "on", "many", "operate", "systems", "and", "a", "translation", "that", "restricts", "to", "the", "character", "ranges", "a", "z", "A", "Z", "NUMBER", "NUMBER", "and", "seems", "extremely", "overly", "restrictive", "NUMBER", "Especially", "considering", "_", "be", "also", "a", "commonly", "use", "file", "name", "element", "NUMBER", "One", "possible", "solution", "be", "to", "expose", "a", "hook", "to", "how", "the", "file", "name", "be", "generate", "from", "the", "path", "to", "allow", "people", "to", "decide", "how", "restrictive", "they", "want", "the", "file", "system", "translation", "to", "be", "NUMBER", "Right", "now", "that", "library", "search", "be", "already", "a", "fairly", "complicated", "processes", "since", "it", "looks", "through", "the", "cartesian", "product", "of", "the", "library", "directories", "and", "extensions", "and", "searches", "for", "matching", "pairs", "of", "source", "and", "binary", "libraries", "optionally", "recompiling", "libraries", "if", "the", "source", "code", "of", "the", "library", "or", "it", "s", "dependencies", "has", "change", "since", "the", "last", "time", "the", "library", "was", "compiled", "NUMBER", "I", "d", "have", "to", "think", "some", "about", "how", "this", "would", "plug", "in", "to", "the", "system", "and", "how", "this", "should", "be", "expose", "NUMBER", "Sorry", "I", "did", "not", "get", "this", "in", "before", "the", "release", "NUMBER", "The", "INSERTREVISIONMONTHSPACEYEAR", "tag", "in", "there", "was", "something", "that", "needed", "to", "be", "replaced", "by", "hand", "when", "the", "documents", "be", "generate", "NUMBER", "I", "have", "replaced", "this", "with", "a", "little", "code", "to", "put", "the", "current", "month", "and", "year", "in", "the", "corresponding", "place", "in", "the", "document", "and", "it", "should", "build", "without", "needing", "the", "hand", "editing", "as", "of", "commit", "NUMBER", "febe", "NUMBER", "b", "NUMBER", "Thanks", "for", "the", "reminder", "marcomaggi", "I", "ve", "add", "the", "finished", "documents", "and", "intermediate", "file", "to", "the", "NUMBER", "gitignore", "As", "far", "as", "an", "install", "docs", "rule", "in", "the", "makefile", "the", "current", "install", "writes", "these", "documents", "to", "tmp", "in", "preparation", "for", "putting", "them", "online", "NUMBER", "So", "before", "we", "add", "an", "install", "docs", "we", "probably", "need", "to", "decide", "where", "these", "should", "go", "NUMBER", "For", "unix", "like", "operate", "systems", "I", "think", "putting", "these", "in", "usr", "share", "csv", "TAG", "or", "usr", "local", "share", "csv", "TAG", "be", "probably", "the", "natural", "default", "for", "these", "we", "could", "put", "this", "under", "the", "installprefix", "directory", "and", "add", "an", "installdocsuffix", "for", "controlling", "this", "under", "the", "installprefix", "as", "we", "do", "with", "the", "manual", "pages", "NUMBER", "I", "m", "not", "sure", "about", "Windows", "INSTALL", "though", "for", "cygwin", "we", "could", "certainly", "follow", "the", "same", "convention", "NUMBER", "Nice", "work", "It", "build", "fine", "with", "Bash", "WSL", "NUMBER", "Please", "squash", "and", "rebase", "the", "two", "commit", "and", "I", "ll", "merge", "it", "into", "master", "NUMBER", "I", "install", "Git", "Large", "File", "Storage", "LINK", "lfs", "NUMBER", "github", "NUMBER", "com", "and", "it", "integrated", "seamlessly", "with", "git", "NUMBER", "I", "then", "run", "git", "lfs", "migrate", "import", "include", "NUMBER", "boot", "include", "ref", "refs", "heads", "master", "to", "rewrite", "the", "master", "branch", "use", "LFS", "NUMBER", "I", "push", "the", "result", "to", "LINK", "Running", "git", "clone", "on", "this", "repository", "downloaded", "a", "mere", "NUMBER", "MB", "and", "still", "allows", "me", "to", "go", "back", "in", "time", "and", "retrieve", "the", "boot", "file", "NUMBER", "akeep", "do", "TravisCI", "work", "with", "GitHub", "s", "large", "file", "support", "It", "looks", "as", "though", "it", "s", "support", "by", "default", "on", "Linux", "machines", "but", "requires", "an", "install", "for", "macOS", "NUMBER", "I", "followed", "the", "example", "and", "get", "it", "to", "work", "on", "macOS", "but", "it", "broke", "all", "the", "Linux", "build", "because", "they", "don", "t", "have", "Homebrew", "NUMBER", "I", "figured", "out", "how", "to", "get", "it", "to", "work", "by", "update", "NUMBER", "travis", "NUMBER", "yml", "with", "the", "following", "before_install", "if", "TRAVIS_OS_NAME", "osx", "then", "brew", "install", "git", "lfs", "fi", "if", "TRAVIS_OS_NAME", "osx", "then", "git", "lfs", "install", "fi", "before_script", "if", "TRAVIS_OS_NAME", "osx", "then", "git", "lfs", "pull", "fi", "I", "didn", "t", "do", "anything", "about", "GitHub", "authentication", "and", "it", "seems", "to", "be", "work", "NUMBER", "Installing", "git", "lfs", "be", "easy", "on", "Linux", "macOS", "and", "Windows", "NUMBER", "The", "documentation", "online", "be", "easy", "to", "follow", "NUMBER", "What", "other", "things", "should", "we", "investigate", "to", "determine", "if", "we", "want", "to", "use", "git", "lfs", "for", "Chez", "Scheme", "I", "delete", "my", "copy", "because", "it", "exceeded", "the", "NUMBER", "GB", "GitHub", "LFS", "free", "limit", "NUMBER", "Thanks", "Peter", "Would", "you", "please", "add", "a", "line", "to", "LOG", "indicating", "that", "you", "change", "c", "vs", "NUMBER", "bat", "and", "squash", "the", "NUMBER", "commit", "into", "one", "Some", "of", "the", "mat", "failures", "be", "because", "you", "don", "t", "have", "iconv", "NUMBER", "dll", "in", "the", "bin", "m", "folder", "NUMBER", "I", "use", "LINK", "iconv", "win", "iconv", "to", "build", "one", "for", "i", "NUMBER", "nt", "and", "a", "NUMBER", "nt", "NUMBER", "The", "directory", "list", "failures", "with", "depend", "on", "code", "in", "c", "io", "NUMBER", "c", "NUMBER", "It", "uses", "HOMEDRIVE", "and", "HOMEPATH", "NUMBER", "Perhaps", "that", "code", "should", "use", "USERPROFILE", "instead", "I", "install", "Visual", "Studio", "NUMBER", "BuildTools", "and", "the", "a", "NUMBER", "nt", "machine", "pass", "the", "mats", "o", "NUMBER", "and", "o", "NUMBER", "NUMBER", "Thanks", "for", "point", "this", "out", "It", "should", "be", "fix", "in", "commit", "f", "NUMBER", "ec", "NUMBER", "e", "NUMBER", "cf", "NUMBER", "f", "NUMBER", "d", "NUMBER", "b", "NUMBER", "b", "NUMBER", "e", "NUMBER", "Michael", "Adams", "created", "a", "type", "recovery", "algorithm", "and", "implement", "it", "for", "Chez", "Scheme", "as", "part", "of", "his", "dissertation", "research", "with", "help", "from", "Andy", "Keep", "and", "others", "but", "I", "never", "took", "the", "time", "to", "put", "it", "into", "the", "release", "stream", "which", "would", "have", "involved", "fleshing", "out", "the", "primdata", "information", "among", "other", "things", "NUMBER", "Before", "incorporating", "another", "solution", "it", "would", "be", "nice", "to", "give", "that", "work", "a", "close", "look", "NUMBER", "This", "paper", "LINK", "_flow_sensitive_cfa", "paper", "NUMBER", "oopsla", "NUMBER", "pdf", "describes", "the", "algorithm", "NUMBER", "Hey", "gus", "massa", "Thanks", "for", "all", "your", "work", "on", "this", "It", "looks", "like", "this", "pull", "request", "be", "not", "quite", "ready", "to", "go", "though", "because", "when", "I", "run", "the", "Chez", "Scheme", "unit", "test", "I", "end", "up", "with", "a", "variety", "of", "failures", "NUMBER", "I", "would", "note", "that", "you", "should", "not", "need", "to", "change", "the", "NUMBER", "travis", "NUMBER", "yml", "file", "to", "get", "things", "work", "if", "your", "boot", "file", "be", "up", "to", "date", "NUMBER", "Two", "types", "of", "error", "I", "saw", "I", "saw", "two", "types", "of", "unit", "test", "failures", "when", "run", "the", "mats", "NUMBER", "First", "there", "be", "a", "few", "places", "where", "the", "output", "of", "cp", "NUMBER", "be", "test", "and", "the", "cptypes", "pass", "improves", "on", "the", "output", "by", "use", "unsafe", "primitives", "in", "place", "of", "the", "type", "checking", "version", "NUMBER", "These", "if", "you", "think", "they", "be", "correct", "you", "should", "go", "ahead", "and", "update", "NUMBER", "As", "part", "of", "the", "review", "process", "these", "change", "will", "be", "looked", "at", "as", "well", "NUMBER", "Second", "there", "be", "places", "where", "the", "change", "in", "the", "PR", "be", "leading", "to", "some", "error", "in", "the", "mats", "NUMBER", "The", "sint", "list", "bytevector", "procedure", "be", "incorrectly", "optimized", "when", "compile", "the", "Chez", "Scheme", "libraries", "and", "this", "be", "leading", "a", "handful", "to", "test", "relate", "to", "it", "to", "fail", "and", "there", "be", "places", "where", "a", "specific", "error", "was", "expected", "and", "there", "be", "now", "an", "invalid", "memory", "reference", "error", "NUMBER", "I", "spent", "some", "time", "looking", "into", "the", "sint", "list", "bytevector", "problem", "and", "I", "was", "able", "to", "isolate", "it", "to", "an", "erroneous", "optimization", "that", "be", "get", "rid", "of", "a", "loop", "in", "the", "case", "of", "a", "list", "of", "NUMBER", "bit", "sign", "integers", "NUMBER", "The", "original", "bytevector", "NUMBER", "ss", "file", "be", "a", "little", "big", "to", "operate", "on", "so", "I", "managed", "to", "pair", "it", "down", "to", "a", "smaller", "test", "that", "demonstrates", "the", "problem", "scheme", "define", "s", "NUMBER", "native", "list", "bytevector", "lambda", "ls", "let", "v", "make", "bytevector", "fx", "length", "ls", "NUMBER", "let", "loop", "ls", "ls", "i", "NUMBER", "unless", "null", "ls", "let", "k", "car", "ls", "unless", "and", "fixnum", "k", "fx", "TAG", "bytevector", "lambda", "ls", "NUMBER", "let", "v", "NUMBER", "NUMBER", "make", "bytevector", "NUMBER", "fx", "NUMBER", "NUMBER", "length", "ls", "NUMBER", "letrec", "loop", "NUMBER", "lambda", "ls", "NUMBER", "i", "NUMBER", "if", "NUMBER", "null", "ls", "NUMBER", "NUMBER", "void", "begin", "let", "k", "NUMBER", "NUMBER", "car", "ls", "NUMBER", "if", "if", "NUMBER", "fixnum", "k", "NUMBER", "NUMBER", "fx", "TAG", "bytevector", "lambda", "ls", "NUMBER", "let", "v", "NUMBER", "NUMBER", "make", "bytevector", "NUMBER", "fx", "NUMBER", "NUMBER", "length", "ls", "NUMBER", "if", "NUMBER", "null", "ls", "NUMBER", "NUMBER", "void", "let", "k", "NUMBER", "NUMBER", "car", "ls", "NUMBER", "if", "if", "NUMBER", "fixnum", "k", "NUMBER", "NUMBER", "fx", "TAG", "bytevector", "lambda", "ls", "NUMBER", "let", "v", "NUMBER", "NUMBER", "make", "bytevector", "NUMBER", "fx", "NUMBER", "NUMBER", "length", "ls", "NUMBER", "letrec", "loop", "NUMBER", "lambda", "ls", "NUMBER", "i", "NUMBER", "if", "NUMBER", "null", "ls", "NUMBER", "NUMBER", "void", "begin", "let", "k", "NUMBER", "NUMBER", "car", "ls", "NUMBER", "if", "if", "NUMBER", "fixnum", "k", "NUMBER", "NUMBER", "fx", "TAG", "bytevector", "lambda", "ls", "NUMBER", "let", "v", "NUMBER", "NUMBER", "make", "bytevector", "NUMBER", "fx", "NUMBER", "NUMBER", "length", "ls", "NUMBER", "letrec", "loop", "NUMBER", "lambda", "ls", "NUMBER", "i", "NUMBER", "if", "NUMBER", "null", "ls", "NUMBER", "NUMBER", "void", "let", "k", "NUMBER", "NUMBER", "car", "ls", "NUMBER", "if", "if", "NUMBER", "fixnum", "k", "NUMBER", "NUMBER", "fx", "TAG", "About", "the", "ideas", "for", "change", "change", "empty", "x", "eq", "x", "TAG", "OK", "NUMBER", "I", "m", "only", "worry", "about", "the", "possibility", "in", "the", "future", "of", "reusing", "fxmap", "NUMBER", "ss", "in", "another", "pass", "like", "cp", "NUMBER", "and", "get", "a", "different", "singleton", "NUMBER", "This", "would", "be", "a", "problem", "be", "the", "fxmaps", "be", "somehow", "stored", "and", "shared", "NUMBER", "This", "problem", "be", "too", "hypothetical", "so", "it", "can", "be", "solve", "with", "a", "comment", "in", "the", "file", "with", "a", "warning", "for", "the", "future", "NUMBER", "Actually", "you", "be", "already", "treating", "this", "as", "a", "singleton", "in", "places", "where", "you", "return", "empty", "fxmap", "in", "fxmap", "remoe", "and", "fxmap", "remove", "base", "and", "when", "you", "initialize", "pred", "env", "empty", "it", "be", "treated", "as", "potentially", "different", "only", "in", "fxmap", "for", "each", "diff", "There", "be", "three", "lines", "in", "cptypes", "NUMBER", "ss", "that", "have", "a", "CHECK", "reminder", "warning", "NUMBER", "These", "be", "parts", "that", "I", "think", "that", "be", "correct", "but", "I", "m", "not", "sure", "NUMBER", "For", "example", "the", "clause", "for", "immutable", "list", "in", "cptypes", "raw", "NUMBER", "I", "think", "that", "you", "already", "looked", "at", "the", "code", "and", "thought", "it", "was", "fine", "but", "can", "you", "take", "another", "look", "at", "them", "so", "I", "remove", "the", "reminder", "warning", "The", "immutable", "list", "and", "cte", "optimization", "lock", "look", "good", "to", "me", "NUMBER", "immutable", "list", "be", "a", "special", "case", "that", "allows", "for", "cp", "NUMBER", "to", "look", "inside", "a", "list", "it", "knows", "was", "constructed", "during", "expansion", "of", "some", "internal", "syntax", "when", "we", "know", "there", "be", "no", "way", "it", "could", "be", "modify", "so", "we", "can", "treat", "it", "as", "constant", "without", "doing", "any", "escape", "analysis", "on", "it", "NUMBER", "The", "predicate", "implies", "check", "be", "a", "good", "question", "NUMBER", "Obviously", "eq", "be", "the", "safest", "check", "here", "though", "I", "think", "eqv", "be", "also", "safe", "enough", "NUMBER", "In", "theory", "I", "believe", "that", "these", "be", "quoted", "constants", "which", "should", "not", "mutated", "though", "Chez", "Scheme", "do", "not", "prevent", "this", "mutation", "NUMBER", "That", "said", "I", "think", "I", "d", "rather", "stick", "with", "eqv", "right", "now", "unless", "we", "find", "some", "places", "where", "we", "think", "this", "be", "be", "overly", "conservative", "NUMBER", "If", "we", "do", "loosen", "it", "up", "we", "may", "also", "want", "to", "consider", "checking", "for", "record", "equality", "which", "r", "NUMBER", "rs", "equal", "do", "not", "do", "NUMBER", "Sounds", "good", "NUMBER", "If", "the", "recursion", "be", "now", "within", "cptypes", "and", "the", "body", "expression", "be", "just", "a", "call", "to", "Expr", "then", "all", "of", "the", "cata", "morphisms", "can", "have", "the", "cptypes", "remove", "NUMBER", "This", "will", "cause", "Expr", "to", "recur", "to", "Expr", "directly", "for", "the", "cata", "morphisms", "NUMBER", "It", "probably", "won", "t", "have", "a", "measurable", "impact", "on", "performance", "but", "it", "do", "simplify", "the", "code", "a", "bit", "NUMBER", "I", "agree", "on", "the", "eqv", "I", "think", "get", "the", "numeric", "equivalence", "be", "worthwhile", "NUMBER", "Cool", "NUMBER", "I", "ll", "can", "rebuild", "the", "boot", "file", "after", "merge", "this", "in", "to", "a", "local", "copy", "of", "master", "NUMBER", "We", "should", "get", "the", "LOG", "and", "CSUG", "change", "pull", "in", "too", "if", "we", "can", "NUMBER", "I", "can", "take", "a", "look", "at", "this", "over", "the", "weekend", "and", "hopefully", "get", "things", "put", "together", "NUMBER", "Just", "so", "I", "understand", "it", "sounds", "like", "the", "things", "you", "checked", "in", "on", "this", "pull", "request", "be", "up", "to", "date", "with", "the", "exception", "of", "the", "LOG", "and", "CSUG", "change", "NUMBER", "As", "far", "as", "the", "travis", "change", "I", "ve", "actually", "re", "do", "how", "travis", "checks", "things", "on", "master", "and", "it", "should", "be", "doing", "the", "checking", "correctly", "now", "though", "it", "will", "still", "run", "afoul", "of", "the", "change", "that", "invalid", "the", "boot", "file", "NUMBER", "It", "took", "me", "a", "bit", "more", "effort", "than", "I", "expected", "to", "get", "the", "boot", "file", "build", "but", "I", "managed", "to", "get", "these", "build", "and", "test", "NUMBER", "Unfortunately", "in", "test", "I", "run", "into", "what", "looks", "like", "it", "might", "be", "an", "unexpect", "error", "NUMBER", "I", "was", "test", "on", "a", "NUMBER", "osx", "i", "NUMBER", "osx", "ti", "NUMBER", "osx", "and", "ta", "NUMBER", "osx", "and", "run", "into", "a", "strange", "bug", "on", "one", "of", "the", "runs", "of", "ta", "NUMBER", "osx", "NUMBER", "I", "m", "get", "the", "error", "pred", "env", "union", "base", "when", "run", "one", "of", "the", "threaded", "test", "NUMBER", "My", "suspicion", "be", "that", "something", "be", "get", "fouled", "up", "with", "all", "the", "threads", "run", "there", "be", "a", "call", "to", "eval", "in", "the", "thread", "test", "which", "be", "invoking", "the", "cptypes", "pass", "scheme", "NUMBER", "define", "pred", "env", "union", "from", "from", "base", "types", "new", "base", "NUMBER", "Calculate", "the", "union", "of", "types", "and", "from", "and", "intersect", "it", "with", "new", "base", "NUMBER", "Iterate", "over", "the", "difference", "of", "from", "and", "base", "NUMBER", "NUMBER", "let", "ret", "new", "base", "NUMBER", "fxmap", "for", "each", "diff", "lambda", "key", "x", "y", "NUMBER", "let", "z", "fxmap", "ref", "types", "key", "f", "NUMBER", "x", "from", "NUMBER", "y", "base", "NUMBER", "z", "types", "NUMBER", "set", "ret", "pred", "env", "add", "key", "ret", "key", "pred", "union", "x", "z", "NUMBER", "lambda", "key", "x", "NUMBER", "let", "z", "fxmap", "ref", "types", "key", "f", "NUMBER", "x", "from", "NUMBER", "z", "types", "NUMBER", "set", "ret", "pred", "env", "add", "key", "ret", "key", "pred", "union", "x", "z", "NUMBER", "lambda", "key", "x", "error", "pred", "env", "union", "base", "void", "NUMBER", "from", "NUMBER", "base", "NUMBER", "ret", "It", "looks", "like", "line", "NUMBER", "in", "this", "test", "be", "get", "something", "unexpect", "but", "I", "have", "not", "yet", "figured", "out", "why", "nor", "do", "I", "have", "a", "good", "way", "to", "reproduce", "this", "quite", "yet", "NUMBER", "The", "fact", "that", "this", "only", "showed", "up", "in", "one", "machine", "type", "of", "the", "two", "that", "run", "the", "thread", "test", "and", "then", "only", "in", "one", "of", "the", "twelve", "runs", "of", "this", "tells", "me", "that", "something", "intermittent", "and", "well", "buried", "be", "going", "on", "in", "this", "code", "so", "it", "might", "take", "some", "effort", "to", "ferret", "it", "out", "NUMBER", "Just", "FYI", "we", "should", "update", "this", "error", "message", "to", "use", "oops", "or", "impoops", "if", "you", "think", "this", "should", "be", "impossible", "with", "a", "who", "argument", "like", "compiler", "internal", "and", "a", "little", "bit", "more", "meaningful", "error", "message", "to", "give", "us", "some", "kind", "of", "indication", "as", "to", "what", "might", "have", "fail", "NUMBER", "We", "try", "to", "stick", "to", "use", "oops", "or", "impoops", "inside", "the", "compiler", "though", "I", "notice", "a", "few", "error", "or", "error", "calls", "have", "leaked", "in", "from", "place", "to", "place", "NUMBER", "The", "actual", "error", "I", "saw", "was", "in", "the", "following", "summary", "from", "a", "ta", "NUMBER", "osx", "run", "the", "three", "error", "be", "all", "in", "a", "row", "and", "the", "second", "one", "be", "almost", "certainly", "the", "result", "of", "the", "first", "though", "the", "third", "one", "may", "or", "may", "not", "be", "relate", "cat", "NUMBER", "mats", "summary", "o", "NUMBER", "o", "NUMBER", "o", "NUMBER", "cp", "NUMBER", "t", "cl", "NUMBER", "o", "NUMBER", "cp", "NUMBER", "t", "cl", "NUMBER", "o", "NUMBER", "spi", "t", "p", "t", "o", "NUMBER", "spi", "t", "p", "t", "o", "NUMBER", "eval", "interpret", "cl", "NUMBER", "o", "NUMBER", "eval", "interpret", "cl", "NUMBER", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "NUMBER", "a", "NUMBER", "NUMBER", "thread", "NUMBER", "mo", "Error", "in", "mat", "thread", "clause", "NUMBER", "pred", "env", "union", "base", "at", "line", "NUMBER", "char", "NUMBER", "of", "thread", "NUMBER", "ms", "thread", "NUMBER", "mo", "Error", "in", "mat", "thread", "clause", "NUMBER", "extra", "threads", "run", "TAG", "TAG", "TAG", "TAG", "TAG", "TAG", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "thread", "NUMBER", "ms", "thread", "NUMBER", "mo", "Bug", "in", "mat", "thread", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "thread", "NUMBER", "ms", "o", "NUMBER", "ehc", "t", "eoc", "f", "cl", "NUMBER", "o", "NUMBER", "ehc", "t", "eval", "interpret", "Oh", "almost", "forgot", "NUMBER", "I", "ll", "continue", "to", "poke", "at", "this", "a", "bit", "but", "any", "insight", "you", "can", "provide", "would", "be", "helpful", "NUMBER", "Thanks", "I", "believe", "the", "only", "place", "more", "than", "one", "compiler", "session", "should", "have", "its", "hands", "on", "the", "same", "prelex", "be", "as", "part", "of", "the", "cte", "optimization", "info", "relate", "to", "a", "symbol", "or", "as", "part", "of", "the", "box", "in", "the", "cte", "optimization", "loc", "NUMBER", "cp", "NUMBER", "depends", "on", "this", "be", "true", "for", "more", "than", "just", "the", "prelex", "operand", "info", "it", "be", "also", "modifying", "the", "prelex", "name", "which", "be", "uses", "to", "replace", "incoming", "prelex", "records", "with", "new", "prelex", "record", "NUMBER", "cpnanopass", "also", "relies", "on", "this", "when", "it", "replaces", "the", "prelex", "with", "uvar", "records", "NUMBER", "So", "if", "we", "can", "have", "multiple", "compiler", "sessions", "run", "simultaneously", "with", "their", "hands", "on", "the", "same", "prelex", "I", "would", "expect", "these", "places", "to", "also", "be", "a", "problem", "though", "the", "nature", "of", "race", "conditions", "be", "that", "they", "might", "not", "show", "up", "very", "often", "so", "it", "be", "possible", "we", "ve", "just", "not", "had", "quite", "the", "right", "conditions", "to", "expose", "this", "NUMBER", "All", "of", "that", "said", "we", "should", "be", "able", "to", "look", "into", "this", "and", "check", "for", "it", "by", "putting", "in", "some", "auxiliary", "information", "in", "the", "cptypes", "pass", "to", "identify", "a", "prelex", "we", "be", "seeing", "for", "the", "first", "time", "that", "already", "has", "its", "prelex", "operand", "set", "NUMBER", "We", "ve", "certainly", "had", "cases", "where", "we", "were", "allowing", "a", "single", "prelex", "record", "to", "be", "use", "at", "more", "then", "one", "binding", "form", "within", "the", "system", "which", "led", "to", "some", "problem", "NUMBER", "One", "other", "thing", "worth", "noting", "on", "this", "be", "that", "prelex", "records", "be", "created", "as", "part", "of", "the", "expander", "process", "and", "each", "compiler", "session", "runs", "its", "own", "expander", "so", "it", "be", "creating", "new", "prelex", "records", "for", "the", "code", "it", "produces", "NUMBER", "In", "order", "for", "multiple", "sessions", "to", "have", "a", "handle", "on", "the", "same", "prelex", "it", "would", "need", "to", "be", "the", "case", "that", "output", "from", "a", "single", "expander", "session", "get", "sent", "to", "multiple", "compiler", "instances", "NUMBER", "The", "only", "way", "I", "know", "of", "that", "this", "can", "happen", "be", "from", "a", "code", "fragment", "be", "inlined", "from", "the", "cte", "optimization", "loc", "box", "aka", "the", "cross", "library", "optimization", "information", "from", "another", "library", "which", "I", "don", "t", "think", "we", "should", "be", "seeing", "here", "but", "that", "be", "definitely", "worth", "looking", "in", "to", "NUMBER", "It", "might", "be", "a", "few", "of", "days", "before", "I", "get", "a", "chance", "to", "spend", "much", "time", "on", "this", "again", "but", "hopefully", "we", "can", "get", "a", "reproducible", "which", "will", "make", "me", "more", "confident", "in", "our", "fix", "One", "question", "I", "did", "have", "in", "the", "fxmap", "code", "be", "why", "you", "decided", "to", "have", "the", "merge", "function", "run", "by", "side", "effect", "instead", "of", "constructing", "the", "output", "functionally", "Was", "this", "just", "to", "try", "to", "optimize", "around", "the", "O", "m", "n", "worst", "case", "of", "the", "merge", "function", "Sorry", "that", "I", "ve", "be", "a", "little", "slow", "get", "back", "to", "this", "work", "was", "a", "bit", "hectic", "and", "it", "has", "taken", "me", "a", "little", "bit", "of", "time", "to", "get", "back", "to", "this", "NUMBER", "Just", "to", "make", "sure", "I", "understand", "the", "differences", "currently", "in", "this", "PR", "be", "with", "your", "change", "that", "seem", "to", "run", "without", "error", "across", "the", "board", "but", "if", "I", "take", "a", "look", "at", "your", "branch", "NUMBER", "NUMBER", "Types", "Pass", "Error", "LINK", "massa", "ChezScheme", "commit", "NUMBER", "NUMBER", "Types", "Pass", "Error", "it", "will", "fail", "reliably", "in", "the", "threaded", "test", "NUMBER", "Is", "your", "suspicion", "that", "the", "change", "in", "the", "current", "PR", "still", "have", "the", "bug", "but", "have", "chased", "it", "into", "hiding", "I", "ve", "made", "some", "change", "in", "a", "local", "copy", "of", "this", "to", "match", "recent", "commit", "merge", "master", "into", "this", "set", "of", "change", "and", "I", "m", "currently", "run", "all", "the", "test", "in", "a", "NUMBER", "osx", "i", "NUMBER", "osx", "ta", "NUMBER", "osx", "and", "ti", "NUMBER", "osx", "on", "my", "mac", "NUMBER", "So", "far", "this", "seems", "to", "be", "run", "along", "fine", "but", "if", "we", "think", "there", "be", "still", "bug", "hiding", "at", "the", "intersection", "of", "the", "prelex", "counter", "code", "change", "and", "the", "threaded", "version", "I", "can", "try", "to", "dig", "into", "that", "a", "bit", "though", "I", "m", "not", "sure", "if", "I", "ll", "have", "a", "chance", "to", "finish", "it", "up", "this", "week", "and", "I", "m", "traveling", "over", "the", "long", "weekend", "NUMBER", "Thanks", "for", "continuing", "to", "push", "this", "along", "I", "feel", "like", "we", "re", "really", "close", "to", "get", "this", "in", "NUMBER", "I", "had", "a", "little", "time", "today", "to", "experiment", "with", "the", "NUMBER", "NUMBER", "Types", "Pass", "Error", "LINK", "massa", "ChezScheme", "commit", "NUMBER", "NUMBER", "Types", "Pass", "Error", "branch", "and", "you", "be", "not", "test", "what", "you", "think", "you", "be", "test", "NUMBER", "The", "problem", "with", "the", "test", "be", "that", "the", "counter", "and", "hash", "table", "be", "effectively", "be", "allocated", "only", "once", "instead", "of", "each", "time", "cptypes", "be", "run", "NUMBER", "Since", "cptypes", "be", "run", "multiple", "times", "it", "be", "actually", "the", "same", "thread", "that", "be", "seeing", "the", "same", "prelex", "across", "multiple", "invocations", "of", "cptypes", "NUMBER", "When", "I", "looked", "at", "the", "test", "my", "first", "thought", "was", "that", "I", "wanted", "to", "have", "proof", "that", "it", "was", "in", "fact", "different", "threads", "that", "were", "be", "the", "same", "prelex", "so", "instead", "of", "storing", "just", "the", "index", "in", "the", "prelex", "operand", "flag", "I", "had", "it", "store", "a", "pair", "of", "the", "count", "and", "the", "thread", "id", "from", "get", "thread", "id", "NUMBER", "When", "I", "run", "this", "I", "had", "the", "error", "message", "include", "the", "thread", "id", "as", "part", "of", "the", "result", "NUMBER", "What", "I", "saw", "was", "that", "it", "was", "the", "same", "thread", "id", "that", "had", "both", "assigned", "the", "prelex", "and", "was", "now", "re", "assigning", "the", "prelex", "NUMBER", "The", "update", "prelex", "counter", "code", "scheme", "define", "prelex", "counter", "let", "define", "count", "NUMBER", "define", "know", "make", "eq", "hashtable", "lambda", "x", "when", "prelex", "operand", "x", "let", "k", "eq", "hashtable", "ref", "know", "car", "prelex", "operand", "x", "f", "if", "k", "unless", "eq", "x", "k", "newline", "printf", "matting", "cptypes", "duplicate", "prelex", "counter", "with", "s", "and", "s", "s", "on", "thread", "s", "s", "on", "thread", "s", "x", "k", "car", "prelex", "operand", "x", "cdr", "prelex", "operand", "x", "count", "get", "thread", "id", "newline", "impoops", "cptypes", "duplicate", "prelex", "counter", "with", "s", "and", "s", "s", "on", "thread", "s", "s", "on", "thread", "s", "x", "k", "car", "prelex", "operand", "x", "cdr", "prelex", "operand", "x", "count", "get", "thread", "id", "begin", "newline", "printf", "matting", "cptypes", "unexpect", "prelex", "counter", "with", "s", "s", "on", "thread", "s", "s", "on", "thread", "s", "x", "car", "prelex", "operand", "x", "cdr", "prelex", "operand", "x", "count", "get", "thread", "id", "newline", "impoops", "cptypes", "unexpect", "prelex", "counter", "with", "s", "s", "on", "thread", "s", "s", "on", "thread", "s", "x", "car", "prelex", "operand", "x", "cdr", "prelex", "operand", "x", "count", "get", "thread", "id", "or", "let", "p", "prelex", "operand", "x", "and", "p", "car", "p", "let", "c", "count", "set", "count", "fx", "count", "NUMBER", "prelex", "operand", "set", "x", "cons", "c", "get", "thread", "id", "eq", "hashtable", "set", "know", "c", "x", "c", "One", "run", "of", "compile", "the", "thread", "NUMBER", "mo", "mats", "for", "instance", "showed", "amongst", "other", "some", "cascading", "thread", "error", "Error", "in", "mat", "thread", "clause", "NUMBER", "cptypes", "duplicate", "prelex", "counter", "with", "ignore", "and", "ignore", "NUMBER", "on", "thread", "NUMBER", "NUMBER", "on", "thread", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "thread", "NUMBER", "ms", "Error", "in", "mat", "thread", "clause", "NUMBER", "cptypes", "duplicate", "prelex", "counter", "with", "tmp", "and", "x", "NUMBER", "on", "thread", "NUMBER", "NUMBER", "on", "thread", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "thread", "NUMBER", "ms", "In", "both", "cases", "the", "setter", "and", "the", "detection", "were", "on", "the", "same", "thread", "NUMBER", "in", "the", "first", "case", "NUMBER", "in", "the", "second", "case", "NUMBER", "One", "way", "to", "avoid", "this", "problem", "be", "to", "move", "the", "creation", "of", "the", "hash", "table", "and", "the", "counter", "within", "the", "pass", "probably", "I", "should", "have", "do", "this", "when", "I", "change", "prelex", "counter", "in", "the", "first", "place", "since", "the", "intention", "was", "for", "count", "to", "start", "at", "NUMBER", "for", "each", "case", "NUMBER", "I", "ended", "up", "moving", "the", "define", "pass", "line", "up", "above", "the", "prelex", "counter", "definition", "along", "with", "all", "of", "the", "other", "function", "definitions", "in", "the", "code", "NUMBER", "This", "required", "a", "bit", "of", "re", "giggering", "of", "the", "code", "since", "pred", "env", "empty", "was", "no", "longer", "in", "scope", "NUMBER", "You", "can", "see", "the", "update", "and", "the", "diff", "in", "this", "gist", "LINK", "NUMBER", "So", "I", "m", "going", "to", "see", "if", "I", "m", "going", "to", "pull", "some", "of", "the", "change", "in", "the", "gist", "into", "my", "current", "copy", "of", "this", "and", "give", "it", "a", "try", "run", "the", "full", "Chez", "Scheme", "bully", "test", "to", "see", "if", "I", "can", "get", "the", "error", "to", "occur", "if", "it", "survives", "the", "bully", "test", "I", "m", "going", "to", "be", "tempted", "to", "merge", "this", "though", "I", "may", "also", "ask", "for", "a", "second", "opinion", "on", "where", "we", "ended", "up", "NUMBER", "Thanks", "again", "gus", "massa", "I", "think", "you", "should", "be", "able", "to", "test", "this", "by", "disabling", "cp", "NUMBER", "since", "we", "now", "run", "the", "cptypes", "pass", "as", "part", "of", "the", "block", "with", "cpletrec", "so", "that", "it", "runs", "regardless", "of", "if", "cp", "NUMBER", "be", "on", "or", "not", "NUMBER", "Actually", "I", "made", "this", "change", "for", "exactly", "this", "reason", "NUMBER", "I", "ve", "also", "discussed", "this", "pass", "a", "bit", "with", "dybvig", "partially", "to", "verify", "my", "assumptions", "around", "how", "we", "be", "use", "the", "prelex", "in", "the", "cptypes", "pass", "NUMBER", "As", "part", "of", "our", "conversation", "he", "asked", "if", "you", "had", "tried", "write", "this", "up", "in", "a", "paper", "NUMBER", "We", "both", "agree", "that", "this", "can", "be", "helpful", "in", "checking", "the", "reasoning", "on", "the", "path", "and", "I", "think", "it", "would", "help", "dybvig", "and", "I", "to", "better", "understand", "exactly", "what", "be", "going", "on", "in", "the", "pass", "NUMBER", "I", "feel", "like", "I", "have", "a", "decent", "general", "understanding", "but", "there", "be", "still", "some", "parts", "particularly", "around", "the", "type", "environment", "maintenance", "that", "I", "don", "t", "fully", "grok", "yet", "NUMBER", "As", "I", "mention", "I", "m", "traveling", "this", "weekend", "in", "fact", "I", "was", "supposed", "to", "be", "on", "a", "plane", "right", "now", "but", "we", "re", "currently", "delayed", "do", "to", "maintenance", "issue", "with", "the", "plane", "so", "it", "will", "probably", "be", "Wednesday", "evening", "before", "I", "get", "much", "time", "to", "look", "at", "this", "again", "NUMBER", "Looks", "good", "thanks", "NUMBER", "Thanks", "I", "agree", "that", "guardians", "should", "be", "handle", "use", "the", "trigger", "mechanism", "even", "though", "chains", "might", "be", "rare", "NUMBER", "sweep", "be", "probably", "not", "the", "right", "tool", "to", "use", "to", "process", "the", "contents", "of", "the", "objects", "guarded", "by", "an", "ordered", "guardian", "NUMBER", "I", "believe", "there", "be", "at", "least", "three", "problem", "that", "might", "result", "Weak", "pair", "car", "field", "be", "not", "processed", "by", "sweep", "so", "objects", "reachable", "from", "the", "car", "field", "will", "not", "be", "ordered", "properly", "and", "cycles", "through", "the", "car", "field", "will", "not", "prevent", "the", "weak", "pair", "from", "be", "finalized", "NUMBER", "The", "processing", "of", "ephemeron", "pairs", "be", "deferred", "via", "add_ephemeron_to_pending", "NUMBER", "I", "haven", "t", "traced", "this", "through", "but", "this", "might", "cause", "a", "problem", "similar", "to", "the", "problem", "with", "weak", "pairs", "NUMBER", "In", "general", "cycles", "leading", "back", "to", "the", "object", "pass", "to", "sweep", "will", "cause", "the", "object", "to", "be", "forwarded", "out", "from", "under", "sweep", "NUMBER", "That", "be", "the", "first", "two", "field", "of", "the", "object", "be", "swept", "will", "be", "overwritten", "with", "the", "forward", "marker", "and", "forwarding", "address", "NUMBER", "In", "some", "cases", "where", "this", "might", "cause", "harm", "it", "happens", "not", "to", "do", "so", "for", "example", "if", "the", "car", "field", "of", "a", "regular", "pair", "points", "to", "the", "pair", "relocating", "the", "car", "causes", "the", "pair", "s", "field", "to", "be", "overwritten", "but", "because", "the", "cdr", "field", "be", "now", "a", "pointer", "to", "the", "new", "space", "pair", "relocating", "the", "cdr", "field", "causes", "no", "harm", "NUMBER", "In", "the", "case", "of", "code", "objects", "overwriting", "the", "first", "two", "field", "can", "cause", "the", "wrong", "length", "to", "be", "pass", "to", "S_record_code_mod", "NUMBER", "While", "the", "latter", "issue", "be", "easily", "fix", "by", "grabbing", "the", "length", "early", "the", "situation", "be", "inherently", "fragile", "NUMBER", "It", "might", "be", "possible", "to", "solve", "the", "weak", "pair", "and", "ephemeron", "pair", "problem", "with", "a", "specialized", "version", "of", "sweep", "though", "I", "believe", "that", "if", "a", "weak", "or", "ephemeron", "has", "already", "be", "forwarded", "we", "ll", "still", "have", "to", "sweep", "it", "NUMBER", "The", "other", "problem", "seems", "trickier", "NUMBER", "We", "could", "solve", "it", "by", "copying", "guarded", "objects", "before", "sweeping", "them", "but", "that", "s", "an", "unfortunate", "bit", "of", "extra", "run", "time", "overhead", "NUMBER", "This", "change", "makes", "sense", "to", "me", "otherwise", "the", "pariah", "form", "be", "worthless", "unless", "cp", "NUMBER", "be", "disabled", "NUMBER", "Please", "fix", "any", "mats", "that", "break", "as", "a", "result", "of", "the", "change", "if", "any", "and", "particularly", "if", "there", "aren", "t", "any", "that", "break", "add", "new", "test", "that", "verify", "the", "change", "has", "the", "desired", "effect", "NUMBER", "Please", "also", "add", "a", "LOG", "entry", "NUMBER", "Don", "t", "bother", "rebuilding", "boot", "file", "however", "NUMBER", "Thanks", "for", "the", "pull", "request", "but", "void", "doesn", "t", "take", "any", "argument", "so", "it", "doesn", "t", "make", "sense", "for", "the", "optimizer", "to", "discard", "them", "NUMBER", "Are", "you", "proposing", "that", "void", "should", "be", "modify", "generally", "to", "accept", "any", "number", "of", "argument", "and", "ignore", "them", "If", "so", "more", "would", "need", "to", "be", "change", "than", "cp", "NUMBER", "and", "before", "additional", "change", "be", "made", "I", "d", "like", "to", "know", "why", "it", "s", "desirable", "NUMBER", "values", "can", "already", "be", "use", "for", "this", "purpose", "in", "many", "cases", "and", "of", "course", "there", "s", "always", "begin", "or", "lambda", "r", "void", "NUMBER", "Incidentally", "the", "result", "of", "an", "argument", "expression", "evaluating", "to", "other", "than", "one", "value", "be", "unspecified", "and", "the", "compiler", "often", "chooses", "not", "to", "verify", "that", "an", "argument", "expression", "evaluates", "to", "exactly", "one", "value", "when", "no", "further", "processing", "of", "the", "value", "be", "required", "e", "NUMBER", "g", "NUMBER", "when", "the", "value", "be", "unuse", "or", "when", "the", "entire", "call", "evaluates", "to", "the", "value", "as", "in", "cons", "values", "NUMBER", "NUMBER", "so", "if", "the", "optimization", "made", "sense", "at", "optimization", "level", "NUMBER", "it", "would", "make", "sense", "at", "other", "optimization", "levels", "NUMBER", "This", "looks", "good", "to", "me", "though", "with", "the", "pull", "of", "NUMBER", "the", "make", "file", "be", "out", "of", "date", "and", "my", "attempt", "to", "fix", "the", "conflict", "lost", "the", "record", "of", "your", "commit", "NUMBER", "Would", "you", "please", "update", "the", "file", "so", "I", "can", "do", "a", "clean", "pull", "It", "looks", "like", "we", "might", "be", "use", "an", "NUMBER", "byte", "memory", "read", "where", "we", "should", "be", "use", "a", "NUMBER", "byte", "read", "to", "extract", "a", "flonum", "exponent", "and", "this", "can", "sometimes", "run", "beyond", "accessible", "memory", "NUMBER", "I", "ll", "take", "a", "deeper", "look", "and", "try", "to", "fix", "it", "NUMBER", "burgerrg", "I", "have", "a", "fix", "for", "this", "ready", "to", "push", "NUMBER", "I", "m", "holding", "off", "for", "now", "in", "case", "you", "re", "planning", "to", "pull", "the", "date", "dst", "request", "so", "samth", "need", "not", "rebase", "again", "NUMBER", "Fixed", "with", "this", "commit", "LINK", "NUMBER", "Good", "change", "thanks", "NUMBER", "Generally", "speaking", "it", "s", "not", "necessary", "to", "commit", "new", "boot", "file", "if", "the", "change", "don", "t", "affect", "compilation", "NUMBER", "For", "example", "a", "change", "in", "an", "error", "message", "or", "a", "change", "in", "the", "definition", "of", "a", "primitive", "in", "prims", "NUMBER", "ss", "would", "not", "require", "new", "boot", "file", "NUMBER", "A", "change", "to", "primdata", "NUMBER", "ss", "would", "typically", "affect", "compilation", "but", "the", "output", "type", "be", "not", "presently", "use", "for", "anything", "if", "I", "m", "not", "mistaken", "NUMBER", "I", "m", "tempted", "to", "make", "this", "fully", "backward", "incompatible", "by", "having", "every", "source", "object", "record", "line", "and", "column", "information", "in", "addition", "to", "file", "position", "information", "NUMBER", "This", "would", "add", "overhead", "to", "the", "reader", "which", "I", "don", "t", "think", "be", "a", "big", "deal", "since", "it", "doesn", "t", "tend", "to", "be", "a", "bottleneck", "on", "compilation", "at", "least", "and", "it", "would", "increase", "the", "size", "of", "every", "source", "object", "NUMBER", "We", "could", "probably", "mitigate", "the", "latter", "with", "some", "careful", "encoding", "NUMBER", "For", "example", "we", "could", "combine", "bfp", "beginning", "line", "and", "beginning", "column", "in", "a", "single", "fixnum", "when", "they", "be", "small", "enough", "and", "we", "could", "do", "the", "same", "for", "efp", "ending", "line", "and", "ending", "column", "except", "represent", "them", "as", "offsets", "from", "the", "bfp", "starting", "line", "and", "starting", "column", "to", "reduce", "the", "chance", "we", "d", "have", "to", "resort", "to", "a", "larger", "encoding", "NUMBER", "If", "this", "be", "too", "much", "of", "a", "compatibility", "hit", "we", "could", "make", "the", "line", "and", "column", "information", "optional", "NUMBER", "_If", "this", "be", "too", "much", "of", "a", "compatibility", "hit", "we", "could", "make", "the", "line", "and", "column", "information", "optional", "NUMBER", "_", "I", "guess", "that", "s", "what", "you", "ve", "already", "do", "NUMBER", "Though", "I", "would", "be", "tempted", "to", "require", "line", "and", "column", "for", "both", "bfp", "and", "efp", "or", "for", "neither", "have", "source", "object", "bfp", "and", "source", "object", "efp", "return", "simple", "positions", "and", "add", "source", "object", "b", "e", "l", "c", "procedures", "that", "return", "beginning", "and", "ending", "line", "and", "column", "all", "or", "none", "of", "which", "can", "be", "false", "NUMBER", "Source", "objects", "with", "line", "and", "column", "information", "could", "be", "represented", "by", "a", "subtype", "of", "the", "exist", "source", "objects", "NUMBER", "I", "ve", "be", "looking", "over", "the", "source", "location", "PR", "and", "have", "to", "admit", "record", "source", "lines", "and", "columns", "and", "all", "it", "entails", "aren", "t", "really", "to", "my", "liking", "NUMBER", "In", "the", "interface", "I", "don", "t", "like", "the", "rather", "indirect", "interaction", "of", "the", "record", "source", "lines", "and", "columns", "parameter", "selected", "calls", "to", "make", "source", "file", "descriptor", "and", "make", "source", "object", "nor", "do", "I", "like", "the", "need", "to", "prune", "the", "table", "explicitly", "NUMBER", "In", "the", "implementation", "putting", "the", "table", "in", "the", "source", "file", "descriptor", "sfd", "rather", "than", "say", "associating", "it", "with", "the", "sfd", "via", "a", "weak", "hashtable", "be", "problematic", "because", "it", "s", "too", "easy", "for", "the", "table", "to", "get", "write", "along", "with", "the", "sfd", "to", "an", "object", "file", "as", "will", "currently", "happen", "with", "compile", "file", "and", "compile", "library", "which", "read", "compile", "and", "write", "the", "object", "file", "one", "expression", "at", "a", "time", "NUMBER", "Also", "line", "breaks", "can", "be", "determined", "properly", "in", "general", "only", "via", "a", "transcoded", "text", "port", "so", "make", "source", "file", "descriptor", "needs", "to", "do", "an", "additional", "pass", "separate", "from", "the", "checksum", "computation", "through", "the", "file", "s", "contents", "to", "create", "the", "table", "NUMBER", "The", "exist", "pre", "PR", "implementation", "has", "two", "major", "benefits", "which", "be", "low", "read", "time", "overhead", "and", "low", "storage", "overhead", "requiring", "as", "it", "do", "only", "the", "maintenance", "and", "storage", "of", "the", "bfp", "and", "efp", "NUMBER", "It", "has", "one", "major", "issue", "which", "be", "large", "overhead", "when", "multiple", "calls", "to", "locate", "source", "be", "made", "for", "the", "same", "file", "since", "locate", "source", "opens", "and", "scans", "the", "file", "twice", "on", "each", "call", "NUMBER", "It", "also", "has", "a", "couple", "of", "minor", "issue", "the", "file", "might", "not", "be", "available", "by", "the", "time", "locate", "source", "be", "call", "and", "the", "current", "transcoder", "might", "have", "change", "NUMBER", "Setting", "aside", "the", "record", "source", "lines", "and", "columns", "parameter", "and", "all", "it", "entails", "your", "solution", "potentially", "address", "both", "the", "major", "and", "minor", "issue", "since", "it", "allows", "program", "such", "as", "the", "reader", "to", "compute", "the", "line", "and", "column", "information", "in", "the", "same", "pass", "as", "it", "computes", "the", "file", "positions", "NUMBER", "On", "the", "other", "hand", "doing", "so", "loses", "the", "major", "benefits", "of", "low", "read", "time", "and", "storage", "overhead", "NUMBER", "What", "would", "you", "think", "about", "having", "locate", "source", "create", "and", "cache", "via", "a", "weak", "hashtable", "the", "position", "to", "line", "table", "instead", "as", "a", "way", "of", "avoiding", "multiple", "rereadings", "of", "the", "source", "file", "Because", "sfds", "might", "last", "indefinitely", "via", "pointers", "from", "compiled", "code", "we", "could", "have", "each", "maximum", "generation", "collection", "clear", "the", "cache", "of", "any", "tables", "that", "haven", "t", "be", "use", "since", "the", "last", "maximum", "generation", "collection", "NUMBER", "This", "would", "address", "the", "major", "issue", "without", "add", "read", "time", "or", "storage", "overhead", "and", "it", "s", "a", "completely", "transparent", "change", "with", "no", "new", "primitives", "or", "incompatibilities", "NUMBER", "It", "would", "not", "address", "the", "minor", "issue", "NUMBER", "If", "you", "really", "need", "to", "be", "able", "to", "determine", "and", "store", "lines", "and", "columns", "at", "read", "time", "in", "some", "cases", "e", "NUMBER", "g", "NUMBER", "you", "re", "reading", "something", "other", "than", "a", "file", "and", "can", "t", "use", "a", "similar", "cache", "or", "you", "need", "to", "be", "able", "to", "report", "line", "and", "column", "information", "for", "file", "that", "aren", "t", "present", "at", "locate", "source", "time", "we", "could", "allow", "bfp", "and", "efp", "to", "be", "represented", "as", "integers", "or", "records", "as", "the", "PR", "do", "and", "also", "modify", "locate", "source", "to", "create", "and", "cache", "the", "position", "to", "line", "tables", "to", "handle", "cases", "where", "the", "information", "isn", "t", "supplied", "NUMBER", "In", "either", "case", "I", "would", "leave", "out", "record", "source", "lines", "and", "columns", "and", "the", "relate", "change", "NUMBER", "Though", "I", "like", "the", "simplicity", "of", "the", "current", "mechanism", "and", "I", "have", "some", "qualms", "about", "the", "potential", "performance", "hit", "to", "the", "reader", "I", "can", "go", "along", "with", "allowing", "the", "optional", "use", "of", "file", "position", "records", "in", "place", "of", "simple", "file", "positions", "in", "source", "objects", "as", "well", "as", "add", "and", "use", "the", "current", "make", "source", "object", "parameter", "which", "I", "believe", "you", "mean", "rather", "than", "current", "make", "syntax", "object", "NUMBER", "I", "still", "think", "locate", "source", "actually", "locate", "source", "should", "handle", "caching", "internally", "and", "there", "be", "better", "ways", "to", "prevent", "trolling", "through", "the", "filesystem", "at", "run", "time", "so", "I", "d", "prefer", "to", "add", "caching", "to", "locate", "source", "and", "not", "add", "the", "current", "locate", "source", "parameter", "NUMBER", "More", "on", "my", "rational", "in", "my", "responses", "to", "your", "comments", "below", "NUMBER", "_This", "implementation", "do", "not", "add", "caching", "for", "locate", "source", "NUMBER", "I", "don", "t", "know", "how", "to", "do", "that", "and", "remain", "consistent", "with", "the", "idea", "that", "locate", "source", "tells", "you", "whether", "the", "source", "file", "has", "change", "NUMBER", "_", "I", "don", "t", "share", "your", "concern", "with", "this", "NUMBER", "There", "s", "already", "a", "window", "between", "when", "the", "file", "be", "opened", "and", "the", "two", "scans", "to", "compute", "the", "CRC", "and", "locate", "the", "line", "and", "column", "be", "complete", "during", "which", "the", "file", "might", "change", "on", "disk", "NUMBER", "If", "we", "prune", "the", "table", "fairly", "quickly", "the", "window", "be", "not", "that", "much", "larger", "NUMBER", "Also", "note", "the", "check", "be", "gone", "completely", "if", "the", "line", "and", "column", "be", "computed", "at", "compile", "time", "since", "by", "design", "the", "update", "locate", "source", "doesn", "t", "bother", "to", "find", "the", "file", "and", "check", "the", "CRC", "NUMBER", "_I", "worry", "about", "system", "operations", "trolling", "through", "the", "filesystem", "in", "a", "final", "application", "NUMBER", "_", "You", "make", "it", "sound", "so", "nefarious", "NUMBER", "Seriously", "since", "this", "most", "commonly", "happens", "only", "when", "the", "application", "error", "out", "without", "having", "set", "an", "appropriate", "exception", "handler", "how", "worrisome", "be", "it", "Also", "via", "current", "make", "source", "object", "one", "can", "ensure", "that", "all", "source", "object", "positions", "be", "file", "position", "records", "in", "which", "case", "locate", "source", "won", "t", "do", "the", "trolling", "anyway", "NUMBER", "One", "can", "also", "limit", "trolling", "by", "setting", "source", "directories", "and", "library", "directories", "before", "calling", "anything", "that", "might", "end", "up", "in", "locate", "source", "NUMBER", "Having", "to", "ask", "for", "the", "current", "directory", "among", "the", "parameters", "to", "check", "if", "the", "cache", "be", "still", "valid", "be", "a", "big", "hit", "depending", "on", "the", "O", "S", "NUMBER", "It", "makes", "me", "wonder", "if", "we", "aren", "t", "better", "off", "change", "the", "interface", "to", "make", "caching", "explicit", "perhaps", "along", "the", "lines", "you", "suggested", "earlier", "or", "perhaps", "by", "change", "the", "interface", "to", "locate", "source", "NUMBER", "For", "example", "make", "source", "locator", "might", "take", "an", "sfd", "and", "return", "a", "source", "locator", "i", "NUMBER", "e", "NUMBER", "a", "representation", "of", "the", "cache", "and", "locate", "source", "might", "optionally", "accept", "a", "source", "locator", "in", "place", "of", "an", "sfd", "NUMBER", "I", "think", "it", "works", "and", "it", "doesn", "t", "require", "source", "objects", "to", "contain", "a", "source", "file", "locator", "but", "it", "do", "push", "the", "responsibility", "of", "maintaining", "the", "cache", "onto", "the", "locate", "source", "caller", "NUMBER", "That", "was", "the", "effect", "I", "was", "going", "for", "because", "it", "doesn", "t", "change", "the", "behavior", "of", "locate", "source", "and", "the", "caller", "should", "know", "better", "its", "tolerance", "for", "change", "that", "might", "affect", "the", "search", "NUMBER", "On", "the", "other", "hand", "it", "be", "inconvenient", "and", "a", "way", "to", "achieve", "a", "similar", "effect", "would", "be", "an", "optional", "_okay", "to", "cache", "_", "argument", "to", "locate", "source", "to", "say", "it", "s", "okay", "to", "cache", "unconditionally", "NUMBER", "For", "most", "applications", "this", "would", "be", "the", "desired", "behavior", "NUMBER", "Incidentally", "checking", "current", "directory", "and", "the", "other", "parameters", "be", "insufficient", "as", "well", "as", "expensive", "because", "it", "doesn", "t", "catch", "change", "in", "the", "filesystem", "that", "effectively", "relocate", "source", "file", "NUMBER", "current", "directory", "can", "also", "fail", "due", "to", "lack", "of", "permissions", "or", "even", "fail", "to", "return", "due", "to", "cycles", "in", "the", "file", "system", "though", "such", "situations", "be", "rare", "NUMBER", "Although", "it", "s", "impossible", "to", "make", "the", "cache", "truly", "transparent", "due", "to", "various", "race", "conditions", "we", "could", "come", "pretty", "close", "by", "recording", "the", "file", "modification", "time", "and", "having", "locate", "source", "go", "through", "the", "motions", "of", "locating", "the", "source", "file", "use", "the", "same", "algorithm", "as", "open", "source", "file", "but", "stop", "short", "of", "open", "the", "file", "and", "computing", "the", "checksum", "and", "instead", "compare", "the", "file", "modification", "time", "NUMBER", "I", "prefer", "the", "optional", "_okay", "to", "cache", "_", "argument", "to", "locate", "source", "however", "NUMBER", "Using", "a", "tc", "parameter", "for", "current", "make", "source", "object", "might", "help", "but", "the", "replacement", "of", "inline", "allocation", "with", "an", "anonymous", "procedure", "call", "be", "probably", "the", "bigger", "hit", "NUMBER", "Right", "NUMBER", "That", "s", "where", "it", "gets", "inconvenient", "NUMBER", "The", "let", "values", "macro", "or", "perhaps", "the", "expander", "operate", "on", "its", "behalf", "would", "have", "to", "maintain", "a", "mapping", "from", "sfds", "to", "locator", "objects", "NUMBER", "That", "s", "why", "I", "prefer", "the", "_okay", "to", "cache", "_", "flag", "NUMBER", "Thanks", "NUMBER", "Is", "it", "necessary", "to", "represent", "the", "line", "explicitly", "in", "the", "position", "line", "table", "That", "be", "isn", "t", "the", "vector", "index", "the", "same", "as", "the", "line", "number", "so", "can", "t", "the", "table", "just", "be", "a", "vector", "of", "positions", "so", "that", "v", "NUMBER", "be", "the", "position", "of", "line", "NUMBER", "v", "NUMBER", "the", "position", "of", "line", "NUMBER", "etc", "NUMBER", "I", "like", "what", "you", "did", "with", "make", "source", "object", "NUMBER", "Maybe", "we", "should", "take", "it", "a", "step", "further", "and", "combine", "it", "with", "your", "idea", "for", "use", "a", "tc", "parameter", "new", "tc", "parameter", "current", "mso", "initially", "f", "current", "make", "source", "object", "returns", "or", "current", "mso", "make", "source", "object", "current", "make", "source", "object", "p", "sets", "current", "mso", "to", "if", "eq", "p", "make", "source", "object", "f", "p", "after", "verifying", "p", "be", "a", "procedure", "make", "source", "object", "becomes", "a", "macro", "defined", "in", "read", "NUMBER", "ss", "that", "if", "current", "mso", "be", "f", "calls", "make", "source", "otherwise", "calls", "current", "mso", "That", "should", "eliminate", "most", "of", "the", "read", "overhead", "when", "current", "make", "source", "object", "has", "its", "default", "value", "NUMBER", "I", "think", "I", "d", "prefer", "to", "have", "current", "locate", "source", "take", "exactly", "the", "same", "argument", "as", "locate", "source", "and", "to", "push", "the", "logic", "that", "looks", "for", "the", "existence", "of", "the", "source", "object", "start", "line", "column", "into", "the", "caller", "NUMBER", "If", "that", "doesn", "t", "seem", "reasonable", "I", "agree", "current", "locate", "source", "be", "misnamed", "and", "there", "ought", "to", "be", "a", "name", "for", "its", "default", "value", "that", "one", "can", "call", "directly", "or", "use", "to", "reset", "the", "parameter", "NUMBER", "Here", "be", "some", "possible", "shorter", "alternatives", "to", "locate", "source", "object", "source", "source", "object", "location", "source", "location", "determine", "source", "location", "determine", "location", "I", "would", "be", "tempted", "to", "leave", "out", "the", "use", "cache", "argument", "and", "have", "the", "default", "procedure", "pass", "locate", "source", "t", "for", "the", "argument", "NUMBER", "Agreed", "NUMBER", "I", "m", "okay", "with", "the", "current", "names", "NUMBER", "I", "have", "review", "the", "latest", "code", "change", "in", "detail", "and", "I", "have", "a", "few", "final", "suggestions", "NUMBER", "NUMBER", "The", "current", "mso", "thread", "context", "field", "needs", "to", "be", "relocated", "by", "sweep_thread", "gc", "NUMBER", "c", "so", "add", "relocate", "CURRENTMSO", "tc", "after", "relocate", "SFD", "tc", "NUMBER", "When", "call", "from", "display", "condition", "rather", "than", "make", "source", "oops", "display", "condition", "should", "probably", "pass", "current", "locate", "source", "object", "source", "f", "for", "the", "use", "cache", "argument", "NUMBER", "The", "display", "condition", "prefix", "argument", "already", "distinguishes", "the", "calls", "from", "display", "condition", "and", "make", "source", "oops", "though", "before", "it", "be", "also", "use", "to", "determine", "the", "value", "of", "use", "cache", "it", "should", "probably", "be", "renamed", "NUMBER", "NUMBER", "I", "would", "change", "source", "object", "bfl", "and", "source", "object", "bfc", "to", "source", "object", "line", "and", "source", "object", "col", "or", "source", "object", "column", "NUMBER", "I", "don", "t", "think", "anyone", "would", "be", "surprised", "that", "these", "be", "the", "beginning", "line", "and", "column", "NUMBER", "NUMBER", "I", "would", "rewrite", "the", "loop", "in", "the", "read", "NUMBER", "ss", "definition", "of", "binary", "search", "from", "let", "loop", "lo", "NUMBER", "hi", "vector", "length", "table", "let", "mid", "fxsra", "fx", "lo", "hi", "NUMBER", "pos", "vector", "ref", "table", "mid", "cond", "fx", "fx", "NUMBER", "lo", "hi", "values", "name", "hi", "fx", "NUMBER", "fx", "fp", "pos", "TAG", "I", "didn", "t", "make", "the", "third", "change", "NUMBER", "I", "think", "the", "indirection", "through", "pending_ephemerons", "makes", "the", "GC", "perform", "less", "work", "in", "the", "common", "case", "NUMBER", "TAG", "Fair", "enough", "NUMBER", "Is", "there", "a", "reason", "why", "check_dirty_ephemeron", "should", "not", "also", "put", "the", "ephemeron", "on", "pending_ephemerons", "rather", "than", "on", "the", "trigger", "lists", "That", "s", "what", "I", "was", "thinking", "NUMBER", "I", "m", "test", "the", "change", "now", "and", "will", "commit", "it", "unless", "I", "run", "into", "a", "problem", "NUMBER", "Nice", "find", "fxarithmetic", "shift", "left", "also", "gives", "the", "wrong", "error", "who", "fxsll", "when", "the", "argument", "be", "not", "fixnums", "NUMBER", "The", "logic", "in", "library", "NUMBER", "ss", "for", "fxsll", "and", "fxarithmetic", "shift", "left", "needs", "to", "correct", "NUMBER", "dybvig", "the", "documentation", "of", "fxsll", "and", "fxarithmetic", "shift", "left", "aren", "t", "in", "sync", "NUMBER", "fxsll", "allows", "fixnum", "width", "shifts", "whereas", "fxarithmetic", "shift", "left", "doesn", "t", "NUMBER", "fxarithmetic", "shift", "left", "doesn", "t", "mention", "an", "exception", "on", "overflow", "NUMBER", "What", "would", "you", "like", "me", "to", "change", "Nice", "find", "The", "enum", "set", "indexer", "code", "in", "enum", "NUMBER", "ss", "needs", "to", "check", "that", "the", "variable", "be", "a", "symbol", "before", "calling", "symbol", "hashtable", "ref", "with", "it", "NUMBER", "I", "don", "t", "know", "that", "we", "have", "any", "particular", "plan", "to", "work", "on", "this", "right", "now", "but", "we", "would", "certainly", "welcome", "the", "effort", "if", "someone", "wanted", "to", "take", "the", "lead", "on", "the", "porting", "work", "NUMBER", "Kent", "I", "ve", "get", "a", "possible", "fix", "on", "rgburger", "threads", "NUMBER", "Thanks", "I", "ll", "make", "those", "two", "edits", "and", "push", "to", "master", "NUMBER", "Chez", "Scheme", "s", "default", "scheme", "start", "procedure", "treats", "each", "argument", "as", "a", "filename", "to", "load", "NUMBER", "If", "you", "want", "different", "behavior", "you", "ll", "need", "to", "specify", "a", "scheme", "start", "procedure", "NUMBER", "Another", "option", "be", "to", "use", "the", "script", "argument", "to", "Chez", "Scheme", "NUMBER", "Suppose", "script", "NUMBER", "ss", "has", "the", "following", "in", "it", "pretty", "print", "command", "line", "Then", "chez", "script", "script", "NUMBER", "ss", "flag", "NUMBER", "will", "print", "script", "NUMBER", "ss", "flag", "NUMBER", "The", "storage", "for", "mutex", "and", "condition", "objects", "allocated", "by", "malloc", "in", "c", "thread", "NUMBER", "c", "be", "never", "freed", "NUMBER", "What", "would", "it", "take", "to", "place", "them", "under", "the", "garbage", "collector", "s", "control", "Perhaps", "a", "guardian", "like", "file", "guardian", "that", "detects", "when", "they", "re", "no", "longer", "use", "And", "we", "ll", "have", "to", "be", "careful", "about", "the", "places", "where", "the", "c", "code", "be", "call", "with", "the", "raw", "address", "and", "the", "wrapper", "Scheme", "object", "be", "no", "longer", "referenced", "NUMBER", "I", "have", "a", "propose", "fix", "on", "branch", "rgburger", "threads", "NUMBER", "dybvig", "or", "akeep", "what", "do", "you", "think", "I", "add", "a", "keep", "live", "primitive", "to", "keep", "the", "mutex", "and", "condition", "Scheme", "records", "live", "across", "calls", "that", "deactivate", "the", "thread", "mutex", "acquire", "and", "condition", "wait", "and", "then", "keep", "track", "of", "the", "inaccessible", "mutexes", "and", "conditions", "with", "guardians", "that", "get", "cleaned", "out", "with", "close", "resurrected", "mutexes", "conditions", "NUMBER", "We", "could", "change", "the", "Scheme", "condition", "and", "mutex", "records", "to", "use", "a", "mutable", "addr", "and", "set", "it", "to", "NUMBER", "when", "the", "C", "data", "structure", "be", "freed", "NUMBER", "It", "would", "then", "be", "easy", "to", "detect", "this", "situation", "and", "report", "an", "exception", "NUMBER", "Shall", "I", "make", "that", "change", "I", "ve", "made", "the", "change", "and", "add", "a", "mat", "for", "this", "case", "NUMBER", "Is", "there", "anything", "else", "This", "looks", "like", "a", "CRLF", "line", "ending", "problem", "NUMBER", "Are", "you", "use", "Cygwin", "s", "git", "Is", "it", "configured", "to", "use", "CRLF", "line", "endings", "If", "so", "configure", "it", "not", "to", "change", "the", "line", "endings", "NUMBER", "You", "ve", "pick", "one", "of", "the", "trickier", "records", "to", "update", "NUMBER", "Often", "the", "solution", "be", "simply", "to", "change", "the", "uid", "i", "NUMBER", "e", "NUMBER", "in", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "signatures", "change", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "to", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "NUMBER", "You", "might", "want", "to", "check", "first", "to", "make", "sure", "the", "new", "name", "isn", "t", "use", "elsewhere", "NUMBER", "This", "resolve", "the", "mismatched", "record", "type", "error", "NUMBER", "In", "this", "case", "however", "you", "immediately", "get", "another", "problem", "which", "be", "an", "unrecognized", "record", "error", "in", "uncprep", "NUMBER", "Such", "error", "typically", "result", "from", "old", "instances", "floating", "around", "that", "code", "expecting", "new", "instances", "trips", "on", "NUMBER", "They", "can", "often", "be", "resolve", "by", "use", "the", "update", "record", "type", "macro", "which", "be", "defined", "in", "cmacros", "NUMBER", "ss", "NUMBER", "For", "example", "update", "record", "type", "primref", "make", "primref", "primref", "primref", "name", "primref", "flags", "primref", "arity", "primref", "signatures", "old", "record", "definition", "with", "stub", "for", "miss", "accessor", "begin", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "define", "primref", "signatures", "x", "signature", "new", "record", "definition", "with", "stub", "for", "miss", "accessor", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "signatures", "In", "this", "case", "however", "the", "error", "results", "from", "new", "instances", "tripping", "up", "old", "code", "NUMBER", "To", "get", "around", "this", "requires", "a", "bit", "of", "work", "starting", "with", "build", "one", "system", "that", "understands", "but", "doesn", "t", "create", "instances", "of", "the", "new", "record", "type", "use", "it", "to", "bootstrap", "a", "new", "system", "that", "understands", "and", "creates", "instances", "of", "the", "new", "record", "type", "then", "use", "it", "to", "bootstrap", "a", "system", "that", "understands", "only", "the", "new", "record", "type", "NUMBER", "To", "make", "life", "easier", "if", "you", "make", "mistakes", "or", "need", "to", "adjust", "your", "change", "you", "should", "actually", "bootstrap", "the", "first", "from", "one", "that", "deals", "only", "with", "the", "old", "record", "type", "NUMBER", "By", "the", "same", "token", "to", "make", "life", "harder", "you", "can", "try", "to", "do", "all", "of", "these", "steps", "in", "the", "same", "workarea", "and", "you", "might", "succeed", "if", "you", "get", "everything", "right", "the", "first", "time", "NUMBER", "Assuming", "you", "re", "on", "an", "OS", "X", "system", "here", "s", "the", "complete", "process", "NUMBER", "Create", "a", "fresh", "copy", "of", "the", "repository", "NUMBER", "WARNING", "if", "you", "choose", "not", "to", "clone", "a", "new", "copy", "make", "sure", "your", "exist", "copy", "be", "free", "from", "any", "of", "the", "relate", "change", "before", "starting", "NUMBER", "git", "clone", "TAG", "chezscheme", "cd", "chezscheme", "NUMBER", "Build", "an", "untouched", "base", "system", "for", "bootsrapping", "NUMBER", "configure", "workarea", "understands", "only", "old", "make", "NUMBER", "Next", "build", "a", "system", "that", "understands", "the", "new", "record", "type", "but", "doesn", "t", "create", "instances", "of", "it", "yet", "use", "a", "different", "workarea", "NUMBER", "WARNING", "don", "t", "forget", "to", "make", "a", "local", "copy", "of", "the", "file", "you", "edit", "on", "this", "and", "the", "other", "steps", "NUMBER", "Don", "t", "edit", "the", "root", "directory", "copies", "or", "you", "ll", "find", "it", "difficult", "to", "retrace", "your", "steps", "if", "you", "need", "to", "make", "change", "NUMBER", "workarea", "a", "NUMBER", "osx", "understands", "new", "creates", "old", "pushd", "understands", "new", "creates", "old", "s", "cp", "NUMBER", "NUMBER", "s", "primref", "NUMBER", "ss", "NUMBER", "edit", "s", "primref", "NUMBER", "ss", "Edit", "NUMBER", "below", "make", "f", "Mf", "cross", "m", "a", "NUMBER", "osx", "xm", "a", "NUMBER", "osx", "base", "NUMBER", "NUMBER", "understands", "only", "old", "cd", "NUMBER", "c", "make", "popd", "NUMBER", "Next", "build", "a", "system", "that", "understands", "and", "creates", "instances", "of", "the", "new", "record", "type", "workarea", "a", "NUMBER", "osx", "understands", "new", "creates", "new", "pushd", "understands", "new", "creates", "new", "s", "cp", "NUMBER", "NUMBER", "s", "primref", "NUMBER", "ss", "NUMBER", "NUMBER", "s", "primvars", "NUMBER", "ss", "NUMBER", "edit", "s", "primref", "NUMBER", "ss", "and", "s", "primvars", "NUMBER", "ss", "Edit", "NUMBER", "below", "make", "f", "Mf", "cross", "m", "a", "NUMBER", "osx", "xm", "a", "NUMBER", "osx", "base", "NUMBER", "NUMBER", "understands", "new", "creates", "old", "cd", "NUMBER", "c", "make", "popd", "NUMBER", "Finally", "build", "a", "system", "that", "understands", "only", "the", "new", "record", "type", "bootstrapping", "itself", "at", "the", "end", "workarea", "a", "NUMBER", "osx", "understands", "only", "new", "pushd", "understands", "only", "new", "s", "cp", "NUMBER", "NUMBER", "s", "primref", "NUMBER", "ss", "NUMBER", "NUMBER", "s", "primvars", "NUMBER", "ss", "NUMBER", "edit", "s", "primref", "NUMBER", "ss", "and", "s", "primvars", "NUMBER", "ss", "Edit", "NUMBER", "below", "make", "f", "Mf", "cross", "m", "a", "NUMBER", "osx", "xm", "a", "NUMBER", "osx", "base", "NUMBER", "NUMBER", "understands", "new", "creates", "new", "cd", "NUMBER", "c", "make", "make", "allx", "popd", "Edit", "NUMBER", "primref", "NUMBER", "ss", "only", "The", "first", "edit", "replaces", "the", "exist", "record", "definition", "of", "primref", "with", "one", "that", "understands", "both", "old", "and", "new", "record", "types", "but", "creates", "old", "ones", "NUMBER", "It", "abuses", "the", "update", "record", "type", "macro", "by", "swapping", "old", "and", "new", "roles", "since", "update", "record", "type", "export", "the", "new", "maker", "and", "we", "want", "the", "old", "NUMBER", "update", "record", "type", "primref", "make", "primref", "primref", "primref", "name", "primref", "flags", "primref", "arity", "primref", "signatures", "new", "record", "definition", "with", "stub", "for", "miss", "accessor", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "signatures", "old", "record", "definition", "with", "stub", "for", "miss", "accessor", "begin", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "define", "primref", "signatures", "x", "signature", "Edit", "NUMBER", "primref", "NUMBER", "ss", "and", "primvars", "NUMBER", "ss", "both", "This", "edit", "to", "primref", "NUMBER", "ss", "simply", "puts", "the", "update", "record", "type", "form", "in", "the", "proper", "order", "update", "record", "type", "primref", "make", "primref", "primref", "primref", "name", "primref", "flags", "primref", "arity", "primref", "signatures", "old", "record", "definition", "with", "stub", "for", "miss", "accessor", "begin", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "define", "primref", "signatures", "x", "signature", "new", "record", "definition", "with", "stub", "for", "miss", "accessor", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "signatures", "For", "primvars", "NUMBER", "ss", "make", "the", "change", "you", "already", "made", "NUMBER", "Edit", "NUMBER", "primref", "NUMBER", "ss", "and", "primvars", "NUMBER", "ss", "both", "This", "edit", "remove", "the", "update", "recordd", "type", "form", "leaving", "only", "the", "new", "definition", "in", "place", "define", "record", "type", "primref", "nongenerative", "primref", "a", "NUMBER", "xltlrcpeygsahopkplcn", "NUMBER", "sealed", "t", "field", "name", "flags", "arity", "signatures", "For", "primvars", "NUMBER", "ss", "again", "make", "the", "change", "you", "already", "made", "NUMBER", "You", "can", "start", "again", "at", "Step", "NUMBER", "if", "you", "need", "to", "modify", "the", "new", "record", "type", "definition", "NUMBER", "At", "some", "point", "if", "you", "want", "to", "commit", "and", "push", "the", "change", "you", "ll", "need", "to", "get", "the", "final", "local", "copies", "back", "to", "the", "root", "directory", "NUMBER", "You", "can", "use", "checkin", "understands", "only", "new", "to", "do", "that", "or", "simply", "copy", "the", "file", "you", "ve", "modify", "including", "the", "boot", "file", "into", "the", "proper", "root", "source", "directory", "NUMBER", "The", "change", "in", "representation", "your", "proposal", "lays", "out", "doesn", "t", "actually", "limit", "the", "lengths", "of", "vectors", "since", "the", "high", "order", "bit", "of", "the", "type", "length", "field", "was", "previously", "always", "zero", "NUMBER", "It", "also", "doesn", "t", "actually", "require", "mutators", "to", "do", "a", "separate", "mutability", "check", "since", "they", "can", "mask", "in", "and", "check", "the", "mutable", "bit", "when", "they", "check", "the", "type", "NUMBER", "It", "do", "limit", "the", "lengths", "of", "strings", "and", "bytevectors", "and", "the", "main", "question", "be", "whether", "this", "be", "acceptable", "on", "NUMBER", "bit", "machines", "NUMBER", "The", "prospect", "doesn", "t", "bother", "me", "as", "much", "as", "it", "once", "would", "have", "because", "we", "have", "the", "NUMBER", "bit", "option", "NUMBER", "How", "much", "longer", "will", "we", "care", "about", "NUMBER", "bit", "machines", "anyway", "I", "would", "indeed", "want", "to", "extend", "the", "immutability", "option", "to", "fxvectors", "for", "consistency", "which", "would", "be", "easy", "NUMBER", "Ideally", "I", "would", "also", "want", "to", "extend", "it", "to", "pairs", "which", "would", "not", "be", "easy", "following", "the", "path", "you", "ve", "propose", "since", "there", "s", "no", "place", "in", "the", "pair", "itself", "to", "store", "a", "mutable", "bit", "NUMBER", "Here", "be", "a", "different", "proposal", "that", "support", "an", "immutability", "option", "for", "all", "types", "of", "objects", "including", "pairs", "while", "it", "doesn", "t", "reduce", "lengths", "it", "do", "waste", "space", "particularly", "for", "smaller", "objects", "on", "NUMBER", "bit", "machines", "align", "objects", "on", "NUMBER", "byte", "rather", "than", "just", "NUMBER", "byte", "boundaries", "use", "the", "extra", "primary", "tag", "bit", "as", "a", "mutable", "flag", "and", "add", "an", "immutable", "procedure", "which", "for", "an", "input", "value", "_x_", "returns", "a", "value", "_y_", "that", "be", "like", "_x_", "except", "that", "if", "the", "object", "to", "which", "_x_", "refers", "can", "be", "mutated", "directly", "through", "_x_", "it", "cannot", "be", "mutated", "directly", "through", "_y_", "NUMBER", "That", "way", "mutability", "would", "be", "a", "capability", "of", "the", "pointer", "rather", "than", "an", "inherent", "property", "of", "the", "object", "itself", "and", "an", "object", "remains", "mutable", "through", "the", "original", "pointer", "NUMBER", "Is", "this", "sufficient", "for", "Racket", "s", "purposes", "or", "can", "Racket", "be", "modify", "to", "make", "it", "sufficient", "On", "NUMBER", "bit", "machines", "most", "objects", "all", "but", "flonums", "be", "already", "aligned", "on", "NUMBER", "byte", "boundaries", "so", "the", "hit", "here", "be", "again", "significant", "only", "on", "NUMBER", "bit", "machines", "NUMBER", "Aligning", "pairs", "on", "NUMBER", "bytes", "boundaries", "on", "NUMBER", "bit", "machines", "be", "a", "particularly", "big", "waste", "since", "it", "effectively", "doubles", "the", "size", "of", "a", "list", "NUMBER", "If", "we", "re", "willing", "to", "steal", "an", "extra", "primary", "code", "for", "pairs", "say", "from", "symbols", "we", "could", "leave", "pairs", "aligned", "on", "NUMBER", "byte", "boundaries", "on", "NUMBER", "bit", "machines", "and", "still", "be", "able", "to", "distinguish", "mutable", "from", "immutable", "pairs", "NUMBER", "For", "example", "we", "could", "give", "pairs", "primary", "type", "code", "b", "NUMBER", "immutable", "and", "b", "NUMBER", "mutable", "so", "that", "after", "isolating", "the", "type", "bits", "pair", "would", "check", "to", "see", "if", "the", "result", "be", "NUMBER", "or", "greater", "and", "mutable", "pair", "would", "check", "to", "see", "if", "the", "result", "be", "exactly", "NUMBER", "Closures", "and", "flonums", "could", "remain", "aligned", "on", "NUMBER", "byte", "boundaries", "on", "NUMBER", "bit", "machines", "since", "they", "be", "already", "immutable", "NUMBER", "Of", "course", "this", "doesn", "t", "reduce", "the", "waste", "for", "other", "small", "objects", "like", "boxes", "ratnums", "small", "strings", "small", "vectors", "small", "bytevectors", "and", "small", "record", "instances", "NUMBER", "Never", "mind", "my", "alternative", "proposal", "it", "add", "unacceptable", "overhead", "to", "object", "field", "accesses", "which", "would", "have", "to", "mask", "off", "the", "mutable", "bit", "NUMBER", "Of", "course", "I", "didn", "t", "think", "of", "that", "until", "walking", "away", "from", "the", "keyboard", "and", "letting", "my", "mind", "clear", "NUMBER", "The", "thing", "to", "do", "with", "vectors", "be", "to", "handle", "them", "more", "like", "strings", "bytevectors", "and", "fxvectors", "i", "NUMBER", "e", "NUMBER", "put", "the", "immutable", "bit", "near", "the", "low", "end", "with", "the", "type", "tag", "NUMBER", "There", "s", "no", "advantage", "to", "putting", "the", "immutable", "bit", "at", "the", "top", "and", "it", "makes", "the", "mask", "larger", "resulting", "in", "larger", "instructions", "especially", "on", "NUMBER", "bit", "machines", "NUMBER", "Vectors", "were", "be", "treated", "differently", "just", "to", "take", "advantage", "of", "the", "fact", "that", "the", "length", "could", "be", "a", "plain", "fixnum", "which", "will", "no", "longer", "be", "the", "case", "NUMBER", "To", "make", "this", "feasible", "I", "m", "work", "on", "a", "set", "of", "change", "now", "intended", "to", "reduce", "the", "special", "handle", "of", "vectors", "to", "no", "more", "than", "a", "few", "cases", "which", "will", "be", "flagged", "by", "meta", "asserts", "NUMBER", "Assuming", "I", "catch", "all", "of", "the", "cases", "it", "should", "be", "relatively", "straightforward", "to", "treat", "vectors", "more", "like", "the", "others", "NUMBER", "Immutable", "boxes", "would", "be", "easy", "to", "support", "with", "a", "bit", "in", "the", "tag", "field", "NUMBER", "Pairs", "be", "the", "troublemakers", "NUMBER", "With", "this", "commit", "LINK", "I", "ve", "weeded", "out", "the", "special", "handle", "of", "vectors", "in", "the", "compiler", "and", "run", "time", "system", "commonized", "more", "of", "the", "string", "fxvector", "bytevector", "vector", "code", "in", "the", "compiler", "and", "test", "with", "alternative", "type", "vector", "mask", "vector", "and", "vector", "length", "offset", "settings", "b", "NUMBER", "b", "NUMBER", "NUMBER", "on", "a", "NUMBER", "bit", "build", "b", "NUMBER", "b", "NUMBER", "NUMBER", "on", "a", "NUMBER", "bit", "build", "NUMBER", "All", "seems", "to", "work", "but", "I", "revert", "the", "settings", "for", "vectors", "back", "to", "the", "fixnum", "type", "mask", "and", "offset", "since", "that", "gives", "us", "shorter", "instruction", "sequences", "for", "some", "vector", "operations", "for", "now", "NUMBER", "For", "separate", "mutable", "and", "immutable", "vectors", "you", "ll", "want", "to", "use", "the", "top", "type", "bit", "as", "the", "immutable", "bit", "or", "you", "ll", "get", "a", "fail", "idiot", "check", "on", "start", "up", "about", "vector", "type", "length", "field", "not", "looking", "like", "fixnums", "so", "just", "what", "I", "listed", "above", "for", "immutable", "vectors", "and", "for", "mutable", "vectors", "use", "type", "b", "NUMBER", "on", "NUMBER", "bit", "build", "and", "b", "NUMBER", "on", "NUMBER", "bit", "build", "NUMBER", "If", "you", "re", "happy", "with", "the", "more", "restricted", "interface", "that", "doesn", "t", "alter", "objects", "in", "place", "that", "s", "fine", "with", "me", "but", "it", "do", "prevent", "one", "from", "defining", "a", "cyclic", "structure", "use", "mutation", "then", "marking", "all", "of", "the", "pieces", "immutable", "NUMBER", "Also", "if", "the", "public", "Scheme", "feature", "copies", "the", "object", "I", "d", "prefer", "the", "public", "C", "feature", "do", "so", "as", "well", "especially", "since", "we", "might", "come", "up", "with", "an", "implementation", "that", "doesn", "t", "involve", "mutation", "someday", "NUMBER", "Is", "it", "appropriate", "to", "mark", "the", "empty", "vector", "bytevector", "string", "and", "fxvector", "immutable", "from", "the", "start", "To", "the", "question", "about", "boxes", "yes", "NUMBER", "Try", "to", "find", "a", "bit", "within", "the", "first", "NUMBER", "however", "so", "the", "tag", "check", "remains", "a", "byte", "comparison", "NUMBER", "I", "don", "t", "understand", "the", "problem", "you", "have", "with", "bootstrapping", "NUMBER", "Please", "explain", "further", "NUMBER", "I", "believe", "maximum", "vector", "length", "should", "still", "be", "the", "same", "as", "most", "positive", "fixnum", "if", "so", "you", "appear", "to", "have", "gone", "too", "far", "on", "change", "relate", "to", "that", "NUMBER", "copy", "in", "gc", "NUMBER", "c", "can", "now", "put", "immutable", "vectors", "and", "boxes", "into", "space_pure", "NUMBER", "Woe", "be", "unto", "the", "programmer", "who", "decides", "NUMBER", "vector", "set", "be", "a", "useful", "way", "to", "work", "around", "immutability", "NUMBER", "Kent", "I", "d", "be", "tempted", "to", "add", "make", "reader", "graph", "or", "in", "this", "one", "case", "allow", "the", "Racket", "implementation", "of", "make", "reader", "graph", "access", "the", "imperative", "routines", "in", "from", "the", "system", "module", "rather", "than", "commit", "to", "a", "public", "imperative", "interface", "NUMBER", "Adapting", "the", "language", "to", "the", "contract", "system", "seems", "rather", "backward", "but", "okay", "NUMBER", "Rather", "than", "allocating", "a", "fresh", "immutable", "empty", "vector", "etc", "NUMBER", "each", "time", "I", "would", "create", "one", "at", "startup", "like", "the", "mutable", "empty", "vector", "so", "that", "eq", "returns", "t", "when", "pass", "immutable", "empty", "vectors", "just", "as", "it", "do", "for", "mutable", "empty", "vectors", "NUMBER", "To", "cure", "the", "unbound", "variable", "error", "add", "stub", "definitions", "to", "patch", "NUMBER", "ss", "e", "NUMBER", "g", "NUMBER", "define", "vector", "immutable", "x", "f", "NUMBER", "Back", "out", "the", "definitions", "once", "bootstrapped", "NUMBER", "I", "just", "looked", "at", "the", "code", "a", "bit", "and", "have", "a", "few", "small", "suggestions", "NUMBER", "When", "fx", "n", "NUMBER", "be", "followed", "by", "fx", "TAG", "n", "NUMBER", "oops", "who", "s", "be", "not", "a", "nonnegative", "fixnum", "n", "unless", "fx", "TAG", "strcpy", "foo", "foo", "However", "it", "be", "a", "bit", "verbose", "NUMBER", "Following", "from", "the", "correct", "version", "of", "the", "example", "which", "jltaylor", "us", "point", "out", "be", "checked", "into", "the", "examples", "repository", "you", "can", "use", "the", "u", "NUMBER", "type", "to", "pass", "a", "Scheme", "allocated", "byte", "vector", "that", "C", "can", "write", "into", "NUMBER", "You", "could", "re", "implement", "the", "solution", "above", "as", "follows", "racket", "define", "strcpy", "NUMBER", "let", "strcpy", "foreign", "procedure", "strcpy", "u", "NUMBER", "u", "NUMBER", "void", "lambda", "str", "let", "dst", "make", "bytevector", "string", "length", "str", "strcpy", "dst", "string", "utf", "NUMBER", "str", "bytevector", "string", "dst", "native", "transcoder", "This", "be", "quite", "a", "bit", "simpler", "but", "be", "a", "bit", "of", "a", "cheat", "since", "technically", "we", "should", "be", "ensuring", "our", "byte", "vector", "be", "null", "terminated", "before", "we", "pass", "it", "in", "and", "we", "should", "be", "provide", "a", "byte", "vector", "with", "space", "for", "the", "null", "terminator", "but", "if", "we", "do", "that", "we", "also", "will", "need", "to", "trim", "off", "the", "final", "null", "character", "of", "the", "string", "NUMBER", "The", "u", "NUMBER", "be", "something", "that", "can", "be", "use", "in", "general", "to", "provide", "Scheme", "allocated", "space", "to", "C", "but", "should", "be", "use", "with", "a", "bit", "of", "caution", "since", "a", "misbehaved", "C", "function", "could", "write", "all", "over", "the", "Scheme", "heap", "starting", "from", "that", "pointer", "if", "you", "be", "not", "careful", "NUMBER", "As", "far", "as", "the", "documentation", "we", "should", "clean", "that", "up", "by", "make", "use", "of", "the", "example", "code", "from", "the", "repository", "NUMBER", "The", "problem", "here", "be", "not", "the", "foreign", "function", "interface", "you", "be", "calling", "bytevector", "copy", "with", "the", "argument", "in", "the", "wrong", "order", "NUMBER", "From", "LINK", "NUMBER", "objects", "s", "NUMBER", "scheme", "bytevector", "copy", "src", "src", "start", "dst", "dst", "start", "n", "You", "have", "your", "source", "and", "destination", "reversed", "NUMBER", "No", "this", "be", "expected", "behavior", "NUMBER", "import", "b", "makes", "the", "export", "from", "library", "b", "available", "but", "it", "do", "not", "cause", "any", "code", "to", "run", "NUMBER", "The", "library", "initialization", "code", "in", "this", "case", "setting", "the", "definition", "of", "foo", "and", "resetting", "the", "value", "of", "box", "a", "be", "not", "do", "until", "the", "one", "of", "the", "non", "syntactic", "export", "be", "actually", "accessed", "NUMBER", "In", "R", "NUMBER", "RS", "Scheme", "there", "be", "no", "guarantee", "of", "when", "or", "how", "many", "times", "initialization", "code", "will", "be", "run", "NUMBER", "In", "Chez", "we", "endeavor", "to", "run", "it", "only", "once", "the", "first", "time", "an", "export", "of", "the", "library", "be", "referenced", "in", "a", "given", "Scheme", "session", "other", "implementations", "like", "Racket", "s", "R", "NUMBER", "RS", "implementation", "for", "instance", "runs", "the", "initialization", "code", "for", "each", "phase", "the", "library", "be", "referenced", "in", "effectively", "this", "could", "cause", "a", "to", "be", "set", "and", "reset", "over", "the", "course", "of", "the", "library", "load", "NUMBER", "In", "Chez", "there", "be", "three", "phases", "for", "an", "library", "import", "visit", "and", "invoke", "also", "know", "as", "revisit", "NUMBER", "Import", "which", "happens", "when", "the", "library", "be", "imported", "import", "b", "only", "sets", "up", "the", "bindings", "in", "Chez", "s", "syntactic", "environment", "visit", "which", "happens", "the", "first", "time", "an", "export", "macro", "be", "referenced", "sets", "up", "the", "syntactic", "transformers", "and", "the", "compile", "time", "environment", "and", "invoke", "which", "happens", "the", "first", "time", "a", "non", "macro", "export", "be", "referenced", "sets", "up", "the", "values", "of", "the", "definitions", "and", "runs", "initialization", "code", "NUMBER", "In", "general", "if", "you", "have", "initialization", "code", "you", "d", "like", "to", "run", "at", "a", "particular", "point", "it", "be", "best", "to", "simply", "wrap", "that", "initialization", "code", "in", "a", "function", "and", "call", "it", "explicitly", "NUMBER", "library", "b", "export", "foo", "a", "import", "scheme", "a", "define", "foo", "display", "hello", "world", "define", "initialize", "b", "set", "box", "a", "t", "andy", "On", "November", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "NUMBER", "PM", "rain", "NUMBER", "notifications", "github", "NUMBER", "com", "write", "Hello", "I", "find", "something", "strange", "when", "work", "on", "an", "extensible", "pattern", "matcher", "in", "Chez", "NUMBER", "Here", "s", "a", "minimal", "test", "case", "library", "a", "export", "a", "import", "scheme", "define", "a", "box", "f", "library", "b", "export", "foo", "a", "import", "scheme", "a", "define", "foo", "display", "hello", "world", "set", "box", "a", "t", "import", "b", "a", "f", "foo", "hello", "world", "a", "t", "Is", "this", "the", "correct", "behavior", "You", "be", "receiving", "this", "because", "you", "be", "subscribed", "to", "this", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "or", "mute", "the", "thread", "LINK", "auth", "AAG", "NUMBER", "rw", "NUMBER", "DcrZt", "NUMBER", "v", "NUMBER", "eDqoV", "NUMBER", "ZjLMpDbP", "NUMBER", "Vks", "NUMBER", "q", "NUMBER", "MGgaJpZM", "NUMBER", "Kwz", "NUMBER", "z", "NUMBER", "I", "was", "get", "ready", "to", "incorporate", "this", "change", "but", "I", "start", "thinking", "about", "this", "in", "depth", "and", "I", "was", "wondering", "what", "the", "situation", "be", "where", "two", "expressions", "could", "have", "the", "same", "starting", "file", "position", "and", "different", "ending", "file", "positions", "Part", "of", "what", "I", "m", "wondering", "be", "if", "ignoring", "the", "end", "file", "position", "be", "actually", "an", "optimization", "recognizing", "that", "the", "beginning", "file", "position", "be", "already", "unique", "NUMBER", "Do", "you", "have", "an", "example", "Yes", "that", "makes", "sense", "NUMBER", "I", "should", "have", "read", "the", "title", "more", "carefully", "Thanks", "for", "the", "clarification", "andy", "Thank", "you", "Thanks", "for", "the", "pull", "request", "this", "looks", "like", "a", "really", "good", "start", "at", "a", "port", "to", "Dragonfly", "BSD", "NUMBER", "I", "do", "have", "a", "couple", "of", "request", "NUMBER", "NUMBER", "Please", "add", "an", "Mf", "a", "NUMBER", "df", "and", "Mf", "ta", "NUMBER", "df", "to", "the", "mats", "directory", "NUMBER", "The", "mats", "directory", "be", "where", "our", "unit", "test", "live", "and", "part", "of", "how", "we", "test", "Chez", "Scheme", "to", "make", "sure", "all", "of", "its", "parts", "be", "work", "be", "to", "run", "make", "all", "make", "allx", "or", "make", "bullyx", "in", "the", "mats", "directory", "NUMBER", "I", "d", "like", "to", "make", "sure", "that", "Chez", "Scheme", "on", "Dragonfly", "BSD", "can", "pass", "the", "allx", "mats", "before", "we", "merge", "this", "pull", "request", "NUMBER", "NUMBER", "When", "we", "make", "change", "to", "Chez", "Scheme", "we", "update", "the", "LOG", "file", "in", "the", "base", "directory", "of", "the", "repository", "NUMBER", "Please", "add", "a", "log", "entry", "NUMBER", "I", "also", "have", "a", "separate", "question", "Does", "the", "NUMBER", "bit", "version", "of", "Dragonfly", "BSD", "support", "a", "NUMBER", "bit", "tool", "chain", "Or", "be", "there", "a", "NUMBER", "bit", "version", "of", "the", "DragonFly", "BSD", "OS", "If", "so", "we", "should", "consider", "add", "an", "i", "NUMBER", "df", "and", "ti", "NUMBER", "df", "for", "NUMBER", "bit", "support", "NUMBER", "Good", "thought", "but", "all", "other", "things", "aren", "t", "equal", "in", "this", "case", "NUMBER", "The", "loop", "be", "indeed", "intentionally", "unrolled", "and", "I", "just", "measured", "the", "benefit", "of", "the", "unrolling", "on", "an", "Intel", "i", "NUMBER", "NUMBER", "k", "cpu", "a", "NUMBER", "le", "build", "run", "make", "all", "in", "the", "s", "directory", "to", "be", "about", "a", "NUMBER", "NUMBER", "reduction", "in", "cp", "NUMBER", "run", "time", "NUMBER", "The", "overall", "compile", "time", "reduction", "be", "a", "modest", "NUMBER", "or", "so", "NUMBER", "If", "you", "want", "to", "repeat", "my", "test", "run", "make", "all", "pps", "t", "egrep", "cp", "NUMBER", "TOTAL", "a", "dozen", "or", "so", "times", "with", "and", "without", "the", "change", "NUMBER", "Cpu", "time", "be", "in", "the", "NUMBER", "column", "NUMBER", "It", "usually", "pays", "to", "optimize", "environment", "lookup", "NUMBER", "I", "m", "going", "to", "go", "ahead", "and", "close", "this", "PR", "since", "there", "be", "performance", "reasons", "for", "the", "unrolled", "loop", "NUMBER", "Thanks", "for", "the", "fix", "and", "the", "LOG", "entry", "You", "ll", "need", "to", "capture", "a", "continuation", "that", "can", "be", "invoked", "by", "the", "exception", "handler", "NUMBER", "One", "way", "would", "be", "to", "define", "a", "function", "that", "grabs", "the", "continuation", "and", "parameterizes", "the", "base", "exception", "handler", "during", "the", "call", "to", "eval", "to", "something", "that", "invokes", "that", "continuation", "after", "debug", "returns", "An", "easier", "solution", "would", "be", "to", "have", "the", "function", "use", "guard", "NUMBER", "If", "you", "want", "debug", "to", "do", "anything", "but", "print", "Nothing", "to", "debug", "NUMBER", "and", "exit", "your", "exception", "handler", "should", "set", "the", "debug", "condition", "parameter", "before", "calling", "debug", "NUMBER", "Please", "add", "an", "appropriate", "entry", "to", "LOG", "describing", "the", "change", "NUMBER", "I", "haven", "t", "had", "time", "yet", "to", "look", "over", "the", "change", "NUMBER", "What", "be", "the", "purpose", "of", "Mf", "embed", "NUMBER", "Where", "be", "the", "file", "install", "Do", "you", "differentiate", "the", "library", "install", "location", "based", "on", "whether", "it", "s", "a", "NUMBER", "bit", "build", "or", "a", "NUMBER", "bit", "build", "For", "the", "most", "part", "R", "NUMBER", "RS", "try", "to", "remain", "representation", "agnostic", "to", "allow", "a", "wide", "variety", "of", "implementation", "choices", "for", "inexact", "arithmetic", "NUMBER", "One", "choice", "be", "to", "use", "arbitrary", "precision", "inexact", "arithmetic", "in", "which", "all", "finite", "numbers", "be", "representable", "albeit", "imprecisely", "and", "in", "which", "inf", "NUMBER", "and", "inf", "NUMBER", "represent", "only", "non", "finite", "numbers", "NUMBER", "An", "implementation", "may", "however", "choose", "to", "treat", "finite", "numbers", "as", "inf", "NUMBER", "and", "inf", "NUMBER", "if", "they", "be", "out", "of", "that", "implementation", "s", "representable", "range", "NUMBER", "The", "exact", "zero", "value", "of", "NUMBER", "inf", "NUMBER", "derives", "from", "that", "choice", "in", "such", "an", "implementation", "inf", "NUMBER", "and", "inf", "NUMBER", "most", "often", "represent", "out", "of", "range", "finite", "numbers", "and", "multiplying", "such", "numbers", "by", "exact", "NUMBER", "should", "produce", "exact", "NUMBER", "A", "program", "needing", "infinities", "that", "never", "represent", "mere", "out", "of", "range", "finite", "numbers", "isn", "t", "well", "served", "by", "this", "NUMBER", "My", "guess", "be", "such", "program", "aren", "t", "common", "aren", "t", "well", "served", "anyway", "by", "a", "single", "pair", "of", "infinities", "representing", "all", "cardinalities", "and", "might", "even", "require", "some", "form", "of", "symbolic", "arithmetic", "NUMBER", "What", "s", "wrong", "here", "be", "that", "NUMBER", "NUMBER", "evaluates", "to", "inf", "NUMBER", "It", "should", "be", "an", "error", "or", "at", "least", "nan", "NUMBER", "since", "a", "it", "be", "division", "by", "exact", "zero", "not", "something", "arbitrarily", "close", "to", "zero", "and", "b", "the", "sign", "be", "indeterminate", "since", "exact", "NUMBER", "be", "neither", "positive", "nor", "negative", "NUMBER", "R", "NUMBER", "RS", "however", "requires", "NUMBER", "NUMBER", "to", "return", "inf", "NUMBER", "under", "the", "assumption", "that", "NUMBER", "be", "first", "converted", "to", "NUMBER", "inf", "NUMBER", "and", "inf", "NUMBER", "shouldn", "t", "be", "use", "when", "something", "went", "wrong", "as", "in", "this", "example", "NUMBER", "Should", "NUMBER", "also", "be", "treated", "as", "NUMBER", "And", "what", "be", "the", "value", "of", "NUMBER", "NUMBER", "Your", "third", "note", "back", "claims", "it", "s", "problematic", "for", "NUMBER", "inf", "NUMBER", "to", "give", "a", "different", "result", "from", "NUMBER", "inf", "NUMBER", "when", "NUMBER", "NUMBER", "evaluates", "to", "t", "NUMBER", "By", "the", "same", "logic", "it", "s", "equally", "problematic", "for", "NUMBER", "NUMBER", "to", "give", "a", "different", "result", "from", "NUMBER", "NUMBER", "when", "NUMBER", "NUMBER", "evaluates", "to", "t", "yet", "that", "s", "what", "your", "second", "and", "first", "note", "back", "require", "NUMBER", "So", "your", "interpretation", "be", "problematic", "or", "your", "logic", "be", "flawed", "NUMBER", "In", "this", "issue", "your", "logic", "be", "flawed", "numeric", "equality", "be", "inherently", "imprecise", "when", "inexact", "numbers", "be", "involved", "and", "do", "not", "imply", "identical", "behavior", "NUMBER", "There", "be", "many", "cases", "where", "the", "behavior", "of", "numerically", "equal", "numbers", "can", "differ", "NUMBER", "For", "example", "NUMBER", "NUMBER", "t", "but", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "f", "NUMBER", "Your", "interpretation", "has", "a", "flaw", "as", "well", "because", "R", "NUMBER", "RS", "calculations", "treat", "NUMBER", "differently", "from", "NUMBER", "in", "more", "than", "the", "one", "case", "you", "brought", "up", "originally", "precisely", "because", "NUMBER", "be", "exactly", "NUMBER", "and", "NUMBER", "be", "not", "NUMBER", "A", "trivial", "example", "be", "that", "NUMBER", "NUMBER", "while", "NUMBER", "NUMBER", "NUMBER", "A", "particularly", "relevant", "example", "be", "that", "NUMBER", "NUMBER", "raises", "an", "exception", "while", "NUMBER", "NUMBER", "do", "not", "NUMBER", "Also", "as", "has", "be", "observed", "recently", "LINK", "an", "inexact", "zero", "imaginary", "part", "makes", "a", "complex", "number", "non", "real", "while", "an", "exact", "zero", "imaginary", "part", "do", "not", "NUMBER", "This", "difference", "shows", "up", "in", "calculations", "too", "e", "NUMBER", "g", "NUMBER", "cos", "NUMBER", "NUMBER", "i", "cos", "NUMBER", "NUMBER", "while", "cos", "NUMBER", "NUMBER", "i", "NUMBER", "NUMBER", "NUMBER", "The", "possibility", "of", "other", "interpretations", "aside", "I", "remain", "comfortable", "with", "the", "interpretation", "that", "NUMBER", "and", "NUMBER", "be", "close", "to", "but", "not", "quite", "zero", "and", "inf", "NUMBER", "and", "inf", "NUMBER", "be", "large", "but", "not", "quite", "infinity", "NUMBER", "My", "preference", "for", "this", "interpretation", "reflects", "a", "the", "fact", "that", "inf", "NUMBER", "and", "inf", "NUMBER", "can", "arise", "through", "overflow", "or", "through", "underflow", "followed", "by", "division", "and", "b", "my", "suspicion", "that", "they", "arise", "this", "way", "much", "more", "often", "than", "through", "the", "intentional", "introduction", "of", "a", "true", "infinity", "NUMBER", "So", "I", "remain", "convinced", "that", "in", "Chez", "Scheme", "NUMBER", "TAG", "should", "continue", "to", "evaluate", "to", "NUMBER", "which", "R", "NUMBER", "RS", "allows", "and", "TAG", "NUMBER", "should", "raise", "an", "exception", "which", "R", "NUMBER", "RS", "do", "not", "allow", "though", "I", "m", "tempted", "to", "arrange", "for", "the", "version", "of", "export", "from", "the", "chezscheme", "library", "to", "do", "so", "NUMBER", "This", "commit", "LINK", "should", "fix", "the", "problem", "NUMBER", "I", "would", "rather", "have", "pull", "your", "fix", "but", "as", "you", "point", "out", "your", "change", "was", "not", "the", "correct", "fix", "NUMBER", "While", "tempting", "add", "instructions", "for", "installing", "XQuartz", "would", "be", "inconsistent", "unless", "we", "provide", "similar", "instructions", "for", "other", "things", "upon", "which", "we", "depend", "such", "as", "the", "required", "package", "file", "for", "various", "flavors", "of", "Linux", "or", "the", "required", "tool", "for", "various", "version", "of", "Windows", "NUMBER", "This", "be", "a", "slippery", "slope", "with", "no", "clear", "stopping", "point", "and", "I", "d", "prefer", "in", "any", "case", "not", "to", "take", "on", "the", "responsibility", "of", "maintaining", "correct", "instructions", "for", "other", "package", "as", "things", "change", "NUMBER", "The", "intent", "be", "for", "guard", "not", "to", "ruin", "a", "continuable", "exception", "by", "use", "raise", "to", "re", "raise", "an", "exception", "that", "might", "have", "be", "raise", "by", "raise", "continuable", "NUMBER", "It", "s", "not", "to", "convert", "a", "raise", "into", "a", "raise", "continuable", "NUMBER", "When", "you", "use", "raise", "you", "get", "to", "assume", "it", "will", "never", "return", "NUMBER", "To", "your", "point", "about", "the", "utility", "of", "raise", "continuable", "it", "s", "useful", "for", "issue", "warnings", "including", "via", "warning", "warningf", "i", "NUMBER", "e", "NUMBER", "raising", "non", "fatal", "exception", "while", "allowing", "the", "dynamic", "context", "the", "opportunity", "to", "display", "them", "treat", "them", "as", "error", "or", "ignore", "them", "NUMBER", "One", "can", "also", "use", "it", "to", "allow", "the", "dynamic", "context", "more", "control", "over", "what", "the", "code", "raising", "the", "exception", "should", "do", "NUMBER", "For", "example", "a", "library", "routine", "might", "raise", "a", "continuable", "exception", "when", "it", "can", "t", "find", "a", "required", "file", "and", "allow", "the", "dynamic", "context", "to", "supply", "one", "possibly", "by", "querying", "the", "user", "NUMBER", "Thanks", "for", "work", "on", "this", "NUMBER", "It", "would", "be", "nice", "to", "have", "Chez", "Scheme", "available", "via", "macports", "NUMBER", "Honoring", "the", "CC", "variable", "preferably", "at", "configure", "time", "ala", "CFLAGS", "CPPFLAGS", "and", "LDFLAGS", "seems", "like", "a", "reasonable", "and", "straightforward", "change", "to", "make", "NUMBER", "Feel", "free", "to", "make", "the", "change", "yourself", "and", "put", "in", "a", "pull", "request", "or", "let", "me", "know", "if", "you", "d", "prefer", "we", "do", "it", "NUMBER", "The", "complaints", "about", "zlib", "in", "the", "ticket", "be", "due", "to", "a", "couple", "of", "misunderstandings", "NUMBER", "First", "we", "link", "statically", "against", "libz", "NUMBER", "a", "so", "the", "install", "location", "for", "the", "dynamic", "library", "be", "irrelevant", "NUMBER", "Second", "X", "NUMBER", "be", "required", "by", "the", "expression", "editor", "not", "by", "zlib", "NUMBER", "So", "I", "would", "push", "back", "on", "this", "so", "we", "don", "t", "have", "to", "hook", "the", "configure", "build", "process", "to", "support", "other", "mechanisms", "for", "including", "zlib", "NUMBER", "That", "begs", "the", "question", "about", "the", "X", "NUMBER", "include", "file", "NUMBER", "The", "reason", "why", "they", "re", "needed", "by", "the", "expression", "editor", "be", "covered", "in", "the", "discussion", "of", "issue", "NUMBER", "LINK", "NUMBER", "The", "macports", "version", "should", "support", "use", "under", "X", "NUMBER", "if", "possible", "NUMBER", "If", "compile", "against", "the", "X", "NUMBER", "libraries", "be", "not", "possible", "we", "ll", "have", "to", "provide", "a", "way", "to", "build", "without", "X", "NUMBER", "and", "leave", "Xquartz", "users", "with", "a", "choice", "between", "use", "macports", "to", "install", "Chez", "Scheme", "or", "get", "full", "functionality", "NUMBER", "dybvig", "do", "you", "think", "we", "should", "add", "Sstring_utf", "NUMBER", "or", "update", "S_string", "to", "process", "UTF", "NUMBER", "I", "don", "t", "see", "any", "cases", "in", "the", "C", "code", "that", "use", "an", "NUMBER", "bit", "encoding", "other", "than", "UTF", "NUMBER", "Commit", "LINK", "address", "this", "issue", "NUMBER", "The", "command", "line", "argument", "and", "environment", "variables", "be", "now", "processed", "for", "Unicode", "NUMBER", "I", "add", "Sstring_utf", "NUMBER", "to", "the", "scheme", "NUMBER", "h", "interface", "to", "make", "it", "convenient", "to", "create", "Unicode", "Scheme", "strings", "from", "C", "NUMBER", "The", "inspector", "shows", "only", "what", "s", "currently", "in", "the", "continuation", "i", "NUMBER", "e", "NUMBER", "the", "calls", "that", "still", "remain", "to", "be", "returned", "from", "and", "this", "be", "often", "insufficient", "NUMBER", "You", "might", "find", "this", "document", "LINK", "useful", "for", "general", "debugging", "tips", "NUMBER", "For", "unbound", "identifiers", "the", "best", "advice", "I", "can", "give", "you", "be", "to", "re", "structure", "your", "code", "into", "libraries", "and", "top", "level", "program", "NUMBER", "Library", "and", "program", "scopes", "be", "self", "contained", "and", "you", "get", "compile", "time", "error", "identifying", "the", "location", "of", "unbound", "identifiers", "NUMBER", "If", "that", "s", "not", "practical", "you", "can", "always", "grep", "for", "unbound", "identifier", "with", "relatively", "unique", "names", "and", "if", "the", "uses", "aren", "t", "obviously", "unbound", "rename", "one", "at", "a", "time", "or", "half", "of", "them", "at", "a", "time", "if", "there", "be", "a", "lot", "to", "something", "you", "know", "to", "be", "bound", "and", "see", "if", "you", "can", "narrow", "it", "down", "that", "way", "NUMBER", "Having", "use", "ulimit", "on", "other", "operate", "systems", "to", "deal", "with", "this", "sort", "of", "problem", "I", "can", "understand", "the", "frustration", "of", "dealing", "with", "an", "operate", "system", "or", "shell", "that", "doesn", "t", "provide", "such", "a", "mechanism", "but", "I", "m", "not", "excited", "about", "add", "a", "mechanism", "to", "Chez", "Scheme", "first", "because", "it", "s", "otherwise", "unnecessary", "and", "second", "because", "it", "would", "necessarily", "be", "incomplete", "in", "that", "it", "wouldn", "t", "be", "appropriate", "to", "track", "all", "allocation", "by", "a", "process", "just", "the", "allocation", "for", "which", "Chez", "Scheme", "be", "directly", "responsible", "NUMBER", "A", "quick", "web", "search", "turned", "up", "a", "couple", "of", "third", "party", "tool", "you", "might", "be", "able", "use", "for", "this", "purpose", "and", "not", "only", "for", "Scheme", "program", "NUMBER", "The", "malloc", "result", "should", "definitely", "be", "checked", "because", "memcpy", "might", "do", "worse", "than", "crash", "the", "system", "when", "pass", "a", "null", "pointer", "NUMBER", "It", "should", "be", "fine", "for", "S_create_thread_object", "to", "call", "S_error", "to", "report", "a", "malloc", "failure", "when", "S_create_thread_object", "be", "call", "from", "the", "parent", "thread", "via", "S_fork_thread", "but", "it", "s", "worth", "thinking", "about", "what", "happens", "when", "S_create_thread_object", "be", "call", "from", "the", "child", "thread", "via", "Sactivate_thread", "NUMBER", "Nothing", "good", "probably", "because", "Sactivate_thread", "sets", "the", "thread", "context", "to", "the", "base", "thread", "s", "context", "which", "the", "new", "thread", "has", "no", "business", "use", "NUMBER", "Sactivate_thread", "should", "probably", "set", "the", "thread", "context", "to", "null", "rather", "than", "the", "base", "thread", "context", "before", "calling", "S_create_thread_object", "with", "the", "latter", "taking", "the", "parent", "thread", "context", "as", "an", "argument", "and", "with", "do_error", "in", "schsig", "NUMBER", "c", "going", "the", "errors_to_console", "route", "when", "the", "thread", "context", "be", "null", "NUMBER", "Then", "S_create_thread_object", "can", "use", "S_error", "to", "report", "a", "malloc", "failure", "NUMBER", "We", "d", "need", "to", "make", "sure", "S_create_thread_object", "can", "t", "lead", "to", "other", "references", "to", "the", "thread", "context", "that", "will", "fail", "if", "it", "s", "set", "to", "null", "NUMBER", "Those", "should", "also", "be", "address", "NUMBER", "I", "will", "fix", "these", "when", "I", "get", "the", "chance", "but", "will", "be", "just", "as", "happy", "if", "someone", "beats", "me", "to", "it", "NUMBER", "There", "be", "a", "couple", "of", "issue", "here", "NUMBER", "One", "issue", "be", "whether", "some", "of", "the", "build", "in", "subsystems", "or", "individual", "features", "should", "be", "moved", "from", "core", "into", "external", "libraries", "NUMBER", "That", "will", "have", "to", "wait", "until", "there", "s", "a", "good", "repository", "for", "Chez", "Scheme", "libraries", "and", "a", "good", "mechanism", "for", "accessing", "it", "NUMBER", "Even", "with", "that", "some", "things", "that", "could", "theoretically", "move", "out", "won", "t", "because", "they", "support", "other", "things", "in", "the", "core", "or", "can", "be", "implement", "more", "efficiently", "within", "the", "core", "NUMBER", "The", "other", "issue", "be", "whether", "the", "chezscheme", "library", "should", "continue", "to", "export", "everything", "in", "the", "core", "NUMBER", "The", "chezscheme", "library", "be", "useful", "when", "one", "just", "wants", "to", "write", "code", "and", "doesn", "t", "want", "to", "figure", "out", "which", "libraries", "be", "needed", "to", "access", "to", "a", "build", "in", "binding", "NUMBER", "To", "serve", "that", "purpose", "it", "needs", "to", "remain", "universal", "and", "so", "must", "export", "not", "only", "all", "current", "bindings", "but", "also", "all", "future", "core", "bindings", "NUMBER", "In", "any", "case", "defining", "additional", "libraries", "that", "export", "the", "core", "bindings", "of", "individual", "subsystems", "be", "a", "fine", "idea", "for", "example", "an", "additional", "library", "for", "the", "SRFI", "NUMBER", "time", "and", "date", "procedures", "could", "be", "useful", "NUMBER", "The", "nanopass", "library", "be", "not", "a", "good", "example", "incidentally", "since", "it", "defines", "bindings", "that", "aren", "t", "build", "in", "and", "more", "importantly", "be", "and", "always", "has", "be", "a", "separate", "project", "and", "code", "base", "NUMBER", "No", "short", "of", "disassembling", "the", "code", "that", "dispatches", "on", "argument", "count", "NUMBER", "It", "s", "probably", "possible", "NUMBER", "Doing", "so", "would", "likely", "involve", "modifying", "both", "the", "machine", "independent", "and", "machine", "dependent", "handle", "of", "these", "form", "NUMBER", "This", "looks", "about", "right", "NUMBER", "Please", "make", "the", "following", "change", "NUMBER", "Condition", "the", "deactivate_thread", "and", "reactivate_thread", "calls", "on", "DISABLECOUNT", "tc", "FIX", "NUMBER", "NUMBER", "Disabling", "interrupts", "_should_", "prevent", "automatic", "collections", "NUMBER", "NUMBER", "Move", "the", "declaration", "of", "tc", "to", "the", "top", "of", "the", "function", "body", "NUMBER", "The", "assignment", "can", "remain", "where", "it", "be", "NUMBER", "Some", "C", "compilers", "don", "t", "like", "inline", "declarations", "so", "we", "avoid", "them", "generally", "NUMBER", "NUMBER", "Add", "a", "LOG", "entry", "describing", "the", "change", "NUMBER", "You", "ll", "should", "pull", "the", "latest", "version", "from", "master", "so", "you", "be", "modifying", "the", "current", "copy", "of", "LOG", "NUMBER", "That", "s", "correct", "NUMBER", "The", "c", "code", "boot", "file", "loader", "has", "no", "way", "to", "talk", "with", "the", "Scheme", "code", "library", "manager", "NUMBER", "One", "way", "to", "fix", "this", "would", "be", "to", "switch", "from", "the", "C", "code", "loader", "to", "the", "Scheme", "code", "loader", "once", "the", "latter", "be", "in", "place", "NUMBER", "It", "might", "also", "be", "possible", "to", "have", "the", "C", "code", "loader", "invoke", "Scheme", "code", "library", "manager", "procedures", "NUMBER", "I", "don", "t", "know", "whether", "there", "be", "other", "issue", "with", "compiled", "libraries", "in", "boot", "file", "NUMBER", "Indeed", "NUMBER", "In", "fact", "there", "were", "more", "substantial", "change", "which", "somehow", "escaped", "mention", "in", "the", "release", "note", "NUMBER", "I", "ve", "rectified", "that", "and", "update", "system", "NUMBER", "ex", "NUMBER", "Extending", "the", "exist", "ftype", "ref", "and", "ftype", "set", "form", "to", "work", "for", "bytevectors", "would", "add", "dispatch", "overhead", "to", "the", "generate", "code", "and", "increase", "the", "code", "size", "NUMBER", "A", "better", "option", "might", "be", "to", "add", "bytevector", "specific", "version", "of", "the", "form", "NUMBER", "I", "would", "be", "inclined", "to", "limit", "those", "version", "to", "operate", "on", "scalar", "field", "and", "not", "to", "support", "a", "bytevector", "version", "of", "ftype", "ref", "to", "avoid", "issue", "with", "pointers", "into", "and", "out", "of", "bytevectors", "NUMBER", "It", "seems", "like", "this", "issue", "be", "resolve", "so", "I", "m", "closing", "it", "NUMBER", "There", "be", "an", "uninstall", "target", "in", "Mf", "install", "but", "it", "only", "echos", "instructions", "and", "I", "don", "t", "think", "it", "handles", "scheme", "script", "NUMBER", "I", "ll", "look", "into", "this", "NUMBER", "I", "add", "an", "uninstall", "target", "in", "NUMBER", "e", "NUMBER", "fc", "NUMBER", "ceede", "NUMBER", "f", "NUMBER", "d", "NUMBER", "b", "NUMBER", "f", "NUMBER", "Yes", "thank", "you", "configure", "considers", "a", "machine", "type", "m", "available", "if", "the", "file", "boot", "m", "scheme", "NUMBER", "boot", "be", "present", "so", "you", "first", "need", "to", "create", "that", "boot", "file", "NUMBER", "To", "get", "the", "required", "boot", "and", "header", "file", "in", "place", "try", "the", "instructions", "given", "in", "BUILDING", "in", "the", "second", "paragraph", "under", "make", "bootfiles", "NUMBER", "No", "NUMBER", "I", "get", "caught", "up", "discussing", "the", "colors", "and", "the", "color", "assignment", "algorithm", "with", "a", "data", "visualization", "expert", "Rachael", "Brady", "in", "our", "group", "at", "Cisco", "NUMBER", "For", "colors", "she", "has", "suggested", "add", "a", "dedicated", "color", "for", "executed", "once", "to", "go", "along", "with", "the", "exist", "dedicated", "not", "profiled", "and", "profiled", "but", "not", "executed", "colors", "and", "trying", "different", "shades", "of", "blue", "for", "all", "of", "the", "others", "except", "the", "highest", "count", "group", "which", "would", "get", "something", "like", "red", "or", "yellow", "so", "only", "the", "latter", "really", "stands", "out", "NUMBER", "I", "was", "going", "to", "play", "with", "that", "before", "committing", "your", "change", "but", "I", "haven", "t", "had", "a", "chance", "yet", "to", "do", "so", "NUMBER", "Michael", "I", "m", "finally", "get", "around", "to", "this", "and", "I", "would", "like", "to", "merge", "the", "change", "you", "made", "without", "make", "any", "additional", "change", "yet", "at", "least", "NUMBER", "The", "only", "thing", "stopping", "me", "right", "now", "be", "a", "LOG", "entry", "NUMBER", "If", "you", "wouldn", "t", "mind", "please", "update", "your", "repo", "and", "append", "an", "appropriate", "entry", "to", "LOG", "possibly", "crafted", "from", "the", "commit", "log", "text", "NUMBER", "Also", "Rachael", "seem", "to", "like", "the", "lighter", "background", "and", "I", "don", "t", "really", "have", "a", "preference", "so", "if", "you", "also", "prefer", "the", "lighter", "background", "you", "should", "go", "ahead", "and", "commit", "that", "NUMBER", "I", "don", "t", "have", "an", "opinion", "about", "the", "CSS", "change", "you", "suggest", "NUMBER", "Since", "I", "ve", "heard", "no", "objections", "from", "others", "I", "d", "say", "go", "it", "if", "you", "re", "so", "inclined", "NUMBER", "I", "m", "closing", "this", "pull", "request", "pending", "completion", "of", "a", "more", "complete", "update", "NUMBER", "This", "commit", "LINK", "add", "a", "print", "extend", "identifier", "parameter", "that", "when", "t", "causes", "the", "printer", "to", "print", "and", "and", "other", "extend", "identifiers", "like", "NUMBER", "without", "escapes", "NUMBER", "Have", "you", "looked", "into", "use", "the", "wide", "version", "of", "ncurses", "ncursesw", "If", "it", "works", "it", "should", "simplify", "the", "input", "side", "plus", "I", "m", "not", "sure", "the", "non", "wide", "ncurses", "will", "even", "deliver", "multibyte", "input", "characters", "NUMBER", "Thanks", "for", "the", "pointer", "to", "the", "comment", "NUMBER", "I", "had", "forgotten", "curses", "getch", "NUMBER", "required", "that", "we", "go", "full", "screen", "NUMBER", "The", "NUMBER", "gitignore", "file", "should", "use", "Makefile", "instead", "of", "Makefile", "just", "as", "you", "suggested", "NUMBER", "Thanks", "so", "much", "for", "finding", "this", "Fixed", "in", "commit", "NUMBER", "fb", "NUMBER", "ea", "NUMBER", "bc", "NUMBER", "d", "NUMBER", "a", "NUMBER", "cf", "NUMBER", "d", "NUMBER", "Yes", "the", "windows", "build", "be", "a", "bit", "rickety", "but", "it", "actually", "was", "recently", "test", "and", "work", "NUMBER", "Part", "of", "the", "trick", "as", "noted", "in", "the", "BUILDING", "document", "be", "that", "you", "need", "to", "put", "the", "ChezScheme", "directory", "on", "a", "shared", "file", "system", "for", "example", "on", "a", "samba", "share", "and", "mount", "it", "from", "Windows", "NUMBER", "This", "lets", "the", "Linux", "side", "of", "the", "build", "do", "its", "part", "run", "configure", "and", "setting", "up", "symlinks", "and", "the", "like", "and", "the", "Windows", "side", "see", "it", "as", "though", "it", "was", "a", "just", "a", "normal", "file", "system", "NUMBER", "It", "be", "suboptimal", "but", "it", "was", "recently", "test", "NUMBER", "Our", "setup", "for", "test", "has", "be", "a", "Windows", "VM", "run", "on", "an", "older", "Fedora", "NUMBER", "machine", "with", "the", "chezscheme", "directory", "hosted", "on", "the", "Fedora", "machine", "and", "Windows", "mounting", "the", "directory", "through", "samba", "NUMBER", "metab", "NUMBER", "t", "No", "the", "symlinks", "be", "only", "needed", "for", "the", "build", "process", "NUMBER", "Once", "things", "be", "complete", "you", "can", "copy", "the", "contents", "of", "the", "bin", "and", "boot", "directories", "which", "be", "now", "the", "file", "that", "have", "be", "produced", "by", "the", "Windows", "C", "and", "Chez", "Scheme", "compilers", "NUMBER", "Commit", "e", "NUMBER", "a", "NUMBER", "f", "NUMBER", "f", "NUMBER", "c", "NUMBER", "a", "NUMBER", "d", "NUMBER", "b", "NUMBER", "f", "NUMBER", "eaa", "NUMBER", "cad", "NUMBER", "add", "support", "for", "MinGW", "MSYS", "build", "of", "Chez", "Scheme", "on", "Windows", "NUMBER", "We", "still", "use", "the", "Microsoft", "C", "compiler", "NUMBER", "The", "Travis", "continuous", "integration", "server", "now", "uses", "a", "variant", "of", "MSYS_NT", "to", "build", "and", "test", "the", "Windows", "version", "of", "Chez", "Scheme", "NUMBER", "Thanks", "for", "the", "the", "and", "relate", "fix", "NalaGinrut", "You", "can", "disable", "the", "collector", "use", "the", "collection", "request", "handler", "from", "the", "NUMBER", "version", "of", "CSUG", "chapter", "NUMBER", "LINK", "NUMBER", "smgmt", "s", "NUMBER", "Automatic", "collection", "may", "be", "disabled", "by", "setting", "collect", "request", "handler", "to", "a", "procedure", "that", "do", "nothing", "e", "NUMBER", "g", "NUMBER", "collect", "request", "handler", "void", "However", "as", "the", "collection", "time", "be", "fairly", "small", "I", "would", "hazard", "to", "guess", "it", "be", "actually", "the", "bignum", "arithmetic", "that", "be", "killing", "this", "NUMBER", "I", "suspect", "we", "ll", "have", "to", "improve", "the", "bignum", "operations", "in", "number", "NUMBER", "c", "to", "improve", "the", "results", "of", "this", "NUMBER", "As", "we", "think", "about", "trying", "to", "improve", "the", "bignum", "implementation", "in", "Chez", "it", "might", "be", "interesting", "to", "take", "a", "look", "at", "the", "Glasgow", "Haskell", "Compiler", "GHC", "work", "around", "the", "same", "issue", "LINK", "They", "start", "from", "a", "different", "point", "in", "that", "GHC", "had", "be", "use", "the", "GNU", "MP", "but", "there", "were", "uses", "of", "GHC", "for", "whom", "the", "LGPL", "licensing", "of", "GNU", "MP", "was", "problematic", "see", "LINK", "NUMBER", "They", "experimented", "with", "a", "number", "of", "other", "fast", "arbitrary", "precision", "libraries", "with", "more", "permissive", "licenses", "as", "well", "as", "creating", "a", "fast", "enough", "implementation", "in", "Haskell", "NUMBER", "One", "or", "more", "of", "these", "more", "permissively", "licensed", "libraries", "might", "be", "an", "interesting", "option", "for", "improving", "Chez", "s", "bignum", "performance", "NUMBER", "As", "of", "NUMBER", "years", "ago", "when", "the", "GHC", "community", "went", "through", "this", "exercise", "there", "were", "quite", "a", "few", "interesting", "trade", "offs", "in", "performance", "given", "the", "libraries", "available", "at", "the", "time", "NUMBER", "I", "find", "an", "additional", "library", "bigz", "LINK", "listed", "on", "the", "wikipedia", "arbitrary", "precision", "page", "LINK", "_of_arbitrary", "precision_arithmetic_software", "NUMBER", "Since", "it", "has", "be", "NUMBER", "years", "since", "the", "GHC", "community", "did", "these", "experiments", "it", "be", "probably", "worth", "evaluating", "the", "options", "again", "NUMBER", "hyln", "NUMBER", "I", "ll", "have", "to", "look", "at", "the", "DCE", "as", "a", "separate", "issue", "NUMBER", "johnwcowan", "I", "m", "happy", "to", "bless", "this", "with", "the", "caveat", "that", "I", "ve", "not", "be", "much", "of", "an", "IRC", "user", "over", "the", "last", "NUMBER", "or", "so", "years", "but", "I", "will", "try", "to", "drop", "in", "from", "time", "to", "time", "if", "that", "be", "acceptable", "NUMBER", "Sounds", "good", "NUMBER", "I", "definitely", "bless", "it", "then", "NUMBER", "I", "did", "drop", "in", "for", "a", "bit", "last", "night", "and", "I", "will", "try", "to", "make", "some", "effort", "to", "drop", "in", "from", "time", "to", "time", "NUMBER", "Do", "you", "need", "anything", "beyond", "me", "saying", "it", "be", "blessed", "to", "make", "it", "official", "Do", "you", "need", "me", "to", "send", "anything", "to", "freenode", "NUMBER", "net", "for", "instance", "If", "not", "feel", "free", "to", "consider", "this", "matter", "blessed", "and", "we", "can", "close", "this", "out", "NUMBER", "Done", "NUMBER", "Andy", "Keep", "Sent", "with", "Airmail", "On", "April", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "NUMBER", "AM", "johnwcowan", "notifications", "github", "NUMBER", "com", "write", "That", "barfed", "NUMBER", "It", "s", "msg", "nickserv", "register", "password", "email", "address", "You", "be", "receiving", "this", "because", "you", "commented", "NUMBER", "Reply", "to", "this", "email", "directly", "or", "view", "it", "on", "GitHub", "I", "can", "reproduce", "the", "time", "problem", "on", "my", "Mac", "OS", "X", "install", "by", "change", "my", "timezone", "NUMBER", "I", "ve", "not", "had", "a", "chance", "to", "look", "and", "see", "if", "this", "be", "just", "a", "bad", "test", "because", "it", "be", "dependent", "on", "timezone", "or", "if", "we", "be", "producing", "the", "wrong", "results", "NUMBER", "As", "a", "test", "to", "my", "hypothesis", "be", "there", "anyone", "with", "their", "time", "zone", "set", "to", "Eastern", "Daylight", "Time", "EDT", "who", "be", "seeing", "this", "bug", "adamsmd", "Actually", "that", "be", "helpful", "NUMBER", "I", "know", "the", "current", "committers", "including", "myself", "be", "on", "Eastern", "Time", "and", "I", "think", "the", "problem", "be", "that", "we", "re", "printing", "a", "UTC", "time", "use", "the", "machines", "current", "locale", "NUMBER", "Basically", "the", "test", "needs", "to", "be", "update", "to", "make", "sure", "that", "the", "printed", "string", "be", "consistent", "regardless", "of", "locale", "NUMBER", "I", "ll", "try", "to", "fix", "this", "up", "tonight", "when", "I", "get", "home", "from", "work", "NUMBER", "It", "turned", "out", "there", "was", "a", "simple", "fix", "for", "the", "time", "utc", "date", "test", "we", "simply", "needed", "to", "pass", "the", "optional", "timezone", "offset", "to", "time", "utc", "date", "in", "the", "test", "NUMBER", "This", "should", "be", "correct", "in", "commit", "NUMBER", "ef", "NUMBER", "I", "m", "going", "to", "close", "this", "issue", "because", "I", "think", "dybvig", "has", "already", "address", "the", "file", "system", "issue", "but", "feel", "free", "to", "reopen", "if", "something", "be", "still", "broken", "NUMBER"], "text_count": [0, 15599, 3181, 1409, 721, 237, 961, 5, 61, 1768, 2761, 4276, 2292, 1434, 1886, 542, 0, 0, 0, 0, 4726, 1256, 791, 595, 951, 741, 0, 0, 0, 0, 8868, 5824, 3203, 289, 1813, 447, 0, 0, 0, 0, 10461, 85, 3595, 3231, 3947, 0, 0, 0, 0, 0, 3110, 1134, 1694, 807, 1071, 464, 1168, 0, 0, 0, 7683, 452, 6263, 511, 0, 0, 0, 0, 0, 0, 5788, 520, 3913, 1499, 1086, 0, 0, 0, 0, 0, 9726, 4152, 788, 4200, 601, 544, 0, 0, 0, 0, 731, 3140, 301, 0, 0, 0, 0, 0, 0, 0, 8426, 1738, 4777, 2104, 0, 0, 0, 0, 0, 0, 16861, 31907, 410, 1267, 334, 606, 0, 0, 0, 0, 42189, 193, 31563, 509, 8119, 9143]}, {"repo": "ChezScheme", "type": "nonelite", "title": "", "number of text": 848, "text": "  Building the compiler in safe mode for 32-bit x86 reveals incorrect uses of `fxzero?` in \"x86.ss\": a 32-bit immediate is not necessarily a fixnum.\r\n\r\nFor example, compilation of \"newhash.ss\" triggers an error, since it involves an `fx+` on 523658599 which turns into an inline `+` on the immediate 2094634396.\r\n\r\nThe misuses of `fxzero?` cause no trouble when compiled as unsafe, since that turns into a `eq?` that works as intended in this case.  This patch adds a `compress-level` parameter that can be used to control the amount of effort expended compressing, whether with the default LZ4 compression or gzip compression.  The parameter can take on one of the symbolic values `low`, `medium`, `high`, or `maximum`.   The default is medium, which for LZ4 currently maps to `LZ4HC_CLEVEL_MIN` and is both more effective and slower (at compression, but not decompression) than the previous default.  The patch also makes several changes to the LZ4-support code added in #410; in particular, it restructures the code a bit, puts the compress format directly in the thread context (which now also holds the compress level), and changes how the compressed bytevector compression format and length are stored in the header word.  I have tested the changes on OSX and Linux but not Windows. These changes look good to me.\r\n\r\n(Just to confirm, Racket-on-Chez builds fine with the patch, its boot file size goes down by about 17%, and load time remains about the same and maybe slightly faster.) Thanks for the corrections! Thanks for all the changes on this branch! Valgrind's memcheck tool is happy now.\r\n\r\nNote typo on line 85 of compress-io.c: \"lcoal\" -> \"local\".\r\n  At least, I think it's a typo.  If not, can someone explain what it means?\r\n\r\nhttps://www.scheme.com/tspl4/syntax.html#./syntax:h2 says, in the next-to-last bullet:\r\n> <tt><i>P</i></tt> is of the form <tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp; <i>P<sub>k</sub></i>&nbsp;<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>, where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt> and <tt><i>F</i></tt> is a vector of <i>n</i> or more elements whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>k</sub></i></tt>, whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></tt>, and whose remaining <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>\r\n\r\nShouldn't \"_n_ or more elements\" be just \"_n_ elements\" instead?\r\n\r\n(Section 11.19 of R6RS says the same thing.)\r\n\r\n Hmm.  That doesn't seem right either.  If the first _k_ elements match _P<sub>1</sub>_ through _P<sub>k</sub>_, and the last _m_ match _S<sub>1</sub>_ through _S<sub>m</sub>_, and there are _n_ altogether, the number of elements left to match _P<sub>e_ is _n_ - _k_ - _m_, not _n_ - _m_.  This seems like a good idea.  I would go for squashing in variation 1 162c044 (with experimental hg support).  This patch speeds up compressed-code loading (and decompression in general) by using LZ4 in place of zlib. Loading LZ4-compressed code on my machine takes about the same time as loading uncompressed code \u2014 in contrast to decompression via zlib, which makes loading take about twice as long.\r\n\r\nThis patch does not remove the use of zlib, but it adds LZ4 and makes it the default. Setting the `compress-format` parameter to `'gzip` makes compression use zlib instead of LZ4. Reading a compressed file infers the compression format, so `compress-format` has no effect on loading/reading.\r\n\r\nThe LZ4 implementation is pulled in via a submodule, analogous to zlib, but I added `ZLIB` and `LZ4` options to `configure` to enable selecting an existing zlib and/or lz4 build. The LZ4 source does not appear to have support for a non-DLL Windows build, so that part's especially ugly. How do we build the Scheme side? I get invalid memory accesses when using make, and with the patch file technique, I get unexpected primref records from $uncprep. @burgerrg Thanks for the repair, and I'll rename \"compress.*\" soon.\r\n\r\nI expect a build in a clean checkout to work (i.e., with the old checked-in bootfiles). Assuming that you don't already have some older bootfiles in your checkout, I don't know what went wrong. Technically, the checked-in boot files will call some kernel functions without a new boolean argument while bootstrapping, but a random value for that boolean should be harmless and merely cause a compression format to be selected at random for some intermediate steps. I did a clean build on both macOS and Windows but couldn't get it to work.\r\n\r\nOn macOS make in the s directory yields:\r\n```\r\necho '(reset-handler abort)'\\\r\n             '(base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))'\\\r\n             '(keyboard-interrupt-handler (lambda () (display \"interrupted---aborting\\n\") (reset)))'\\\r\n             '(optimize-level 3)'\\\r\n             '(debug-level 0)'\\\r\n             '(commonization-level (commonization-level))'\\\r\n             '(generate-inspector-information #f)'\\\r\n             '(subset-mode (quote system))'\\\r\n             '(compile-file \"cmacros.ss\" \"cmacros.so\")'\\\r\n             | ../bin/a6osx/scheme -q\r\ncompiling cmacros.ss with output to cmacros.so\r\nException in fasl-write: invalid fasl object #<foreign>\r\n```\r\n\r\nOn Windows make in the s directory yields:\r\n```\r\necho '(reset-handler abort)'\\\r\n             '(base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))'\\\r\n             '(keyboard-interrupt-handler (lambda () (display \"interrupted---aborting\\n\") (reset)))'\\\r\n             '(optimize-level 3)'\\\r\n             '(debug-level 0)'\\\r\n             '(commonization-level (commonization-level))'\\\r\n             '(generate-inspector-information #f)'\\\r\n             '(subset-mode (quote system))'\\\r\n             '(compile-file \"cmacros.ss\" \"cmacros.so\")'\\\r\n             | ../bin/a6nt/scheme.exe -q\r\nError in foreign-procedure: no entry for ~s\r\n(\"(cs)find_pcode\")\r\n``` @burgerrg Still no idea about the build problems, since things work for me from a clean build on macOS, Windows (WSL), and Linux, and the build works on Travis-CI. I note that `find_pcode` was removed in 68e20f7216 and the bootfiles were updated in 4b42811557. Maybe it will help somehow that I rebased to pull in yesterday's commit. I see that I overlooked lots of C compiler warnings on Windows. I'll fix those. Thanks! Rebased. This looks good to me---just a couple of nits:\r\n\r\n- In primdata.ss, the second signature for compress-format should be [(sub-symbol) -> (void)].\r\n- The copyright notice on compress-io.c identifies the file as system.h.\r\n- The copyright notice on compress-io.h is missing.\r\n\r\nI like the new mat parameters subform.\r\n\r\nI ran some quick tests on my machine (with solid state drive): start-up time (presumably mostly loading the boot files) dropped by about 9% with the change.  Bootstrapping time also dropped, by 6%.  Nice!  Though start-up time still took nearly twice as long for me with lz4-compressed boot files as with uncompressed boot files.\r\n Correction: start-up time with lz4 compression is actually 35% faster for me than with zlib compression and just 31% slower than with no compression.  (It turns out I was getting zlib-compressed boot files as a result of bootstrapping in an existing workarea.) Thanks for the copyright and \"primdata.ss\" repairs \u2013 now pushed.  Looks good, thanks for putting in those changes!  (/ 0 4.0) evaluates to 0.0. I'm not sure this is a bug, but I was expecting 0, like (* 0 0.25). Is there a good reason for the current behavior? >\n>\n> (/ 0 4.0) evaluates to 0.0. I'm not sure this is a bug, but I was\n> expecting 0, like (* 0 0.25). Is there a good reason for the current\n> behavior?\n>\n>\n> R6RS has the following example:\n\n    (/ 0 3.5)  \u21d2  0.0\n\nhttp://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.7.4.3\n Thanks.\r\n\r\nAfter thinking about it some more, I guess the argument is that 3.5, as an inexact number, could conceivably be so inaccurate that it's actually zero, in which case the quotient is undefined, not zero.  Hello,\r\n\r\nAfter the commit 7be1d190, a fresh build of Chez Scheme fails with the following error:\r\n```\r\ncannot find compatible scheme.boot in search path\r\n  \"${InstallPrefix}/lib/csv%v/%m\"\r\n```\r\n\r\nHere's the replication process for `a6le`:\r\n```bash\r\ngit clone https://github.com/cisco/ChezScheme\r\ncd ChezScheme\r\n./configure\r\nmake install\r\ncd ..\r\necho '(printf \"Works\\n\")' | scheme\r\n``` It looks like the changes to configure broke the way $w/c/config.h generates DEFAULT_HEAP_PATH on non-Windows systems. In particular, $installlib contains the literal ${InstallPrefix} instead of resolving it. That fixed it, thanks.\r\nAnd thank you for the quick response.  The following code works as expected in a terminal REPL, but not from an Emacs REPL:\r\n\r\n```\r\n(fork-thread\r\n (lambda ()\r\n  (let loop ()\r\n    (sleep (make-time 'time-duration 0 1))\r\n    (display \"Hello\")\r\n    (flush-output-port)\r\n    (loop))))\r\n```\r\n\r\nI've tried `run-scheme`, `comint-run`, `shell`, and `ansi-term`. Strangely, if I evaluate some stuff at the Emacs REPL, the thread seems to run briefly, then stops again.\r\n\r\nThis isn't a problem with printing or output ports. My actual code pushes OSC via UDP to SuperCollider, so the side-effect is audible - the behaviour is the same.\r\n\r\nI have been looking at similar issues, such as [this one](https://github.com/cisco/ChezScheme/issues/127), where @ovenpasta mentions this exact problem, but I don't really understand the conclusions. Apologies if this is obvious! If you use scheme --eedisable, you should see the same blocking behavior at a terminal REPL.\r\n\r\nI think the problem is caused by the REPL's blocking read to stdin holding the tc-mutex, although I'm not yet sure why that happens. Any other thread that needs this mutex (and it's used for lots of operations) would have to wait for the read to complete. Thanks for the quick reply! Yes I do see the same behaviour in that case.\r\n\r\nI suppose enabling the expression editor is probably a pretty bad idea in the Emacs environment (if it's even possible). It's a shame, as this is the only thing holding me back from a very nice live-coding music environment. I don't suppose there are any other workarounds you can think of? I'm looking into the root cause of the problem.\r\n\r\nIn the meantime, you could try [Swish](https://github.com/becls/swish), an extension of the single-threaded Chez Scheme that performs asynchronous I/O. Swish doesn't support UDP, so you'd have to code it. Wonderful! I'll give Swish a try. I put together the UDP myself anyway with modifcations to [this socket implementation](https://github.com/theschemer/socket). I can't thank you enough for your response, I've been stuck on this for a few days. Here's a work-around for Chez Scheme:\r\n```\r\n(define (fix-stdin)\r\n  (let ([stdin (transcoded-port (standard-input-port)\r\n                 (make-transcoder (utf-8-codec)))])\r\n    (current-input-port stdin)\r\n    (console-input-port stdin)))\r\n\r\n(fix-stdin)\r\n(fork-thread\r\n (lambda ()\r\n   (let loop ()\r\n     (sleep (make-time 'time-duration 0 1))\r\n     (display \"Hello\")\r\n     (flush-output-port)\r\n     (loop))))\r\n``` Chez Scheme sets the console input and output ports to be the same input/output port. The port handler (see s/io.ss) holds the tc-mutex around blocking calls. As a result, you must create a separate port if you want to do blocking reads without holding the tc-mutex. Section 15.6 of the [user guide](https://scheme.com/csug8/threads.html#./threads:h6) explains this:\r\n\r\n> The initial console and current input and output ports are thread-safe, as are transcript ports, so it is safe for multiple threads to print error and/or debugging messages to the console. The output may be interleaved, even within the same line, but the port will not become corrupted. Thread safety for these ports is accomplished at the high cost of acquiring a mutex for each I/O operation.\r\n\r\n@dybvig, perhaps the guide should also say that the same mutex is used for other system operations. As a result, if you're doing a blocking read on the initial console input port, beware that operations on other threads that require this mutex will block. > Here's a work-around for Chez Scheme:\r\n\r\nIt works, thank you so much! I did read that line in the user guide while investigating the issue, but I didn't realise it applied here.\r\n\r\nI'll take a look at Swish anyway, though I'm still downloading mactex (3.2GB!). @burgerrg You enabled me to get going and I'm making terrific progress on my music system, thanks! I'm running into a problem now that I believe is related. If anything goes wrong on my background thread, it stops altogether, and doesn't print any error messages. I'd like it to print an error and continue gracefully, by simply resetting the thunk that it's performing regularly. I tried this:\r\n\r\n```\r\n(define (my-thread-thunk)\r\n  (with-exception-handler\r\n      (lambda (x)\r\n\t(display x)\r\n\t(newline)\r\n\t(flush-output-port)\r\n\t(define-top-level-value 'p1 (lambda () (void))))\r\n    p1)\r\n```\r\n\r\nWhere `my-thread-thunk` is the thunk passed to `fork-thread` and `p1` is a thunk that does my work. But no dice - the thread just stops as before with no printout if `p1` raises an exception. The exception handler needs to invoke a continuation so that Chez Scheme doesn't subsequently raise a non-continuable error.\r\n\r\n```\r\n(fork-thread\r\n (lambda ()\r\n   (call/cc\r\n    (lambda (done)\r\n      (with-exception-handler\r\n       (lambda (e)\r\n         (pretty-print e)\r\n         (flush-output-port)\r\n         (done (void)))\r\n       (lambda ()\r\n         (let loop ()\r\n           (sleep (make-time 'time-duration 0 1))\r\n           (display \"Hello\")\r\n           (flush-output-port)\r\n           (error #f \"boom!\")\r\n           (loop))))))))\r\n```\r\n\r\nUsing the `guard` form is more succinct:\r\n```\r\n(fork-thread\r\n (lambda ()\r\n   (guard (x [else (display-condition x) (newline) (flush-output-port)])\r\n     (let loop ()\r\n       (sleep (make-time 'time-duration 0 1))\r\n       (display \"Hello\")\r\n       (flush-output-port)\r\n       (error #f \"boom!\")\r\n       (loop)))))\r\n``` The thread now seems to behave nicely, although I don't see an error printout. Actually, a simple call to `display` or `write` in the guard handler doesn't seem to work either. I'm sure I can figure that out though. \r\n\r\nThis prevents me needing to restart Chez when something goes wrong, which is a huge improvement. Thanks so much! That didn't seem to be it.  Welcome to the Ouroboros:\r\n\r\n> '#0=#0#\r\n#0=#0#\r\n\r\nIt's a reference to itself. But what is its type?\r\n\r\n> (pair? '#0=#0#)\r\n#f\r\n> (boolean? '#0=#0#)\r\n#f\r\n> (procedure? '#0=#0#)\r\n#f\r\n> (eq? (void) '#0=#0#)\r\n#f\r\n\r\nNo idea. But it's still a thing, this Ouroboros, and in fact, it's a unique thing --- there's only one like it, and you can place it in a list:\r\n\r\n> '(#0=#0#)\r\n(#0=#0#)\r\n\r\n> '(#0=#0# #1=#1# #2=#2#)\r\n(#0=#0# #0# #0#)\r\n\r\nThe Ouroboros is, in fact, so unique and special, that you can't have other Ouroboroi with mutually-pointing edges:\r\n\r\n> '(#0=#1# #1=#0#)\r\n  C-c C-c\r\n\r\nThis is an infinite loop out of which you exit only with a break (i.e., control-C). I'll say it again: This is an infinite loop in a mechanism that was specifically designed to avoid infinite loops that are inherent to naive processing of circular data structures.\r\n\r\nWhat did I step on just now? Is this a bug? Is this a feature? Why does it exist and what does it mean?\r\n\r\n\r\n The entire documentation on the reader being able to understand this syntax is the sentence\r\n\r\n> The graph syntax is understood by the procedure read, allowing graph structures to be printed and read consistently.\r\n\r\nin the documentation for `print-graph`, so unless you can construct any of those examples as normal scheme objects and `write` outputs them as you've shown, I'd say this is an example of undefined behavior (i.e., neither a bug nor a feature).\r\n\r\nThat's not to say that the behavior _shouldn't_ be either documented explicitly or changed so that it's handled as an error (like other invalid syntax in the reader). Undefined behaviour is a great term, but when the evaluation of '(#0=#0#) terminates and the evaluation of the very similar '(#0=#1# #1=#0#) results in an infinite loop, isn't that sufficient reason to call it a bug?\r\n\r\nFor example, the order of evaluation of procedure arguments is also undefined. This gives the implementer license to pick an  order. It does not give the implementer license to do something else: If there are two orders of evaluation possible, and one gives the value 2, and the other 3, then returning 47.23 cannot be justified just because the behaviour is undefined.  If I compile this file\r\n\r\n```\r\n(top-level-program\r\n  (import (chezscheme))\r\n\r\n  (define (main)\r\n    (let ([code (foreign-callable (lambda ()\r\n                                    (display \"Hello world\\n\")\r\n                                    ) () void)])\r\n      (display \"back from foreign-callable\\n\")\r\n      (lock-object code)\r\n      (foreign-callable-entry-point code))\r\n\r\n    (exit 0)\r\n    )\r\n  (scheme-start\r\n    (lambda ()\r\n      (main)))\r\n  )\r\n```\r\nlike so\r\n\r\n```\r\n(begin\r\n  (generate-wpo-files #t)\r\n  (compile-file \"testit.scm\"))\r\n```\r\nand then create a boot file\r\n```\r\n(begin\r\n  (compile-whole-program \"testit.wpo\" \"testit.so\")\r\n  (make-boot-file \"testit.boot\" '(\"petite\") \"testit.so\")\r\n  )\r\n```\r\nand run the boot file, I get \r\n```\r\ndca@dido:/tmp$ scheme -b testit.boot\r\nPetite Chez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\nException: invalid memory reference.  Some debugging context lost\r\n```\r\nBut, if I replace the setting of scheme-start with a call to main, compile and load the .so, it works:\r\n\r\n```\r\ndca@dido:/tmp$ scheme testit.so\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\nback from foreign-callable\r\ndca@dido:/tmp$\r\n```\r\n\r\nI suspect this has something to do with the code in the boot file being loaded into \"static\" memory, as discussed in Section 2.8 of the User Guide. Regardless of whether my guess is right, I am trying to build an application that involves callbacks (from gtk3) and calling to Scheme from C is essential. I would also like to use the packaging, efficiency and invocation advantages of boot files. This does not appear to be possible, unless there is a workaround for this problem, or I have done something incorrect. I would appreciate some guidance. Thank you. On Wed, 6 Feb 2019 at 21:03, R. Kent Dybvig <notifications@github.com>\nwrote:\n\n> You suspicion that this is connected with static memory is correct. When\n> any code object is relocated into the static generation, its relocation\n> table is dropped, since it won't ever need to be relocated again. Each time\n> a foreign-callable form is evaluated, however, a copy of the original code\n> object is created with a pointer to the Scheme procedure to be invoked\n> embedded in it. The relocation table is needed both to find the proper\n> location for the embedded pointer and because the freshly allocated code\n> object might be relocated by the collector. Since the static code object in\n> your example is missing its relocation table, the code that creates the\n> copy of the foreign-callable code object crashes.\n>\nThanks for figuring this out so quickly. Rather than using the workaround\nbelow, which would involve some re-arrangement of my code, because the\ncallbacks I am writing reference things defined in main as free variables,\nI can just temporarily not use a boot file and instead test it by loading\nthe application .so file into petite and call main instead of setting\nscheme-start. This will allow me to continue development. I can switch back\nto use of the boot file when your fix becomes available.\n\n/Don\n\n> Solving this probably involves setting a flag on each foreign-callable\n> code object to say its relocation table should not be dropped. In the\n> meantime, a workaround is to arrange for the foreign-callable form to be\n> evaluated at boot time (before the relocation table has been dropped), not\n> when (scheme-start) is invoked. For example, the following variation of\n> your example doesn't crash:\n>\n> (top-level-program\n>   (import (chezscheme))\n>\n>   (define code (foreign-callable (lambda ()\n>                                    (display \"Hello world\\n\")\n>                                    ) () void))\n>\n>   (define (main)\n>     (display \"back from foreign-callable\\n\")\n>     (lock-object code)\n>     (foreign-callable-entry-point code)\n>\n>     (exit 0)\n>     )\n>   (scheme-start\n>     (lambda ()\n>       (main)))\n>   )\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/392#issuecomment-461262433>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEzjJ65FUa5Tn7DbRf35BYEyMOWWyqjAks5vK4mBgaJpZM4akYQO>\n> .\n>\n On Thu, 7 Feb 2019 at 01:28, R. Kent Dybvig <notifications@github.com>\nwrote:\n\n> This should be fixed by this commit\n> <https://github.com/cisco/ChezScheme/commit/71d3abba684e04b134720ea1bd9a8c847c38ac5f>\n> .\n>\nWow, that was fast! I have an appointment this first thing this morning,\nbut I should be able to test this later in the morning. I will let you know\nhow things go.\n\n\u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/392#issuecomment-461302666>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEzjJyWtWxQGiEKB8tXlv2C4dxRSx8A8ks5vK8ePgaJpZM4akYQO>\n> .\n>\n On Thu, 7 Feb 2019 at 07:46, Donald Allen <donaldcallen@gmail.com> wrote:\n\n>\n>\n> On Thu, 7 Feb 2019 at 01:28, R. Kent Dybvig <notifications@github.com>\n> wrote:\n>\n>> This should be fixed by this commit\n>> <https://github.com/cisco/ChezScheme/commit/71d3abba684e04b134720ea1bd9a8c847c38ac5f>\n>> .\n>>\n> Wow, that was fast! I have an appointment this first thing this morning,\n> but I should be able to test this later in the morning. I will let you know\n> how things go.\n>\n\nI've tested it with the code I've written thus far, with just one callback.\nThis is the code that previously failed, which led to my opening this\nissue. That code now works correctly, with the latest github version of\nChez.\n\nThanks again for the quick turn around on this.\n\n/Don\n\n>\n> \u2014\n>> You are receiving this because you authored the thread.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/cisco/ChezScheme/issues/392#issuecomment-461302666>,\n>> or mute the thread\n>> <https://github.com/notifications/unsubscribe-auth/AEzjJyWtWxQGiEKB8tXlv2C4dxRSx8A8ks5vK8ePgaJpZM4akYQO>\n>> .\n>>\n>\n  Sketch of a fix for #389 \r\n\r\nIs there any point in trying `#2%apply` in `fold-primref2` when `app-convention` is not `call`? Seems that if `objs-if-constant` succeeds here, but the `apply` handler didn't turn `apply` into `call`, then we're going to end up residualizing anyway, so I'm inclined to check the convention earlier in that first `cond` clause and simplify.\r\n\r\n- [x] get review from someone who has been in this code more recently\r\n- [x] do we need more tests?\r\n- [x] update LOG That sounds right.  What about apply3?  Is that not the same story?\r\n\r\nAn error? test for (apply zero? 0) might be nice. Thanks. I've updated my branch to add some tests and to bail earlier if `app-convention` is not `call`.\r\n\r\nI may be bailing too early, since inline handlers won't be able to special-case based on `app-convention`. Offhand, I'm not sure who would want to do that (maybe to avoid a value-visit somewhere?). Edit: silly me, the original code also prevented this.\r\n\r\nTravis will be unhappy since I haven't yet updated the expected errors. Attempted to update expected errors and restored original indentation to minimize diffs from master. Added a test for the 'effect unrestricted discard case, updated LOG, and squashed. Re-pushed to update the release notes.  In some cases, apply will throw an exception if the last argument isn't a list (as required in r6rs), while in other cases, it executes just fine.\r\n\r\nFor instance:\r\n```\r\n> (apply + 1)\r\nException in apply: 1 is not a proper list\r\nType (debug) to enter the debugger.\r\n> (apply zero? 0)\r\n#t\r\n``` This appears to be an issue with `cp0`, which is enabled by default.\r\n```\r\n> (apply null? 'hypothesis)\r\n#f\r\n> (apply zero? 0)\r\n#t \r\n```\r\nBut if we disable `cp0`:\r\n```\r\n> (run-cp0 (lambda (f x) x)) ;; disable cp0\r\n> (apply null? 'hypothesis)\r\nException in apply: hypothesis is not a proper list\r\nType (debug) to enter the debugger.\r\n> (apply zero? 0)\r\nException in apply: 0 is not a proper list\r\nType (debug) to enter the debugger.\r\n```  Tue Jan 29 08:13:10 GMT 2019\r\n\r\nCorrect mitpress link for book.\r\n\r\n(Will close issue: https://github.com/cisco/cisco.github.io/issues/9.)  A repair for #379\r\n\r\nThe `dofretu...*` intrinsics use ac1 without declaring it as killed, which effectively broke register allocation for handling string/bytevector foreign-call results or callable arguments.\r\n\r\nThere was a \"FIXME\" in the implementation of `dofretu...*` that suggests avoiding ac1, so maybe that intent is why ac1 never got declared. With respect to the \"FIXME\", though, `get-room` does preserve td and ts, but I didn't find a way to avoid ac1 on x86 (because `alloc` involve ts and xp?). So, that's why the repair declares ac1 as killed by `dofretu...*` instead of trying to avoid it.    Related to issue 372\r\n\r\nNow `make-mutex` and `make-condition` accept an optional\r\nargument name, which must be a symbol. When the mutex or\r\ncondition is printed, the name is also printed. The name\r\nis immutable and can be accessed by mutex-name and\r\ncondition-name.\r\n\r\nhttps://github.com/cisco/ChezScheme/issues/372 This looks good to me, thanks!  Please add an entry to LOG.  If you feel like updating the release notes and the user's guide as well, go ahead, or I'll make the changes after pulling the changes. Added entries to LOG and release notes and updated CSUG. What do you think of allowing #f for the optional second argument of make-mutex and make-condition? This would make the definitions of the single-argument cases simpler and make it easier to write functions that take an optional name. That's probably a good idea.  I don't see how it simplifies the single-argument cases, however.  In fact, they would need to explicitly allow `#f` as well as symbols, and the error messages would have to be adjusted. @jessymilare, if you use `set-who!` rather than set! for `make-mutex`, `mutex-name`, `make-condition`, and `condition-name`, you can replace the quoted names with `who` in the error messages and just put each of the tests on one line to tighten up the code.  I've been doing that with most of the things I've added recently. For the single argument cases, I meant that one could simply call the two-argument case with #f and wouldn't need to duplicate the body. Ah, I guess you mean the zero-argument cases.  Yes, but that would send the zero-argument case through an unnecessary check.  Although if one the zero-argument case calls the one-argument case, the `case-lambda` form should be wrapped in a rec, e.g., `(rec make-mutex <case-lambda form>)` to make the call local, in which case cp0 would presumably inline the one-argument code into the zero-argument code and discard the check.  Though I would probably instead just add a helper that both cases use to make clear the test isn't necessary in the zero-argument case. Thanks, I got my argument counts off by one! Yes, a helper without checks that is used by both front doors would be a good way to implement it. Sorry for the polution in the commits. I use aggressive-indent-mode and I forgot to disable it before editing. If the code is OK, I can recreate the commits or create one single commit for all changes. The build system found an error while building the threaded versions of Chez Scheme: [Details](https://travis-ci.org/cisco/ChezScheme/builds/510617020?utm_source=github_status&utm_medium=notification)\r\n<pre>Warning: undeclared variable assignment to $make-mutex at line 1485, char 1 of prims.ss</pre> > The build system found an error while building the threaded versions of Chez Scheme: [Details](https://travis-ci.org/cisco/ChezScheme/builds/510617020?utm_source=github_status&utm_medium=notification)\r\n> \r\n> Warning: undeclared variable assignment to $make-mutex at line 1485, char 1 of prims.ss\r\n\r\nFixed.  The good news is that this patch can cut startup time in half when loading uncompressed boot files. The bad news is that it's a significant addition to the kernel: about 2/3 the size of the GC implementation, and duplicating some of the GC code in its current form.\r\n\r\nOn my machine, startup time from uncompressed \"petite.boot\" and \"scheme.boot\" files is reduced from 60ms to 30ms. With Racket-on-Chez's \"racket.boot\" in addition (which is a little larger than \"petite.boot\" and \"scheme.boot\" combined), startup goes from 140ms to 70ms. The extra code seems worth it to save 70ms on every Racket's startup \u2014 unless, of course, something simpler can provide the same benefit.\r\n\r\nThe \"vfasl\" format implemented by this patch is mostly an image of the code and data that can read directly into a GC-managed memory space. Just as important as loading the image directly, it can be loaded into the static generation, saving work to compact loaded code into the static generation.\r\n(The vfasl loader does not update object counts for static content.)\r\n\r\nThe vfasl format can also cut loading non-boot code in half, at least for relatively large code files, but the benefit of vfasl loading is limited if the code has to be traversed later by the GC. Also, the in-memory format of data is larger than the fasl format, and the size difference tends to defeat any benefit of vfasl for small code files.\r\n\r\nUse `vfasl-convert-file` to convert to the vfasl format, something like this:\r\n ```\r\n     (compile-compressed #f)\r\n     (vfasl-convert-file \"orig/petite.boot\" \"new/petite.boot\" '())\r\n     (vfasl-convert-file \"orig/scheme.boot\" \"new/scheme.boot\" '(\"petite\"))\r\n     (vfasl-convert-file \"orig/mine.boot\" \"new/mine.boot\" '(\"petite\" \"scheme\"))\r\n```\r\n This looks potentially related to work in GHC: http://ezyang.com/compact.html I wonder if they managed to avoid the complexity you're worried about. @samth That work doesn't deal with code, shared objects like symbols and record-type descriptors, or mutable values (such as symbols that have property lists) \u2013 all ways to reduce complexity, certainly, but not applicable to the problem of loading and linking Scheme code. Note on the revised patch: Corrected to ensure that an object either does not span multiple or segments or resides at start of a segment (which is needed when loading directly to the static generation). For many years, Chez Scheme supported the notion of \"saved heaps\", and \"incremental saved heaps\", which is similar to this.  Saved heaps were essentially pre-built heap images.  There was a saved heap that corresponded to the base boot file and incremental saved heaps that corresponded to non-base boot files.  With mmap'd saved heaps, startup time was practically zero, and sharing of memory between processes cut total memory usage considerably when many Scheme processes were used.\r\n\r\nWe ended up abandoning saved heaps when address randomization became ubiquitous.\r\n\r\nPerhaps it's time to come up with a new implementation of saved heaps.  One approach is to have a \"live\" saved heap in the form of a background process created upon the first invocation of Chez Scheme (or Racket), and have each subsequent invocations merely fork a new copy of the background process.  This has the downside that the forked process is a child of the background process rather than the program (e.g., shell) of invocation and its environment, but it's not unlike how other applications work these days.\r\n\r\nAnother approach is to save an image as we used to and adjust all the pointers on start-up to account for the new random base address.  Of course, we can always request the original address when mmap'ing and avoid the adjustment if we get it.\r\n\r\nIf machines supported EA-relative addressing (like PC-relative jumps add in the address of the jump, EA-relative loads would add the effective address of a loaded pointer to the loaded pointer), we could avoid the adjustment entirely.  We could of course do the add ourselves at the cost of an extra instruction or two at each ptr load. @dybvig You might find it interesting to compare with Daniel Colascione's work on the Emacs Portable Dumper, which had to deal with a lot of the same issues. It uses the 'relocate on startup' approach, and it has been working relatively well (I believe he mentioned it as taking a dozen milliseconds or so).\r\n\r\nEmacs has for years relied on unexec to implement 'saved heap' functionality, but for various reasons it has been less and less viable as a solution, including the inability to support ASLR, and the desire of glibc to phase out support for unexec. The portable dumper is the new implementation of saved heaps, and recently (past month) got merged into master, so it will likely be rolling out in emacs 27.\r\n\r\nAnyhow, the following is his overview of the implementation: https://dancol.org/pdumperpres.pdf  Brand new to chezscheme, trying to make a new condition using [(make-condition) from chezscheme user guide](https://www.scheme.com/csug8/threads.html#./threads:h3), but other chezscheme library functions work:\r\n\r\n```\r\nPS C:\\> scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (import (chezscheme))\r\n> (make-condition)\r\nException: variable make-condition is not bound\r\nType (debug) to enter the debugger.\r\n> (pretty-print '(define factorial (lambda (n) (let fact ((i n) (a 1))\r\n    (if (= i 0) a (fact (- i 1) (* a i)))))))\r\n(define factorial\r\n  (lambda (n)\r\n    (let fact ([i n] [a 1])\r\n      (if (= i 0) a (fact (- i 1) (* a i))))))\r\n>\r\n```\r\n\r\nRunning this on scheme built (for Windows 10) from this repo less than a week ago. Also, [the commonly linked chezscheme debug pdf is no longer hosted](https://www.cs.indiana.edu/chezscheme/debug/) making debugging even more difficult. It sounds like you are using a non-threaded version of Chez Scheme (the default  build):\r\n\r\n```\r\n% ./configure # builds non-thread version\r\n% make\r\n(cd a6osx && /Applications/Xcode.app/Contents/Developer/usr/bin/make build)\r\n(cd c ; /Applications/Xcode.app/Contents/Developer/usr/bin/make)\r\nln -s ../../c/statics.c statics.c\r\n   .\r\n   .\r\n   .\r\n/Applications/Xcode.app/Contents/Developer/usr/bin/make resetbootlinks\r\ntouch bootstrap\r\n% cd a6osx/s\r\n% ../bin/scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (threaded?) ;; note this version is not threaded, we can check using (threaded?)\r\n#f\r\n> (make-condition)  ;; make-condition is only defined in the threaded version\r\nException: variable make-condition is not bound\r\nType (debug) to enter the debugger.\r\n> \r\n```\r\n\r\nTo build the threaded version just specify `-threads`:\r\n\r\n```\r\n% ./configure --threads\r\n% make\r\n(cd ta6osx && /Applications/Xcode.app/Contents/Developer/usr/bin/make build)\r\n(cd c ; /Applications/Xcode.app/Contents/Developer/usr/bin/make)\r\nln -s ../../c/statics.c statics.c\r\n   .\r\n   .\r\n   .\r\n/Applications/Xcode.app/Contents/Developer/usr/bin/make resetbootlinks\r\ntouch bootstrap\r\n% cd ta6osx/s  # note the 't' here which means it is the threaded version\r\n% ../bin/scheme\r\nChez Scheme Version 9.5.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (threaded?)  ;; this time we are running the threaded version\r\n#t\r\n> (make-condition)  ;; and make condition is defined.\r\n#<condition>\r\n> \r\n```\r\n\r\n\r\n\r\n Aha, that was the problem. Incidentally, the windows build automatically made the threaded version for me alongside the non-threaded version (a6nt and ta6nt folders). \r\n\r\nI don't see anything for --threads in the BUILDING file, could something be added to that file to clarify this issue?  When using the USE_MALLOC allocator instead of USE_MMAP, valgrind gives warnings. The merge request silences the warnings. Maybe better to initialize the relevant fields explicitly instead of zeroing the whole segment.\r\n\r\n==16544== Conditional jump or move depends on uninitialised value(s)\r\n==16544==    at 0x11E308: copy (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x126BCD: S_gc_oce (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x114A81: Scompact_heap (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x13AAD7: Sbuild_heap (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x10F9D9: main (in /home/chn/chez/install/bin/scheme)\r\n==16544==  Uninitialised value was created by a heap allocation\r\n==16544==    at 0x483577F: malloc (vg_replace_malloc.c:299)\r\n==16544==    by 0x11071E: S_getmem (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x110B31: S_find_segments (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x111590: S_find_more_room (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x11182F: S_alloc_init (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x13A9D4: Sbuild_heap (in /home/chn/chez/install/bin/scheme)\r\n==16544==    by 0x10F9D9: main (in /home/chn/chez/install/bin/scheme)\r\n >  Can the code actually reference uninitialized values, i.e., is the chunk not fully initialized by the call that follows the getmem call?\r\n\r\nYes, the copy() function reads the uninitialized values as seen on the valgrind log. Thanks Dybvig for the reply. Please try valgrind yourself, I added these two lines after the include statements in segment.c\r\n```\r\n#define USE_MALLOC\r\n#undef USE_MMAP\r\n```\r\nThen I passed CFLAGS=\"-O0 -g\" to make to get valgrind to pinpoint the line number as well.\r\nI get warnings on the `trigger_empherons` field and I also got a warning on the `sorted` field of seginfo, by running this small program with scheme -program empty.scm\r\n```\r\n(import (chezscheme))\r\n``` Thanks for verifying a clean valgrind run for you as well.\r\n\r\n> Would you like to alter your pull request to replace zero-filling with these two lines? If so, please also add a brief entry in LOG.\r\n\r\nDone! However, feel free to brush up the merge request yourself since I'm not familiar with the code style and the right level of details in LOG.  Possibly the repair for #364  I believe this new commit is much more likely to be the repair for #364.\r\n\r\nIf receiving arguments to a callable involves allocation \u2014 such as when receiving a flonum, bignum, or pointer  \u2014 then the value in the `cp` field of the thread context can get changed when `%cp` is a real register and the register value gets saved in the thread context. In particular, if the caller or a callable has set that register, then the `cp` field in the thread context will have that wrong value. Guard against the problem by claiming `%cp` as live and initialized by `cp` from the thread context while unpacking arguments.  I can redefine functions in the `interaction-environment` via eval while a program is running. Is there any way to redefine functions in a library? I'd love to run two threads, one with the program, one with a repl, where I can redefine (exported) functions inside libraries. Is there a way to find all libraries directly or indirectly depending upon a given library, so I can automatically reload them all?    http://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:h1 says:\r\n> These forms are described in Chatper 11.\r\n\r\n\"Chatper\" should be \"Chapter\".\r\n\r\nhttp://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:h1 also says:\r\n> (This algorithm is described in Section 11.1 of <i>The Scheme Programming Language, 4th Edition</i>.) As a result, [some code] and [more code] both result in the giving <tt>x</tt> the value 3, even though an unbound variable reference to <tt>a</tt> would result if the two forms within the latter <tt>begin</tt> expression where run independently at top level.\r\n\r\n\"11.1\" links to the Chez Scheme User's Guide, not to The Scheme Programming Language.  And section 11.1 of TSPL doesn't discuss that algorithm either.  I think section 8.1 of TSPL is the right one.\r\n\r\nAlso, \"where\" should be \"were\".\r\n\r\nhttp://cisco.github.io/ChezScheme/csug9.5/binding.html#./binding:h2 says:\r\n> <b>syntax</b>: <tt>(define-values&nbsp;formals&nbsp;<i>expr</i>)</tt>\r\n\r\n<tt>formals</tt> should be italicized. http://cisco.github.io/ChezScheme/csug9.5/io.html#./io:h3 says:\r\n> The codec returned by <tt>utf-16-codec</tt> can be used to create process data written UFT-16 format.\r\n\r\n\"UFT-16\" should be \"UTF-16\".  And I think there should be an \"or\" between \"create\" and \"process\".  The Posix native threads are awefully slow on OS X. The code provided [1] shows some toy example with corresponding outputs. The threaded version ist 10-15 times slower than the normal version. \r\n\r\nOS X Version: 10.13.6 (17G65)\r\n\r\n[1] [thread_slowdown.txt](https://github.com/cisco/ChezScheme/files/2412903/thread_slowdown.txt)\r\n\r\n It also appears to be unique to Mac OS X. The Linux version is much closer in performance:\r\n```\r\nUNTHREADED\r\n(time (for-each (lambda (...) ...) ...))\r\n    21 collections\r\n    0.648093737s elapsed cpu time, including 0.175064540s collecting\r\n    0.648127418s elapsed real time, including 0.175127350s collecting\r\n    176012816 bytes allocated, including 88135072 bytes reclaimed\r\n(time (for-each (lambda (...) ...) ...))\r\n    20 collections\r\n    0.588600240s elapsed cpu time, including 0.125116317s collecting\r\n    0.588624933s elapsed real time, including 0.125194479s collecting\r\n    176012112 bytes allocated, including 67268800 bytes reclaimed\r\n(time (for-each (lambda (...) ...) ...))\r\n    21 collections\r\n    0.571824199s elapsed cpu time, including 0.109007713s collecting\r\n    0.571829064s elapsed real time, including 0.109071223s collecting\r\n    176012752 bytes allocated, including 83986704 bytes reclaimed\r\nTHREADED\r\n(time (for-each (lambda (...) ...) ...))\r\n    54 collections\r\n    0.934692263s elapsed cpu time, including 0.389601882s collecting\r\n    1.323082193s elapsed real time, including 0.389739652s collecting\r\n    459187888 bytes allocated, including 455042896 bytes reclaimed\r\n(time (for-each (lambda (...) ...) ...))\r\n    62 collections\r\n    1.518299404s elapsed cpu time, including 0.389906244s collecting\r\n    1.762021038s elapsed real time, including 0.390061343s collecting\r\n    526854880 bytes allocated, including 522868352 bytes reclaimed\r\n(time (for-each (lambda (...) ...) ...))\r\n    63 collections\r\n    1.601723684s elapsed cpu time, including 0.389943765s collecting\r\n    1.772709277s elapsed real time, including 0.390101073s collecting\r\n    529498992 bytes allocated, including 531325696 bytes reclaimed\r\n``` Thanks, the fix made the program above run much faster under Windows and macOS!  First call to `gensym` takes about 5s on macOS, and `time` does not handled it right.\r\n\r\ne.g.,\r\n```\r\n(time (gensym))\r\n    no collections\r\n    0.000000000s elapsed cpu time\r\n    0.000000000s elapsed real time\r\n    48 bytes allocated\r\n```\r\nActually, above takes about 5s. After the first call, `gensym` works well.\r\n\r\nChez Scheme version: 9.5.1\r\nmacOS version: Mojave This could be related to #338 if takes five seconds because your computer's hostname is invalid and the DNS query to resolve it times out.\r\n\r\nThe code that I suspect is here:\r\nhttps://github.com/cisco/ChezScheme/blob/41eca9aeea5d036877d09f996414c1f9311ecdb8/c/stats.c#L77-L107\r\n\r\nDoes the five second delay go away if you add \"return 0;\" on line 82 and rebuild? @weinholt Thanks, and yes, this related to #338. The five seconds delay go away after the \"return 0\" added.\r\nThis issue can be bypassed by adding hostname into `/etc/hosts`.\r\n\r\n@burgerrg Thanks. Should be closed, see #338 and 2fd3db6.  Currently, the build instructions here:\r\n\r\nhttps://github.com/cisco/ChezScheme/blob/master/BUILDING\r\n\r\nMention WSL as possible build environment. It neglects to mention however, that the way the build works (by calling cmd.exe /c with a make.bat file in the build directory) will only work on a location under /mnt/c (or d, or e, etc). This is because cmd.exe can only interact with files outside the Linux environment, which /mnt/c and friends are considered to be. In other words: anything outside /mnt/c (or d, or e ,etc) cannot be translated to a windows path and hence, cmd.exe will fail to find the make.bat passed to it.\r\n\r\nMore background here: https://blogs.msdn.microsoft.com/commandline/2016/10/19/interop-between-windows-and-bash/  _FYI:_ I got a new computer and I installed Visual Studio 2017 (Community) and Cygwin. When I compiled Chez Scheme I got this error:\r\n\r\n    $ make\r\n    (cd a6nt && make build)\r\n    (cd c ; make)\r\n    cmd.exe /c make.bat\r\n    \\cygwin64\\cygwin\\tmp\\dd_vsdevcmd15_preinit_env.log was unexpected at this time.\r\n    make[2]: *** [Makefile:28: ../bin/a6nt/scheme] Error 255\r\n    make[1]: *** [Makefile:20: build] Error 2\r\n    make: *** [Makefile:19: build] Error 2\r\n\r\nAfter a lot of debugging, guessing and searches in Google, I discovered that the problem was that I installed Cygwin as an administrator and I was trying to compile with a normal user. The problem was that the temporary folder was not writable by my user, so some of the .bat files got a weird error when trying to save some temporary data. (The problem was in VsDevCmd.bat that is called by vcvarsall.bat.)\r\n\r\nI fixed the problem following the advice of https://cygwin.com/cygwin-ug-net/using.html#usertemp , i.e. \r\n \r\n> The usertemp file system can be configured in /etc/fstab like this:\r\n\r\n    none /tmp usertemp binary,posix=0 0 0\r\n\r\nSo I think my problem was a case of a bad cygwin configuration, not a bug in the Chez Scheme compilation. Anyway, the error is too cryptic and it was very difficult to find the solution, so I'm posting this in case someone else has the same problem in the future. \r\n\r\n(I think you can just close this issue, unless you know a much better solution.)\r\n  I build error on windows cygwin or Microsoft Ubuntu  at first  with output message:\r\n\r\n: not found: 2: ./configure:\r\n: not found: 17: ./configure:\r\n: not found: 18: ./configure:\r\n./configure: 19: ./configure: Syntax error: word unexpected (expecting \"do\")\r\n\r\nI guess it's windows text file endline different from linux txt file\r\nso to fix this problem by using vi : \r\n\r\nvi configure\r\n:set fileformat=unix\r\n:wq\r\n\r\nvi workarea\r\n:set fileformat=unix\r\n:wq\r\n\r\n @burgerrg  you are right. it's git settting cause this problem.\r\nafter I set git config :\r\n\r\ngit config --global core.autocrlf false\r\n\r\nthen git clone again. It can  build right \r\n  Hello schemers,\r\n\r\nWhile going over the code for porting to GNU Hurd (yeah, I know), I found that gensyms may contain public IP addresses. This isn't mentioned in the documentation anywhere that I could find and it surprised me. I'm probably not alone, so I'm opening this issue to have a discussion about whether it's ok or not.\r\n\r\nHere's code that extracts the info in gensyms (with some examples from csug): https://gist.github.com/weinholt/7f06739113f1fa78a894ea2ef3945331\r\n\r\nPeople may wish to keep their public IP address hidden and are likely not aware that gensyms can contain them. > This isn't mentioned in the documentation anywhere that I could find\r\n\r\nYou mean, like in the description for `(gensym)`?\r\n> Globally unique names are constructed (lazily---see below) from some combination of a unique machine identifier (**such as the network address**), the current process identifier (PID), and the time at which the Scheme session began, along with an internal counter\r\n\r\nhttp://cisco.github.io/ChezScheme/csug9.5/objects.html#./objects:s88\r\n\r\n(which is not to say that I disagree with changing the source for the seed used for the unique prefix - just that it is in the documentation) Oops, my eyes skipped right over that. :) @burgerrg If you were using apt directly you could do this:\r\n```\r\napt-get install uuid-dev:i386\r\n```\r\nMaybe you can add `uuid-dev:i386` to the travis.yml file.  This patch adds a `hashtable-cells` procedure that is mostly the obvious companion to `hashtable-keys` and `hashtable-values`, but with an extra twist: `hashtable-cells` takes an optional second argument to limit the resulting vector size \u2014 and therefore limit the amount of work performed by `hashtable-cells`. Calling `hashtable-cells` with a size of N takes O(N) time, even if the hashtable contains more than O(N) entries.\r\n\r\nTo iterate over N entries in O(N) time when N is not known in advance, get Q cells for the first Q iterations (for some small Q), then 2Q cells to continue for roughly up to 2Q iterations, and so on. The second set of iterations will actually go to somewhere between 2Q and 3Q iterations, since the call to get 2Q cells is not guaranteed to include the same cells as the first Q. (An intervening collection can change the order for an `eq?`-based table, for example.) Still, the first Q cells and second 2Q cells can be merged in O(Q) time to produce a vector of 2Q to 3Q cells, and so on.\r\n\r\nMeanwhile, getting cells (instead of keys and values) accommodates iterations that change the hash table without exposing stale mappings and without needlessly retaining keys and values from a weak/ephemeron hash table.\r\n I don't understand how you can merge the first Q and second 2Q cells in O(Q) time, given the lists aren't necessarily in the same order, and with the addition of \"and so on\" I think it gets beyond O(Q) time regardless of the order.  However, I like the idea of providing a `hashtable-cells` procedure, and I don't object to allowing the max-size limit to be specified.\r\n\r\nDoes it make sense to add optional max-size arguments to `hashtable-values`, `hashtable-keys`, and `hashtable-entries` for consistency?\r\n\r\nThe code for `hashtable-cells` does some redundant tests and `hashtable-size` calls (which lead to additional redundant tests and unnecessary memory references).  Plus I don't like going back through the top level for `case-lambda` clauses.  Instead, I prefer using a `rec` wrapper, so the call is local, or using a shared helper.  Here is a version that uses a shared helper and eliminates the redundant tests and calls to `hashtable-size`, but I haven't tried it to make sure it actually works.\r\n\r\n```\r\n(set-who! hashtable-cells\r\n  (let ()\r\n    (define (dispatch h max-sz)\r\n      (unless (xht? h) ($oops who \"~s is not a hashtable\" h))\r\n      (case (xht-type h)\r\n        [(eq) ($eq-hashtable-cells h max-sz)]\r\n        [(eqv) ($eqv-hashtable-cells h max-sz)]\r\n        [else ($ht-hashtable-cells h max-sz)]))\r\n    (define (invalid-length max-sz)\r\n      ($oops who \"~s is not a valid length\" max-sz))\r\n    (case-lambda\r\n      [(h max-sz)\r\n       (cond\r\n         [(fixnum? max-sz)\r\n          (unless (fx>= max-sz 0) (invalid-length max-sz))\r\n          (dispatch h max-sz)]\r\n         [(bignum? max-sz)\r\n          (unless (>= max-sz 0) (invalid-length max-sz))\r\n          (dispatch h (most-positive-fixnum))]\r\n         [else (invalid-length max-sz)])]\r\n      [(h) (dispatch h (most-positive-fixnum))])))\r\n```\r\n Thanks for the improved `hashtable-cells`. I'll look into similar versions of `hashtable-values`, `hashtable-keys`, and `hashtable-entries`.\r\n\r\nMerging a first Q and second 2Q cells in O(Q) time works by using a `eq?`-based hashtable in the general case. Fair enough, in amortized terms.  Still, the process you describe takes O(N) time, as you say, so it's the same asymptotically as calling `hashtable-cells` without the max-size argument, with a larger constant factor in general, so this doesn't seem like a good use of the max-size argument.  I can see wanting to process and remove at most Q elements at a time from a hashtable whose size might be greater than Q, so I can see why the max-size argument might be useful.\r\n The updated commit adds an optional size argument to `hashtable-keys`, `hashtable-values`, and `hashtable-entries`, which involved splitting out a separate R6RS variant for `hashtable-keys` and `hashtable-entries`.\r\n\r\n-------\r\n\r\nI see that I haven't explained my use of `hashtable-cells` well. Maybe it doesn't matter, anyway, but I'll give it one more try.\r\n\r\nMy overall goal is to adapt hashtables to a generic sequence-iteration interface. The interface includes operations to get a starting index, to increment an index (functionally, so the previous index remains usable as long as the hash table doesn't change in certain ways), and to get the value/key at an index. Those operations all need to be amortized constant-time.\r\n\r\nSo, it's ok to take O(N) time overall to get to the Nth index/key/value, but it must be O(N) time even if the size of the table is greater than O(N) \u2014 and there's no way to predict N in advance, because N corresponds to the number of iterations steps that are performed before the iteration is abandoned.\r\n\r\nAdding `hashtable-cells` with a size argument is enough to achieve that goal, but it wasn't obvious to me until I thought of the merging piece, so that's why I commented on the merging strategy.\r\n  Some tests need repair for different evaluation modes \u2013 such as `interpret` instead of `compiled`, which doesn't preserve names.  This will close #325 \r\n\r\nThe main issue is that on current OS X, X11 is no more provided default. cc @burgerrg  @burgerrg thanks for the comment, then I will close this PR and take a try to implement as your comment later. I did that in check in: f8cf536720fe43d07ca83d284e5bd1733c97372a So I think\nwe're good there, the only missing part was the X11 autodetect.\n\n-andy:)\n\n\n\nOn July 17, 2018 at 10:16:50 AM, Bob Burger (notifications@github.com)\nwrote:\n\nThanks, it would be great if you could unentangle the X11 clipboard and\nmacOS pasteboard in the expression editor.\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\n<https://github.com/cisco/ChezScheme/pull/333#issuecomment-405597704>, or mute\nthe thread\n<https://github.com/notifications/unsubscribe-auth/AAG5r4hsHCD0KhACXdRnEYsQBnfyhFL8ks5uHfHEgaJpZM4VQo7M>\n.\n @akeep I check the commit, it seems we can reopen this pr and merge it, and then things go well, doesn't it?  # add an option `--disable-x11` to configure, which allows you to build Chez Scheme with X11 disabled\r\n\r\nnow you can build Chez Scheme like this:\r\n\r\n```\r\n./configure --installprefix=$HOME/scheme --disable-x11\r\nmake\r\nmake install\r\n```\r\n\r\nsee help by `./configure --help` Relevant #325 and #84  Looks good, thanks!  7.ss, scheme.1.in, comments of many files\r\n\r\nThis will close #326  @burgerrg I think this PR is a net win, could you please review it when you are free? My inclination would be to update the copyright notice in a source files only when we modify it and to update the copyright date in the greeting and readme files around the beginning of the year or possibly when we produce a release. ... by @dybvig suggestion  https://github.com/cisco/ChezScheme/blob/6c738bdfde601b815c296f489697e61c314e4621/c/Mf-a6osx#L20\r\n\r\nActually it is in `/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Tk.framework/Headers/`, there is not a symbol link from `/opt/include/X11`. See https://support.apple.com/en-us/ht201341 This causes \r\n```\r\n(cd a6osx && /Applications/Xcode.app/Contents/Developer/usr/bin/make build)\r\n(cd c ; /Applications/Xcode.app/Contents/Developer/usr/bin/make)\r\ngcc  -m64 -Wpointer-arith -Wall -Wextra -Wno-implicit-fallthrough -Werror -O2 -I/opt/X11/include/  -c -DX86_64 -I../boot/a6osx -I../zlib expeditor.c\r\nexpeditor.c:888:10: fatal error: 'X11/Xlib.h' file not found\r\n#include <X11/Xlib.h>\r\n         ^~~~~~~~~~~~\r\n1 error generated.\r\nmake[2]: *** [expeditor.o] Error 1\r\nmake[1]: *** [build] Error 2\r\nmake: *** [build] Error 2\r\n```\r\n\r\nI can locally change `-I/opt/X11/include/` to `-I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Tk.framework/Headers/` and `make` done. But wondering whether there is a more compatible approach. @burgerrg any idea? ummm, assume users are able to fix it by themselves is well One can install [XQuartz](https://www.xquartz.org/) to fix this,  and I think it might worth a troubleshooting document/README/INSTALL Relevant #84 @W4anD0eR96 #328 has bug while building with X11, and it should not be merged. I will try to fix it. But you can try the solution in #84  @burgerrg and I had discussed this a little offline and I was planning to take a look at a fix this weekend.\r\n\r\nFor a little context, X11 is used by the expression editor to interact with the X11 clipboard and, currently, on macOS the LIBX11 flag is also used to decide if the expression editor should interact with the macOS pasteboard.  In many cases (on macOS at least) the paste support isn't really needed because if you are just using the expression editor within the macOS terminal, the terminal itself will trap the paste key combination and paste for you, however, if you are in either an Xquartz terminal or if you are running inside another terminal emulator that does not do this for you, it would be nice to support the macOS pasteboard, even when X11 is not available.\r\n\r\nAdditionally, I'd prefer that the decision to build in support for X11 be something the configure script decide, similar to the way autoconfig decides these things.  I have some ideas on how this should work, but I'll need to test it out.\r\n\r\nSo, I'd like to make two changes as part of this:\r\n\r\n1. Have X11 support be detected by configure\r\n2. Unentangle the X11 clipboard and macOS pasteboard in the expression editor.\r\n\r\n#84 also mentions ncurses.  Unlike X11 which is primarily used for clipboard support, ncurses is needed to support the expression editor.  It is possible to turn off the expression editor (though I've not tested this aspect yet, it should turn off cleanly) if we can detect it is not available in configure, however, it is worth noting that interacting with REPL is a lot less pleasant when the expression editor, which gives you multi-line editing, history search, auto indent, tab completion, and configurable keyboard macros---see sections [Section 2.2. Expression Editor ](http://cisco.github.io/ChezScheme/csug9.5/use.html#./use:h2) and [Chapter 14. Expression Editor](http://cisco.github.io/ChezScheme/csug9.5/expeditor.html#g130) for details.\r\n\r\nI'm not opposed to having configure determine that it could not support the expression editor, though I'd probably want configure to raise a warning, or perhaps require a flag to indicate it was okay to leave it off. Update: New PR #331 , add an option `--disable-x11` to configure, which allows you to build Chez Scheme with X11 disabled  I'm still looking at this one, but I haven't been able to provoke it by running `make foreign.so` by itself \u2013 only by running `make test`. Do you have a shorter way that `make test` that crashes? Is it possible that in `S_call_help`, copying the `tc` argument to a `volatile` variable will help?\r\n\r\nFrom my understanding of the C spec, neither `code` nor `tc` need to be declared `volatile`, because they don't change after the `setjmp`. But I think GCC declares an incompatibility with the standard and requires `code` and `tc` to be `volatile`. Maybe MSVC has a similar limitation.\r\n\r\nConcretely, after changing `S_call_help` to\r\n\r\n```\r\nvoid S_call_help(tc_in, singlep, lock_ts) ptr tc_in; IBOOL singlep; IBOOL lock_ts; {\r\n  /* declaring code volatile should be unnecessary, but it quiets gcc */\r\n  void *jb; volatile ptr code;\r\n  volatile ptr tc = tc_in;\r\n```\r\n\r\nthen I can no longer provoke a crash with `make test`. But since the crashes are less consistent for me, I'm not sure that means anything.\r\n\r\nThe change is probably a good idea to accommodate GCC's stated limitations, in any case. PS - I can get invalid references with VS 2015, just not as easily as you apparently do with VS 2017.  This is a repair for the main bug report in #320.\r\n\r\nI have not yet run the updated tests on ppc32le, but I'll do that tomorrow.\r\n @burgerrg Ok, I'll make that improvement (but allocating two pages before adjusting the second one). The main problem wasn't so much being unlucky with the next page, though, but that the return-type tests weren't using `malloc_at_boundary` before. The \"foreign.ms\" tests pass on ppc32le, and `malloc_on_boundary` is updated for Windows, so I think this is ready for review.  @mflatt it appears that the ftype return code writes past the end of ftypes whose size is less than the native pointer size. See the valgrind report below.\r\n\r\n```\r\n==9392== Invalid write of size 8\r\n...\r\n==9392==  Address 0x6023150 is 0 bytes inside a block of size 1 alloc'd\r\n==9392==    at 0x4C2CB6B: malloc (vg_replace_malloc.c:299)\r\n==9392==    by 0x429F65: s_malloc (in /usr/bin/scheme)\r\n...\r\n```\r\n\r\nThe output above was generated by running the following excerpt from foreign.ms in an a6le workarea.\r\n\r\n```\r\n$ cd mats\r\n$ make foreign1.so\r\n$ valgrind ../bin/scheme\r\n(load-shared-object \"./foreign1.so\")\r\n(define get (foreign-procedure \"f4_get_i8\" () (& integer-8)))\r\n(let ([v (make-ftype-pointer integer-8 (foreign-alloc (ftype-sizeof integer-8)))])\r\n  (get v)\r\n  (ftype-ref integer-8 () v))\r\n```\r\n\r\nPerhaps change foreign4.c's `malloc_at_boundary` as follows, so that the system will raise an invalid memory reference when we exceed the boundary: \r\n\r\n```\r\nEXPORT void *malloc_at_boundary(int sz)\r\n{\r\n  intptr_t alloc_size = getpagesize();\r\n  char *p;\r\n  p = mmap(NULL, 2 * alloc_size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\r\n  mprotect(p + alloc_size, alloc_size, PROT_NONE);\r\n  return p + alloc_size - sz;\r\n}\r\n```\r\n The repair in #321 seems unlikely to be related to the a6nt failure, since that test happens before any of the `&`-result tests, but I'll investigate more.  I was reading the [Chez-Scheme documentation - Section 4.9 - Example: Socket Operations](https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:h9) and was a bit surprised by the following code: \r\n\r\n```scheme\r\n;;; Requires csocket.so, built from csocket.c.\r\n(case (machine-type)\r\n  [(i3le ti3le) (load-shared-object \"libc.so.6\")]\r\n  [(i3osx ti3osx) (load-shared-object \"libc.dylib\")]\r\n  [else (load-shared-object \"libc.so\")])\r\n\r\n;;; Requires from C library:\r\n;;;   close, dup, execl, fork, kill, listen, tmpnam, unlink\r\n(load-shared-object \"libc.so\") \r\n```\r\n\r\nShouldn't it be this instead?\r\n\r\n```scheme\r\n;;; Requires from C library:\r\n;;;   close, dup, execl, fork, kill, listen, tmpnam, unlink\r\n(case (machine-type)\r\n  [(i3le ti3le) (load-shared-object \"libc.so.6\")]\r\n  [(i3osx ti3osx) (load-shared-object \"libc.dylib\")]\r\n  [else (load-shared-object \"libc.so\")])\r\n\r\n;;; Requires csocket.so, built from csocket.c.\r\n(load-shared-object \"csocket.so\") \r\n```\r\n\r\nIt seems to be necessary to load our own library and doesn't make sense to load the libc twice... yes If I understand correctly it will be updated on the Chez Scheme project homepage at the next stable release of Chez Scheme. I totally missed the fact that the documentation was stored in the `csug` folder. \r\n\r\nAnyway, thanks for taking time to fix and improve the examples, I am sure it will help me (and others) a lot :smile: \r\n\r\nI don't know if you want to keep the issue opened until the website is updated, if not, feel free to close it.\r\n  The mrvs case of `boot_call` uses a zero-based index when it looks like it intends a 1-based index, but fixing that doesn't help since the value it's going after isn't saved. Since `boot_call` already handles the case of zero return values and otherwise ignores all but the first return value, it seemed simpler to set up `%ac1` which is already covered by the `save-scheme-state` in the hand-coded `invoke`.\r\n\r\nMaybe there is a better fix? Either way, perhaps we can add a fix for this the next time we have a compelling reason to rebuild the boot files. (If we take this change, we can make the obvious simplification in `boot_call`, omitted here to minimize the diff.)\r\n\r\nBefore:\r\n```\r\n$ echo '(exit 7)' | scheme -q; echo $?\r\n7\r\n$ echo '(exit 4 5 6)' | scheme -q; echo $?\r\n1\r\n$ echo '(exit 0 8 9)' | scheme -q; echo $?\r\n1\r\n```\r\n\r\nAfter: the latter two print 4 and 0 respectively.\r\n\r\nI'm not sure what to do about the additional test cases in the commit at the tip of this branch. The [documentation](http://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s156) says they should return -1, but `Sscheme_start` returns 1, which is simpler in cross-platform case, so maybe it's better to update CSUG there?\r\n Clarification: The example output shown above was generated on **a6le**. On **a6nt** the multiple-value examples both return 0 before patching. Simplified so it doesn't need to wait for next boot file update. Bob and I put a couple alternatives on [owaddell/alt-invoke](https://github.com/owaddell/ChezScheme/commits/owaddell/alt-invoke) That seems reasonable.  Having the invoke code object save the argument registers shouldn't cause a problem, as far as I know.\r\n\r\nI agree with @owaddel that the documentation should change to reflect the (corrected) behavior.  By my reading of the code and documentation, the documentation is also wrong in the single-value case, both in the handling of a single Svoid value and in the handling of non-32-bit 64-bit integer values on 64-bit machines.  In both cases the documentation says the result should be -1, but the actual value for Svoid is 0 and the actual value for a non-32-bit 64-bit integer value on a 64-bit machine is the result of casting the value to an int.  Calling `library-exports` on a compiled library raises an exception if the library has not yet been imported.\r\n\r\nIf we compile testfile-li3.ss and start a new session, we get:\r\n\r\n```\r\n> (load-library \"testfile-li3.so\")\r\n> (library-exports '(testfile-li3))\r\nException in library-exports: unexpected binding (global . #{testfile-li3 dxvp567u7nmy7h0a66skcx-272})\r\nType (debug) to enter the debugger.\r\n```\r\n\r\nWith the change on this branch, if we recompile testfile-li3.ss and start a new session, we get: \r\n```\r\n> (load-library \"testfile-li3.so\")\r\n> (library-exports '(testfile-li3))\r\n(x)\r\n```\r\n\r\nIs this approach misguided? If not, maybe we can tidy up and cherry-pick the next time we have a compelling reason to rebuild the boot files. (Right now it's mingled with the changes for #310.)\r\n\r\nThe original `chi-top-library` had installed the `interface-binding` with different values for `token` in the call to `$sc-put-cte` (`#f`) vs. the call to `build-cte-install` (`*system*`). I moved the work of the residual call into `import-library` and preserved the `*system*`, but perhaps that should have been `#f` originally, based on the [comment in `chi-top-library`](https://github.com/cisco/ChezScheme/blob/2230e5adcb61ac8b27c9deee682270f4e17fbafb/s/syntax.ss#L2639).\r\n @akeep, does this look like a reasonable way to address the issue outlined above?\r\n\r\nThe [build failure on ta6osx](https://travis-ci.org/cisco/ChezScheme/jobs/420629174) is puzzling. We could not reproduce this on a MacBook Pro running OS X Sierra 10.12.6. The travis build exceeded the maximum time limit for jobs because it seems to have become overly fond of running unix.ms, examples.ms, ieee.ms, date.ms, exceptions.ms, and oop.ms.  @owaddell this seems like a nice interface improvement, in that it allows a certain amount if inspection without actually needing to execute any of the code in the library.\r\n\r\nI have mixed feelings about pulling the interface binding code:\r\n\r\n```scheme\r\n($sc-put-cte uid (libdesc-interface-binding desc) '*system*)\r\n```\r\n\r\nout of the `import-code` thunk, because it feels like we are in a bit of a strange point in the space when you add up my change to put the visit code bindings in the `libdesc-visit-id*` so that  I could restore them in `visit-library` failed.  It means we have the library interface and visit ids as data in the `libdesc` record (really the `ctdesc` record), we have the code for installing the interface in `import-library` and the code for setting the visit id* in the thunk, but also the visit identifier list in the `ctdesc-export-id*`.  It makes me wonder if we should just get rid of the `import-code` thunk entirely, and add the invoke identifiers to the `ctdesc` data structure as well.\r\n\r\nThe other interesting piece of this is that you and I have made different decisions about where to put this information.  I made the visit ids part of the `$install-library-ct/code` call, where you've added the interface information to the `library-ct/info` record.  It may be it just has to be separated this way, because the binding expressions are potentially not data, but effectively I think they are currently all data for the bindings created in the `import-code` thunk.  It makes me wonder if we should handle all of this information the same way.\r\n\r\nSorry for the somewhat disconnected observations, I'm just wondering if moving to a more data structural representation for all of this and treating the import consistently would have some benefits for us.  #### compile.ss\r\nShould we revise the flush-output-port change to fetch parameter values once per `(when ...)`?\r\n\r\n#### syntax.ss\r\nI left a WIP commit at the tip hoping that @akeep can sanity check it.\r\n\r\nHere is the error message issue (note that it is masked by the WIP commit):\r\n```\r\n> (import-notify #t)\r\n> (generate-wpo-files #t)\r\n> (compile-imported-libraries #t)\r\n> (with-output-to-file \"B.ss\"\r\n    (lambda ()\r\n      (pretty-print\r\n       '(library (B) (export b) (import (scheme)) (define b 9))))\r\n    'replace)\r\n> (with-output-to-file \"prog.ss\"\r\n    (lambda ()\r\n      (for-each pretty-print\r\n        `((import (B) (scheme))\r\n          (import-notify #t)\r\n          (define (run args)\r\n            (guard (c [#t (display-condition c) (newline)])\r\n              (pretty-print\r\n               (top-level-value (car args) (environment (cdr args))))))\r\n          (when (> b 0) ;; reference export\r\n            (let ([args (map string->symbol (command-line-arguments))])\r\n              (if (= (length args) 2)\r\n                  (begin\r\n                    (run args)\r\n                    (run args))\r\n                  (error #f \"expected 2 args\")))))))\r\n    'replace)\r\n> (compile-program \"prog.ss\")\r\n> (compile-whole-program \"prog.wpo\" \"prog-visible\" #t)\r\n> (compile-whole-program \"prog.wpo\" \"prog-not-visible\" #f)\r\n```\r\n\r\nBefore:\r\n```\r\n$ scheme --program prog-not-visible b B\r\nException in visit: library (B) is not visible\r\nException: unknown module #{B b8zzvxtl8z5jmjgbh9vh6q-0}\r\n```\r\n\r\nAfter the \"clarify 'unknown module' error message ...\" commit:\r\n```\r\n$ scheme --program prog-not-visible b B\r\nException in visit: library (B) is not visible\r\nException: unknown library (B)\r\n```\r\n\r\nAfter the \"WIP\" commit:\r\n```\r\n$ scheme --program prog-not-visible b B\r\nException in visit: library (B) is not visible\r\nException in visit: library (B) is not visible\r\n```\r\n\r\n Thanks for pointing me to the other code. I updated the `on-reset` for `import-library` and added a mat in 8.ms.\r\n\r\nI don't think you missed anything in the generated code: when you made the changes in 6dbd724, nothing in the import code thunk should have raised an error. My change in 220dca3 broke that assumption. Now the body of the import code thunk is either:\r\n 1. a call to `$oops`, or\r\n 2. a sequence installing compile-time bindings as before (quoted data).\r\n \r\nIn the first case, no compile-time bindings are installed, so there is nothing to roll back. In the second, nothing should raise an error.  (There is a call to `syntax-error` in the `do-import` case of `$sc-put-cte`, but `chi-top-library` doesn't generate such bindings.) I could be missing something, but it looks like we don't need to capture anything more for this. Maybe it needs a comment in the code? @akeep could you look at this again? I fixed the placement of the `on-reset` and rebased. I think my reply above addresses your other feedback. @owaddell, I think these changes make sense.  It took me a little while to look through the code base a bit and see what all might appear in the `import-code` thunk.  After looking, I'm pretty sure there is nothing in that thunk that can raise an error, since it is just setting up compile-time environment bindings, and none of the expressions in the bindings do anything that can raise an exception, so I think it is probably unnecessary to \"roll-back\" the side-effects in that code.\r\n\r\nSo, yeah, I think this looks good. @akeep, thanks for looking at this.  hello,\r\n\r\nis it interpreter still available?  It would be nice to have embeddable scheme on ios.\r\n thanks for info. closing.    As `${LibBin}` is expanded to `${TempRoot}${InstallLibBin}`, if we create a symlink with a source pointing to the `${TempRoot}` path, once installed (for example in an RPM), the symlink will still point to the `${TempRoot}` path.\r\n\r\nThat's why we must use the final path `${InstallLibBin}`. Another solution could have been to use a relative path. Thanks for your review, indeed I only encountered a problem with `ln -sf ${LibBin}/scheme.boot ${LibBin}/${InstallScriptName}.boot;` and totally missed the fact that the other lines were hard links.\r\n\r\nI will try to replace only the previously mentionned line by a hard link and update this PR if it works. I have backported the patch to my RPM package and it looks like it works, the build succeeded on all platforms: [see on copr](https://copr.fedorainfracloud.org/coprs/superboum/chez-scheme/build/765566/) - [see on github](https://github.com/superboum/rpm/commit/4a3a7a11785c2a108df64ac0ca4b5ab86bf9e4d1).\r\n\r\nI have also updated this PR accordingly.\r\nHowever I am not sure of scheme-script behaviour, should it act like `scheme --script` ? Because it's not the case for me, but it looks like another problem as even with the symlink `scheme-script` doesn't act like `scheme --script`. Indeed, I compared the following programs:\r\n\r\n```\r\n#!/usr/bin/scheme-script\r\n(display \"hello\")\r\n```\r\n\r\nFails with `Exception: invalid top-level program import subform (display \"hello\") at line 2, char 1 of ./test`\r\n\r\n```\r\n#!/usr/bin/scheme --script\r\n(display \"hello\")\r\n```\r\n\r\nWorks\r\n\r\nI think it could be that I don't understand what is `scheme-script` purpose or I failed something in my packaging scripts, so probably not related, but I prefer asking before breaking something in ChezScheme via a broken PR! `scheme-script` is equivalent to `scheme --program` Ok, so it works as intended :smiley:   I currently have `autocomplete` working via company, but `autodoc` is not working with `company-quickhelp`. \r\n\r\nHere is what I have installed:\r\nUbuntu 17.10\r\nGNU Emacs 25.2.2\r\nChez Scheme Version 9.5.1 \r\nGeiser 20180329.548\r\n\r\nHere is my setup:\r\n```emacs-lisp\r\n  (use-package geiser\r\n    :ensure t\r\n    :config\r\n    (defvar geiser-active-implementations)\r\n    (setq geiser-active-implementations '(chez))\r\n    (setq geiser-mode-start-repl-p t)\r\n    (setq geiser-repl-history-filename \"~/.emacs.d/geiser-history\")\r\n    (add-to-list 'company-backends 'geiser-company))\r\n\r\n(use-package company\r\n    :ensure t\r\n    :config\r\n    (add-hook 'prog-mode-hook 'company-mode)\r\n    (setq company-dabbrev-downcase 0)\r\n    (setq company-idle-delay 0.3))\r\n\r\n  (use-package company-quickhelp\r\n    :ensure t\r\n    :config\r\n    (company-quickhelp-mode 1)\r\n    (define-key company-active-map (kbd \"C-c h\") #'company-quickhelp-manual-begin))\r\n```\r\n\r\nand the error I get is:\r\n\r\n> Error running timer \u2018company-quickhelp--show\u2019: (error \"No buffer named No documentation available for \u2019default-exception-handler\u2019\")\r\n\r\nAnd here is a screenshot of the autodoc failure:\r\n![screenshot from 2018-04-09 19-38-15](https://user-images.githubusercontent.com/27776051/38528418-9e14fe14-3c2d-11e8-9fc6-9dcb5ec22258.png)\r\n\r\n Geiser uses Chez\u02bcs inspect/object functionality. For procedures that you created, you need to evaluate them before you can see autodoc. For built-in procedures you need to compile Chez with generate-inspector-information set to #t. By setting generate-inspector-information to #t will we be able to get the minibuffer strings that show a functions parameters?\r\n\r\nlike _map f l | f l l2_ ...etc? @Silverbeard00 yes! I got this working by editing the following lines in the build file \"s/Mf-base\"\r\n\r\n\r\n```\r\n# i determines whether inspector-information is generated: f for false, t for true\r\ni = f\r\n```\r\n\r\nI changed `i = f` to `i = t` and then rebuilt Chez with\r\n\r\n```\r\n.configure\r\nsudo make\r\nsudo make bootfiles\r\nsudo make install\r\n```\r\n\r\nAfter that Geiser began showing arguments for **some** built-in procedures, like `printf`, but not all. For instance, nothing is shown for `map`. I think this is a problem with Geiser's handling of procedures defined by `lambda-case` with multiple arities, but I'm not sure.\r\n\r\nI figured I should document this here because I didn't find how to compile Chez with \"generate-inspector-information\" anywhere. On Wed, Sep 12 2018, andregrigon wrote:\n\n> After that Geiser began showing arguments for some built-in\n> procedures, like printf, but not all. For instance, nothing is shown\n> for map. I think this is a problem with Geiser's handling of\n> procedures defined by lambda-case with multiple arities, but I'm not\n> sure.\n\nI haven't looked, so I might be missing something but: geiser's elisp\ndoesn't guess any arguments by itself, it just asks the scheme process\n(chezscheme in this case) for a list of arities of the given procedure.\nSo, Geiser's elisp doesn't even know in general whether the function was\ndefined as a lambda-case or in any other form (or even if it's a macro,\nfor that matter), as long as the arities are reported in the expected\nformat (which is fixed; multiple arities are supported).  That arity\nlist is generated somewhere in Geiser's scheme code for ChezScheme, so\nmaybe that's the code that is not handling correctly reporting of\narities for lambda-case.\n\n Oh right, that's what I meant. I think the problem is in the following procedure from geiser/scheme/chez/geiser/geiser.ss\r\n\r\n```\r\n(define (procedure-parameter-list p)\r\n    ;; same as (inspect object), then hitting c\r\n    (let ((s (((inspect/object p) 'code) 'source)))\r\n      (if s\r\n          (let ((form (s 'value)))\r\n            (if (and (list? form)\r\n                     (> (length form) 2)\r\n                     (eq? (car form) 'lambda))\r\n                (cadr form)\r\n                #f))\r\n          #f)))\r\n```\r\nIt seems to look at the procedure source to determine the parameter list and only treats lambdas.\r\n\r\nSorry for the confusion!  Here is what I have:\r\n\r\n```scheme\r\namirouche@neitram:~/src/scheme/chez/tmp$ cat foo.scm\r\n(import (rnrs))\r\n\r\n(define (foo example)\r\n  (let ((bar 1))\r\n    (bar)))\r\n\r\n(foo 42)\r\namirouche@neitram:~/src/scheme/chez/tmp$ scheme --debug-on-exception --program foo.scm\r\nException: attempt to apply non-procedure 1\r\ndebug> i\r\n#<continuation>                                                   : sl\r\n  continuation:          #<system continuation in ksrc>\r\n  procedure code:        (lambda () (letrec* ((...) (...)) ((...))))\r\n  call code:             (bar)\r\n#<continuation>                                                   : \r\n```\r\n\r\nIs it  possible to know in which module `bar` is defined?\r\n\r\nAlso, \r\n\r\n- is it possible to have traceback on errors instead of having to enter the debugger?\r\n- the debugger is very crude, it doesn't support sexp editor nor readline (history, autocomplete) Also, this article is helpful https://www.cs.indiana.edu/chezscheme/debug/\r\n If you want an error handler to print a stack trace then install an error handler that prints stack traces.  #128 \r\n\r\nIf you want the inspector to support the expression editor (which seems like a pretty good idea to me) then you might have better luck opening an issue specifically for that.  (I'm a little surprised that there isn't one already.)\r\n\r\nAs for knowing where `bar` is defined... well, first, your question as written doesn't make sense, since there are no modules at all in your example.  Presuming you meant that you wanted to know where the variable was introduced into scope (which still won't necessarily tell you where it was assigned the bad value), that's a good question.  Perhaps one of the maintainers will chime in and tell us if that information is retained in the compiled code (when inspector information is enabled).  Frankly, I'm a little surprised that it kept enough information to know that there was a `bar` in the first place, since `expand/optimize` gets rid of it completely.  .....\r\nprim5.c: In function \u2018s_showalloc\u2019:\r\nprim5.c:329:85: error: \u2018td of \u2019 directive output may be truncated writing 6 bytes into a region of size between 0 and 18 [-Werror=format-truncation=]\r\n   snprintf(fmtbuf, FMTBUFSIZE, \"%%#0%dtx %%#0%dtx (+ %%#0%dtx bytes @ %%#0%dtx) %%%dtd of %%%dtd\\n\",\r\n                                                                                     ^~~~~~\r\nprim5.c:329:3: note: \u2018snprintf\u2019 output between 54 and 112 bytes into a destination of size 60\r\n   snprintf(fmtbuf, FMTBUFSIZE, \"%%#0%dtx %%#0%dtx (+ %%#0%dtx bytes @ %%#0%dtx) %%%dtd of %%%dtd\\n\",\r\n   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n       addrwidth, byteswidth, headerbyteswidth, headeraddrwidth, segswidth, segswidth);\r\n       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ncc1: all warnings being treated as errors\r\nmake[2]: *** [Makefile:29: prim5.o] Error 1\r\nmake[1]: *** [Makefile:20: build] Error 2\r\nmake: *** [Makefile:22: install] Error 2\r\n\r\n\r\nI can't find any other similar errors online. I'm not knowledgeable enough to determine whether this is an issue with s_showalloc in prim5.c or GCC's snprintf. \r\n\r\nG\r\n #299  Thank you.\r\n9.5 still won't build after patching because it can't find xlocale.h. However, master builds fine. make CFLAGS=-Wno-format-truncation can temporarily disable the warning, but not the final solution.  arm32le dose not support thread? I went crash.\r\n\r\nSIGSEGV (signal SIGSEGV: invalid address (fault address: 0x28))\r\nin source file alloc.c line 736 thread_find_room(tc, type_typed_object, d, p);\r\n\r\n\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG: Build fingerprint: 'Xiaomi/sagit/sagit:8.0.0/OPR1.170623.027/V9.5.7.0.OCACNFA:user/release-keys'\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG: Revision: '0'\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG: ABI: 'arm'\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG: pid: 7029, tid: 7727, name: Thread-27  >>> org.evilbinary.chez <<<\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG: signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x28\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG: Cause: null pointer dereference\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG:     r0 00000000  r1 00000038  r2 00000000  r3 c477b4cc\r\n05-07 01:08:44.370 7733-7733/? A/DEBUG:     r4 0000000c  r5 c3ed4b50  r6 00000000  r7 c3ed4b50\r\n05-07 01:08:44.371 7733-7733/? A/DEBUG:     r8 0000004e  r9 c9eb4400  sl c10fef30  fp c10feebc\r\n05-07 01:08:44.371 7733-7733/? A/DEBUG:     ip c452fdfc  sp c10fee00  lr c44cc080  pc c44cc08c  cpsr 40070010\r\n @dybvig @akeep   Matthias Klose reported in https://bugs.debian.org/897720 that Chez Scheme fails to build with gcc-8, which is due to snprintf() writing to a buffer that is potentially too small. Please review this patch. Anyone have a look at this yet? The valid return value of `snprintf` is '`0 <= return value < buffer size`'.  But in C code of Chez Scheme, it seems that all return value of `snprintf` have not been properly checked. No error I can think out for now. The results checking of `snprintf` is just a suggestion, and this checking is looks like too tedious at here. And the compiler seems do a good job to check the `snprintf`.\r\n  The following code:\r\n```scheme\r\n(library (bug)\r\n  (export)\r\n  (import (chezscheme))\r\n\r\n  (define-record-type test)\r\n\r\n  (record-writer (type-descriptor test)\r\n                 (lambda (r p wr) #f))\r\n\r\n  (define (fails-here) #f))\r\n```\r\nCauses the error message: `Exception: invalid context for definition (define (fails-here) #f) at line 11, char 3 of bug.ss`.\r\nThis error occurred on version `9.5` target `a6nt`.\r\nIf the `record-writer` is the last thing in the library it doesn't cause an error message, and if the code is toplevel it doesn't happen either.\r\n\r\nThe following code gives a different error message that seems to leak some implementation information that might be useful:\r\n```scheme\r\n(library (bug)\r\n  (export)\r\n  (import (chezscheme))\r\n\r\n  (define-record-type test-a)\r\n\r\n  (record-writer (type-descriptor test-a)\r\n                 (lambda (r p wr) #f))\r\n\r\n  (define-record-type test-b)\r\n\r\n  (record-writer (type-descriptor test-b)\r\n                 (lambda (r p wr) #f))\r\n\r\n  (define (fails-here) #f))\r\n```\r\nError message:\r\n`Exception: invalid context for definition (define rtd ($make-record-type-descriptor #!base-rtd (quote test-b) #f (quote #f) #f ...))` Okay, thanks for clarifying.   Error happens during `make test`, here is full summary in `a6le/mats/summary` file:\r\n```\r\n-------- o=0 --------\r\n-------- o=3 --------\r\n-------- o=0 cp0=t --------\r\n-------- o=3 cp0=t --------\r\n-------- o=0 spi=t p=t --------\r\n-------- o=3 spi=t p=t --------\r\n-------- o=0 eval=interpret --------\r\n-------- o=3 eval=interpret --------\r\n-------- o=0 cp0=t eval=interpret --------\r\n-------- o=3 cp0=t eval=interpret --------\r\n-------- o=0 ehc=t eoc=f --------\r\n-------- o=3 ehc=t eval=interpret --------\r\n0a1\r\n> 8.mo:Error in mat locate-source-caching clause 1: \"source-cache-test: loading lots of `let-values` forms seems to take too long\" at line 11081, char 3 of 8.ms\r\n```\r\n\r\n- System Info: Linux Mint 18.2 (ubuntu 16.04 base); gcc-5.4.0; Thanks for quick reply! Forget mention I am using `v9.5 release` rather than master branch. I just tried master branch which can pass all test. \r\n  were reversed in csug, flipped to be correct.  ```\r\n(define-syntax json-reduce\r\n        (lambda (x)\r\n            (syntax-case x ()\r\n                ((_ j v1 p) #'(reduce j v1 p))\r\n                ((_ j v1 v2 p) #'(json-reduce j v1 (lambda (x y) (json-reduce y v2 (lambda (n m)(p (cons n x) m))))))\r\n                ((_ j v1 v2 v3 p ...) #'(json-reduce j v1 v2 (lambda (x y) (json-reduce y v3 (lambda (n m)(p (cons n x) m)))) ...)))))\r\n```\r\n\r\n(reduce) accept 3 args : a list or vector, a #t and a procedure need two args.\r\n\r\nthere is the problem:\r\n\r\n`(json-reduce y #t  (lambda (x y) x))`   is ok\r\n`(json-reduce y #t #t  (lambda (x y) x))`  is ok\r\n`(json-reduce y #t #t #t  (lambda (x y) x)) `is ok\r\n\r\nbut\r\n\r\n```\r\n(json-reduce y #t #t #t #t  (lambda (x y) x)) \r\nException: incorrect number of arguments to #<procedure>\r\nType (debug) to enter the debugger.\r\n```\r\n\r\ncode origin of  (reduce): https://github.com/guenchi/json/blob/master/json.sc\r\n\r\nfor define the y: https://github.com/guenchi/json/blob/master/exemple.sc  \r\n@akeep \r\n\r\ndon't use the macro json-reduce of the file \"json.sc\"\r\n\r\nuse the code json-reduce which I post in here. \r\n\r\n(the code json-reduce in the file \"json.sc\" isn't record all the key that the filter passed. It's a semi-finished product that I didn't complete the design goal)\r\n\r\n  @akeep thx a lot! I got much from it!\r\n\r\nas a newbie of scheme, I don't know how to use debug, expand and trace-define-syntax.\r\n\r\neven i don't found the define of ... . (I try to move it)\r\n\r\nafter one night and one day of trying, I put the problem here and I got more than I expect.\r\n\r\n  When I use Chezscheme to run a scheme file whose absolute path contain utf-8 encoding in sublime_text, Chez will report an error:\nException in load: the_file_absolute_path: no such file or directory!\n But if I run the file with Chez in a terminal with a relative path, it well done. Please tell me whether Chez doesn't support a utf-8 encoding directory or I didn't set it well to work! You are correct. Chez Scheme currently handles only ASCII-encoded paths as command-line arguments. See Issue https://github.com/cisco/ChezScheme/issues/81 for details. I plan to fix this. Thanks! Thanks, I tested it on linux, it worked well.  Can any boy integrate the GMP Bignum Library into ChezScheme? \nI find that ChezScheme is so fast in simple addition and subtraction, almost fast as C, but too slow in bignum's operation! What about using [bsdnt](https://github.com/wbhart/bsdnt) or [LibBF](https://bellard.org/libbf/)? @akeep Thank you very much, I am so foolish! I am learning SICP book recently, when i try to compute fib function\uff0cChezScheme took about 0.6sec for n=1000,000, and more than 80sec for n=10,000,000, is slower than mit-scheme. \nI tried to use python3 for the same algorithm, it takes about 2sec for n=10,000,000.\nI also tried to use GMP Library  to compute fib function, it takes about 1.2sec for n=100,000,000. \nI was using Chez to compute the sum of 0->n, found it is so fast even faster than using C language. So I think Chez is really very fast, but could be improved at bignum's computation.\n\nI just think Chez is limited, at bignum's computation, no other meanings. maybe I should learn more about git/github and variant Open Source Licenses and improve English before come here to ask question!  http://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:h1 says:\r\n\r\n> The Revised<sup>6</sup> Report distinguishes two types of special numeric objects: fixnums and flonums. <i>Chez&nbsp;Scheme</i> additionally distinguishes <i>bignums</i> (exact integers outside of the bignum range) and <i>ratnums</i> (ratios of exact integers).\r\n\r\nBignums are outside the fixnum range, not outside the bignum range. I believe https://github.com/cisco/ChezScheme/blob/master/csug/csug.stex and so on is the source of csug, maybe if you added a pull request, that might be easier to merge? http://cisco.github.io/ChezScheme/csug9.5/use.html#./use:h3 says:\r\n\r\n<blockquote>For example, assuming that <tt>yin</tt> and <tt>yang</tt> have not\r\nbeen defined,\r\n<p>\r\n<p><tt>(define&nbsp;yin&nbsp;(lambda&nbsp;()&nbsp;(-&nbsp;(yang)&nbsp;1)))</tt>\r\n<p>defines <tt>yin</tt> at top level as a variable to a procedure that calls\r\nthe value of the top-level variable <tt>yang</tt>, even though <tt>yang</tt>\r\nhas not yet been defined.</blockquote>\r\n\r\nProbably, \"a variable to a procedure\" should be \"a variable bound to a procedure\".  https://www.scheme.com/tspl4/objects.html#./objects:h10 says:\r\n> `bytevector-copy!` overwrites the _n_ bytes of _dst_ starting at _dst-start_ with the _n_ bytes of _dst_ starting at _src-start_.\r\n\r\nThe second _dst_ should be _src_ instead.\r\n\r\n https://www.scheme.com/tspl4/objects.html#./objects:h5 says:\r\n\r\n> _Fixnums_ represent exact integers in the fixnum range, which is required to be a closed range [-2<sup>_w_-1</sup>,2<sup>_w_-2</sup> - 1], where _w_ (the _fixnum width_) is at least 24.\r\n\r\nThe right endpoint of the range should be 2<sup>_w_-1</sup> - 1, not 2<sup>_w_-2</sup> - 1. https://www.scheme.com/tspl4/objects.html#./objects:h4 says:\r\n\r\n> A mantissa width <tt>|<i>w</i></tt> may appear as the suffix of a real number or the real components of a complex number written in floating-point or scientific notation. The mantissa width <tt><i>m</i></tt> represents the number of significant bits in the representation of the number.\r\n\r\n<tt><i>m</i></tt> should be <tt><i>w</i></tt>.  (Or vice versa.) Are the sources of TSPL online anywhere (like csug is)? That might make actual PRs easier. https://www.scheme.com/tspl4/objects.html#./objects:s144 says:\r\n> If <tt><i>exint<sub>2</sub></i></tt> is negative, <tt>bitwise-arithmetic-shift</tt> returns the\r\nresult of arithmetically shifting <tt><i>exint<sub>1</sub></i></tt> right by <tt><i>exint<sub>2</sub></i></tt> bits.\r\n\r\nThe last <tt><i>exint<sub>2</sub></i></tt> should be <tt>-<i>exint<sub>2</sub></i></tt>. https://www.scheme.com/tspl4/objects.html#./objects:s260\r\n\r\nFor both `bytevector->uint-list` and `bytevector->sint-list`, in the description of the return value, \"_`size`_-bit\" should be \"_`size`_-byte\". https://www.scheme.com/tspl4/objects.html#./objects:s224 says:\r\n\r\n> <tt><i>start</i></tt> and <tt><i>end</i></tt> must be exact nonnegative integers;<tt><i>start</i></tt> must be less than the length of <tt><i>string</i></tt>, while <tt><i>end</i></tt> may be less than or equal to the length of <tt><i>string</i></tt>. If <tt><i>end</i></tt>&nbsp;&le;&nbsp;<tt><i>start</i></tt>, a string of length zero is returned.\r\n\r\nBut R6RS allows <tt><i>start</i></tt> to be equal to the length of <tt><i>string</i></tt>, and does not allow it to be greater than <tt><i>end</i></tt>.\r\n\r\n(The actual behavior of Chez Scheme follows R6RS and not TSPL4.) The last example at https://www.scheme.com/tspl4/objects.html#./objects:s216 is:\r\n> <tt>(string-ci=?&nbsp;\"Stra\\sse\"&nbsp;\"Strasse\")</tt>\r\n\r\nI guess it should be:\r\n> <tt>(string-ci=?&nbsp;\"Stra\u00dfe\"&nbsp;\"Strasse\")</tt>\r\n http://cisco.github.io/ChezScheme/csug9.5/io.html#./io:s55 says:\r\n> The buffer mode <tt><i>b-mode</i></tt> defaults to <tt>block</tt>, which differs from <tt>block</tt> in <i>Chez&nbsp;Scheme</i> only for textual output ports. See the lead-in to Section&nbsp;<a href=\"http://scheme.com/tspl4/./io.html#g123\">7.2</a> of <i>The Scheme Programming Language, 4th Edition</i> for a description of the constraints on and effects of the other arguments.\r\n\r\n> The Revised<sup>6</sup> Report version of this procedure does not accept the optional <tt><i>b-mode</i></tt> and <tt><i>?transcoder</i></tt> arguments, which limits it to an implementation-dependent buffering mode (<tt>block</tt> in <i>Chez&nbsp;Scheme</i>) and binary output.\r\n\r\n1) <tt>block</tt> differs from <tt>block</tt>?\r\n2) We're describing <tt>(standard-input-port)</tt> here, so why talk about textual output ports or binary output?\r\n3) There are no other arguments. https://www.scheme.com/tspl4/libraries.html#./libraries:h2 says:\r\n\r\n> If code is intended for use with systems that do not automatically determine\r\nwhen a library's bindings must be made available, however, the <tt>for</tt>\r\nmust be used if the importing library's bindings would not otherwise be\r\navailable at the right time.\r\n\r\nI'm not sure, but I think \"importing\" should be \"imported\". https://www.scheme.com/tspl4/libraries.html#./libraries:h2 says:\r\n> Similarly, a <tt>&lt;=</tt> <tt><i>subversion-reference</i></tt> matches a <tt><i>version</i></tt>'s <tt><i>subversion</i></tt> if the <tt><i>version</i></tt>'s <tt><i>subversion</i></tt> is less than or equal to the <tt><i>subversion</i></tt> appearing within the <tt>&gt;=</tt> form.\r\n\r\n\"the <tt>&gt;=</tt> form\" should be \"the <tt>&lt;=</tt> form\". https://www.scheme.com/tspl4/libraries.html#./libraries:h4 says:\r\n> The syntactic extension <tt>set</tt> expands into a reference to the variable <tt>list-&gt;set</tt>, and <tt>member?</tt> similarly expands into a reference to the variable <tt>$member?</tt>. While <tt>list-&gt;set</tt> is explicitly exported, <tt>$member?</tt> is not. This makes <tt>$member?</tt> an indirect export.\r\n\r\nThere is no variable called <tt>$member?</tt>. Apparently it was changed to <tt>member-help?</tt>.  I'm having a bit of trouble wrapping C functions like `recv` and `send` which can block for arbitrarily long times.\r\n\r\nI'm trying to wrap them using *only* Scheme code (and the FFI), no C code. I've been successful in non-threaded builds (or threaded builds with only a single thread), but I'm seeing strange blocking behaviour of other threads in threaded builds.\r\n\r\nI have code similar to\r\n````\r\n(lock-object buffer)\r\n((foreign-procedure \"recv\" ...) buffer ...)\r\n(unlock-object buffer)\r\n````\r\nFrom reading csug, I think I might have to call `Sactivate_thread` and `Sdeactivate_thread` somewhere here, but can I even do that from inside Scheme? I want to avoid building and linking C code at all costs.\r\n\r\nThanks for any assistance with this or clarifications on what I'm doing wrong :) You could do this  https://github.com/evilbinary/scheme-lib/blob/master/packages/cffi/cffi.ss#L755 wrap Sdeactivate_thread  and Sactivate_thread. cffi is a usefull  lib to call c with thread. I'll close this, it should be solved if #267 is merged.  \r\n```scheme\r\n  (define request\r\n    (lambda (info)\r\n        (let ((code (foreign-callable info (string string string) string)))\r\n            (lock-object code)\r\n            (foreign-callable-entry-point code))))\r\n\r\n(define handle_get\r\n     (request\r\n           (lambda (request_header path_info payload)\r\n                (here_back_the_value_of_respone_to_C_function))))\r\n```\r\n```c\r\ntypedef char* (*res)(char* request_header, char* path_info, char* payload); \r\n\r\n\r\nres res_get;\r\n\r\nint handle_request(res response_get)\r\n{\r\n\t\tres_get = response_get;\r\n}\r\n```\r\n```scheme\r\n (handle_request req_get)\r\n```\r\nin a  C function\r\n\r\n```c\r\nchar* respone = res_get(request_header, path_info, query_stirng);\r\n```\r\n\r\n\r\nif strcpy() the respone\r\n\r\n```bash\r\nException: invalid memory reference.  Some debugging context lost\r\n```\r\n\r\nI can't do any thing to operate to respone or get its value.\r\n\r\n thx for your response. @akeep \r\n\r\nso here is the original code that I got the problem.\r\n\r\nhttps://github.com/guenchi/Igropyr/blob/master/igropyr/src/httpc.c\r\n\r\nline 291:\r\n\r\nchar* respone = res_get(request_header, path_info, query_stirng);\r\n\r\nwhen I use \"strcpy\" to respone, or anything to operating it. like \r\n\r\n```\r\nchar* end = respone;\r\nend++;\r\n*end = '\\0';\r\n```\r\n\r\nthe programme will crash.\r\n @akeep \r\n\r\nI can't reproduce the problem, maybe it because\r\n\r\n`(define handle-request (foreign-procedure \"handle_request\" (void*) int))`\r\n\r\ni have used iptr instead of void*.\r\n\r\n I have changed it since \"https://github.com/cisco/ChezScheme/issues/272\"\r\n\r\nnow i can use \r\n```\r\nchar* end = respone;\r\nend++;\r\n*end = '\\0';\r\n```\r\n\r\nbut the strcpy isn't work:\r\n\r\n\r\nhttps://github.com/guenchi/Igropyr/blob/master/igropyr/src/httpc.c\r\n```\r\n294\t\t\tif(STATIC_PATH) \r\n295\t\t\t{\t\t\t\t\r\n296\t\t\t\tchar* file_path = respone;\r\n297\t\t\t\tfile_path++;\r\n```\r\nline 296 change to: \r\n```\r\nchar* file_path;\r\nstrcpy(file_path, respone);\r\n```\r\nand change \r\nhttps://github.com/guenchi/Igropyr/blob/master/igropyr/http.sc\r\nline 57-59\r\n```\r\n(define sendfile\r\n      (lambda (type content)\r\n           (string-append \" \" content)))\r\n```\r\nchange procedure to:\r\n```\r\n(define sendfile\r\n        (lambda (type content)\r\n            (string-append \" \" content \" application/octet-stream\")))\r\n```\r\nnow use this code to run: (set a path and a file)\r\n```\r\n(import (igropyr http))\r\n\r\n    (define test\r\n        (lambda (request-header path-info query-string)\r\n            (sendfile 200 \"filename.postfix\" )))\r\n\r\n(server \r\n    (request test)\r\n    (request test)     \r\n    (set \r\n        ('staticpath \"/file/path/\"))\r\n    (listen 8080))\r\n```\r\n\r\nopen `localhost:8080/`\r\nyou will got:\r\nException: invalid memory reference.  Some debugging context lost\r\n\r\n\r\nBy the way, would you please to look a little line 46 - 47.\r\nhttps://github.com/guenchi/Igropyr/blob/master/igropyr/src/httpc.c\r\n```\r\n41   static void after_uv_write(uv_write_t* w, int status) \r\n42  {\r\n46\t // if(w->data)\r\n47\t //\t    free(w->data); \r\n50\t     uv_close((uv_handle_t*)w->handle, after_uv_close_client);\r\n51\t     free(w);\r\n52  }\r\n```\r\nif I free the memory by hand, the programme will crash.\r\nthe programme running good if I don't free it. \r\nI'm not sure if it's Chez Scheme manage this memory or here will cause a memory leak. thx  \r\nWhen building threaded version (unthreaded builds and installs normally) I encouter this error (needless to say that libz.a is present):\r\n\r\n```\r\n(cd ta6le && make install)\r\n(cd c ; make)\r\ngcc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2 -D_REENTRANT -pthread  -c -DX86_64 -I../boot/ta6le -I../zlib scheme.c\r\n(cd ../zlib; make)\r\nPlease use ./configure first.  Thank you.\r\nld -melf_x86_64 -r -X -o ../boot/ta6le/kernel.o statics.o segment.o alloc.o symbol.o intern.o gcwrapper.o gc-ocd.o gc-oce.o number.o schsig.o io.o new-io.o print.o fasl.o stats.o foreign.o prim.o prim5.o flushcache.o schlib.o thread.o expeditor.o scheme.o i3le.o ../zlib/libz.a\r\nld: cannot find ../zlib/libz.a: No such file or directory\r\nmake[2]: *** [Makefile:34: ../boot/ta6le/kernel.o] Error 1\r\nmake[1]: *** [Makefile:20: build] Error 2\r\nmake: *** [Makefile:22: install] Error 2\r\n\r\n```  https://cisco.github.io/ChezScheme/csug9.4/foreign.html#./foreign:h0\r\n\r\n\r\nin exemple:\r\n\r\n\r\n```\r\n#include <stdio.h> \r\n\r\ntypedef void (*CB)(char); \r\n\r\nCB callbacks[256]; \r\n\r\nvoid cb_init(void) {\r\n   int i; \r\n\r\n   for (i = 0; i < 256; i += 1)\r\n       callbacks[i] = (CB)0;\r\n} \r\n\r\nvoid register_callback(char c, int cb) `{`\r\n    callbacks[c] = (CB)cb;\r\n} \r\n\r\nvoid event_loop(void) {\r\n    CB f; char c; \r\n\r\n    for (;;) {\r\n        c = getchar();\r\n        if (c == EOF) break;\r\n        f = callbacks[c];\r\n        if (f != (CB)0) f(c);\r\n    }\r\n}\r\n\r\n(define cb-init\r\n  (foreign-procedure \"cb_init\" () void))\r\n(define register-callback\r\n  (foreign-procedure \"register_callback\" (char int) void))\r\n(define event-loop\r\n  (foreign-procedure \"event_loop\" () void))\r\n\r\n```\r\n\r\nmay have a problem \r\n\r\ninvalid foreign-procedure argument 4383673376\r\n\r\n\r\nit will work well if we change:\r\n\r\n```\r\nvoid register_callback(char c, CB cb) {\r\n    callbacks[c] = (CB)cb;\r\n} \r\n```\r\n\r\n\r\nand call it as\r\n\r\n`(foreign-procedure \"register_callback\" (char iptr) void))`  When  `(#2%map p '())` is reduced in cp0 to `'()`, the expression of p is discarded without a check that it is a procedure. But the signature of `map` in primdata.ss is `((procedure list list...) ->(list))`.\r\n\r\nThe problem is that in the [PR of cptypes #192](https://github.com/cisco/ChezScheme/pull/192) uses the signature to mark `p` as a procedure after this expression, assuming that otherwise `map` would have raise an error. \r\n\r\nThe code to show the problem should be a mix of some reductions of cp0 and some reduction of cptypes:\r\n\r\n    (define (f p b)\r\n     (unbox b)\r\n     (map p (if (box? b) '() '(1 2 3)))\r\n     (list p (procedure? p)))\r\n    \r\n    (f 7 (box 0)) ;==> \r\n    ; ==> (7 #f) in the current version of Chez Scheme\r\n    ; ==> [error] in Chez Schem + this patch\r\n    ; ==> (7 #t) in Chez Scheme + cptypes [wrong]\r\n\r\nI think that the best behavior is to raise an error. This patch removes one of the reductions in cp0 so the other reduction is triggered and an error is raised.\r\n\r\nBut I think it's also ok to not raise an error, but in this case the signature of map should be weaker, and allow the first argument to be any pointer. The patch to do this is in my [alternative branch](https://github.com/gus-massa/ChezScheme/commits/18-2-Map-Null-Alternative).\r\n\r\nBut I think that the result `(list p (procedure? p))` --> `(7 #t)` is wrong, and it can cause further problems in cptypes in more complex and realistic examples. Fixed.\r\n\r\nI also changed lines [3628](https://github.com/cisco/ChezScheme/pull/269/commits/dd96ca9fcf63148663b3e15c8bbb40d78dfc985c#diff-b056327abff41de13bd32f375c12cc3dR3628) and [3633](https://github.com/cisco/ChezScheme/pull/269/commits/dd96ca9fcf63148663b3e15c8bbb40d78dfc985c#diff-b056327abff41de13bd32f375c12cc3dR3633) so `make-seq` and `make-seq*` get the right value. Fixed.\r\n\r\nI copied the long example about the reduction of `#2%map` in a o=3 environment to `#2%for-each`, but I also added the small examples like `(map 3 '())` to all the similar constructions like `andmap`.  Threads are often used in event-handling libraries like the one shown in the documentation for `foreign-callable`. Prior to this patch, activating and deactivating a thread to make an event-based pattern thread-friendly required glue C code to call `Sdeactivate_thread` and `Sactivate_thread`.\r\n\r\nThis patch adds `__thread` as a convention modifier for `foreign-procedure` and `foreign-callable`:\r\n\r\n * On a foreign procedure, `__thread` causes the calling thread to be deactivated (at the last moment, after arguments to the procedure are unpacked), and the thread is re-activated when the foreign procedure returns.\r\n\r\n * On a foreign callable, `__thread` causes the calling thread to be activated, and the activation state is reverted when the callable returns. \"Reverted\" has no effect if the thread was already activated, but \"reverted\" can mean \"destroyed\" if the thread had not been registered when the callable was invoked.\r\n\r\nAs an example, using a pair of `__thread` annotations in the `event-loop` example for `foreign-callable` makes the example play nicely with threads, instead of causing threads to block when they try to GC. A `__thread` annotation on a callable can also make the callable work when invoked by an unspecified thread, instead of requiring that that the thread is first activated.\r\n\r\nThis patch builds on #213. The changes could stand alone, but since the modifications overlap and since Racket needs both patches, it seems easiest to combine the changes, and it may make sense to review them together.\r\n Nice feature! EDIT: has this been merged into the struct PR? is this obsolete?\r\n\r\nI get compile errors. Do I need to also apply the ftype patches before compiling?\r\n````\r\ngcc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2 -D_REENTRANT -pthread  -c -DX86_64 -I../boot/ta6le -I../zlib foreign.c\r\ngcc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2 -D_REENTRANT -pthread  -c -DX86_64 -I../boot/ta6le -I../zlib prim.c\r\nprim.c: In function \u2018create_c_entry_vector\u2019:\r\nprim.c:127:21: error: \u2018CENTRY_activate_thread\u2019 undeclared (first use in this function); did you mean \u2018S_activate_thread\u2019?\r\n     install_c_entry(CENTRY_activate_thread, proc2ptr(S_activate_thread));\r\n                     ^~~~~~~~~~~~~~~~~~~~~~\r\n                     S_activate_thread\r\nprim.c:127:21: note: each undeclared identifier is reported only once for each function it appears in\r\nprim.c:128:21: error: \u2018CENTRY_deactivate_thread\u2019 undeclared (first use in this function); did you mean \u2018CENTRY_activate_thread\u2019?\r\n     install_c_entry(CENTRY_deactivate_thread, proc2ptr(Sdeactivate_thread));\r\n                     ^~~~~~~~~~~~~~~~~~~~~~~~\r\n                     CENTRY_activate_thread\r\nprim.c:129:21: error: \u2018CENTRY_unactivate_thread\u2019 undeclared (first use in this function); did you mean \u2018CENTRY_deactivate_thread\u2019?\r\n     install_c_entry(CENTRY_unactivate_thread, proc2ptr(S_unactivate_thread));\r\n                     ^~~~~~~~~~~~~~~~~~~~~~~~\r\n                     CENTRY_deactivate_thread\r\nmake[2]: *** [Makefile:29: prim.o] Error 1\r\nmake[1]: *** [Makefile:20: build] Error 2\r\nmake: *** [Makefile:19: build] Error 2\r\n\r\n````\r\n\r\n\r\n````\r\n> gcc --version                                                    \r\ngcc (GCC) 7.2.1 20171224\r\nCopyright (C) 2017 Free Software Foundation, Inc.\r\nThis is free software; see the source for copying conditions.  There is NO\r\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n```` @ecraven The problem is that the boot files aren't updated, where \"boot files\" includes headers that have changed and are needed to compile the C part. So, you need to cross-compile to try it out.\r\n\r\nTo build for a platform `$M` (e.g., \"ta6osx\"), if you have an existing build for platform `$M` in `$ORIG`, then cross-compile with\r\n\r\n```\r\n  ./configure\r\n  (cd $M/s && make -f Mf-cross m=$M xm=$M base=$ORIG/$M)\r\n  (cd $M/c && make)\r\n  (cd $M/s && make allx)\r\n```\r\n Rebased, but the cross-compile steps are still needed to build. For 32-bit Windows, I assume __thread uses the __cdecl calling convention? Is there any convenient way to be able to specify both __thread and __stdcall or __com? (I'm not writing new code against 32-bit Windows any more, so this is not important to me, but I ask in order to make you aware of the issue.) @burgerrg Yes, the patch generalizes the syntax of `foreign-prcedure`, etc., to accept multiple \"conventions\", although `__thread` is the only one that is allowed in combination with any other. Thanks, that leaves a good way to support __thread with the other conventions if the need arises. @burgerrg I started to reply \"I mean that `__thread` already works with `__stdcall` and `__com`\", but then I realized that I forgot to add tests. So, of course, it didn't work for all combinations.\r\n\r\nI've added tests and repairs so that `__thread` works with `__stdcall` and `__com`. Great, thanks! I've tested this with running my SLIME swank and a web server in parallel, and it seems to solve the problems I had very well!\r\nIs there any way I can help with getting this merged? @dybvig, are you planning to review this pull request? I haven't looked at it in detail because I know you've recently inspected changes related to the foreign-procedure interface and may already be planning to review it. Hey @burgerrg,\r\n\r\n@dybvig and I talked a bit about it last week, and I volunteered to pick this up, but I've not had time to review the code in any level of detail, and I probably won't have a chance until next weekend.\r\n\r\nOne of the concerns we had about this is that any Scheme object passed as an argument to this function would need to be locked before the thread is deactivated, otherwise there is a chance that the collector might start between when the thread deactivation occurs and the argument is passed to the underlying C function.  A ``foreign-procedure`` marked with ``__thread`` would need to be at least somewhat responsible for this, because in some cases (like ``string`` arguments which are copied to a ``bytevector`` and the pointer into the ``bytevector`` data is passed to the underlying function) the programmer never actually has their hands on the object to lock.\r\n\r\nWe also discussed a little bit having a different name for this which is a little more descriptive.  Something like ``__thread_safe`` or ``__collector_safe``, since the property we are trying to express is that it is safe for the collector to run while the underlying C call is blocking. This does sound dangerous. What would you think if it locked all Scheme objects before deactivating and unlocked them after re-activating? That's what my custom C code does in Swish. Isn't this only relevant for strings? I'm passing bytevectors to recv and send, which I lock myself, so that isn't so bad. Are there any other datatypes except for strings that get copied internally?\r\n\r\nLocking all objects seems excessive, as the FFI call could potentially block for a very long time, resulting in nothing being collected, right? @ecraven Yes, I think the automatic object creation/copying is only for strings, so if you have non-string arguments and you are locking them already, you should be good to go.  The procedure code for the scheme wrapper is also created, but I think that should already be automatically locked before the C call.  I'd have to double check to be sure.\r\n\r\n@burgerrg Yes, @dybvig and I talked about having it auto-lock/unlock. I think where we landed on this, was that it might be nice to lock/unlock automatically but provide a syntax for specifying that an argument is already locked (though now that  I think about it you'd probably want that at the call site for the foreign procedure and we were thinking of this at the ``foreign-procedure`` definition site).  @akeep Checking whether I understand the issue with strings: Even before this PR, that can be an issue with a foreign function that invokes a callbable and is also passed a converted string (which it might access after the callable), right? @mflatt Yes, if the C function holds onto the pointer into the ``bytevector`` across the call to the ``foreign-callable``. Wouldn't it suffice to automatically lock the temporary bytevector of string arguments for each __thread foreign procedure, and unlock it afterwards? Everything else would stay the same as right now, wouldn't it? @ecraven The idea with the automatic locking is to allow programmers to use this feature without needing to lock the arguments themselves.  So, you wouldn't need to lock the ``bytevector`` around the call yourself, you could just let the ``foreign-procedure`` code take care of it for you.  I think @mflatt's struct parameter change added automatic locking and unlocking of ``foreign-callable`` arguments for the same reason. i'm not against automatic locking, but if anyone is, I think automatic locking of only the temporary string bytevectors should be sufficient. Personally, I'd welcome automatic locking of all relevant objects. @akeep FWIW, there was no new argument locking for callables \u2013 only some new locking of the callable itself, since a return address to the callable stays on the stack more than it used to.\r\n\r\nI'm not opposed to extra automatic locking, but given that the rule is already \"don't do that\" when a foreign procedure might invoke a callable, \"don't do that\" seems equally workable with `__thread` (or its replacement). That is, string types could be considered conveniences that only work in simple cases, and using `__thread` creates obligations for a caller in the same way as using callables does. Whereas C code called without `__thread` can safely use unlocked Scheme objects, C code with the `__thread` calling convention cannot safely use an unlocked Scheme object. Consequently, it seems appropriate that the system handles the locking and unlocking automatically of all argument types that need to be locked. If a particular application cannot tolerate the overhead, it can use `uptr` and `#%$object-address` to pass the address of a locked Scheme object to the C code. In case it helps, I've added a commit to change `__thread` to `__collect_safe` and to report an error if a string type is misused with `__collect_safe` as an argument (for foreign procedures) or result (for foreign callables). I could squash the commits if that's helpful.\r\n\r\nI didn't muster enough interest in automatic locking to try that direction myself, so `__collect_safe` as implemented is an assertion of safety, not a request to make the call safe.\r\n Thanks, I like the name change and disallowing string types. Not having automatic locking/unlocking is fine with me. Thank you for proposing this important feature addition. With it I'll be able to avoid wrapper code when making blocking calls that are collector safe. @akeep Thanks for the feedback. It will be a week or two before I can work on this more. Could you send/post your changes to use `(conv ...)` instead of making `conv` mean a sequence? (It seemed tedious when I tried that originally, but maybe I didn't pick the right approach.) @akeep Thanks for the `conv` conversion. I've added your commit here, and further adjusted some `conv` names to `conv*`.\r\n\r\nFor the error when using a string type with `__collect_safe`, reporting the original type name would mean adding to the function RTD and more, which seems heavyweight for an error that will be rarely seen. I made the error message slightly more generic by always using \"string\" instead of naming a specific type. Meanwhile, reporting is now consistent from a non-threaded build.\r\n\r\nFinally, I updated the docs as you suggested. Thanks to everyone concerned for the hard work, great that this was merged!  The most nearly stuff I've found is http://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:h9\r\n\r\nHowever, for what reason chez itself does not support procedure on network programming? OK so I could either write it by myself or use an exist lib. Thank you. I feel good with such philosophy.  Chez scheme is a real pleasure to use, I'm especially fond of the expression editor on the command line for some interactive coding. But I have one question \u2014 I understand that chez is known for being quite efficient, why does it take so long to start up?\r\n\r\n```\r\n$ echo \"(exit)\" | time chez -q\r\nchez -q  0.17s user 0.04s system 54% cpu 0.383 total\r\n$ time ruby -e 'exit'\r\nruby -e 'exit'  0.08s user 0.02s system 93% cpu 0.108 total\r\n$ time python3 -c 'exit()'\r\npython3 -c 'exit()'  0.05s user 0.01s system 76% cpu 0.083 total\r\n```\r\n\r\nIs this possibly a bug?  You are comparing the python and ruby interpreter with the chez scheme compiler. Interpreters have generally a faster startup time. Try it with the chez scheme interpreter :  `time petite -q`. I was playing around with this, and it seems like the majority of the startup time is spent inflating the boot files. I added some logging around parts of the load process, and using already inflated boot files I reduced the load time a fair bit:\r\n```\r\ngmw@ash: /home/gmw/software/ChezScheme\r\n06:51:32 $ ./ta6le/bin/scheme -q -b ./ta6le/boot/ta6le/petite.boot -b ./ta6le/boot/ta6le/scheme.boot <<< ''\r\nmain_init(); took 0.001036 seconds\r\nload(tc, i++, 1); S_boot_time = 0; while (i < boot_count) load(tc, i++, 0); took 0.125844 seconds\r\nif (boot_count != 0) Scompact_heap(); took 0.020594 seconds\r\ngmw@ash: /home/gmw/software/ChezScheme\r\n06:51:40 $ zcat ./ta6le/boot/ta6le/petite.boot ./ta6le/boot/ta6le/scheme.boot > chez.boot                  \r\ngmw@ash: /home/gmw/software/ChezScheme\r\n06:52:42 $ ./ta6le/bin/scheme -q -b ./chez.boot <<< ''                                                     \r\nmain_init(); took 0.001707 seconds\r\nload(tc, i++, 1); S_boot_time = 0; while (i < boot_count) load(tc, i++, 0); took 0.040372 seconds\r\nif (boot_count != 0) Scompact_heap(); took 0.019447 seconds\r\n```\r\nI wonder if more efficient use of zlib is possible? Very informative!  Seems like the decision about whether to optimize for space or startup speed should be left up to the installation, though.  The effect of the file size on startup speed is going to vary widely depending on whether the files are being read from SSD, spinning disk, slow network, etc.\r\n\r\nMaybe there should be an option to `configure` to not zip the boot files?  Or maybe if someone makes an installer then it should be an install-time option.  I'm working on a REPL, is there a way to \"enter\" a library and evaluate code in its environment? This would mean accessing non-exported bindings.\r\nThat would be very beneficial for developping on the REPL.\r\nA slightly related question, is there a way to force `import` to reload a library, after editing the source files? I get (incorrect) cyclic dependencies and other errors most of the time when trying to achieve this :-/\r\n  I discovered the support of r7rs **define-library** by chez, but I couldn't find the any code that **define** **define-library**. I think the reason is that the code is compiled into a boot file in a close-source way. \r\nI tried to find something by **git grep**, but found nothing. I haven't dissect boot file yet.  When will Chez Scheme support R7RS?  I've found `make-input/output-port`, and I've seen that it internally uses `#%$make-textual-input/output-port`, but I'd like to create a custom *binary* port. It seems that `#%$make-binary-input/output-port` is not exposed. Am I missing something? Would it be possible to expose this, as all the internal functionality seems to be there already?\r\nI could probably hack something together, if I could somehow access `make-port-handler` to create the relevant structure for `#%make-binary-input/output-port` directly :-/  ~~Unfortunately that is hard-coded to buffer 256 bytes (I think `max-put-copy` in `io-types.ss`), which is totally useless for my use case. From my (rather limited) understanding of `io.ss` there is no way to disable this buffering :-/~~ Ah, the above post is incorrect. The problem is that `get-bytevector-n` reads *exactly* *n* characters, not up to n, depending on how many are present... How would the custom port handler signal that there is no input right now, but there might be some later? If I return 0, that is #!eof :-/ Is there any way to return an *empty* bytevector / zero bytes read?\r\nFor example, this is useful for non-blocking network traffic.\r\n @akeep a problem with open-fd-input/output-port is that when closing, the system attempts to seek to the end of the input, which is ~undefined~ an error for everything that's not a normal file. Also, afaiu, things like OpenSSL don't provide an actual socket, but SSL_read/write and friends, so there's no way a file descriptor would work here.\r\nIs there any chance you might consider *changing* the convention to make -1 mean #!eof and 0 just mean \"return an empty bytevector\"? Or even just make -1 mean empty, that won't break existing code. @ecraven, are you implementing `select` or `epoll` or `kqueue` or Windows completion ports in order to get notified when I/O is ready/complete? If so, do you want the Chez Scheme binary port abstraction? Couldn't you implement an API for open, non-blocking read, non-blocking write, close, and select/epoll/kqueue? Then you won't run into the synchronous assumptions of the binary port abstraction.\r\n\r\nI took a different approach when implementing socket I/O in Chez Scheme: add a lightweight process abstraction a la Erlang (using one-shot continuations) and asynchronous I/O via libuv. It uses an event loop to run the callbacks and awaken the lightweight processes when data is available. This way, each lightweight process does synchronous I/O, which is much easier to deal with. See https://github.com/BECLS/swish for details. Another option is to use the threaded version of Chez Scheme and do synchronous socket I/O. It works well for a few sockets but doesn't scale as well as the asychronous approach when dealing with many connections. @burgerrg: I have not implemented those yet, as I wasn't sure how to usefully expose them for the binary port abstraction. For now, I'll go with what I have, thanks to your tips things are working ok for me. If needed, I'll go with multithreading at the moment.\r\n@akeep: Thanks for discussing it! \r\nI will close this issue, thanks to all participating for helping me understand this better ;) Looking up the web for asynchronous ports using chez scheme lead me here.\r\n\r\nSo, here is the result of my research. Based on [ecraven socket work](https://github.com/ecraven/chez-scheme-libraries/tree/master/socket) I created [a proof of concept that implements asynchronous ports](https://github.com/amirouche/xp-chez-scheme/commit/d13bc83020b292c3258cbd409411372a1339b590). Based on microbenchmarks, it's faster than the equivalent synchronous code. It rely on [epoll](http://man7.org/linux/man-pages/man7/epoll.7.html) (like [guile-fibers](https://github.com/wingo/fibers)) and `call/cc`. I annotated the commit from above. Right now, it only works non-secure socket. The code that opens the secure socket use an API an that doesn't expose the underlying file descriptor. Here is an example program in C that use epoll with openssl https://github.com/mdaxini/howto-openssl/blob/master/src/epoll_tls_client.c#L135  When wrapping things that write into buffers (like =recv= and =send=), it would be nice to have a way to say \"write into the bytevector at this index\". Is there any way to get the pointer that the =u8*= specification would pass to the function? Then I could just add the relevant offset to it myself. If you're using a foreign function, pass the bytevector as `u8*` and the index as `size_t` and do the pointer addition in the foreign code. See https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:s8 for details:\r\n\r\n> u8*: The argument must be a Scheme bytevector or #f. For #f, the null pointer (0) is passed to the foreign procedure. For a bytevector, a pointer to the first byte of the bytevector's data is passed. If the C routine to which the data is passed requires the input to be null-terminated, a null (0) byte must be included explicitly in the bytevector. The bytevector should not be retained in foreign variables or data structures, since the memory management system may relocate or discard them between foreign procedure calls, and use their storage for some other purpose. Ideally I'd like to not have to write C code (that would mean I cannot deploy the Scheme code without also having a C compiler). recv and send are standard C networking functions, I'd prefer not having to wrap them just for some pointer arithmetic.. is the problem that the bytevector might be moved around by the GC while I'm trying to calculate the correct addresses in Scheme code? Yes, you can get the address in Scheme, but you'll need to either lock the bytevector before getting its address or enter a critical section so that the garbage collector won't move the bytevector at the wrong time.\r\n\r\nIf you go with the C wrapper approach, you would compile the wrapper on your machine and distribute the shared library. The target machine won't need a C compiler. See https://github.com/becls/swish for an example of a wrapper and C code that locks scheme objects when it stores their addresses and unlocks them when it's finished. > Yes, you can get the address in Scheme, but you'll need to either lock\n> the bytevector before getting its address or enter a critical section\n> so that the garbage collector won't move the bytevector at the wrong\n> time. \n> If you go with the C wrapper approach, you would compile the wrapper\n> on your machine and distribute the shared library. The target machine\n> won't need a C compiler. See https://github.com/becls/swish for an\n> example of a wrapper and C code that locks scheme objects when it\n> stores their addresses and unlocks them when it's finished. \n\nCan all that be done from inside Scheme, without C? What functions am I\nlooking for to lock down objects and to get the bytevectors address?\n\nThanks for any help with this!\n `lock-object` and `unlock-object` are described [here](https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s30).\r\n\r\nTo get the address, you'll need an undocumented procedure, `$object-address`, and knowledge of how bytevectors are represented. The code below disables interrupts (and hence garbage collection), determines the address of bytevector `bv` at 0-based index `index` and passes it to `f`. It doesn't do type or bounds checking.\r\n\r\n`(with-interrupts-disabled (f (#%$object-address bv (+ (foreign-sizeof 'ptr) 1 index)))` The C wrapper option is supported without the use of undocumented system procedures and may not even need to lock the bytevector, so I recommend the C wrapper. @burgerrg: thank you, that looks exactly what I had in mind!\r\n@akeep: how would I use them to allocate a bytevector that C cod can write into? I can only use it to allocate an array, which I still have to convert to a Scheme object if I want to easily access it, right?   Thanks for clarifying this! @burgerrg I've used your suggestions, things seem to work fine so far ;) Thanks to both of you for helping me with this!  we start a project : A Package Manager for Chez Scheme, it can easily download, initial the Scheme library, and automatelly compile c library.\r\n\r\nGitHub: https://github.com/guenchi/Raven\r\nOfficiel Web Site: http://ravensc.com\r\n\r\nAnd there is the problem : \r\n\r\nif the current project depends lib A and lib B\r\nand lib A depends lib C 1.1.0, lib B depends lib C 2.1.0\r\nwe can't import two different version of one same library in a same project\r\n As was [posted](https://groups.google.com/forum/#!topic/chez-scheme/X6z1coCurj8) in the chez-scheme google group less than a week ago, this is expected behavior for an r6rs compliant scheme implementation.\r\n\r\n> Graham Watt | Dec 24\r\nYou cannot import two libraries with different versions into the same runtime. See this for info: http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-10.html#node_idx_268\r\n> \r\n> The relevant sentence is:\r\n>> To avoid problems such as incompatible types and replicated state, implementations should prohibit the two libraries whose library names consist of the same sequence of identifiers but whose versions do not match to co-exist in the same program.\r\n\r\nThat said, the r6rs spec says \"should\" not \"must\", so it may be possible to come up with some semantics that make sense and allow multiple versions of a library to coexist in one runtime.  Seems like a lot of opportunity for unexpected behavior, though.  Perhaps one of the maintainers will chime in.  Make `(even? +inf.0)`, etc., raise an exception. Now with more `who`.  Its terrific that Chez is now open source. I'm psyched to play with it.\r\n\r\nI wanted to get an idea of how fast Chez is, say compared to Go. I wrote up a little matrix multiplication study. The results are here,\r\nhttps://github.com/go-interpreter/chezgo#initial-simple-matrix-mulitply-benchmark\r\n\r\nwhere I see Chez running about 8x slower than Golang.\r\n\r\nI wonder if there is anything else I could do to speed up the Chez run?  I do want to try and compare the same style of matrix multiply, namely the vector of vectors implementation, but are there other flags that might be helpful to the Chez run time (or code changes that keep the same/similar data structure)?  Perhaps there's a way to only use floats and not get generic multiplication?\r\n\r\nSpecifics:\r\n\r\nGo code\r\nhttps://github.com/go-interpreter/chezgo/blob/master/cmd/matmul/matmul.go\r\n\r\nChez code:\r\nhttps://github.com/go-interpreter/chezgo/blob/master/matrix.ss \r\n  (based on https://www.scheme.com/tspl3/examples.html  )\r\n\r\nThank you.\r\n\r\nBest regards,\r\n\r\nJason\r\n\r\n What are you benchmarking?\n\nMultiplication of floating point matrix multiplication?\nOr should the elements of the matrix be generic?\n(I don't know Go - so I can't compare)\n\nIf so: Use the floating point operation fl* and friends\ninstead of the generic multiplication operator.\n\nThe vector of vector representation of matrices imply more\nallocations than a single vector would.\n\nBefore running the timings, force a garbage collection.\nThe program should not be punished for any garbage left\nover by, say, the compilation process.\n\nFinally you are using matrix-set! in mul,\n\n;;; matrix-set! changes the jth element of the ith row.\n(define matrix-set!\n  (lambda (m i j x)\n    (vector-set! (vector-ref m i) j x)))\n\nwhich means that (vector-ref m i) is called multiple times for each row.\nCall (vector-ref m i) once for each row in mul. -- Jens Axel S\u00f8gaard\n\n\n\n2017-12-25 11:14 GMT+01:00 Jason E. Aten, Ph.D. <notifications@github.com>:\n\n> I wanted to get an idea of how fast Chez is, say compared to Go. I wrote\n> up a little matrix multiplication study. The results are here,\n> https://github.com/go-interpreter/chezgo#initial-simple-matrix-mulitply-\n> benchmark\n>\n> where I see Chez running about 8x slower than Golang.\n>\n> I wonder if there is anything else I could do to speed up the Chez run? I\n> do want to try and compare the same style of matrix multiply, namely the\n> vector of vectors implementation, but are there other flags that might be\n> helpful to the Chez run time?\n>\n> Specifics:\n>\n> Go code\n> https://github.com/go-interpreter/chezgo/blob/master/cmd/matmul/matmul.go\n>\n> Chez code:\n> https://github.com/go-interpreter/chezgo/blob/master/matrix.ss\n> (based on https://www.scheme.com/tspl3/examples.html )\n>\n> Thank you.\n>\n> Best regards,\n>\n> Jason\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/248>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAcLxVIe-uAMG_XKThnXpLgaM2GpoM8Yks5tD3VwgaJpZM4RMO4h>\n> .\n>\n\n\n\n-- \n-- \nJens Axel S\u00f8gaard\n Apropos: Are there an equivalent to Racket floating point vectors\n(flvector) somewhere in Chez?\n\n/Jens Axel\n\n\n2017-12-25 13:19 GMT+01:00 Jens Axel S\u00f8gaard <jensaxel@soegaard.net>:\n\n> What are you benchmarking?\n>\n> Multiplication of floating point matrix multiplication?\n> Or should the elements of the matrix be generic?\n> (I don't know Go - so I can't compare)\n>\n> If so: Use the floating point operation fl* and friends\n> instead of the generic multiplication operator.\n>\n> The vector of vector representation of matrices imply more\n> allocations than a single vector would.\n>\n> Before running the timings, force a garbage collection.\n> The program should not be punished for any garbage left\n> over by, say, the compilation process.\n>\n> Finally you are using matrix-set! in mul,\n>\n> ;;; matrix-set! changes the jth element of the ith row.\n> (define matrix-set!\n>   (lambda (m i j x)\n>     (vector-set! (vector-ref m i) j x)))\n>\n> which means that (vector-ref m i) is called multiple times for each row.\n> Call (vector-ref m i) once for each row in mul. -- Jens Axel S\u00f8gaard\n>\n>\n>\n> 2017-12-25 11:14 GMT+01:00 Jason E. Aten, Ph.D. <notifications@github.com>\n> :\n>\n>> I wanted to get an idea of how fast Chez is, say compared to Go. I wrote\n>> up a little matrix multiplication study. The results are here,\n>> https://github.com/go-interpreter/chezgo#initial-simple-\n>> matrix-mulitply-benchmark\n>>\n>> where I see Chez running about 8x slower than Golang.\n>>\n>> I wonder if there is anything else I could do to speed up the Chez run? I\n>> do want to try and compare the same style of matrix multiply, namely the\n>> vector of vectors implementation, but are there other flags that might be\n>> helpful to the Chez run time?\n>>\n>> Specifics:\n>>\n>> Go code\n>> https://github.com/go-interpreter/chezgo/blob/master/cmd/matmul/matmul.go\n>>\n>> Chez code:\n>> https://github.com/go-interpreter/chezgo/blob/master/matrix.ss\n>> (based on https://www.scheme.com/tspl3/examples.html )\n>>\n>> Thank you.\n>>\n>> Best regards,\n>>\n>> Jason\n>>\n>> \u2014\n>> You are receiving this because you are subscribed to this thread.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/cisco/ChezScheme/issues/248>, or mute the thread\n>> <https://github.com/notifications/unsubscribe-auth/AAcLxVIe-uAMG_XKThnXpLgaM2GpoM8Yks5tD3VwgaJpZM4RMO4h>\n>> .\n>>\n>\n>\n>\n> --\n> --\n> Jens Axel S\u00f8gaard\n>\n>\n\n\n-- \n-- \nJens Axel S\u00f8gaard\n In order to give the Chez compiler opportunity to do some of the optimizations that it knows how to do, you can't just define functions at top-level, since this has to leave in indirections at the call sites just in case someone comes along and redefines some of them.  There are several ways to keep this from happening \u2013 the one with which I'm most familiar is to put everything inside a library, but I think putting everything inside a `(let () ...)` will do it.\r\n\r\nI want to say that not a lot of development effort has been spent on optimizing floating point math, but I could be making that up. Thanks guys!! \r\n\r\nJens: @soegaard \r\nThese are super helpful suggestions! Thank you.  By re-ordering the innermost two loops and shifting to vector-ref instead of matrix-ref, I shaved 30% of the time off.\r\n\r\nAnswering your question: I'm trying to see how fast Chez can do float64 (double) matrix multiplies, to get a general sense of system performance in the realm of data analysis/statistics.\r\n\r\nJamie: @jltaylor-us \r\nVery good to know, thank you!  Wrapping in a library seems to shave about 4% of the time off.\r\n\r\nSearching, I wasn't able to find a specialized (flvector) or specialized floating-point multiply. So if someone has specific pointers, I would be grateful.\r\n\r\n(Happy Holidays!) Ha!  I just realized that `(fl*)` is the name of the floating point multiply operation, heh. Thanks Jens.  That shaved another 17% off the chez benchmark time. You can probably shave a bit more off by making your loop variables use fixnum operators (i.e., `fx+`, `fx=`, etc), and also use `fl+` when you know you are adding floats. I don't have any tips specific to optimizing matrix multiplication, but you should look into some of chez's profiling tools. The most basic one is the `time` macro. It will display the cpu/real time spent on the given block as well as some memory and gc info.\r\nFor example, in `run-bench` I replaced\r\n```\r\n(let*\r\n        ((t0 (real-time))\r\n         (blah (mul a b))\r\n         (t1 (real-time)))\r\n      (format #t \"~s x ~s matrix multiply in Chez took ~s msec\" sz sz (- t1 t0))\r\n      (newline)\r\n```\r\nwith\r\n```\r\n(time (mul a b))\r\n```\r\nNow I see the following information:\r\n```\r\n(time (mul a ...))\r\n    474 collections\r\n    2.955903772s elapsed cpu time, including 0.053923729s collecting\r\n    2.955872295s elapsed real time, including 0.054470140s collecting\r\n    3998315392 bytes allocated, including 4011334032 bytes reclaimed\r\n```\r\n\r\nThere are more in depth profiling tools as well: http://cisco.github.io/ChezScheme/csug9.5/system.html#./system:h7\r\nUsing `profile-dump-html` I can see where code hotspots are. Check it out here: http://gmw.xen.prgmr.com/stuff/profile.html @gwatt Graham - Wow, nice! that html color profile is super slick. The inner loop of the matrix multiply is the expected hot spot, and that's what we're seeing. Which leads me to think that unboxing really should be avoided to get any further improvement.  So I looked harder for homogenous float64 vectors. \r\n\r\nhttps://srfi.schemers.org/srfi-4/srfi-4.html talks about `f64vector` specialized vector type, but I'm not sure if Chez has it.  https://github.com/arcfide/chez-srfi doesn't list it, and searching google and github don't turn up hits.\r\n\r\nChez and V8 (node.js v9.3.0) do the 500x500 multiply at about the same speed (average chez 2063-2500 msec, depending on how much optimization applied, vs. average node.js 2174 msec). Since both are scheme underneath, that kind of seems reasonable. Moreover Chez at full optimization is beating V8 by 5%. V8 has probably had much more money spent on it by Google, so Chez's performance is actually kind of impressive there.\r\n\r\n Nice, Andy.  I consider myself schooled in the wayward use of `set!`.  That was just my hack, and obviously a poor one.  I should learn idiomatic scheme.\r\n\r\n>  it would be interesting to see how much further we could push this with some additional compiler support.\r\n\r\nWere you thinking of a single-type vector e.g. a f64vector type, or something to avoid all the boxing/unboxing?\r\n\r\nIt's nice to see that Chez can be within 2x of Go.  And it is very responsive at the REPL.\r\n\r\nOf course, Go is not really state of the art for this kind of thing either, OpenBLAS and others yield such multiplications in 2-7 msec. But that's binding to heavily optimized Fortran, and not really in line with the aim of my experiment.  \r\n\r\nMy aim wasn't so much to do numerical linear algebra in Chez, but just to get general sense of how fast the system can be, as I was thinking that Chez's incremental native code compilation might make a nice backend for a Go interpreter. > I suspect part of the problem with the byte vector version of the code is that it is immediately boxing the extracted value, and an f64vector would effectively need to do the same\r\n\r\nAh, I don't quite follow why re-boxing happens, but it even so it seems like converting a byte vector into an unboxed vector of float or an unboxed vector of larger structures will require some kind of unsafe cast. Is there such a cast available? Hi Jason,\n\nI can see that your intent was to compare the vector-of-vectors, but it\nwould\nbe interesting to compare the vector-of-vectors implementation with an\nimplemenation\nusing a single single vector to represent the matrix.\n\n\n/Jens Axel\n\n\n2017-12-25 22:01 GMT+01:00 Jason E. Aten, Ph.D. <notifications@github.com>:\n\n> Ha! I just realized that (fl*) is the name of the floating point multiply\n> operation, heh. Thanks Jens. That shaved another 17% off the chez benchmark\n> time.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/248#issuecomment-353890629>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAcLxdCL9DvMtvcpQTybJoekBy0jrpbbks5tEA0zgaJpZM4RMO4h>\n> .\n>\n\n\n\n-- \n-- \nJens Axel S\u00f8gaard\n > However, the garbage collector (which is a copying collector) would need\nto be in on the game, because we would have pointers pointing into the\nmiddle of objects. These pointers would need to be updated when the main\nobject moved, and it would also need to prevent the original object from\nbeing collected if there is no longer a live reference to that object. We\ndon't currently have support for something like this in the collector.\n\nVery interesting. I thought about this some. I wonder if it would make\nsense to allocate big matrices in a separate region of memory, away from\nthe usual heap.  Then the collector issues and boxing/reboxing would\ndisappear.  Go does something like this. Back before the 10 microsecond\npause collector got implemented in Go, I used to use offheap hashtables to\navoid long pauses.\n\nOn Thu, Dec 28, 2017 at 1:03 PM, Andy Keep <notifications@github.com> wrote:\n\n> Internally, Chez Scheme represents everything as a tagged pointer. There\n> are a few categories of things (fixnums, characters, constants like null,\n> #t, and #f) that do not require heap allocation, because the tag\n> indicates that the value is stored within the tagged pointer.\n>\n> For everything else, heap allocation is required. A byte vector, of\n> course, allows you to store raw data, but once you extract that data into a\n> scheme tagged pointer, you need to allocate space on the heap for it. The\n> value you get back from the reference is a tagged pointer whose tag\n> indicates it is a floating point number. By itself, an f64vector type would\n> have the same problem, namely, we'd need to allocate space for that value\n> to live as its own value.\n>\n> You might wonder why you cannot just have the tagged pointer point to\n> where the value already exists in memory, since in both cases we know the\n> value is already in the form we need it in. However, the garbage collector\n> (which is a copying collector) would need to be in on the game, because we\n> would have pointers pointing into the middle of objects. These pointers\n> would need to be updated when the main object moved, and it would also need\n> to prevent the original object from being collected if there is no longer a\n> live reference to that object. We don't currently have support for\n> something like this in the collector.\n>\n> Additionally, in the case of both a byte vector and the f64vector, both of\n> which would need to be mutable for your purposes, we'd need to make it\n> clear that the variable being held onto could potentially change value\n> through another instruction setting the location.\n>\n> In general, Chez Scheme's operators operate on the tagged pointer\n> representation and are expected to return tagged pointer representations,\n> with a handful of exceptions. The ftype system which is a syntactic layer\n> to make interacting with structured foreign data easier, internally\n> maintains a raw pointer type for computing memory offsets and the like, and\n> it is possible we could do something similar for floating point values.\n>\n> Another concern with raw values floating around is how they impact the\n> garbage collector. We currently maintain a live-pointer mask for each frame\n> on the stack which forms the root set for the collector. In general the\n> live pointer mask indicates what must be maintained across non-tail calls,\n> and any element on the frame not covered by the mask could be replaced with\n> random garbage without causing problems. We would need to subtly change the\n> meaning of the live pointer mask, since we would potentially have valid raw\n> data stored where the live pointer mask indicates they are not live\n> pointers (and we wouldn't want them to marked as live pointers, since the\n> raw data might be interpreted incorrectly by the garbage collector).\n>\n> In addition, I would like to be able to take advantage of the floating\n> point registers that exist on most modern processors to allow us to keep\n> floating point values in registers for longer stretches when there are\n> going to be multiple floating point operations in sequence on them, rather\n> than reading them from memory, doing the operation, then writing them back\n> to memory only to read them again at the start of the next operation. This\n> might not make a big impact for your particular use case, but I do think\n> the \"kernel\" of your matrix multiple would have better code generated there\n> if we could get something like this implemented.\n>\n> If you are interested in seeing what Chez Scheme does now, you can see the\n> assembly code generated by setting the $assembly-output parameter to #t\n> or a textual output port. (#t indicates it should be output to standard\n> out). You'll need to use the #% prefix to use this, as it is a \"hidden\"\n> primitive in Chez Scheme:\n>\n> > (#%$assembly-output)       ;=> #f\n> > (#%$assembly-output #t)\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/248#issuecomment-354338790>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAbLP6DJ-esJMw_cmvCNzU4TdxNK59yGks5tE-X4gaJpZM4RMO4h>\n> .\n>\n Thanks for the sage wisdom.  In the test in WIndows, I get this error in [date.ms#L624-L627](https://github.com/cisco/ChezScheme/blob/master/mats/date.ms#L624-L627)\r\n\r\n    (let ([t (current-time)])\r\n      (time=?\r\n        (date->time-utc (time-utc->date t -14400))\r\n        (date->time-utc (time-utc->date t 0))))\r\n\r\nThe error in the summary is something like\r\n\r\n    -------- o=0 --------\r\n    > date.mo:Bug in mat conversions/sleep clause 7 at line 624, char 3 of date.ms\r\n\r\nFor reference, when I run this variation manually I get this results:\r\n\r\n    (let ([t (current-time)])\r\n      (list\r\n        (date->time-utc (time-utc->date t -14400))\r\n        (date->time-utc (time-utc->date t))))\r\n    ;==> (#<time-utc 0.897842400> #<time-utc 1513881033.897842400>)\r\n In cygwin I get\r\n\r\n    $ echo $TZ\r\n    America/Buenos_Aires\r\n\r\nand using `unset TZ` doesn't fix the problem.\r\n\r\nIn cmd.exe I don't have anything similar to a `TZ` variable, but my timezone is set to \"(UTC-03:00) Ciudad de Buenos Aires\".\r\n\r\nI get similar results `(#<time-utc 0...> #<time-utc 151...>)` running scheme in cmd.exe and in cygwin (with and without TZ)  The first commit adds a checks that first argument of `map` is a procedure in cp02 expansion to raise the same error that the non expanded version\r\n\r\nThis fix an error in the tests in Windows of the mat \"4.ms\", [line 1082-1083](https://github.com/cisco/ChezScheme/blob/master/mats/4.ms#L1082-L1083) and [line 1713-L1714](https://github.com/cisco/ChezScheme/blob/master/mats/4.ms#L1713-L1714)\r\n\r\n    (error? ; nonprocedure\r\n      (map 3 '(a b c)))\r\n    ;[...]\r\n    (error?\r\n      (for-each 3 '(a b c)))\r\n\r\nThe summary is something like\r\n\r\n    -------- o=0 cp0=t --------\r\n    [...]\r\n    270c273\r\n    < 4.mo:Expected error in mat map: \"map: 3 is not a procedure\".\r\n    ---\r\n    > 4.mo:Expected error in mat map: \"attempt to apply non-procedure 3\".\r\n    340c343\r\n    < 4.mo:Expected error in mat for-each: \"for-each: 3 is not a procedure\".\r\n    ---\r\n    > 4.mo:Expected error in mat for-each: \"attempt to apply non-procedure 3\".\r\n\r\nI really don't understand why the test in Linux don't detect this. (Reading some error messages, I guess that it's a difference between scheme.boot and petite.boot, but I'm not sure if this even make sense. I'm very confused.)\r\n\r\n----\r\n\r\nThe second commit is a small improvement. It avoids building the result list in a map that is called for effect. There's a better reason to include the procedure check at optimize level 2, which is that `(#2%map e ---)` should raise an exception if x is not a procedure even when the code containing the call is run at optimize-level 3.  So this seems like a good change to me.  Cosmetically, I'd prefer the then and else parts of the inserted if expression be indented under the test, and the second and third make-seq arguments be indented two spaces rather than under the first argument.  I'm guessing the patch files need to be rebuilt to reflect the change in error messages.  I'll let Andy do a detailed check of the changes if he wants and leave it to him to pull. I fixed the indentation. I can rebase them if necessary.\r\n\r\nBut I don't understand your comment. Is it posible to expand `(#2%map p list ...)` with the current version and then run the expanded version in a way that it doesn't raise an error if `p` is not a procedure?\r\n\r\nOn the other hand, `(#2%map 3 '())` is still reduced to `'()` without any error. I didn't fix it. Is this an error? The documentation is not 100% clear. This is caused by a special case that is checkd before calling `inline-lists`.\r\n OK, I see the problem. Should I change anything?\r\n\r\nI'm still worried about `(map 7 '())`. In my current version with cptypes https://github.com/cisco/ChezScheme/pull/192 the expansion can produce an error, for example in\r\n\r\n    (define (f p b)\r\n     (unbox b)\r\n     (map p (if (box? b) '() '(1 2 3)))\r\n     (list p (procedure? p)))\r\n    (f 7 (box 0)) ;==> (7 #t)\r\n\r\n(The example is strange to make sure that the reductions of cp0 and cptypes are applied in the right order to get the error.)\r\n\r\nOne solution is to fix the expansion of `map` in cp0 and other solution is to change the signature of `map`. (And other similar functions.)\r\n  https://github.com/cisco/ChezScheme/blob/3f65788b5422693f3648a9e2fe575f464eb31ccd/c/main.c#L336\r\n  In the case of `unget-{u8/char}`, the value can be an also an `eof`, so I have to change the type to `ptr`.\r\n\r\nAlso, it is strange that:\r\n\r\n    vector-fill! -> (vector)\r\n    bytevector-fill! -> (void)\r\n    string-fill! -> (void)\r\n    fxvector-fill -> (void)\r\n    substring-fill! -> (string)\r\n I changed the mat of `substring-fill!`, because it used that the return value is the string.\r\n\r\nI removed the changes of the signatures of `vector-fill!` and `substring-fill!`, but I added a change to the signature of `fxvector-fill!` (that I mysteriously missed).\r\n While I was writing the fix, I was also thinking that `char+eof` may be a good idea. (I'm not sure about the name.) . It's similar to `maybe-char`.  Procedure source locations are useful for error backtraces at a much lower cost (while losing some precision) compared to keeping full inspector information.\r\n\r\nThis patch adds `generate-procedure-source-information`, which defaults to #f and only applies when `generate-inspector-information` is #f. If `generate-procedure-source-information` is #t, then a source location is preserved with a code object even when  `generate-inspector-information` is #f. Rebased.\r\n\r\nFor now, Racket-on-Chez's default compilation mode still uses `(generate-inspector-information #f)` and `(generate-procedure-source-information #t)`, and that combination has worked as intended \u2014 preserving the same kind of debugging information as traditional Racket with the same minimal cost.  This is a fix of the `bytevector-[u/s]16-native-set!` signature, and also `bytevector-sint-set!`.\r\n\r\nThe signature of `bytevector-[u/s]32-native-set!` is correct, so it's not necessary to fix it.\r\n    I made of socket fork thread recv and send data, But i found that it may block in recv or send.Here is my code.\r\n\r\n```` \r\n(import (net socket-ffi)\r\n\t(cffi cffi) )\r\n\r\n(define socket-fd 0)\r\n(define n 0)\r\n(define buff (cffi-alloc 4096))\r\n\r\n(cffi-log #t)\r\n\r\n(set! socket-fd (socket AF_INET SOCK_STREAM 0))\r\n(display  (format \"socket-fd=~a\\n\" socket-fd))\r\n\r\n(define server-addr (make-sockaddr-in AF_INET INADDR_ANY 8000))\r\n\r\n(define bind-ret (bind socket-fd  server-addr 16))\r\n(display  (format \"bind-ret=~a\\n\" bind-ret))\r\n\r\n(define listen-ret (listen socket-fd 10))\r\n\r\n(display  (format \"listen-ret=~a\\n\" listen-ret))\r\n\r\n(define (make-thread fd)\r\n  (fork-thread\r\n   (lambda () \r\n     (let loop2 ((buf (cffi-alloc 4096)))\r\n       (printf \"recv ret=~a\\n\" (recv fd buf 1024 0))\r\n       (printf \"send ret=~a\\n\" (send fd \"test\u4f60\u597d\\n\" 6 0))\r\n       ;;(printf \"get ~a ~a\\n\" fd (cffi-string buf))\r\n       ;;(sleep (make-time 'time-duration 100 0))\r\n      (loop2 buf))\r\n     )))\r\n\r\n(let loop ()\r\n  (printf \"loop-thread ~a \\n\"  (get-thread-id))\r\n  (let ((connect-fd (accept socket-fd 0 0)))\r\n    (display (format \"accept connect-fd=~a\\n\" connect-fd))    \r\n    (make-thread connect-fd)\r\n    (printf \"fork-thread end\\n\")\r\n    )\r\n  (loop))\r\n\r\n(close connect-fd)\r\n(close socket-fd) It has two socket connects.I just write a server with c.It dosen't block.I think the fork-thread may block in  recv or send function with mutithread.\r\nHere is the code:\r\n\r\n```` #include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#include<errno.h>\r\n#include<sys/types.h>\r\n#include<sys/socket.h>\r\n#include<netinet/in.h>\r\n#include <pthread.h>\r\n\r\n#define MAXLINE 4096\r\n\r\npthread_t main_tid;  \r\n\r\nvoid print_ids(const char *str)  \r\n{  \r\n    pid_t pid;\r\n    pthread_t tid;  \r\n    pid = getpid();  \r\n    tid = pthread_self();  \r\n    printf(\"%s pid: %u tid: %u (0x%x)/n\",  \r\n                str,  \r\n                (unsigned int)pid,  \r\n                (unsigned int)tid,  \r\n                (unsigned int)tid);  \r\n}  \r\n\r\nvoid *func(void *arg)  \r\n{\r\n\tchar buff[4096];\r\n\tint n;\t \r\n\tint connfd=(int)arg; \r\n\tprint_ids(\"new  thread:\");  \r\n\tfor(;;){\r\n\t\tn = recv(connfd, buff, MAXLINE, 0);\r\n\t\tbuff[n] = '\\0';\r\n\t\tprintf(\"recv msg from client: %s\\n\", buff);\r\n\t\tsend(connfd,buff,6,0);\r\n\t}\r\n    return ((void *)0);  \r\n} \r\n\r\nint \r\nmain(int argc, char **argv)\r\n{\r\n\tint\t\tlistenfd  , connfd;\r\n\tstruct sockaddr_in servaddr;\r\n\tchar\t\tbuff      [4096];\r\n\tint\t\tn;\r\n\r\n\tif ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\r\n\t\tprintf(\"create socket error: %s(errno: %d)\\n\", strerror(errno), errno);\r\n\t\texit(0);\r\n\t}\r\n\tmemset(&servaddr, 0, sizeof(servaddr));\r\n\tservaddr.sin_family = AF_INET;\r\n\tservaddr.sin_addr.s_addr = htonl(INADDR_ANY);\r\n\tservaddr.sin_port = htons(8000);\r\n\r\n\tif (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1) {\r\n\t\tprintf(\"bind socket error: %s(errno: %d)\\n\", strerror(errno), errno);\r\n\t\texit(0);\r\n\t}\r\n\tif (listen(listenfd, 10) == -1) {\r\n\t\tprintf(\"listen socket error: %s(errno: %d)\\n\", strerror(errno), errno);\r\n\t\texit(0);\r\n\t}\r\n\tprintf(\"======waiting for client's request======\\n\");\r\n\twhile (1) {\r\n\t\tif ((connfd = accept(listenfd, (struct sockaddr *)NULL, NULL)) == -1) {\r\n\t\t\tprintf(\"accept socket error: %s(errno: %d)\", strerror(errno), errno);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tint err;  \r\n    \terr = pthread_create(&main_tid, NULL, func, connfd);\r\n    \tif(err != 0){  \r\n        \tprintf(\"create thread error: %s/n\",strerror(err));  \r\n        \treturn 1;  \r\n    \t}  \r\n\t\t//close(connfd);\r\n\t}\r\n\r\n\tclose(listenfd);\r\n\r\n\treturn EXIT_SUCCESS;\r\n}\t\t      \r\n I finally found that Sactivate_thread  and   Sdeactivate_thread should be enclosed ffi function when call. @akeep hmm.\r\n\r\n @evilbinary Hi, how did you fix your scheme code, can you show it? @Saigut  \u662f\u8fd9\u6837\u7684\uff0c\u4f60\u628affi\u7684c\u51fd\u6570\u5305\u56f4\u4e00\u4e0b\uff0c\u6bd4\u5982\r\n\r\nvoid test_read(){\r\nSdeactivate_thread();\r\nread\u51fd\u6570\u6b63\u5e38\u903b\u8f91;\r\nSactivate_thread();\r\n}\r\n\u7136\u540e\u53ef\u4ee5\u5728fork-thread\u91cc\u9762\u7528\u4e86\u3002\u53ef\u4ee5\u52a0\u6211\u7fa4\u8ba8\u8bba\uff0cLisp\u5174\u8da3\u5c0f\u7ec4 239401374 \u8c22\u8c22\uff01 @Saigut  you solved you problem right? Solved #127 This issue ref #267 #213 #64 #58   I think this change is mostly straightforward, but is `(set! ,(make-live-info) ,%rax (asm ,info ,asm-locked-cmpxchg ...))` on line 934 of \"x86_64.ss\" (and similar for \"x86.ss\") the best way to reflect that CMPXCHG may modify the RAX register? I don't think it's necessary since the preceding instruction kills `%rax` via `urax`, so I would remove the assignment and leave the RHS.\r\n\r\nIf it were necessary, I think you'd want it to set `urax` instead of `%rax`, since all assignments other than unspillable assignments need to be visible prior to live analysis.\r\n Updated. Rebased. @burgerrg I use the usual(?) cross-compile steps:\r\n```\r\nset M=<platform>\r\nexport M\r\nset ORIG=<current-version-build-dir>\r\nexport ORIG\r\n(cd $M/s && make -f Mf-cross m=$M xm=$M base=$ORIG/$M)\r\nmake\r\n```\r\nBut I always feel like I must be missing some better and simpler way.  I'd like to roll my own release tarballs that only support the platforms I'm interested for size reasons (currently, only x86-64).  Can anyone fill me in on how to do this?  Also, I'm curious if there'd be interest in just using a regular configure/make/make install flow with normal automake/autoconf tools, rather than the homemade scripts currently in use?  IMHO \"make dist\" would be a nice way to do things...\r\n Awesome, thank you for the help!  Looking to make Chez the basis for a new plotter I'm working on, very excited about the possibility.  On my `x86_64-slackware-linux-gnu` running a build from commit `1558dca8c23284d5718715ff0b1950204794f086`, I see the following boot files installed:\r\n\r\n```\r\nls -l /opt/chez-scheme/9.5.1/lib64/csv9.5.1/a6le/\r\ntotal 4.3M\r\n-r--r--r-- 2 root root 823K Oct 14 20:33 chez.boot\r\n-r--r--r-- 2 root root 1.4M Oct 14 20:33 petite.boot\r\n-r--r--r-- 2 root root 1.4M Oct 14 20:33 petite-chez.boot\r\n-r--r--r-- 2 root root 823K Oct 14 20:33 scheme.boot\r\n-r--r--r-- 1 root root 9.1K Oct 12 06:16 scheme.h\r\nlrwxrwxrwx 1 root root   54 Oct 14 20:37 scheme-script.boot -> /opt/chez-scheme/9.5.1/lib64/csv9.5.1/a6le/scheme.boot\r\n```\r\n\r\nwhen using this build script:\r\n\r\n```\r\nexport CHEZSCHEMELIBEXTS=.chezscheme.sls:.chezscheme.ss:.sls:.ss\r\n#export CHEZSCHEMELIBDIRS=:\r\nunset CHEZSCHEMELIBDIRS\r\nunset SCHEMEHEAPDIRS\r\n\r\nVERSION=${VERSION:=9.5.1}\r\nprefix=/opt/chez-scheme/${VERSION}${CHEZ_INSTALL_SUFFIX}\r\nif test -d /lib64\r\nthen libdir=${prefix}/lib64\r\nelse libdir=${prefix}/lib\r\nfi\r\n\r\nmake clean\r\nmake distclean\r\ngit clean -xfd\r\n./configure \\\r\n    --installprefix=\"$prefix\"\t\t\t\\\r\n    --installlib=\"$libdir\"\t\t\t\\\r\n    --installowner=root\t\t\t\t\\\r\n    --installgroup=root\t\t\t\t\\\r\n    --installschemename=chez\t\t\t\\\r\n    --installpetitename=petite-chez\t\t\\\r\n    CFLAGS='-O3 -Wno-maybe-uninitialized'\t\\\r\n    CPPFLAGS='-I/usr/local/include'\t\t\\\r\n    LDFLAGS='-L/usr/local/lib64 -liconv'\r\nmake\r\nmake docs\r\n\r\n(umask 0 ; sudo install -m 0755 -d \"${prefix}/bin\")\r\n(umask 0 ; sudo install -m 0755 -d \"${prefix}/share\")\r\n(umask 0 ; sudo install -m 0755 -d \"${libdir}\")\r\n(umask 0 ; sudo make install)\r\n``` >  you are seeing hard links which reflect the names you chose to call your Chez Scheme executables\r\n\r\nI see now.\r\n\r\n>  Internally though, `chez.boot` will still be looking for a file called `petite.boot`, so these are simply hard linked to avoid changing the underlying generation of the boot files.\r\n\r\nThat is confusing from the package maintainer point of view.  An executable `ciao-chez` will look for a boot file `ciao-chez.boot`:  I understand this and I agree with this choice.  But why are the original file pathnames still needed?  The pathname is just a Chez Scheme's compile-time string.\r\n\r\n  As far as I can tell there is no way to disable installation of Petite Chez and `scheme-script`.  I would appreciate it through a `configure` option.\r\n\r\n(By the way: does it still make sense to build and install Petite Chez?)\r\n > and can be used a smaller run time for a precompiled scheme program.\r\n\r\nI was not aware of this.  I will have to meditate more on this.\r\n\r\n  The documentation currently shows\r\n\r\n    (format \"~@:(~a~)\" \"Ouch!\")  =>  \"ouch!\"\r\n\r\nChez 9.4.1 instead outputs \"OUCH!\"\r\n\r\n    Chez Scheme Version 9.4.1\r\n    Copyright 1984-2017 Cisco Systems, Inc.\r\n    \r\n    > (format \"~@:(~a~)\" \"Ouch!\")\r\n    \"OUCH!\"\r\n\r\nChez 8.4 also yields this same behavior.  The Common Lisp HyperSpec http://www.lispworks.com/documentation/HyperSpec/Body/22_cha.htm indicates that `~@:(` is bogus. Shouldn't the example be `(format \"~@(~a~)\" \"ouch!\") => \"Ouch!\"` @burgerrg , are you suggesting adjusting the example in the docs, rather than the output?  Yes, I think the example should be updated to be in sync with the format specification. Either use `~:@(` or the example I gave. Updated to @burgerrg 's suggested example.  As @akeep said, colon and at-sign can come in either order, so `~:@(---)` and `~@:(---)` are equivalent.  I believe this is true generally for Common Lisp format.  If so I assume the referenced document just doesn't bother showing both orders and the original fix should be okay.  For example, \r\n\r\n    `(fx+/carry (quote 1) (quote 1) (quote 1))\r\n\r\nwas reduced to\r\n\r\n    `(values 3 0)\r\n\r\nbut to use the nanopass language correctly it should be reduced to\r\n\r\n    `(values (quote 3) (quote 0))\r\n  Hello.  I pulled an update today.  The build failed to make.  The error messages are at the end of the output.\r\n\r\nThank you for your time.\r\n\r\n$ make\r\n(cd a6le && make build)\r\n(cd c ; make)\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib statics.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib segment.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib alloc.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib symbol.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib intern.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib gcwrapper.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib gc-ocd.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib gc-oce.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib number.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib schsig.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib io.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib new-io.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib print.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib fasl.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib stats.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib foreign.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib prim.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib prim5.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib flushcache.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib schlib.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib thread.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib expeditor.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib scheme.c\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib i3le.c\r\nld -melf_x86_64 -r -X -o ../boot/a6le/kernel.o statics.o segment.o alloc.o symbol.o intern.o gcwrapper.o gc-ocd.o gc-oce.o number.o schsig.o io.o new-io.o print.o fasl.o stats.o foreign.o prim.o prim5.o flushcache.o schlib.o thread.o expeditor.o scheme.o i3le.o ../zlib/libz.a\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -c -DX86_64 -I../boot/a6le -I../zlib main.c\r\ncp -p main.o ../boot/a6le/main.o\r\ncc  -m64 -msse2 -Wpointer-arith -Wall -Wextra -Werror -Wno-implicit-fallthrough -O2  -rdynamic -o ../bin/a6le/scheme ../boot/a6le/kernel.o ../boot/a6le/main.o -lm -ldl -lncurses -lrt \r\n(cd s ; make bootstrap)\r\nmake allx\r\nrm -f *.a6le xpatch patch *.patch *.so *.asm script.all header.tmp *.html\r\nrm -rf nanopass\r\ncp -p -f ../boot/a6le/petite.boot ../boot/a6le/sbb\r\ncp -p -f ../boot/a6le/scheme.boot ../boot/a6le/scb\r\nmake all\r\necho '(reset-handler abort)'\\\r\n             '(base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))'\\\r\n             '(keyboard-interrupt-handler (lambda () (display \"interrupted---aborting\\n\") (reset)))'\\\r\n             '(optimize-level 3)'\\\r\n             '(debug-level 0)'\\\r\n             '(generate-inspector-information #f)'\\\r\n             '(subset-mode (quote system))'\\\r\n             '(compile-file \"cmacros.ss\" \"cmacros.so\")'\\\r\n             | ../bin/a6le/scheme -q\r\ncompiling cmacros.ss with output to cmacros.so\r\nException: invalid memory reference.  Some debugging context lost\r\nmake[4]: *** [cmacros.so] Error 255\r\nmake[3]: *** [allx] Error 2\r\nmake[2]: *** [bootstrap] Error 2\r\nmake[1]: *** [build] Error 2\r\nmake: *** [build] Error 2 Mm Thank you Andy!  Your suggestion works!  when input a wrong parameter \"a\" to x of function f, the x can't be inspected in debugger (r x).\r\nand in nested function call, we also can't inspect function parameter in debugger.\r\nhow to deal with it?\r\n`\r\n> (define f (lambda (x) (+ 1 x)))\r\n> (f \"a\")\r\nException in +: \"a\" is not a number\r\nType (debug) to enter the debugger.\r\n> (debug)\r\ndebug> i \r\nsystem continuation in new-cafe                              : sf\r\n  0: system continuation in new-cafe\r\nsystem continuation in new-cafe                              : s\r\n  continuation:          null continuation\r\n  frame and free variables:\r\n  0: system continuation in dynamic-wind\r\n\r\n`\r\n @akeep how to construct a helper function (g x) which non-tail call (f x) for debugging purpose?  This patch is a first cut at adding support struct arguments and results when calling foreign procedure or generating a foreign-callable wrapper for a Scheme procedure (as in #137). The initial implementation is only for x86 and x86_64 on Mac OS, but if the approach makes sense, then I can fill in more.\r\n\r\nSyntactically, the patch adds support for `(& ftype)` as a foreign-procedure argument or result. On the Scheme side, the representation for `(& ftype)` is the same as for `(* ftype)`. On the foreign side, the content of a pointer for `(& ftype)` is passed as a value or received as a result, instead of passing or receiving the pointer.\r\n\r\nFor example,\r\n\r\n```\r\ntypedef struct {\r\n  int x, y;\r\n} pt;\r\n\r\npt get_pt() {\r\n  pt p = { 10, 20 };\r\n  return p;\r\n}\r\n```\r\n\r\ncan be called with\r\n\r\n```\r\n(define-ftype pt\r\n  (struct\r\n    [x int]\r\n    [y int]))\r\n\r\n(define get_pt\r\n  (foreign-procedure (foreign-entry \"get_pt\")\r\n                     () (& pt)))\r\n\r\n```\r\n\r\nThe `ftype` in `(& ftype)` doesn't have to be a struct type. For example, `(& int)` could be used in place of an `int` argument or result, in which case the Scheme side must supply or receive an fpointer to an integer. Unions, packed structs, etc., are all meant to work.\r\n\r\nOn the Scheme side, a result received as `(& ftype)` or a callable's `(& ftype)` argument is allocated with `foreign-alloc` and must be explicitly freed. Similarly, a callable must return a `(& ftype)` result that is allocated, and it will be freed on the foreign side after the value is copied out. An argument `(& ftype)` is not freed by the call, currently. I would be happier with a way to allocate memory as GCable and avoid the explicit frees, but I don't think an fpointer can wrap GC-allocated bytes.\r\n\r\nSome details:\r\n\r\n* I'm unsure about the way that `Scopy-argument` is called to copy the content of a `(& ftype)` callable argument. Is it ok to pass an argument via `%ts`? Is the saved-argument list correct?\r\n\r\n* For callables that return `(& ftype)`, the way that tail-calling a `S_call_...` variant achieves the right result often involves some trickery \u2013 The `S_call_indirect_copy_three_chars` variant is the biggest hack \u2013 and I'm not sure it's better than implementing the ABI directly in each backend. But continuing with the `S_call_...` approach was the path of least resistance. @mflatt You could put in a ftype&-guardian in the collector. It already closes forgotten ports using a guardian: https://github.com/cisco/ChezScheme/blob/master/s/7.ss#L675 @gwatt Thanks for the suggestion! If I understand, you mean registering the fptr that was created to wrap the address to free the `malloc`ed address. I worry about that indirection, since the same address might be wrapped by a different fptr to cast it, and then a programmer would have to take special care to keep the original fptr live as long as the new fptr is used. Also, finalization doesn't currently compose well (when a finalization action for some other object needs to use a finalized fptr), although #190 is an effort to address that kind of problem. The latest patch includes tests and doc updates. It supports x86 and x86_64 on Linux, Windows, Mac OS, and probably other Unix variants. The latest version is a good candidate for merging.\r\n\r\nBased on a suggestion from Kent, the latest implementation treats a `(& ftype)` result as an extra `(* ftype)` initial argument, which eliminates the implicit calls to `malloc` and `free`.\r\n\r\n * When a program invokes a foreign procedure with a `(& ftype)` the program allocates and provides a `(* ftype)` argument before the normal arguments, and the result of the foreign procedure is unspecified.\r\n\r\n * A callable with a `(& ftype)` result should accept an extra `(* ftype)` first argument to receive the result, and the callable's direct result is ignored. A callable's `(& ftype)` arguments correspond to `(* ftype)` arguments that are valid only during the dynamic extent of the callable invocation (because the associated address is on the stack or provided by the C caller).\r\n\r\nThe key to avoiding implicit `malloc` and `free` with the new protocol was to get rid of the tail-called `S_call_...` zoo, replacing it with a non-tail call to `S_call_one_value` or `S_call_any_values` plus a direct implementation of return values in each backend.\r\n\r\nAll backends are implemented: x86, x86_64, ppc32, and arm32.\r\n Two bugs:\r\n\r\n * On i3nt, I must have overlooked `__stdcall` test failures. There's a `20` on line 2710 of \"x86.ss\" that should be `init-stack-offset`.\r\n\r\n * On ppc32le, the pointer to fill for a `(& ....)` result is stashed too deeply on the stack. The `frame-size` on lines 2392, 2416, and 2439 should be the original `frame-size` from line 2383 instead of the shadowing binding on line 2385.\r\n\r\nThese bugs are fixed in #267. I could move the repairs to here, but it may make more sense to just consider the patches together.\r\n If I understand what you mean: I think it would work to treat an ftype name for a struct or union differently from other ftype names. I don't think it would work to treat every ftype name as implicitly using the current `&`. For example, if I define `(define-ftype NSUInteger unsigned-long)` then when specifying `NSUInteger` as a function argument type, I would want to pass a number to the foreign procedure, not a pointer to memory containing an integer. I see no problem with `NSUInteger` or base types if only struct/union ftype names are treated as implying a `&`.\r\n\r\nRacket's FFI does treat a struct/union argument/result type as implicitly having `&`, but it also manages storage differently for `&` results or callable arguments. Racket's FFI allocates GC-managed memory for those structs/unions, so a function type that returns a struct/union still corresponds to a function that returns one (allocated) result. I've implemented Racket's FFI on top of Chez Scheme's FFI using bytevectors, but it requires copying (and, at least for now, object locking and some worse trickery).\r\n\r\nWith the memory-management strategy in this patch, `&` seems more uniform and a better signal to readers in a foreign-procedure specification. For example, the `&` in `(foreign-procedure \"reel_one_in\" () (& fish_t))` helps highlight that the resulting function takes one argument and returns no results. In contrast, `(foreign-procedure \"reel_one_in\" () fish_t)` looks like a function that takes zero arguments and returns one result \u2014 but that wouldn't be true if `fish_t` is defined as a struct or union type that implies `&`.\r\n\r\nEither way works for me, but unless there's a better overall design point, I recommend keeping the explicit `&` as a reminder of memory-management obligations. This would be very helpful for me, is there any way in which I can help with the work to get this into mainline chez? I just cloned `mflatt/fp-struct` and ran `./configure && make`, it stopped with the following error:\r\n````\r\n...\r\n(if `cmp -s ../boot/a6le/equates.h ../boot/a6le/equates.h.bak`;\\\r\n          then mv -f ../boot/a6le/equates.h.bak ../boot/a6le/equates.h;\\\r\n          else rm -f ../boot/a6le/equates.h.bak; fi)\r\nException in $fasl-file-equal?: gensym comparison failed while comparing ../boot/a6le/sbb and ../boot/a6le/petite.boot within fasl entry 931\r\nmake[4]: *** [Mf-base:283: checkboot] Error 255\r\nmake[3]: *** [Mf-base:162: allx] Error 2\r\nmake[2]: *** [Mf-base:174: bootstrap] Error 2\r\nmake[1]: *** [Makefile:21: build] Error 2\r\nmake: *** [Makefile:19: build] Error 2\r\n````\r\nAm I building incorrectly? I have a \"normal\" chez-scheme installed system-wide, is there some interference?\r\n @ecraven That check fails because the patch doesn't include updated bootfiles. But you probably have a working build, and running `make` again will normally succeed. Thanks, that worked. I'll try wrapping some of CSFML, to see how things work ;)  @mflatt thanks for the hint, works fine, no problems with a few struct parameters and return values in CSFML so far. That makes sense. I had not worked out that it previously could make sense to pass a callable without locking it.\r\n\r\nShould the necessary locking be added to the callable's implementation, instead of adjusting the requirements on programs (and the test case)? The new commit is intended to fix locking for the non-tail call to the C helper. Repair applied - thanks! Rebased and squashed, including repairs for the two bugs noted on Jan 22.  Is it possible to add support for translating a library name/reference like `(srfi :0)` to a safe pathname stem like `srfi/%3a0`, like other implementations do?\r\n\r\nIt is a matter of using code like the following to translate symbols in the library name into directory pathname components:\r\n\r\n```scheme\r\n#!r6rs\r\n(import (rnrs (6))\r\n  (only (chezscheme) pretty-print))\r\n\r\n(define (%compose-stem id*)\r\n  (define (%display-hex N port)\r\n    (if (fx<=? 0 N 9)\r\n\t(display N port)\r\n      (write-char (integer->char (fx+ (char->integer #\\a) (fx- N 10))) port)))\r\n  (let-values\r\n      (((port extract) (open-string-output-port)))\r\n    (let next-component ((id  (car id*))\r\n\t\t\t (id* (cdr id*)))\r\n      (write-char #\\/ port)\r\n      (for-each (lambda (N)\r\n\t\t  ;;Only characters in the ranges [#\\a, #\\z], [#\\A, #\\Z], [#\\0, #\\9],\r\n\t\t  ;;plus  #\\- are  left untouched;  everything else  is encoded  in a\r\n\t\t  ;;percent sequence.\r\n\t\t  (if (or (fx<=? (char->integer #\\a) N (char->integer #\\z))\r\n\t\t\t  (fx<=? (char->integer #\\A) N (char->integer #\\Z))\r\n\t\t\t  (fx<=? (char->integer #\\0) N (char->integer #\\9))\r\n\t\t\t  (fx=?  N (char->integer #\\-)))\r\n\t\t      (write-char (integer->char N) port)\r\n\t\t    (let-values\r\n\t\t\t(((D M) (div-and-mod N 16)))\r\n\t\t      (write-char #\\% port)\r\n\t\t      (%display-hex D port)\r\n\t\t      (%display-hex M port))))\r\n\t(bytevector->u8-list (string->utf8 (symbol->string id))))\r\n      (if (pair? id*)\r\n\t  (next-component (car id*) (cdr id*))\r\n\t(extract)))))\r\n\r\n(pretty-print (%compose-stem '(srfi :1 lists))\r\n\t      (current-error-port))\r\n\r\n(pretty-print (%compose-stem '(A./_+%Z<>$!?^*))\r\n\t      (current-error-port))\r\n``` The `:` in file pathnames is also troublesome in Makefiles, where it must be quoted with a backslash; the same goes for command line completion in some Unix shells.  I will try to port my SRFI collection to Chez using quoted `:` in Makefiles and see how it feels.\r\n\r\nWriting build scripts with alphanumeric file pathnames only is for sure easier.  Is this a matter of priority?  Do we favour build scripts comfortability or of file names expressiveness?  We need to remember that only developers (not end users) need to look at file names in 99% of cases.\r\n  The file `BUILDING` has no instructions about how to build and install documentation.  With a checkout up to commit `b79099636e5ef82c8f80e56f5aede3a90d0c1f39` if I do `make docs` I get this:\r\n```\r\n$make docs\r\n(cd a6le && make build)\r\n(cd c ; make)\r\nmake[2]: Nothing to be done for 'doit'.\r\n(cd s ; make bootstrap)\r\nmake[2]: 'bootstrap' is up to date.\r\n(cd csug && make m=a6le)\r\n../a6le/bin/a6le/scheme -b ../a6le/boot/a6le/petite.boot -b ../a6le/boot/a6le/scheme.boot --libdirs \"../stex/src\" --program ../stex/src/scheme-prep.ss tspl4-prep csug\r\nException: library (dsm) not found\r\n../stex/Mf-stex:41: recipe for target 'csug.tex' failed\r\nmake[1]: *** [csug.tex] Error 255\r\nMakefile:31: recipe for target 'docs' failed\r\nmake: *** [docs] Error 2\r\n```\r\n\r\nI have not looked at the code yet, would it be feasible to write a back end for the documentation system to produce a different output format?  Was the system written for this?\r\n Yes, we should probably add some instructions, but in general ``make docs`` should just work.\r\n\r\nThe library ``dsm.ss`` should be in the ``stex`` submodule that lands in the ``stex`` directory, so the ``--libdirs \"../stex/src\"`` should be able to find it.  Is it possible you have set ``CHEZSCHEMELIBEXTS`` to something that does not include ``ss`` before trying the build? Yes, this bites me again and again.  But now I get this with the latest commit:\r\n\r\n```\r\n...\r\nuse canned/cisco-logo-large.png> [1{/usr/local/texlive/2016/texmf-var/fonts/ma\r\np/pdftex/updmap/pdftex.map} <./canned/cisco-logo-large.png>]) (./copyright.tex\r\n(/usr/local/texlive/2016/texmf-dist/tex/latex/base/omscmr.fd)\r\n! Undefined control sequence.\r\nl.28 Revised \\INSERTREVISIONMONTHSPACEYEAR\r\n                                           for Chez Scheme Version 9.4.1.\r\n?\r\n```\r\n\r\nusing this build script:\r\n\r\n```\r\n#!/bin/bash\r\n#\r\n# Informal build script for Chez Scheme\r\n\r\nexport CHEZSCHEMELIBEXTS=.chezscheme.sls:.chezscheme.ss:.sls:.ss\r\n#export CHEZSCHEMELIBDIRS=:\r\nunset CHEZSCHEMELIBDIRS\r\n\r\nPREFIX=/opt/chez-scheme/9.4.1${CHEZ_INSTALL_SUFFIX}\r\n\r\nmake clean\r\nmake distclean\r\ngit clean -xfd\r\n./configure \\\r\n    --installprefix=\"$PREFIX\"\t\t\t\\\r\n    --installowner=root\t\t\t\t\\\r\n    --installgroup=root\t\t\t\t\\\r\n    --installschemename=chez\t\t\t\\\r\n    --installpetitename=petite-chez\t\t\\\r\n    CFLAGS='-O3 -Wno-maybe-uninitialized'\t\\\r\n    CPPFLAGS='-I/usr/local/include'\t\t\\\r\n    LDFLAGS='-L/usr/local/lib64 -liconv'\r\nmake\r\nmake docs\r\n\r\n### end of file\r\n```\r\n\r\n Still fails with commit `c9c45641cc50b073329cc6d219140cf93fbd5c4c`.  Do I need to install a git hook or something like that?\r\n Yes!  Build succeeds with commit `1febe9b1a1e1cde4b7be8bc562153ee4b42afd8c`.  Now, ahem, is there no `make install-doc` rule?\r\n I noticed that, after running `make docs`, if I do a `git status` I see a number of files not tracked by git, but not ignored through `.gitignore`.  A purist would say that this should not happen...\r\n On Unix-like systems I suggest `$prefix/share/doc/csv<version_number>`: that's where stuff goes on my Slackware installation, and it is also the one selected by the GNU Autotools (minus the version number).  I cannot help for Windows.\r\n I correct myself, the doc directory pathname should be `$prefix/share/doc/csv-<version_number>` or the more explicit `$prefix/share/doc/ChezScheme-<version_number>`, with a dash between the package name and the version number.  This is so for Slackware.\r\n  - Separate 64 and 32 bit MSIs\r\n- Add wix bundle to combine MSIs into single installer\r\n- Use basic wix UI\r\n- Use merge modules to install vcredist package\r\n- Add script to locate vcredist merge modules\r\n- Fix installer status text by adding WixUI_ErrorProgressText ref\r\n\r\nMerge modules seems to be the preferred method for installing the redistributable package, which should decrease the package size and speed up installation. This commit also addresses a bug where the installer does not work when VC redistributable is not already installed.\r\n\r\nThe 32 and 64 bit components were split into separate MSIs because Windows Installer only officially supports packages containing a single architecture. A package bundle is then created containing both MSIs so only a single file needs to be distributed.\r\n\r\nThere seemed to be no trivial way to get the path to the vcredist merge modules bundled with visual studio so I added a script (locate-vcredist.bat) that handles this. It will need to be updated in the future for compatibility with newer VS platform toolsets.\r\n\r\nSome paths and name were changed, here's a summary:\r\n\r\n32-bit install path: C:\\Program Files (x86)\\Chez Scheme 9.4.1\\\r\n64-bit install path: C:\\Program Files\\Chez Scheme 9.4.1\\\r\ninstaller file name: ChezScheme.exe\r\ninstaller product name: Chez Scheme 9.4.1 x64 This ended up being much more complicated that what I originally set out to build. Let me know if anyone has any suggestions to trim it down.\r\n\r\n- Dropping a registry key pointing to the install location would provide a robust way to find scheme.exe, especially if multiple versions are installed.\r\n- The 8.4 installer has a handy \"Add to path\" option, is that something we still want?\r\n- Will anyone want multiple different versions of Chez installed at one time? How should we handle this? Currently only one 32-bit and one 64-bit installation are allowed and installing a newer version is treated as an upgrade.\r\n- I haven't tested this Bash/WSL since I don't have that environment set up. Does it work?\r\n\r\n  In order for ChezScheme to compile it needs (comparatively) large binary files to bootstrap the system first. Right now these files are included in the git repo itself, and updated frequently. Due to the way binary files are handled by git this effectively is causing massive size ballooning in the size of a full git repo (at last count I saw the .git repo occupying almost a full gigabyte). As the repo is now hosted on github would it be feasible to move over to using github's binary release system?\r\n\r\nhttps://help.github.com/articles/distributing-large-binaries/\r\n\r\nThis would allow the git repo to remain binary-file-free while still making it feasible to compile the system from scratch.\r\n\r\nIf something like this is not done then the git repo runs the risk of becoming unmanageable in size as it would effectively contain a full backup of every binary for every system ever released. This would indeed be useful.\r\n It's worth looking into, because having boot files in the repo is definitely a problem, and we haven't yet come up with a different solution.  That would force us to create new releases every time the uploaded boot files need to be rebuilt, which is less often than we currently rebuild them. If this is pursued I would recommend updating the build process to be able to compile using the system installed ChezScheme files (for people who have already built it once). Or at least make it default if this is already possible (last time I recompiled I remember its still needing the boot files instead of using my already installed version, mine could've been too out of date or something though).\r\n\r\nOne caveat to this is that to my knowledge the release archives git creates do not include the git repo itself, as in the .git directory. @akeep and I have discussed several potential solutions for this issue, none of them ideal, and none of them fully tested.  Comments and corrections on these potential solutions and suggestions for others are welcome.\r\n\r\n**(1)** Leave the full set of boot files in the main repository.  We want to store the full set of boot files somewhere, and the main repository is the obvious place.  Encourage people to clone with `--depth 1` if they don't need the full repository.\r\n\r\nPROS: This is the simplest solution.  With `--depth 1`, the time to clone and the amount of space are both small.\r\n\r\nCONS: The full repo is still large, and a full clone is slow and requires a lot of disk space, problems that will only get worse.\r\n\r\n**(2)** Prune older boot files from the repository and archive them elsewhere.  We'd probably keep older boot files for a specific machine type, say a6le, since a build for any machine type can be used to build boot files for the other machine types.\r\n\r\nPROS: This would keep the repository size reasonably small and doesn't require people to use `--depth 1` to get a reasonably quick and small clone.\r\n\r\nCONS: This solution is more work for the committers and requires them to modify older commits, which seems unclean and dangerous.  It complicates the build of older commits.  We'd have to find somewhere else to store older boot files.\r\n\r\n**(3)** Use github's large-file support for boot files.\r\n\r\nPROS: This reduces the size of a clone.\r\n\r\nCONS: This doesn't reduce overall repository size.  It requires the use of a different tool chain, and a normal `git clone` will not produce a buildable clone.\r\n\r\n**(4)** Create a separate project for the boot files, treat it as a submodule, and have the configure script use `--depth 1` when it does the submodule init.  (Thanks to @jamtaylo for this suggestion.)\r\n\r\nPROS: This reduces the size of the main repo to the space required just for the source code history, and it reduces the size of a simple (non-recursive) clone.\r\n\r\nCONS: This is a bit more work for the committers.  A recursive clone of the main repo without `--depth 1` will cause the entire boot-file repo to be cloned.\r\n\r\n**(5)** As suggested by @ultimatespirit in [this issue](https://github.com/cisco/ChezScheme/issues/203), create a release each time the boot files change, and upload boot files only as part of a release.  Modify the build process either to require the appropriate release to be installed or to download and build the appropriate release as part of building the current version.\r\n\r\nPROS: This reduces the size of the main repo to the space required just for the source code history, and it reduces the size of a clone.  It reduces the chance that existing and possibly incompatible object files are used with a newer or older version.\r\n\r\nCONS: This is more work for the committers and complicates the build scripts and process.  It significantly increases the size of the repo as a whole, since the releases are required for build and are effectively part of the repo.\r\n\r\nAside from these ideas, we have come up with a couple of ways to reduce the number of boot files:\r\n\r\n**(A)** Don't store boot files for the thread versions, since these can be created from the non-thread versions.  This cuts the boot-file storage requirements in half but complicates the build process.\r\n\r\n**(B)** Don't create new boot files as long as the existing set can still be used to compile the sources.  At present, we typically create new boot files after any change in the `s` directory.  This requires some cleverness on the part of the committers to recognize when a change is not important.  For example, @akeep chose not to create new boot files for the `fx+/carry` and company fixes since these routines are not used in the compiler.  This is error-prone since `fx+/carry` might be used by the compiler in a subsequent commit.\r\n\r\n**(C)** Store only the boot file for one machine type, say a6le.  This would effectively eliminate the boot-file storage problem but would require all cloners to have a Linux box or VM sitting around to build boot files.  We did this before Chez Scheme was open-sourced, but only a handful of us were affected.  (Don't bother commenting on this option, since it's not a serious suggestion, just mentioned for completeness.) >(B) Don't create new boot files as long as the existing set can still be used to compile the sources.\r\n\r\nFor what is worth I agree with this.  \r\n\r\n>  This requires some cleverness on the part of the committers\r\n\r\nI have been bitten by this many times.  But now you can use Travis CI to build a test boot file using a new boot file at every repository push (it increases job execution time, but life is hard).\r\n\r\n Is it possible to have non-binary boot files? @xaengceilbiths \r\n\r\nYes, it is possible to have non-binary boot files, in fact there are a couple of different ways to do that.\r\n\r\nThe simplest way to do this would be to take the existing binary files and encode them as text (imagine using something like [uuencoding](https://en.wikipedia.org/wiki/Uuencoding), though we would likely want to define our own encoding).  The hope here is that the binary files are relatively stable and the encoding of the binaries is also relatively stable, so the changes are minimized and the differences stored in the repository are hence minimized.  @dybvig and I experimented with this, but found, after trying a few encodings, that this style text file was not helpful in reducing the size of the binary differences, in fact if I recall correctly, it pretty much made things worse, which was a bit disappointing.\r\n\r\nAnother way to do this would be to have an intermediate representation of the compiled code that is represented as text, which Chez Scheme's run time can either interpret or finish the compilation of before running.  This is a considerable amount of work and has some challenges.  We would likely need to rework the machine-type-specific assemblers (which are written in scheme) so that the same type of work can be done without having the scheme binary around.  If these files are machine-independent we would also need to capture things like the machine-specific foreign function interface code (also written in scheme) in the C run time.  If these files are machine-dependent, then we would still need the same array of them and the text representation is going to be larger than the binary representation, so the working checkout would be larger, though hopefully the differences would be smaller.\r\n\r\nSo, I think a textual representation is a good idea, but getting there is a bit of a challenge. Here's another alternative. You can store each boot image along with a binary diff that will update it to the latest image. The bsdiff tool (http://www.daemonology.net/bsdiff/) is really good at creating such diffs. I did an experiment:\r\n\r\n```\r\n$ git show 303921d8515:boot/a6le/petite.boot > petite-current.boot.gz\r\n$ git show c9c45641cc5:boot/a6le/petite.boot > petite-previous.boot.gz\r\n$ gunzip petite-*.boot.gz\r\n$ bsdiff petite-previous.boot petite-current.boot petite.boot.bsdiff\r\n$ ls -lh petite.boot.bsdiff\r\n-rw-r--r-- 1 weinholt weinholt 6.9K Nov 29 19:48 petite.boot.bsdiff\r\n```\r\n\r\nThe diff between the current and previous images is a mere 6.9K, which is easily stored in git. I'm not sure if this is a representative result, but it looks promising. The problem isn't storing binary files, but rather that different versions of binary files can be incredibly different, with regards to diff tools, from version to version. It seems bsdiff is designed to be hyper efficient at diffing binary files so the diff between two versions would be small. However, the question then becomes what is the diff between two diffs like? That is, given N boot images you would have to store N-1 diffs, if each diff is significantly different from each other then you end up storing each diff individually in the repo instead of the deltas between them. Have you tested the difference between multiple bsdiffs? @ultimatespirit Do you mean doing a bsdiff of two bsdiffs? I'm guessing it will not give good results, since the bsdiffs are compressed. One would indeed have to store multiple diffs in some way, perhaps with a reset of the base boot image every now and then. You'd probably store (bsdiff base base+1), ..., (bsdiff base+N-1 base+N). With luck, if the 6.9K result is typical, then with bsdiff you'd be storing a diff which is in the same order of magnitude as the code changes themselves (although one per machine type).  Why not create a scheme->c translator for chez scheme? (just joking, or not) then there would not be need for boot files :) Another possibility, albeit highly unlikely to be practical, would be to convert the compiler code / a micro compiler to LLVM IR and distribute that to be bootstrapped into the first scheme compiler to finish the rest of the compilation with.\r\n\r\nA big pro to this would be that LLVM IR is platform independent so we would not need to have multiple platform binary versions (so long as LLVM itself supports the platform).\r\n\r\nOf course this would rely on a hope that the LLVM IR would change little between versions or at least be significantly smaller than the compiled binaries, otherwise it would only replace the problem with something else.\r\n\r\nOut of curiosity, is it known what minimal feature set of (chez) scheme would be required to bootstrap the compiler? If it isn't too large a c / llvm microcompiler to begin bootstrapping from may not be too far fetched. If it's large perhaps boot strapping from older versions up would work (though not very practical I know). Unfortunately LLVM IR is not platform independent or portable. It looks like it is semi-supported.  It is now enabled by default on they\nLinux images, but has to be installed via homebrew on the Mac OS images, so\nwe'll need to update the travis-ci config to set this up on the mac builds\nbefore we build.  There is some mention of authentication here, but I'm not\nsure what it refers to, we might need to experiment with it a bit to get it\nworking.\n\nI like the idea of a solution like this as long installing git lfs isn't\ndeemed to be too big a bar to get over.  Certainly, I like the idea of this\nover building our own support for something like this.\n\n-andy:)\n\n\nOn August 16, 2018 at 4:30:21 PM, Bob Burger (notifications@github.com)\nwrote:\n\nI installed Git Large File Storage <https://git-lfs.github.com/>, and it\nintegrated seamlessly with git.\n\nI then ran git lfs migrate import --include=\"*.boot\"\n--include-ref=refs/heads/master to rewrite the master branch using LFS.\n\nI pushed the result to https://github.com/burgerrg/ChezScheme.\n\nRunning git clone on this repository downloaded a mere 40 MB and still\nallows me to go back in time and retrieve the boot files.\n\n@akeep <https://github.com/akeep>, does TravisCI work with GitHub's large\nfile support?\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\n<https://github.com/cisco/ChezScheme/issues/203#issuecomment-413674533>,\nor mute\nthe thread\n<https://github.com/notifications/unsubscribe-auth/AAG5r2cRqE91tRlLgERj8EDUk5QrYlJ7ks5uRdYOgaJpZM4PDXeO>\n.\n  I've been trying to build and run Chez in a container so support for Visual Studio BuildTools would be nice.\r\n\r\nI have not yet successfully used VS's BuildTools to produce a build that passes all the mats and I'd be happy to sit on this PR until I can prove it all works.\r\n\r\nCurrent mat summary: https://gist.github.com/kleinpa/84f535942dc370846774e38bbf17328a Squashing on the pull request branch caused some confusion but should be good to go.  Everything seems to work until you try to execute \"make workareas\" which ends up causing a file not found error. When I ran things with Cygwin, everything seemed to work fine (though I had to start over from scratch).  cc: @mflatt \r\n\r\nThis is still work in progress, so the files still have some unnecessary comments and rough parts, but it's already big and I think I need some feedback before continuing. \r\n\r\nIn general, this changes are useful with optimization-level 2, because most of the type checks are skipped in level 3.\r\n\r\nThe idea was to reduce most common idioms, for example:\r\n\r\n    (lambda (x) (vector-set! x 0 0) (vector? x)) \r\n      ==> (lambda (x) (vector-set! x 0 0) #t)\r\n\r\n    (lambda (x) (when (vector? x) (vector? x))) \r\n      ==> (lambda (x) (when (vector? x) #t))\r\n\r\n    (lambda (x) (when (vector? x) (box? x))) \r\n      ==> (lambda (x) (when (vector? x) #f))\r\n\r\n    (lambda (x) (unless (vector? x) (error 'e \"\")) (vector? x))\r\n      ==> (lambda (x) (unless (vector? x) (error 'e \"\")) #t)\r\n\r\nMore examples of the reductions are in the first part of cptypes.ms\r\n\r\nThe main part of the code is in cptypes.ss. It has an explanation of the parameters of the main function at the beginning of the file.\r\n\r\n(Some auxiliary functions are copied from cp0.ss.  There is also an hamt implementation in hamt.ss. It's necessary to get fast lookup of the discovered types.)\r\n\r\n----\r\n\r\nThe first commit is just to recalculate automatically the bootfiles in travis-ci. It's handy for testing while writing the initial versions, but my idea is to remove/revert it in the final version. \r\n\r\nThe second commit adds the signature information available in primdata.ss to the `primref`. so the other parts of the code can use it. This step is tricky, so I left it in an isolated commit, but my plan is to squash it in the final version. (The third commit has the bootfiles.)\r\n\r\nThe last commit is the main part of the implementation.\r\n\r\n\r\n I read the preprint only twice, so I hope I didn't misunderstand too much.\r\n\r\nThere are a lot of small differences that can be ported in either way. For example, his implementation reduces `#2%car` to `#3%car` when posible, but I didn't add that. Also, he is using a lattice of types with a very small height, but I'm using 4 or 5 steps in the numeric tower.\r\n\r\nThe main difference is that he is using a graph to handle cycles, like `(let loop ([n 100]) ... )` and I just give up and don't try anything smart with cycles, so all the analysis can be done in one pass.\r\n\r\nThe other difference is that I'm always copying the info from each environment to the surrounding environment. This can lead to quadratic run time in cases like\r\n\r\n    (lamdba (x1 ... xn)\r\n      (let ([r1 (random)])\r\n        ...\r\n           (let ([r2 (random)])\r\n             (display (list (unbox x1) ... (unbox xn)))))\r\n      (display (list (box? x1) ... (box xn))))\r\n\r\nHe is using an abstract analysis of the flow of the types an structure similar to a skiplist to avoiding to update the types in each step, and the types just teletransport to the correct spot. So this is analyzed in O(n log(n)) instead of O(n^2).\r\n\r\nAs an informal benchmark, I'm comparing the runtime between the master branch and my branch. With something like \r\n\r\ncd a6nt/s; time make allx o=3\r\n\r\nmy branch, o=3:   28.6 sec\r\nmaster,  o=3:   26.4 sec\r\n\r\n(with o=2, it runs twice, so you must divide the time by 2 to compare)\r\nmy branch, o=2: 148.8 sec   (~74.4s sec)\r\nmaster, o=2: 170.6 sec   (~85.3s sec)\r\n\r\nI'm \"cheating\" a little because most of the times I'm not saving the type of a variable when it is a `procedure?`.  (My code is correct (I hope), but it miss some optimization opportunities, but not too much in usual code.) If I add all the procedures, the code has to track too many variables and the compilation gets \u00bf50%? slower. He is saving all the info for all procedures, with more details, so this can have an important effect.\r\n Sorry for the long delay. I updated the PR. This is a short description of the commits:\r\n\r\n* fix enumerate signature\r\nA small fix, otherwise the PR doesn\u2019t compile.\r\n---\r\n* add signatures field to primref record\r\n* Add cptypes pass to cp0 to reduce expression using types\r\nThese are the main parts of the old PR. See the description in the initial post.\r\n---\r\n* revert to version that can update primref record (skip)\r\n* recalculate the bootfiles automatically in travis-ci (skip)\r\n* bootfiles (signatures)\r\nThese are some commits to try to test the intermediate versions in Travis without updating the bootfiles with each change. These commits should be deleted of the final version.\r\n---\r\n* Fix hashing of prelex\r\n* fxmap version of cptypes\r\n* change fxmap api to hide internal structure\r\nThese commits change the hamt by an intmap/fxmap made by @97jaz. In particular the new structure can merge two similar intmap in `O(d log(n))`, where `d` is the number of differences and `n` is the total amount of variables. Also, the `prelex` have a new field that is a counter, that is used as the hash key for the map.\r\n---\r\n* remove some unnecessary pred-env merges\r\n* update comments and fix exact-integer? and result type of \u00ecf`\r\n* merge types after if\r\n* rename merge -> union/intersection\r\n* refactor pref-union/intersect\r\nThese are some assorted changes, mostly to avoid unnecessary merges in the `pred-env` to try to avoid quadratic behavior in long chains of nested `let`\u2019s. They also provide more information about the return type of an `if`. (They can probably be squashed in a single commit, but some of them are mixed with the previous commits and they are difficult to reorder.)\r\n---\r\n* upper and lower bound for types\r\n* cache for primref->result/argument-predicate\r\n* add safeongoodargs flag to primref\r\nTry to replace some applications of the primitives with the unsafe version when the types of all the arguments are well enough. This changes `(car <pair>)` to `(#3%car <pair>)` but it doesn\u2019t change `(vector-ref <vector> <n>)` to `(#3%vector-ref <vector> <n>)` because it\u2019s difficult to verify if `<n>` is in the correct interval. There are surprisingly many primitives where all the arguments can be checked.\r\n---\r\n---\r\nAbout the thesis of Michael Adams: The implementation is quite different but most of the results are equivalent. (Something similar to a list of features is in mats/cptypes.ss) My PR uses nanopass instead of a custom graph. \r\nMy version currently passes the checks in Travis. The runtime of the o=3 version increase only a little and the runtime of the o=2 version is smaller. It can be merged after checking a few points that I\u2019m not 100% sure that are correct and fixing a few/many style problems. \r\n IIUC the main features that are missing in my version are:\r\n* Types for loops: I don\u2019t track the types in recursive functions like\r\n```\r\n    (let loop ([n 0])\r\n      (when (< n 100)\r\n        (loop (+ n 1))) ; <- obviously n is a number\r\n```\r\nI think this can be added to my current implementation later. It\u2019s not straightforward but I have a vague idea about the implementation, but I have not written a single line of it.\r\n* [fixed] Quadratic behavior with too many `let`\u2019s, for example in \r\n```\r\n    (let ([x1 (read)])\r\n      (let ([xn (read)])\r\n        (+ x1 xn)\r\n      ) ; <- merge the types\r\n    ) ; <- merge the types\r\n```\r\nIn my first version the extended version of this code has quadratic behavior because the types of each `x1` and `xn` should be merged after each `let`. With the new version I just keep the dead variables in the environment. The new hashing is fast and these additional variables don\u2019t make the code slower.\r\n* Quadratic behavior with too many `if`\u2019s, for example in \r\n```\r\n    (if x1 \r\n      (if x2 1 2)\r\n      (if x3 3 4)\r\n    ) ; <- merge the types discovered in each branch \r\n```\r\nThis example is not quadratic, and I\u2019m still not sure if something like this can be quadratic in the current version. But if in the future I add support for loops and function calls, it will more easy to find quadratic examples.\r\nThe thesis has a chapter to fix the problem of the nested `if`. I think it\u2019s very interesting but the solution is difficult to integrate with my version. In particular, IIUC in the thesis the position of each `if` is important, but I try to reduce the if\u2019s as soon as possible (for example if `x2` is a number, the second `if` is reduced to the constant `1`). I think that long chains of `if` are not so common, so my version is good enough without this feature.\r\n* [half fixed] Avoid unnecessary type checks\r\n```\r\n    (car <pair>) ==> (#3%car <pair>) [fixed]\r\n    (vector-ref <vector> <n>) ==> (#3%vector-ref <vector> <n>) [not fixed]\r\n    (bitwise-copy-bit <sint> <uint> <bit>) ==> (bitwise-copy-bit <sint> <uint> <bit>) [not fixed]\r\n```\r\nI added a reduction for the cases where it is possible to check all the arguments and replace the application with the unsafe version. This is possible with `car`, `cdr`, and many (~200) primitives, but it\u2019s not possible with `vector-ref` and most vector primitives. It\u2019s possible in the future to add some support for more general cases, in particular the operations on vectors.\r\nA special case are the primitives like `bitwise-copy-bit`. They are marked as safeongoodarguments, but the type system I currently use can\u2019t track the variables with enough precision, so they are not changed in the current versions, but it\u2019s possible to extend the type system in the future.\r\n \r\n\r\n Note that large uses of `match` (at least in Racket) can generate quite deeply nested `if` expressions. I'm not sure if that's likely to be a problem with the issue you mentioned.  I\u00b4ll take a look at the expansion `match` in Racket, but I expect them not to be so big to cause a problem.\r\n\r\nI think that it's easier to explain the problem with an example. In the current version of my PR this code:\r\n\r\n    (lambda (t)\r\n      (unless (symbol? t)\r\n        (error 'e \"msg\"))\r\n      (let ([x1 (read)]\r\n            [x2 (read)]\r\n            [xn (read)])\r\n        (if (eq? t 'v1)\r\n            (display (+ 1 x1 x2 xn))\r\n            (if (eq? t 'v2)\r\n                (display (+ 2 x1 x2 xn))\r\n                (if (eq? t 'vm)\r\n                    (display (+ -1 x1 x2 xn))\r\n                    (display (+ -2 x1 x2 xn)))))\r\n        (list (number? x1) (number? x2) (number? xn))))\r\n\r\nThe optimization step for this code is `O(n*m*log(N))`, where `n` is the number of auxiliary variables, `m` is the number of conditions and `N` is the total amount of variables (not shown in the example). But the length of the code is `O(n*m)` because each variable must be used in (almost) each branch condition.  If a variable is used only in one single branch in a long chain of `if`s, after the first type merge it will dispersar and all the the other merges will not see the variable.\r\n\r\nSo this simpler code code is optimized in a time essentially `O(n+m)` (ignoring something like `log(N)`)\r\n\r\n        (if (eq? t 'v1)\r\n            0\r\n            (if (eq? t 'v2)\r\n                1\r\n                (if (eq? t 'vm)\r\n                    (+ -1 x1 x2 xn)\r\n                    (+ -2 x1 x2 xn))))))\r\n\r\n\r\nI'm (slightly) worried than in a future version, I (or someone) will add some tracking of types inside function calls. Something like:\r\n\r\n    (lambda (t)\r\n      (unless (symbol? t)\r\n        (error 'e \"msg\"))\r\n      (let ([x1 (read)]\r\n            [x2 (read)]\r\n            [xn (read)])\r\n        (let ([sum (lambda (z) (dislay (+ z x1 x2 xn)))]) ; let's assume it is not inined\r\n          (if (eq? t 'v1)\r\n              (sum 1)\r\n              (if (eq? t 'v2)\r\n                  (sum 2)\r\n                  (if (eq? t 'vm)\r\n                      (sum -1)\r\n                      (sum -2))))\r\n          (list (number? x1) (number? x2) (number? xn))))\r\n\r\nIn this case, if the optimizer is smart enough to realize that after calling `sum` all the captured variables `x1`, `x2`, `xn` are integers, then the merge of the types will be `O(n*m*log(N))` but the code will be of length `O(n+m)` only because sum is not inlined. \r\n\r\nThis is not a problem in my current version, because it just ignore function calls. Only the primitives may mark the variables. The complexity of the merge algorithm is given in Okasaki and Gill as worst case O(m+n). Thanks for the minimized example. The problem with `bytevector-[u/s]16-native-set!` was that it has a wrong signature. (The 32 bits versions is correct.) So cptypes detects that the variable `k` is a `fixnum?` and it uses the wrong signature to detect that `k` must be a `symbol?`, so it expect that the `bytevector-u16-native-set!` will generate an error, so cptypes drops the rest of the expression.\r\n\r\nI submitted a fix in a different PR https://github.com/cisco/ChezScheme/pull/240 because this looks isolated enough and simple enough to be merged soon.\r\n\r\nI'll reply to the rest of your comment later. I'm working mostly in Windows, but I never could fix the problems with `iconv.dll`, so if I run all the test I get a lot of errors. I'm using a VM with Linux now, so I can see the actual errors.\r\n\r\nI found a few more (~5) errors with the signatures, that were causing explicit error or invalid memory errors. (I'll submit the PR soon.) I also found a a few places were I marked the primitive erroneously  as `safeongoodars`. I also fixed the checks of the expanded code. (I'll update this PR in a week after I fix most of the problems.) \r\n\r\nI still have to fix the errors with records. @mflatt found an error that is probably related to records, but he has no an small/easy example. Some of the messages of the errors in the mats look similar, so I hope that fixing the mats will fix it.\r\n\r\nAbout Style (box -> values): OK, I'll change it\r\n\r\nAbout asymptotic behavior: I'll try to think the details later. I'll try to fix the other problems before.\r\n\r\n\r\n  @burgerrg  I tried now to compile win-iconv, but I got an error (Perhaps because I'm using Cygwin instead of MinGW?) Anyway, I downloaded the compiled version from https://mlocati.github.io/articles/gettext-iconv-windows.html and I copied the file libiconv-2.dll to ChezScheme\\a6nt\\bin\\a6nt and it works.\r\n\r\nI still get some errors in the master branch in Windows. I'll try to classify them and send a pull request or a bug report if I can't fix it.\r\n\r\n@akeep In my \"secret\" branch, I fixed all the errors that the test in \"allx\" can detect. But I want to make a few more tweaks before updating the PR. I'm optimistic about the problems with the quadratic time, I think it's solvable with a few modifications to the current structures. I also tried to change the box to values, but some parts are painful. For example to look at all the arguments of a function: \r\n\r\n    ;--- with box ---\r\n    [(call ,preinfo ,pr ,e* ...)\r\n     (let* ([r* (map (lambda (e) (box #f)) e*)]\r\n            [t* (map (lambda (e) (box (unbox types))) e*)]\r\n            [e* (map (lambda (e r t) (cptypes e 'value r t #f #f))\r\n                     e* r* t*)])\r\n       (set-box! types (something-with (unbox types) e* r*))\r\n       (for-each (lambda (t) (set-box! types (pred-env-intersect (unbox types) (unbox t)))) t*)\r\n       `(call ,preinfo ,pr ,e* ...))]\r\n\r\nand \r\n\r\n    ;--- with box ---\r\n    [(call ,preinfo ,pr ,e* ...)\r\n     (let* ([e/r/t*  (map (lambda (e)\r\n                            (let-values ([(e r t t-t f-t)\r\n                                          (cptypes e 'value types)])\r\n                              (list e r t)))\r\n                          e*)]\r\n            [e* (map car e/r/t*)]\r\n            [r* (map cadr e/r/t*)]\r\n            [t* (map caddr e/r/t*)])\r\n       (let ([types (something-with types e* r*)])\r\n         (values `(call ,preinfo ,pr ,e* ...)\r\n                 #f\r\n                 (fold-left (lambda (types t) (pred-env-intersect types t)) types t*)\r\n                 #f #f)))]\r\n After another long delay ... Fixing the quadratic time was possible, but it was harder than I expected.\r\n\r\nI squashed most of the commits and the fix in a few big commits. Short description:\r\n\r\n---\r\n* add `signatures` field to primref record  \u2026\r\n* Version to upate primref record during rebase: step 1 (skip)\r\n* Version to upate primref record during rebase: step 2 (skip)\r\n* Version to upate primref record during rebase: step 3 (skip)\r\n* recalculate the bootfiles automatically in travis-ci (skip)\r\n* bootfiles (signatures)\r\n\r\nAdd the `signatures` to the `primref`. This step is tricky, so I left the intermediate steps to make a future rebase easier, but most of these commits should be removed in the final version.\r\n\r\n---\r\n* Hashing of prelex for cptypes\r\n* Add fxmap for cptypes\r\n* Add more operations to fxmap\r\n* test for fxmap-{remove,reset}/base (skip)\r\n\r\nImplementation of an intmap that will hold the types recovered during the cptype pass. \r\n\r\n---\r\n* Remove special case for (#2%map p '()) in cp0 [fix in master]  \u2026\r\n* Add cptypes pass to cp0 to reduce expression using types  \u2026\r\n\r\nThis is the main part of the PR. This includes the previous version, some improvements and many fixes.\r\n\r\n---\r\n* add safeongoodargs flag to primref  \u2026\r\n\r\nReductions to replace a primitive by the unsafe version. I left the safeongoodargs separated because it has a lot of instances to be reviewed, so perhaps it's better to merge it later.\r\n\r\n\r\n---\r\n---\r\n\r\nAbout the previous comments:\r\n\r\n### box -> values\r\ndone\r\n\r\n### fix tests\r\ndone\r\n\r\n### records\r\nI changed like the 90% of the implementation for records. I think that now it is correct.\r\n\r\n### quadratic time\r\nThe main idea is that the types are stored in a immutable intmap/fxmap that remembers how much changes were used to create it. So each time it is necessary to merge two intmaps it is possible to select the smaller one and add to the biggest one only the recent differences. The main advantage of this intmaps/fxmaps is that the difference operation can be very efficient.\r\n\r\nSome construction like `let` use a special operation to forget the temporal variables. This operation not only removes the variable but it also tries to reconstruct the inmap before the temporal variable was added. [In particular, with this reconstruction some trees that look `equal?` are `eq?`, like in the additional test. Most of the times only a part of the tree is reconstructed.] This helps the following parts of the code to compare two inmaps faster, because the iterations can skip the common parts using `eq?` without comparing the subtrees. \r\n\r\nThe analysis of the `if`  is more tricky, because it's necessary to use a different strategy when the `test` part is longer than both branches. Also, if one one of the branches is longer than the `test` it's important to use the intmap of the smaller branch for the iterations and compare using lookups in the intmap of the biggest branch. (The \"length\" is actually calculated the number of changes in the relevant intmap, that is bounded by the actual length of the code.)\r\n\r\nThis pass runs in O(N log(N) (log(N)+R)) where N is the total length of the code and R is the depth of the record hierarchy, because to compare two records the program must walk from a rtd to the parents until it finds the other rtd or the base rtd. In practice R is small, I tested with the Chez Scheme compilation and I got R=3, and I expect that most programs don't have rtd with parent  with parent  with parent  with parent  with parent. So the effective bound is O(N log^2(N)).\r\n\r\n[It is possible to fix the problem of the records with too many ancestors, but in that case I think it's better to change it in another time.] This all sounds good.  It will take me a few days to get some time to look through and test all these changes, but I'm looking forward to going through it. Thanks for all the work \ud83d\udc4d  I have no problem with using an auxiliary branch to get the fixes. I was already doing something like that with @97jaz and @mflatt .  \r\n\r\n### About the changes:\r\n\r\nI have read the changes and they look good, but I need a few more days to read them more carefully. (Also, my notebook has a problem with the screen, and I'm using the old one for a few days ...)\r\n\r\nI agree with the change of `types -> types1` in the `if` clause of `cptypes/raw`. (It was a mistake. I was probably shadowing `types` and later decided to rename it as `types1` to get more consistent names, and I forgot to update the name of the variable in these sites.)\r\n\r\n### About the ideas for changes:\r\n\r\n- change `($empty? x)` -> `(eq? x <singleton>)`\r\n\r\nOK. I'm only worry about the possibility in the future of reusing fxmap.ss in another pass (like cp0) and getting a different \"singleton\". This would be a problem is the `fxmap`s are somehow stored and shared. This problem is too hypothetical, so it can be solved with a comment in the file with a warning for the future.\r\n\r\nAnother small improvement would be writing a version of `fxmap-merge` that doesn't try to build a result `fxmap`. I'm using it in `fxmap-for-each/diff`, trying to minimize the result and then discarding it at the end.\r\n\r\n- making `$record/rtd` and `$record/ref` lists into records\r\n\r\nOK. \r\n\r\n- remove temporal `ir` in the `call` clause of `cptypes/raw`.\r\n\r\nOK. I think I wrote that for laziness, to be able to return the default `ir` when necessary without thinking. (Sometimes it's nice because it's clear that the reduction affects only the types and not the main expression.) I used it only 4 times, so it's easy to fix it with cut&paste.\r\n\r\n- use `define-inline` like cp0\r\n\r\nI like the idea, but I'd prefer to wait. I like that `define-inline` makes the code much easier to parse because it's clear where each primitive is handled. But I still not sure about the details of the interface. In particular, the argument `types` can be \r\n  a) the original `fxmap` that is the argument of `cptypes/raw`\r\n  b) the result after adding the types recovered in the arguments\r\n  c) the result of adding also the types that are checked in the primitive definition/signature\r\nCurrently, the effective value is c) because it makes the implementation easier, but in an isolated reduction b) is more natural, but it may be more error prone than a). The value of the argument is important because all the recovered types must be added first to the \"main\" `fxmap` in the result, and later add the additional types to the results that will be used in the \"then\" and \"else\" branches. If you add them in other order, you must use some of the unusual functions of the `fxmap`s. [Mmm. This description is probably not very clear, but I hope it's clear that I don't have the details clear enough yet. So, I'd prefer to think about this and discuss the implementation details later before writing them.]\r\n\r\n###  About the quadratic time:\r\n\r\nI'm sure I fixed all the corner cases (but I have been wrong in the past ...).\r\nThe first important point is that the numeration of the `prelex` is consecutive or quasi-consecutive so the `fxmap`s are almost balanced, or to be more precise the height is bounded by `log(N) +k ` where `N` is the total number of variables in the program and `k` is a small number, I guess 2 or 3. So there are not degenerated cases where a big `fxmap` is actually a long `list`.\r\nAlso, the `fxmap` with the types in the results are constructed in such a way that in an expression like ` (+ e1 e2)` the `types1` of `e1` and the `types2` of `e2` share as much as posible the structure with the original `types`. So the differences between `typesX` and `types` can be iterated in less than ` ((changes typesX) - (changes types)) * log(N)` time. To ensure this property it is necessary be careful and in particular to use `fxmap-remove/base` to remove the temporal variables and rebuild the branches where they were stored.\r\nSo it is possible to pick from `types1` and `types2` the one with fewer changes and copy only those changes to the other one. In particular if one of them has a few changes from the original `types` and the other has a lot of changes from the original `types`, then the merge operation must copy only a few changes and is fast. Selecting the one with fewer changes is the main idea to ensure that the global runtime is O(N log^2(N)).\r\n(Actually, merging all the `fxmap`s in a `if` clause is trickier if you want to avoid quadratic time, so I have to use some weird functions with the `fxmap`s.) There are three lines in cptypes.ss that have a `#;CHECK` reminder/warning. These are parts that I think that are correct, but I'm not sure. (For example, the clause for `immutable-list` in `cptypes/raw`.) I think that you already looked at the code and thought it was fine, but can you take another look at them so I remove the reminder/warning? > The `predicate-implies?` check is a good question.  ...\r\n\r\nI think it's better to use `eqv?` because `predicate-implies?` is used in `predicate-implies-not?`. So we get these reductions\r\n\r\n    (eq? 3.3 3.3) => #t      [unespecified]\r\n    (eq? 3.3 7.7) => #f\r\n    (eqv? 3.3 3.3) => #t\r\n    (eqv? 3.3 7.7) => #f\r\n\r\nThe first one is officialy unespecified, but using `eqv?` in `predicate-implies?` makes cptypes reduce it to `#t` allways. Using `eq?` would make the it sometimes be reduced to `#f`, because the result would depend on some of the internal details, for example if both `3.3` are constant propagated from the same origin, or if they are calculated independently, or if there was a round trip to fasl. \r\n\r\nSomething similar applies to the third one, but the result of the third one must be `#t` , so comparing internaly with `eq?` would be a problem.\r\n\r\n----\r\n\r\nI also found another small optimization of the program in cptypes. I removed the wrapper around `cptypes/raw` and now the recursion calls `cptypes` directly. The wrapper was there to replace `t-types` and `f-types` with the value of `types` when one of them was `#f` (that means the there are no additional predicates for the `#t` or `#f` branches). I now take care of that case inside the clause of `if` when it is necesary, instead of in every recursive call. So it must save a few milliseconds here and there. (I also had to make a trivial tiny modification in the clause of `let/let*/letrec`, but I have to debug the code for a while until I notice that I must fix it too.) [preview ](https://github.com/gus-massa/ChezScheme/commit/c98e69c234da63433abbb6554e60402c4a18fdeb)\r\n\r\n I rebased the PR, and in the last commit I added all the proposed changes exept `define-inline`.\r\n\r\nI  removed the auxiliary commits, so this version doesn't have the correct bootfiles and it gets an error in travis. I have the outdated bootfiles and the trick to make travis recompile them in another branch [gus-massa/17-5-Types-Pass-Extended](https://github.com/gus-massa/ChezScheme/commits/17-5-Types-Pass-Extended) ([tests](https://travis-ci.org/gus-massa/ChezScheme/builds/365899137))\r\n\r\nThe main missing parts are the updates to the LOG and CSUG.  [I still have problem with my main computer, so I have to guess a little ...]\r\n\r\nOne important part of  `(pred-env-union/from from base types new-base)` is it must be possible to construct `from` starting with `base` and using a few `add` operations. Sometimes the process is more complicated, but the operations like `remove/base` ensure that there is an alternative path that uses only `add` operations.\r\n\r\nThe error you found in the test is triggered because `base` has a binding that is not in `from`. This is impossible if you use only `add` operations (`add` actually intersects the new type with the old value, it's not a simple overwrite, it never cleans a binding). I think the `error` procedure should be changed to `$impoops` because in a bug free universe it is impossible to reach this part of the program.\r\n\r\nI still don't understand where the problem is, but something like the following example should cause a problem. Each variable has a friendly name and also a number that is the counter that is temporally assigned to the `prelex-operand` field. The intmap uses only the counters, not the name or the prelex itself. I assume that there is a rogue prelex, that is shared between two threads, and the different threads reuse the numbers.\r\n\r\n    (lambda (t1 x2 y3)\r\n      (when (box? shared4)    ;  <-- the number 4 was assigned by another thread\r\n        (if t1\r\n            (let ([temp4 (read)])\r\n              (display (list (unbox temp4) (unbox temp4)))\r\n              )    ;  <-- here temp4 is removed, but this \"removes\" shared4 too\r\n            (display (list (unbox x2) (unbox y3))\r\n              )    ;  <-- enough recovered types to make this the long branch\r\n            )    ;  <-- here the types are merged, the missing shared4 is a problem\r\n        ))\r\n\r\nThe error will be raised only if the numbers in each tread are luckily aligned. In other cases there may be silent errors. This code is not similar to the code in [thread.ms#L979](https://github.com/cisco/ChezScheme/blob/master/mats/thread.ms#L979) so I can't guarantee this is the problem. My guess is that the imported identifiers in the examples are the shared prelex. This is probably not a problem in `cp0` because they don't get any value overwritten in the `prelex-operand` field.\r\n I made a small debugging change to `prelex-counter` function to remember the `prelex` that it has modified adding the `counter`, and so detect any `prelex` numbered by another thread and raise an error. It is in my branch [17-5-Types-Pass-Error](https://github.com/gus-massa/ChezScheme/commits/17-5-Types-Pass-Error), with two auxiliary commits to make travis-ci happy.\r\n\r\nWith the two auxiliary commits [all the tests pass](https://travis-ci.org/gus-massa/ChezScheme/builds/370800404), but with the main commit I get an [error exactly in all the threaded versions](https://travis-ci.org/gus-massa/ChezScheme/builds/370817470). (This change is more sensitive than the test error you found, because it will catch any bad `prelex`, instead of catching only the cases where the numbering and recovered types are correctly aligned.) (I couldn't find a way to see the error in travis-ci, `grep` is eating the output.)\r\n\r\nI hope it's helpful.\r\n\r\n----\r\n\r\nAbout the side effects instead of the functional approach in the merge: To avoid the `O(n+m)` worst case I need that:\r\n- the `counter`s of the `prelex` are almost continuous (or at lest that they don't increase exponentially) so the big trees look like trees instead of linked lists\r\n- the branches that look `equal?` are actualy `eq?`, so if one tree is constructed from nother tree and they are almost equal then the common parts can be detected with `eq?` and skipped in block, without looking at each leaf.\r\n\r\nSo I need some merge operations that use tree (or four?) `intmaps`. There was a functional merge written by @97jaz , but it was not enough because it uses two trees and the result is a combination of the two trees. But I sometime must paste the results into a third tree to ensure that the common part between the result and the third tree is `eq?` and not just `equal?`. \r\n\r\nOnce I thought about adding a functional version that calls the configurable function with an additional argument that acts like an accumulator, but I didn't understand the code well enough. (Now I think I can, but the code is still tricky.) (In case this is not clear, in the equivalent code with `list`s, it's like replacing a combination of a `for-each` and a `set!` by a `foldr`, the `lambda` needs an additional argument.)\r\n I think we agree, and the current version of this PR has a problem with the `prelex`s that are somehow shared between threads.\r\n\r\nIn [17-5-Types-Pass-Error](https://github.com/gus-massa/ChezScheme/commits/17-5-Types-Pass-Error) I just added an additional checks so any strange `prelex` will raise an error. It doesn't change the result of the program and it should never be triggered, but it is actually triggered reliably in all the threaded compilations in travis.\r\n\r\n I still don't understand why this cause the unexpected `prelex`, but I'll try to read this again in the morning.\r\n\r\nMeanwhile, I tried to reread the current code one more time and I found a small error, and I pushed a fix. I'd normally squash it into my old commit, but since you are already working on top of it it may cause some problems. It's a tiny change, so it's even possible to copy it by hand to your current version.\r\n\r\nIIUC this bug I found is unrelated, but sometimes optimization bugs reappear in strange places. I tried to build a test case, but it's difficult because I think that most of the times the expression is reduced by cp0. I have some notes, I'll give them another read and send them. They are mostly extended comments of the code, and cover mostly the use of the fxmap and prelex, to be sure that there are no quadratic part hiding in the corner cases. \r\n\r\nBut the notes don't discuss the easy parts, like the shotcircuiting of `(begin <bottom> e2)` or `(if <bottom> e2 e3)`. Also IIRC the type lattice is not covered, because I think it has no tricky parts, most of the details of the conversions are in the big comment at the beginning of the file. I just pushed a small fix of the error messages, in particular it uses `$impoops` instead of `error` because it should never happen. I'd squash this commit too, but as you have the fixed the thread problems in a not public branch, it may be easier to just copy these changes there (perhaps with a better text). I made a few small updates. I squashed my two minor last commits with a few new changes. If you have already made some changes I can try to rearrange them with this changes.\r\n\r\n### Fix cptypes in multi-thread version\r\n\r\nThis is essentially the [gist](https://gist.github.com/akeep/37db1369a87bfdf7cd55aaba2619446c) made by @akeep . I removed the error checks and the debug messages.\r\n\r\nWith this change many of the auxiliary functions are defined inside the pass. I'm not sure if this is a good idea, because I'm not sure if they will be slower than a version of the functions that are defined outside the pass.\r\n\r\nAlso, IIUC the cache of the types of the signatures in [L551](https://github.com/gus-massa/ChezScheme/blob/639f32cfc6f462fe9492d13b6fd246cb6be1df3f/s/cptypes.ss#L551) and [L605](https://github.com/gus-massa/ChezScheme/blob/639f32cfc6f462fe9492d13b6fd246cb6be1df3f/s/cptypes.ss#L605) will get a different instance in each time the pass is used, so it will be slower than having a common cache for all the instances that the pass is called. (Are hash-table thread safe?)\r\n\r\n### Fix call case with rest argument in cptypes \r\n\r\nThis has the two small fixes, and a special case to make cptypes detect that `(list x y z)` is a `pair`, i.e. it is not `null`. This is useful because cp0 may reduce \r\n\r\n`((lambda (x . rest) ...) a b c)` ==> `((lambda (x rest) ...) a (list b c))`\r\n\r\nand this make the type detection of `rest` slightly more consistent.\r\n\r\nI also added some test here. More on this in the next commit.\r\n\r\n### more cptypes\r\n\r\nTo make the test pass, I had to add a call to cptypes in two files. \r\n\r\nFirst I made the calls look at the `(enable-type-recovery)` parameter so they can be disabled.\r\n\r\nSecond I added a call to cptypes when cp0 is not called, to make it consistent with other compilation ways. The problem is that after using this in the test I don't like it.\r\n\r\nI made two version of the test. \r\n\r\n* One disables cp0 and use the fact that cptypes will be called anyway\r\n\r\n* The other uses `(run-cp0 (lambda (cp0 x) (#3$cptypes x)))`\r\n\r\nI think that it's more intuitive that disabling cp0 will disable all (or most) of the optimization, including cptypes. It's not intuitive that cptypes is called anyway. My guess is that the normal users will not be interested in testing the behavior of cptypes alone, so in the rare case that any of them are interested, they can use `#3%cptype`. So my proposal is to remove the second part of this commit and also remove all the cptypes from the cp0-was-not-called branches in the compiler. (I didn't write this yet.) \r\n\r\n(I like the flag `(enable-type-recovery)`, it may be useful to isolate bugs.)\r\n\r\n(An additional question: The cp0-was-not-called branches have a call to `$cpletrec`. How bad is that someone redefines `run-cp0` as `(run-cp0 (lambda (cp0 x) (#3$cptypes (cp0 x))))`? Because it will set the flag that `cp0` was called and `$cpletrec` will not be the last pass. (IIUC the properties of the `letrec`s that `$cpletrec` try to enforce are also enforced later in cpnanopass, so this is not a problem.))\r\n\r\nTest in version with bootfiles [here](https://travis-ci.org/gus-massa/ChezScheme/builds/410624476). I added a small commit changing how `enable-type-recovery` work, so \r\n\r\n    (run-cp0 (lambda (cp0 x) x))\r\n\r\nwill disable the traditional cp0 pass and also the cptypes pass. I think it's more intuitive this way. More details in my previous comment. This is based in an old version, so it needs some tricks to pass the test. See [branch](https://github.com/gus-massa/ChezScheme/tree/17-5-Types-Pass-Z) / [tests](https://travis-ci.org/gus-massa/ChezScheme/builds/498334437).\r\n\r\nI also made a rebased version in case it's useful. It needs new bootfiles, but they don't have to be the very latest one. See [branch](https://github.com/gus-massa/ChezScheme/tree/17-5-Types-Pass-ZR) / [tests](https://travis-ci.org/gus-massa/ChezScheme/builds/499446059).\r\n\r\n  Expanding to a definition means that it doesn't interrupt a definition\r\nsequence.  Ordered finalization is intended to make certain finalization patterns more composable. A library might want to finalize internal parts of a data structure while allowing applications to finalize external pieces that refer to the internal parts. In that case, the goal is to finalize the internal pieces only after the application is definitely done with the external parts, including finalization on those external parts. Ordered finalization seems difficult to use correctly, but it looks like a good option for handling foreign resources.\r\n\r\nThis patch includes two changes to guardians: it uses the `seginfo` trigger mechanism to avoid quadratic-time handling of guardian chains (which are, granted, unlikely in practice), and it adds an optional `ordered?` argument to `make-guardian` to provide a form of ordered finalization. I initially planned to stage those changes as two commits, but various representation choices interact, so they're together here.\r\n\r\nThe implementation adds a field to a guardian entry, and so there's a second field to preserve double-word alignment \u2013 which I think is necessary to declare and initialize to work right with the GC, but correct me if that's not right. Since two words seem to be necessary for the one extra bit of information I need to distinguish ordered and unordered finalization, I used the second word to make the handling of triggers more convenient.\r\n\r\nAnother possible choice is to keep separate lists of ordered and unordered entries, but that seems much less convenient in the GC implementation. Also, the trigger lists in the `seginfo` record would have to be kept separate somehow, and triggers for \"hold\" versus \"final\" lists would have to be kept separate. I can think of ways to encode two extra bits of information in the current record, but the ways I see are too ugly unless this seems like a crucial issue.\r\n\r\nThe documentation update is minimal. It's unlikely to be a good specification of ordered finalization, and it certainly doesn't get across the pitfalls and intended use of ordered finalization.\r\n In the case of weak and ephemeron pairs, I concluded that weak references shouldn't count against ordered finalization. I'm not 100% certain of that choice (or anything else about finalization), and it makes some applications that I have in mind more difficult, but it seems workable. Meanwhile, having weak references prevent finalization doesn't seem like it would work in my application, because ordered-finalized objects will typically reside as keys in a weak hashtable.\r\n\r\nI didn't think of the problem with sweep and forwarding. A shortcut of not copying+sweeping for objects that contain only non-ptr values would likely cover most applications that I have in mind. It turns out that the fragile situation goes wrong if a pair's `car` refers back to the pair. The forwarding mark gets overwritten with the forwarded pointer for the `car`, while the `cdr` has been modified to the forwarded pointer. In the end, an extra pair is created, and a weak reference can see the wrong copy.\r\n\r\nI think maybe a pair is the only object that can go wrong that way, but the new commit tries to resolve the fragility more generally. Instead of making a copy of the object, sweep_in_old() scans for immediate self-references, and it just copies the object normally if it finds any. Only if the object is free of immediate self references, it continues on to sweep().\r\n\r\nThe duplication of the sweep() dispatch is a little awkward, but seems ok to me. I'm less happy with the duplication of seep_record(), but maybe it's ok. Handling threads seemed like too much work and unlikely to be useful, so sweep_in_old() just treats every thread as referring to itself. Rebased.\r\n\r\nThis implementation of ordered guardians has worked well for Racket-on-Chez. Racket's drawing and GUI libraries particularly rely on ordered finalization to ensure that resources are safely deallocated, and ordered guardians have worked as expected over the past year.  I'm not sure about this, and I'm not sure if this is the correct fix ...\r\n\r\nIf I run \r\n\r\n    (expand/optimize \r\n     '(if (zero? (random 37))\r\n        (pariah (display \"green\"))\r\n        (void)))\r\n\r\nI get \r\n\r\n    (if (#2%zero? (#2%random 37))\r\n        (#2%display \"green\")\r\n        (#2%void))\r\n\r\nbut I expect something like\r\n\r\n    (if (#2%zero? (#2%random 37))\r\n        (begin\r\n          (pariah (void))\r\n          (#2%display \"green\"))\r\n        (#2%void))\r\n\r\nThe problem is that `(pariah)` is marked as `simple?` and it's removed from the `begin` sequence.\r\n\r\nThis change breaks the reduction of\r\n\r\n    (expand/optimize \r\n     '(if (zero? (random 37))\r\n       (pariah (void))\r\n       (void))) Done. I added a test.  This reduces \r\n\r\n    (#3%void x (vector 1 2) (newline) y) ==> (begin (newline) (void))\r\n\r\nThis can be useful to mark `x` and `y` as unused and avoid allocating the `vector`.\r\n\r\nI was not sure if it\u2019s necessary to add tests, and in which file to put them.\r\n\r\nI enabled it only for the optimization level `3` because otherwise it would reduce\r\n\r\n    (#2%void (values 1 2)) ==> (void)\r\n\r\n I was confused because Racket has an extended version of `void` that just ignores its arguments. It's sometime handy in the RELP to ignore the result of an expression.\r\n\r\n    (void (time (+ 1 2 3)))\r\n\r\nAnyway, it's not very incredible useful, so I think it's better to make no change.  gcc 7 has a new warning: `-Wimplicit-fallthrough`. When coupled with `-Wextra -Werror`, this warning breaks the build. @dybvig done.\r\nI dropped the changes to non-linux makefiles. As this warning is only in gcc7, and pre 4.4 gcc will also issue a warning for unknown flags, I decided to not include it for all architectures that might possible use gcc.  The code below sometimes raises an invalid memory reference when run on a6nt, a6osx, and a6le:\r\n```\r\n(current-eval interpret)\r\n(run-cp0 (lambda (cp0 x) x))\r\n(do ([n 2000 (- n 1)] [ls (iota 2000)])\r\n      ((= n 0))\r\n    (map (lambda (x) (let ([x (exact (sqrt -2.0))]) x)) ls))\r\n```\r\n\r\nI distilled this example from a mat that fails occasionally.\r\n\r\nIt does not happen on i3nt, so the bug may be related to the x86_64 code generator. @dybvig: I would like to pull the date-dst? request, but there's no need to do the bootfiles twice. Can you rebase your fix onto the first commit of the date-dst? request, then make the fix, and rebuild the boot files?  The return value is marked as `fixnum`, but it should be `boolean`.\r\n\r\n(I'm not sure if it is necesary to recalculate the bootfiles.)  This commit adds a way to store line and column information explicitly, instead of reconstructing it from a position by re-reading the file. Specifically a file-position object \u2013 which combines a position, line, and column \u2013 can be used in place of a position integer in functions like `make-source-object`.\r\n\r\nThe intent is to add line and column options without affecting existing code. It's not a completely backward-compatible change, because `source-object-bfp` and `source-object-efp` functions can now return file-position objects instead of integers, but they won't show up unless some new function is used.\r\n\r\nWhen `locate-source` receives a file-position object in place of a position integer, then it doesn't try to consult a file in the filesystem, and just returns the file-position object's line and column. \r\n\r\nThe changed include a new `record-source-lines-and-columns` that causes `compile-file` and other tools to record line and column information instead of just positions. That works by collecting position-to-line information at the same time as computing the file checksum, and the position-to-line table is kept as part of the source-file descriptor. The `make-source-object` function maps a position to a file-position object when the table is present. A `source-file-descriptor-lines-done!` function drops the table, and it's called automatically by `read-datum/annotations`. Maybe there's a better way to do all that. In fact, for my purposes, it's not so important to have something like `record-source-lines-and-columns` at all, but I wanted to try to make the new functionality generally available, and I do use it a little in my current Racket prototype.\r\n\r\nFinally, inspectors for code and continuations support a new `'source-object` message to return the source object directly, instead of sending it through `locate-source`.\r\n Thanks a lot! This is a feature I have been craving. I tried to build this but it seemed to get into an infinite loop. @rain-1 You'll need to use a regular Chez Scheme build to bootstrap this one. Here are some instructions (based on instructs from Kent) that I've been meaning to turn into a PR as a patch `BUILDING`:\r\n\r\n```\r\nBOOSTRAPPING VIA CROSS COMPILATION\r\n\r\nTo build a change that is not compatible with existng Chez Scheme\r\nbuilds, you will need to build in cross-compilation mode. Start with a\r\nbuild from unadulterated sources in $ORIG on machine type $M. Then, in\r\nthe modified source tree:\r\n\r\n  ./configure\r\n  (cd $M/s && make -f Mf-cross m=$M xm=$M base=$ORIG/$M)\r\n  (cd $M/c && make)\r\n  (cd $M/s && make allx)\r\n```\r\n\r\nOne reason I've never gotten around to a PR is that it may be better to add a target to the main `Makefile`, and I'm undecided on that myself. Any of those choices work for me, although I like least the choice of requiring both start and end to have lines and columns, because an ending line and column doesn't seem useful to me. The Racket API is position+line+column+span (and an ending position works well enough in place of a span).\r\n\r\nIf we don't have the requirement of keeping old things the same size, then I think adding a starting line and column to the `source` record type is the way to go. The current implementation causes my example \".so\" files to grow by about 5% (when keeping inspector information), and I expect that adding two fields to `source-object` would be more compact.\r\n\r\nAny of the choices is also an easy change, if you're comfortable with the extra argument to `make-source-file-descriptor` and the way `source-file-descriptor-lines-done!` works. Here's another direction (not yet carefully tested) for your consideration:\r\n\r\n * Keeps file-location objects, so space is the same as before without lines and columns.\r\n\r\n * Gets rid of `record-source-lines-and-columns`, `source-file-descriptor-lines-done!`, and the tasteless and problematic state in source-file objects.\r\n\r\n * Adds `current-locate-source` and `current-make-syntax-object`, which the system uses in place of calling `locate-source` and `make-syntax-object` directly, and whose initial values are `locate-source` and `make-syntax-object`.\r\n\r\nThis implementation does not add caching for `locate-source`. I don't know how to do that and remain consistent with the idea that `locate-source` tells you whether the source file has changed.\r\n\r\nThe `current-locate-source` parameter lets a program disable the system's on-demand computation of lines and files. I find that control appealing, because I worry about system operations trolling through the filesystem in a final application. Meanwhile, `current-locate-source` could be set at compile time to cache files being compiled, or `current-make-syntax-object` could be set to compute line and column information eagerly while the reader constructs annotations.\r\n On `locate-source` and caching: I had imagined that the current setup was designed to handle the case that you you compile a file, start debugging it (without doing enough work to trigger a GC), modify the file, and then use the inspector to view source information. If you're ok with the inspector reporting a bad line and column in that case, then it's fine with me.\r\n\r\nOn the filesystem and final applications: Maybe the issue here is \"final application\". I had in mind one that could use `eval`, which could trigger the compilation of a `define-values` form, which could trigger the use of `locate-source` (on a source that was recorded during the compilation of the application and through `syntax->datum` applied to the evaluated form). I could arrange for Racket to never include `define-values` in its output, but I worry that some other form that Racket uses may change to use `locate-source` in the future. Racket could also avoid source objects that have only positions, but since Racket allows source locations at its own layer to just have positions, it's clumsy at best to encode that in a file-position object. Our users have had trouble with the interaction of slow filesystems and unexpected filesystem operations, and we get bug reports when the distribution contains or accesses paths that it shouldn't. A parameter to disable filesystem access in `locate-source` would avoid complicated questions in a simple and reliable way. The new commit adds caching in `locate-source`. I'm not sure the way I connected cache clearing to a maximum-generation GC is the way you had in mind.\r\n\r\nHere's a program I tried for checking the performance effect of `current-make-source-object` on the reader: https://gist.github.com/mflatt/36b7f5f927b50460ea4369d83e5d56f2 . On my machine, that program runs in about 7.7 seconds with the current Chez Scheme and about 7.9 seconds with this PR \u2013 so a slowdown on the order of 3%. Uncommenting out the parameter adjustment (which means that every source-object constructor goes through an indirection with argument validation) makes it run in about 8.3 seconds, but that kind of penalty happens only when `current-make-source-object` is adjusted. I'm hoping that `read-datum` is generally used to read programs, where expansion and compilation time will be much more than reader time, so that 3% will be ok. Still, it's the least-important part of the PR for my purposes. Well, there are test failures in \"6.ms\". I think the two tests fail because the new cache records a relative path for an `sfd` based on one search, and then the same relative path is used after the directory changes... so, more work there, but only if this is an acceptable direction overall. The new commit makes the cache record state used to find a file, and it discards the cache entry if the state doesn't match. With that repair, the tests pass. If I understand the source-file locator suggestion, then I don't think it works. Annotations contain source objects that become arguments to `locate-source`. A source object shouldn't contain a source-file locator, because that would just take us back to the problem of having a line table in an annotation.\r\n\r\nMy reasoning on the potential cost of `current-directory` was that it's cheaper than reading a file and would at least resolve the current potential quadratic behavior. And there's the `current-locate-source` parameter if an application needs something different.\r\n\r\nAnother thought on the cost of `current-make-source-object`: Is it worth reserving a tc slot for the parameter, which I imagine would make lookup even faster? Or is the cost more likely in the indirection through `$make-source-object`? I'm still missing something. The particular case I have in mind is the call to `locate-source` in the expansion of `let-values`. I can see how `let-values` expansion could reasonably pass a true value of `ok-to-cache?`, but I don't see where a locator object would live for `let-values` to use. The new commit adds a `use-cache?` argument to `locate-source`. Good point! I'll adjust the table representation. I squashed the commits to make the overall diff easier to see (and I can revert if squashing is unhelpful), but there's still a \"patch.ss\" change to revert. Here's another try at the API [edit: as suggested in the original feedback!]. Instead of adding file-position objects, this version adds optional beginning-file-line and beginning-file-column components to a source object. This approach is more compatible with existing code, avoids a new \"file-position object\" concept, and simplifies source-object construction using a line and column. It doesn't support an ending line and column.\r\n\r\nInternally, the variant with line and column components is a subtype of the one without. New `source-object-bfl` and `source-object-bfl` accessors each get a value of a new component, returning #f if the value is not present. [Possible issue: copying/adjusting a source object would be a little tedious, since `make-source-object` doesn't accept #f as a line or column.]\r\n\r\nTo help the compiler, etc., use the new optional components, the function bound to `current-locate-source` does not accept the same arguments as `locate-source`. [Possible issue: maybe `current-locate-source` should have a different name.] Instead, the parameter's function accepts a source object (not an sfd), a boolean for `start?` to indicate whether a start or end position is wanted, and a boolean for `cache?`. If `start?` is true and the source object has sfl and sfc components, the default function for `current-locate-source` returns those components with the sfd path without searching; otherwise, `locate-source` is used. This worked out, because all existing calls to `(current-locate-source)` have a source object on hand.\r\n\r\nThis commit also implements `$current-mso` as suggested.\r\n\r\nThe current commit is set up to simplify cross-compilation. There are several `UNPATCHME`s to clean up after bootstrapping. I added `locate-source-object-source` and renamed the parameter to `current-locate-source-object-source`, although those names seem long.\r\n\r\nHaving the parameter's procedure take a source object is intended to allow control over the way that recorded information and the filesystem are used, since there are many reasonable choices that depend on the application. For example, an application might want to use a recorded line and column but still perform a search for the file path. Leaving out the `use-cache?` argument would mean that the inspector uses the cache, too, which would be a change; some tests in \"6.ms\" (around line 2600) would fail, I think. In that case, the tests would have to change, or the inspector would have to avoid `current-locate-source-object-source`. I recommend keeping `use-cache?`, but the behavior of that corner doesn't matter to me, so I'll go with whatever you prefer.\r\n\r\nI don't have strong opinions on the name for [`current-`]`locate-source-object-source`. FWIW, `current-source-`[`object-`]`location` seems misleading as a replacement for `current-locate-source-object-source` (since it sounds like a parameter that holds a source location, instead of a function to find a location), and I like keeping `locate` in the name to connect it to `locate-source`. But I'd be happy to change to whatever name seems best to you. Thanks for the repairs and other improvements! I think the latest commit gets them all. For (2), I opted for an additional argument, even though the new argument and `prefix?` are correlated.\r\n\r\nIf it's otherwise ok, let me know if you'd like the commits squashed and/or bootfiles added with `UNPATCHME`s removed. I have just one fix to the fixes:  the semicolon after `relocate(&CURRENTMSO(tc))` is unnecessary, if harmless.\r\n\r\nOtherwise, this looks good, so please go ahead and squash, create bootfiles, and remove the patches.\r\n\r\n\r\n\r\n Done  Not a high priority, but would be nice to have if it seems like a good idea: Expose zlib's compress() and uncompress() API as `bytevector-compress` and `bytevector-decompress`.\r\n\r\nThis is useful to Racket, because compiled code is written via `compile-to-port` to a bytevector. With this commit, the resulting bytevector can be compressed and decompressed without going through a file.\r\n I think adding a size to the start of the result of `bytevector-compress` is a good idea. I was originally trying to more directly reflect the underlying function, but having the size built-in would certainly work better in my one use case so far.\r\n\r\nThe `compressBound` function looks handy, and I'll switch to that. Oddly, the documentation that I found for `compress` gives the formula in the code instead of pointing to `compressBound` (which is in the same set of docs). Updated as suggested. Ok - done!  Does not prevent binary creation, the program seems to work as intended but this does not look good.\r\n```\r\n$ make -j2\r\nmake[3]: warning: jobserver unavailable: using -j1.  Add `+' to parent make rule.\r\nException in $fasl-file-equal?: code comparison failed while comparing ../boot/ta6le/sbb and ../boot/ta6le/petite.boot within fasl entry 103\r\nmake[4]: *** [checkboot] Error 255\r\n```\r\n If that is the case, boot files provided by the stable release source package (v9.4, since initial commits apparently) are outdated. The error does not seem to appear after compiling it once, having \"bootfile comparison succeeded\" at the end of the build, to which I assume that is because new bootfiles are compiled. The only way to reproduce that was through `make distclean; ./configure --threads; make`.\r\nIf that behaviour is expected (new bootfiles compiled for the binaries), this issue should be closed, and apologies for wasting your time. Build logs attached, number at the beginning indicates the order.\r\n\r\nOS: CentOS 7.3.1611 x86_64\r\nKernel: 3.10.0-514.26.2.el7.x86_64\r\n`gcc -v\r\nUsing built-in specs.\r\nCOLLECT_GCC=gcc\r\nCOLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper\r\nTarget: x86_64-redhat-linux\r\nConfigured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux\r\nThread model: posix\r\ngcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) \r\n`\r\n[1 - fresh compilation.txt](https://github.com/cisco/ChezScheme/files/1157236/1.-.fresh.compilation.txt)\r\n[2 - make distclean.txt](https://github.com/cisco/ChezScheme/files/1157234/2.-.make.distclean.txt)\r\n[3 - make clean.txt](https://github.com/cisco/ChezScheme/files/1157235/3.-.make.clean.txt)\r\n I finally understand this issue after looking through your `make distclean.txt` attachment.  Yes, this is expected behavior.\r\n\r\nThe bootstrap process generally requires two runs to produce equivalent boot files.  The first run uses the pre-compiled compiler and run-time system in the distribution boot files to compile the compiler and run-time system sources into the first set of new boot files, and the second run uses the freshly compiled compiler and run-time system in the first set of new boot files to compile the sources into the second set of new boot files.  The first set of new boot files is generally not equivalent to the boot files in the distribution, hence the (ignored) boot-file comparison exception you noticed midway through the build.  On the other hand, the second set of new boot files is usually equivalent to the first set of new boot files, hence the overall success of the build.\r\n\r\nThe boot files in the distribution are produced via a cross-compiler.  The cross compiler is compiled with different compiler options that can result in evaluation order differences within the compiler that in turn result in harmless differences in code layout within the boot files.  When the host and target machines differ, the cross-compiler also produces larger and less efficient code due to the disabling of some machine-dependent optimizations.  This is why the first set of new boot files are generally not equivalent to the boot files in the distribution.  Extend the reductions for `map` and `for-each` when the arguments are\r\nexplicit lists like `(list 1 2 3 ...)` or `'(1 2 3 ...)`.\r\n.  cp0.ss 4.ms\r\n\r\nThis has many tweaks here and there, but they are too much interrelated to split this naturaly in a few smaller commits. \r\n\r\n\r\n--- The idea is to extend the reduction for expressions like\r\n\r\n    (map + (list 1 2) (list 3 4))\r\n\r\nto expressions like\r\n\r\n    (map + (list 1 2) '(3 4))\r\n\r\nI have to change the order of some optimizations. In expressions like the former, cp0 first try to inline the lists and if that failt then it tries to inline the implementation of `map` for short list with up to 4 items.\r\n\r\n--- Also, when `map` tries to detect a short list, the optimization will be able to calculate the lenght of list like `(list 1 2 3)`, instead of only list like `'(1 2 3)`. This extend the reductions for expressions like\r\n\r\n    (map + (begin (something) '(1 2 3)) another-list)\r\n\r\nto expressions like\r\n\r\n    (map + (begin (something) (list 1 2 3)) another-list)\r\n\r\n--- I made similar changes to `for-each`. In particular for-each had a reduction for quoted short lists that is extended to list defined with list. \r\n\r\n--- And I added a reduction for expressions like\r\n\r\n    (for-each something (list 1 2 3 ...) '(1 2 3 ...))\r\n\r\nI just used the internal function `inline-lists` with a flag to signal if it is used in a map or a for-each. In a `for-each` it is not necesary to calculate all the `cdr` initially, but using the implementation that is used for `map` avoids creating the list, and in many times the values can be propagated.  \r\n 4 - indentation: Fixed\r\n\r\n2 - `safe-assert`/`(list)`: I added the code in `null-rec?`. I hope the comment is fine.\r\n\r\n3 - more test: I added a few combinations with `map` applied to expressions with side effects with `(list \u2026)` and `\u2018(\u2026)`. \r\n\r\nI also added similar mats with `for-each`. I used a `lambda` with a side effect to ensure that the side effects of the arguments are run before the side effect of the lambda, and to avoid too smart optimizations that remove the whole application. I\u2019m not testing the result of the `for-each`.\r\n\r\nBut I\u2019m not sure if the application order in a `for-each` is guaranteed in Chez Scheme. For example, is this possible?\r\n\r\n    (for-each display \u2018(1 2 3 4)) ; ==> 2 1 4 3\r\n\r\nOne possible fix is to add in each mat all the possible results, so they will pass in possible any application order of the `lambda`. Another possibility is to remove the side effect. And a third possibility is to test both behaviors.\r\n\r\n1 - check long quoted lists: I added a check to avoid the expansion when all list are quoted and they have more than 4 elements. I don\u2019t like the idea of the 4 element threshold too much, because this transformation may enable more reductions than the other cases. In the other cases the code must still build the list so it\u2019s not possible to propagate the values at compile time. Anyway, there are a few bad examples without the threshold like\r\n\r\n    (let ([l \u2018(1 2 3 ... 100)])\r\n      (for-each display l)\r\n      (for-each display l)\r\n      (for-each display l)\r\n      (for-each display l)\r\n      (display l))\r\n Do you think I have to fix something or you are planning to merge this as is? The tests already check the official behavior.  I was sure that the optimization didn\u2019t change the order of the applications. Anyway, I have read it again and double checked just in case. It is ok.\r\n\r\nThe tests assumed no reorder of the application too. (I asked because I was unsure if the tests were too strict.) They are ok too.\r\n I looked at the fix and now I understand the error. I made an easy example to see it:\r\n\r\n    (#3%for-each (lambda (x y) (display '!))\r\n                 (list (display 'a) (display 'A))\r\n                 (list (display 'b) (display 'B)))\r\n\r\nBad output: `Bba!A!`\r\n\r\nCorrect output: `aAbB!!`, `AabB!!`, `BbAa!!`, (8 posibilities) \r\n  Here's a first cut (no documentation or tests) to add ephemerons:\r\n\r\n  * `(make-ephemeron key value)` makes an ephemeron that holds `value` only as long as `key` is reachable, where `value` doesn't count as reachable from the ephemeron until `key` is otherwise determined to be reachable\r\n\r\n * `(ephemeron-value eph)` returns either the value or `#!bwp`, where a value goes to `#!bwp` when the key is unreachable, even if the value is otherwise still reachable\r\n\r\n * `(ephemeron-key eph)` returns either the key or `#!bwp`; the key and value go to `#!bwp` at the same time\r\n\r\n * `(ephemeron? v)` reports whether v is an ephemeron\r\n\r\nRacket does not provide an `ephemeron-key` operation, and I doubt that it's useful, but it seems harmless. The other functions match Racket, which explains the `make-` on the front of `make-ephemeron`, except that Racket uses `#f` in place of `#!bwp`.\r\n\r\nThe implementation includes a new type tag for ephemerons and a new space (since the sweep action is special).\r\n\r\nThe GC change avoids quadratic-time ephemeron processing by registering each discovered ephemeron with the segment that contains its key, if the key has not been determined to be reachable already. The second part of https://gist.github.com/mflatt/1fd3015539f9a571fee429d59799e347 sets up an example that would exhibit quadratic-time behavior, otherwise.\r\n\r\nTriggering ephemerons requires that copy() check the old-space segment for each object. This extra check on every copy() is not measurable in my tests so far. Where copy() used to take a space-kind argument, it now takes a space-info argument \u2014 which was always computed to get the space-kind argument, so I think that part of the change has no effect by itself.\r\n\r\nAn ephemeron is allocated with room for two extra pointers that are used at GC time: one for a list of a all discovered ephemerons, and one for a segment-specific list to trigger. Having the extra pointer space in the object is convenient, but I wonder whether it's better to allocate those administrative lists separately during collection.\r\n Thanks for working on this.  If successful, it might be a useful substitute for weak pairs in weak eq hashables, which probably should probably have ephemeron-like behavior.\r\n\r\nTo that end, do you think it would be possible to make ephemerons a kind of pair, like weak pairs?  Extra fields should be okay, if needed.  gc support for mutable ephemerons could be tricky.\r\n\r\nIncidentally, I just glanced at the first couple of diffs, and I noticed that faslin uses INITCAR and INITCDR to initialize fields of an ephemeron.  I don't think that will work (unless ephemerons become pairs) so I'm guessing it hasn't been tested.\r\n\r\nI'll look closer at the code when I get a chance. I initially considered making ephemerons like weak pairs, with the key and value as being `car` and `cdr`, respectively. That didn't seem useful in the same way as weak pairs, though, since you generally wouldn't want to put a chain in the value part of an ephemeron. Maybe you have a different arrangement in mind, with the value in the `car` part, something strongly held in the `cdr` part, and the key in an additional field?\r\n\r\nI also had in mind that Racket distinguishes ephemerons from other datatypes, and so having a Chez-level empheron respond #t to `pair?` is inconvenient. That's a Racket-specific issue, though.\r\n\r\nYou're right, of course, that I didn't test the fasl part, yet. Hashtables in Chez Scheme store the key and value in the car and cdr of a pair.  In this case, the cdr is not used to chain list elements.  For weak eq hashtables, the pair is a weak pair.  We could instead have the pair be an ephemeron, at least optionally, if ephemerons are pairs (needed for `hashtable-cell`).\r\n\r\nWeak pairs are pairs, but they can be distinguished via the weak-pair? predicate.  We could do the same for ephemerons.  weak-pair? a slow predicate, however, since it has to index into the segment table.  It also involves a foreign procedure call, though we could fix that. I forgot that Chez Scheme hashables expose the implementation's use of pairs though `hashtable-cell`, so now I understand the motivation for making ephemerons a subtype of pairs.\r\n\r\nI'll revise the PR to make the additions just `ephemeron-cons` and `ephemeron-pair?`.\r\n\r\nI don't immediately see an obstacle to making ephemerons mutable, except that a kind of race condition with the GC can leave you with a half-`#!bwp`ed pair. Did you have different problem in mind?\r\n\r\n(To distinguish Racket-level ephemerons from pairs, I guess Racket will just introduce an extra record wrapper \u2013 the same as for weak boxes implemented with weak pairs.) Okay, after thinking about the ephemeron gc problem a bit, I expected to see something like this in the code:\r\n\r\nA. When sweeping an ephemeron in sweep() or sweep_space(), two cases:\r\n\r\n  1. If the key is not oldspace or is oldspace and has been forwarded, relocate both the key and the value.\r\n\r\n  2. Otherwise, associate the ephemeron with the key in a key->ephemeron table (implemented, say, as a hashtable)\r\n\r\nB. After copying any non-flonum object in copy(), relocate the keys and values of all ephemerons associated with the object in the key-ephemeron table, and remove the associations from the table.\r\n\r\nC. At the end of collection, \"bwp\" the key and value of any empheron present in the key-ephemeron table.\r\n\r\nI'm probably missing something I might spot if I actually tried to implement it, but I think I see this basic structure in your code.  It looks like your code treats the segment-info structure as a coarse form of hashtable key, in effect, and that (perhaps because of this) it handles emphemerons in batches at the end of each sweep_space loop.  It also seems like the table might contain emphemerons for which the key has already been forwarded, and for this you need the trigger-next = #t flag.  Is that about right?\r\n\r\nUsing the segment-info structure in this way is clever, but I wonder if it is sufficient to eliminate all pathological behavior.  The copy() check for the presence of a list in si is less overhead than a hashtable lookup, but we might be able to make a hashtable lookup reasonably inexpensive in the common cases (once we figure out what those are).\r\n Nobody should be mutating a pair during collection unless it's locked and being mutated from C code, in which case I'm not too excited about it.   The real problem is dealing with wrong-way pointers in `sweep_dirty` and an analogue of `resweep_dirty_weak_pairs`, though we might get away without the latter. The revised commit changes the API to `ephemeron-cons` and `ephemeron?`.\r\n\r\nThe GC implementation is essentially as before. You're right that the\r\nsegment-info structure is acting as a coarse hash table, and so on. I\r\nbelieve the worst-case complexity here is proportional to the square of\r\nthe number of objects M in a segment --- but I also expect that\r\nworst-case time to be both unlikely and less than the total number of\r\nobjects, and using a per-segment trigger list minimizes the constant\r\nfactor on the number of copied objects. In any case, I'm happy to defer\r\nto your judgment on the GC-time data structures and performance.\r\n\r\nI don't see the need for something like `resweep_dirty_weak_pairs`,\r\nsince the pending list plays a similar role, and ephemeron handling in\r\n`sweep_dirty` seems straightforward, but maybe it's beyond the frontier\r\nof what I've understood.\r\n\r\nThe code at https://gist.github.com/mflatt/1fd3015539f9a571fee429d59799e347\r\nis a step closer to a test suite, including a small initial test for fasl writing and reading. With this third commit to add tests and docs, the pull request is meant to be complete. Great.\n\nweak-cons not weaj-cons ;)\n\n\nOn 01/05/2017 23:21, Matthew Flatt wrote:\n>\n> *@mflatt* commented on this pull request.\n>\n> ------------------------------------------------------------------------\n>\n> In csug/smgmt.stex\n> <https://github.com/cisco/ChezScheme/pull/168#discussion_r114204857>:\n>\n> > +however, the results of the last two expressions will always be\n> +\\scheme{(a . b)}, because the cdr of a weak pair holds a non-weak\n> +reference, and that non-weak reference prevents the car field from becoming\n> +\\scheme{#!bwp}.\n> +\n> +%----------------------------------------------------------------------------\n> +\\entryheader\n> +\\formdef{ephemeron-pair?}{\\categoryprocedure}{(ephemeron-pair? \\var{obj})}\n> +\\returns \\scheme{#t} if obj is a ephemeron pair, \\scheme{#f} otherwise\n> +\\listlibraries\n> +\\endentryheader\n> +\n> +\\schemedisplay\n> +(ephemeron-pair? (ephemeron-cons 'a 'b)) ;=> #t\n> +(ephemeron-pair? (cons 'a 'b)) ;=> #f\n> +(ephemeron-pair? (weaj-cons 'a 'b)) ;=> #f\n>\n> Thanks!\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/pull/168#discussion_r114204857>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AI2neFlZVFHynvQenYsC85aESikZT4a5ks5r1kz1gaJpZM4NEOwk>.\n>\n\n I made the first two changes (the easy ones), rebased, and included a\r\ncommit for bootfiles. I can squash the commits, especially the\r\nnon-bootfile ones, if you'd prefer.\r\n\r\nI didn't make the third change. I think the indirection through\r\n`pending_ephemerons` makes the GC perform less work in the common case\r\n--- but probably not enough to matter. As one example, when running the\r\nRacket expander to load `racket/base`, ephemerons are used for weak\r\nhashtables (as now built-in):\r\n```\r\n ephemerons found         183,173\r\n dirty ephemerons found:    6,752\r\n\r\n ephemeron checks:        191,617 [i.e., how many times a key is checked]\r\n\r\n triggers installed:       81,434\r\n triggered lists:             192\r\n triggered ephemerons:      1,500 [i.e., ephemerons in those lists)\r\n```\r\nIf I remove the indirection through `pending_ephemerons`:\r\n```\r\n ephemerons found         183,220\r\n dirty ephemerons found:    6,576\r\n\r\n ephemeron checks:        311,903\r\n\r\n triggers installed:      202,554\r\n triggered lists:          41,077\r\n triggered ephemerons:     81,030\r\n```\r\nSo, an ephemeron can be handled immediately about 1/2 of the time, and\r\nit's rare for a key to become accessible only after following ephemeron\r\nvalues. As a result, the indirection avoids almost all trigger work. If\r\nadding an emphemeron to `pending_ephemerons` requires allocation, then\r\nmaybe it's worth a check for the half that can be handled right away,\r\nbut keeping the indirection for the rest.\r\n\r\nThen again, these are all tiny numbers relative to the overall run:\r\n```\r\n    643 collections\r\n    8.641620000s elapsed cpu time, including 1.805889000s collecting\r\n    8.663434000s elapsed real time, including 1.811093000s collecting\r\n    5438378944 bytes allocated, including 5347986480 bytes reclaimed\r\n```\r\nThe gist stress test intentionally creates chains through ephemerons,\r\nand then `pending_ephemerons` has no effect (as expected).\r\n Forgot to revert \"patch.ss\", now done in the bootfiles commit. My limited understanding of the context for `check_dirty_ephemeron` was that it needs to decide on a `youngest` result immediately. The more eager check lets it sometimes pick a more precise `youngest`. Oh, if the eager check fails, the ephemeron could be put in the pending list instead of added as a trigger. So, yes, I think I made `check_dirty_ephemeron` too much like `check_ephemeron`.  The `fxarithmetic-shift-left` procedure does not detect overflow under some conditions. Here are some comparisons showing that the upper bits of the result are discarded:\r\n\r\n```Scheme\r\nChez Scheme Version 9.4.1\r\nCopyright 1984-2017 Cisco Systems, Inc.\r\n\r\n> (fixnum-width)\r\n61\r\n> (number->string (fxarithmetic-shift-left #x12 58) 16)\r\n\"800000000000000\"\r\n> (number->string (bitwise-arithmetic-shift-left #x12 58) 16)\r\n\"4800000000000000\"\r\n> (number->string (fxarithmetic-shift-left #xB00000000000000 2) 16)\r\n\"C00000000000000\"\r\n> (number->string (bitwise-arithmetic-shift-left #xB00000000000000 2) 16)\r\n\"2C00000000000000\"\r\n> (number->string (fxarithmetic-shift-left #x-500000000000000 3) 16)\r\n\"-800000000000000\"\r\n> (number->string (bitwise-arithmetic-shift-left #x-500000000000000 3) 16)\r\n\"-2800000000000000\"\r\n```\r\n\r\nTested with master (v9.4-132-g8fbe1b1) on a Debian GNU/Linux 8.7 amd64 system. If you change the shift-count restriction for either, fxsll and fxsrl should behave like fxarithmetic-shift-left and fxarithmetic-shift-right.  The latter are constrained not to allow fixnum-width shifts by R6RS.  fxsll and fxsrl historically allowed fixnum-width shifts, and we didn't change that when adding the R6RS procedures.\r\n\r\nThe requirement to produce &implementation-restriction on fixnum overflow is mentioned in the introduction of TSPL Section 6.5 and also in the introduction of the R6RS library document Section 11.2. Thanks, I didn't change the limits for the shift operators but fixed the overflow detection. Fixed in commit f286688b64f877248ab8d8f00528d19363c6ceba  When I was trying to send a fixnum to a procedure created by enum-set-indexer, I got an exception: \"invalid memory reference. Some debugging context lost\". I know send a number to this procedure is incorrect, but exception won't happen when I send `bignum`, symbols, strings or other objects to this procedure, so it may be a bug?\r\n\r\nThe version of Chez Scheme is 9.4.1, running on macOS.\r\n\r\n```scheme\r\n(define e (make-enumeration '(a b c d)))\r\n((enum-set-indexer e) 1111111111111111111111111111111111111) ;=> #f\r\n((enum-set-indexer e) 1) ;=> error\r\n```\r\n\r\n Fixed in 5df52745d793eb5a16cb6e55065f78f313170ed5  I am trying to cross-compile Chez Scheme on my Lenovo tablet running termux (a unix-like environment), with help on Google Groups from Atticus and Andy Keep. I performed the following steps:\r\n\r\nStep 1: On the host machine (an i3 desktop running Linux Mint)\r\n\r\n    cd # /home/phil\r\n    git clone https://github.com/cisco/ChezScheme.git\r\n    cd ChezScheme-master\r\n    ./configure\r\n    sudo make install\r\n    mkdir boot/arm32le\r\n    cd a6le\r\n    make -f Mf-boot arm32le.boot\r\n    cd ..\r\n    ./configure -m=arm32le\r\n    ./configure --workarea=arm32le\r\n    cd arm32le/s\r\n    make -f Mf-cross m=a6le xm=arm32le base=../../a6le\r\n    cd ../../..\r\n\r\n\r\nStep 2: On the target machine (a Lenovo ARM tablet running Android 5)\r\n\r\n    cd # /data/data/com.termux/files/home\r\n    scp -r phil@haydn:/home/phil/ChezScheme-master/ .\r\n    edit file ChezScheme-master/configure\r\n        change /bin/sh to /data/data/com.termux/files/usr/bin/sh\r\n    edit file ChezScheme-master/zlib/configure\r\n        change /bin/sh to /data/data/com.termux/files/usr/bin/sh\r\n    cd ChezScheme-master/arm32le/c\r\n    make\r\n\r\nWhile performing this step, make encountered three errors, all in file segment.c:\r\n\r\n    at line 350, character 7, symbol build_ptr\r\n    at line 406, character 26, symbol SYMVAL\r\n    at line 406, character 12, symbol Sflonum_value\r\n\r\nThe first two errors were the same:\r\n\r\n    cast to 'ptr' (aka 'void *') from smaller integer type 'unsigned int'\r\n\r\nThe third error was a different message:\r\n\r\n    cast to 'double *' from smaller integer type 'unsigned int'\r\n\r\nThe C compiler is gcc, clang version 3.9.1, target aarch64--linux-android, thread model posix.\r\n\r\nPlease help me compile Chez Scheme. It sounds like you're building the boot and header files for 32-bit (arm32le) and the c directory for 64-bit.  If you mean to build the 32-bit version, you might need to supply the -m32 option to the C compiler. Success build chez on android arm works for me.\r\nLOCAL_ARM_MODE := arm\r\nLOCAL_CFLAGS += -g -Wall -DANDROID    -DINLINES -DGC_MACROS -DARMV6  -Wpointer-arith -Wall -Wextra  -DLIBICONV_PLUG -fPIC -pie -fPIE\r\n[scheme-release-1.2.apk](https://raw.githubusercontent.com/evilbinary/scheme-lib/master/data/apk/scheme-release-1.2.apk)\r\n\r\n I added a line\r\n\r\n        CFLAGS = -m32\r\n\r\nnear the top of ChezScheme-master/arm32le/c/Makefile (above the line that defines C), and received the same three errors. What does your C compiler report as it's target now that CFLAGS is set to\ntarget a 32-bit machine?  (In your original email you indicated it was\ntargeting aarch64--linux-android, which is definitely a 64-bit\narchitecture).\n\n-andy:)\n\n\n\nOn April 23, 2017 at 8:12:44 PM, pbewig (notifications@github.com) wrote:\n\nI added a line\n\n    CFLAGS = -m32\n\nnear the top of ChezScheme-master/arm32le/c/Makefile (above the line that\ndefines C), and received the same three errors.\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\n<https://github.com/cisco/ChezScheme/issues/163#issuecomment-296499182>,\nor mute\nthe thread\n<https://github.com/notifications/unsubscribe-auth/AAG5r4RbyUXuAlji14X4xgCOKGkPxfzgks5ry-jqgaJpZM4M-xN8>\n.\n When I perform 'make' with the provided Makefile, as I did before my first message, I get the following error:\r\n\r\ngcc  -Wpointer-arith -Wextra -Werror -O2  -c -DARMV6 -I../boot/arm32le -I../zlib segment.c\r\nsegment.c:350:7: error: cast to 'ptr' (aka 'void *') from smaller integer type 'unsigned int'\r\n      [-Werror,-Wint-to-void-pointer-cast]\r\n  if (build_ptr(base, 0) == addr && base + nact != ((uptr)1 << (ptr_bits - segment_offset_bits)) - 1)\r\n      ^\r\n./types.h:109:25: note: expanded from macro 'build_ptr'\r\n#define build_ptr(s,o) ((ptr)(((uptr)(s) << segment_offset_bits) | (uptr)(o)))\r\n                        ^\r\nsegment.c:406:26: error: cast to 'ptr *' (aka 'void **') from smaller integer type 'unsigned int'\r\n      [-Werror,-Wint-to-pointer-cast]\r\n    (iptr)(Sflonum_value(SYMVAL(S_G.heap_reserve_ratio_id)) * S_G.number_of_nonstatic_segments);\r\n                         ^\r\n../boot/arm32le/equates.h:758:22: note: expanded from macro 'SYMVAL'\r\n#define SYMVAL(x) (*((ptr *)((uptr)(x)+5)))\r\n                     ^\r\nsegment.c:406:12: error: cast to 'double *' from smaller integer type 'unsigned int'\r\n      [-Werror,-Wint-to-pointer-cast]\r\n    (iptr)(Sflonum_value(SYMVAL(S_G.heap_reserve_ratio_id)) * S_G.number_of_nonstatic_segments);\r\n           ^\r\n../boot/arm32le/scheme.h:101:29: note: expanded from macro 'Sflonum_value'\r\n#define Sflonum_value(x) (*((double *)((uptr)(x)+6)))\r\n                            ^\r\n3 errors generated.\r\nmake: *** [Makefile:29: segment.o] Error 1\r\n\r\nThen when I add a line 'CFLAGS = -m32' to the Makefile, I get exactly the same error, as if CFLAGS is not recognized, and in fact that appears to be the case, since the gcc line at the top of the output does not include the -m32 flag. Next I removed the 'CFLAGS = -m32' line and wrote the -m32 directly in the definition of the C variable. Here is the output of that command:\r\n\r\n$ make\r\ngcc -m32  -Wpointer-arith -Wextra -Werror -O2  -c -DARMV6 -I../boot/arm32le -I../zlib segment.c\r\nIn file included from segment.c:35:\r\nIn file included from ./system.h:25:\r\nIn file included from ../zlib/zlib.h:34:\r\nIn file included from ../zlib/zconf.h:475:\r\nIn file included from /data/data/com.termux/files/usr/include/unistd.h:34:\r\nIn file included from /data/data/com.termux/files/usr/include/sys/select.h:35:\r\nIn file included from /data/data/com.termux/files/usr/include/signal.h:37:\r\n/data/data/com.termux/files/usr/include/asm/sigcontext.h:44:2: error: unknown type name '__uint128_t'\r\n __uint128_t vregs[32];\r\n ^\r\n1 error generated.\r\nmake: *** [Makefile:29: segment.o] Error 1\r\n\r\nI guess that's progress: we've gone from a 64-bit error to a 128-bit error. The result of 'gcc --version', both with and without the -m32 flag, is shown below:\r\n\r\n$ gcc --version\r\nclang version 3.9.1 (tags/RELEASE_391/final)\r\nTarget: aarch64--linux-android\r\nThread model: posix\r\nInstalledDir: /data/data/com.termux/files/usr/bin\r\n$ gcc -m32 --version\r\nclang version 3.9.1 (tags/RELEASE_391/final)\r\nTarget: arm--linux-android\r\nThread model: posix\r\nInstalledDir: /data/data/com.termux/files/usr/bin\r\n\r\nThank you for your assistance.\r\n\r\nPhil I still don't have this working. I upgraded from clang 3.9.1 to clang 4.0.0, but the error remains the same.\r\n\r\nI realize that the error points to something in the compiler, not in Chez Scheme. Do you know a better place to get help? I found an explanation of the problem, but no solution: http://stackoverflow.com/questions/25802724/is-there-a-way-to-use-int128-t-with-the-android-ndk:\r\n\r\n> __int128_t is emulated, and its only available on 64-bit platforms.\r\n> Its not available on Android, which is a 32-bit platform.\r\n\r\nIs there anything I can do? Just define __int128_t to int @pbewig  Android is one of most important platforms now, any plan to support ARMv7 ARM64 @dybvig ?\r\nChez Scheme is a great fit( small and effective ) of script programming on embeded devices. I got Chez Scheme to compile on Android within the GnuRoot environment. See\nhttps://programmingpraxis.com/2017/09/15/compile-chez-scheme-on-android-arm/\n.\n\nOn Mon, Jan 15, 2018 at 3:08 PM, Andy Keep <notifications@github.com> wrote:\n\n> I don't know that we have any particular plans to work on this right now,\n> but we would certainly welcome the effort if someone wanted to take the\n> lead on the porting work.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/163#issuecomment-357789423>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AHZz1q7sMODPyQeyY7k-E1P-DqnkUlD5ks5tK745gaJpZM4M-xN8>\n> .\n>\n @evilbinary: On my android arm tablet, when I say (sqrt 47.9) Chez responds\n6.920982589199311, exactly the same as my desktop computer.\n\nOn Tue, Jan 16, 2018 at 8:09 PM, evilbinary <notifications@github.com>\nwrote:\n\n> @pbewig <https://github.com/pbewig> android arm does not suport floating.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/163#issuecomment-358171869>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AHZz1vgd3G-MelrCuSeKwV68V7gh6dzqks5tLVZngaJpZM4M-xN8>\n> .\n>\n @pbewig  really? did you see this? https://github.com/cisco/ChezScheme/issues/85 @evilbinary: Don't ever doubt me.\n\n[image: Inline image 1]\n\nOn Wed, Jan 17, 2018 at 9:10 PM, evilbinary <notifications@github.com>\nwrote:\n\n> @pbewig <https://github.com/pbewig> really? did you see this? #85\n> <https://github.com/cisco/ChezScheme/issues/85>\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cisco/ChezScheme/issues/163#issuecomment-358524133>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AHZz1k8IBuGzZQBQ9RZWdM-5yUXOBFCDks5tLrYIgaJpZM4M-xN8>\n> .\n>\n https://github.com/racket/racket/commit/e337c65204402ef4faf09f6a848d2d873d0e63a7\r\n  It looks like start_thread fails to process the guardian entries when calling destroy_thread. It appears as though guardians store entries in the current thread context.  If an object is registered with a guardian on a thread that then exits, calling the guardian never results in the objects.\r\n```\r\n(with-interrupts-disabled\r\n (let ([g (make-guardian)])\r\n   (fork-thread\r\n    (lambda ()\r\n      (disable-interrupts)\r\n      (g (list 'a 'b))))\r\n   (sleep (make-time 'time-duration 100000000 0))\r\n   (collect 0 0)\r\n   (g)))\r\n```\r\nThis should return (a b) but returns #f. You're right.  I will implement a fix unless someone beats me to it. Looks good Bob, though it's probably not necessary to set `GUARDIANENTRIES(tc)` to `Snil` before freeing it.  Incidentally, it seems like there is a missing`break;` after `status = 1;`, which you might also want to fix.  running \r\n\r\nchez -- --flag 1\r\n\r\nshould, according to the man page, pass --flag 1 through as (command-line) or (command-line-arguments). but running that at the shell raises\r\n\r\n> chez -- --flag 1\r\nChez Scheme Version 9.4.1\r\nCopyright 1984-2016 Cisco Systems, Inc.\r\n\r\nException in load: failed for --flag: no such file or directory\r\n\r\nI pulled everything from master today, and compiled with --threads --installschemename=chez\r\n\r\n\r\n Thanks for the info. However: this is not very clear in the man page, and should maybe be clarified. Agreed.  I have attempted such a clarification with [this commit](https://github.com/cisco/ChezScheme/commit/a963a4dbc872be084cbe0ede3f7c361bcabedea5). @dybvig That is indeed more clear, but the explanation for \"--\" still says \"pass all remaining command line arguments through to scheme\" (which was what confused me in the first place. I was writing a getopt-long clone and needed to play with the command line interactively). In the perfect world, everyone  would read the whole man-page, but as it is now it is often just a quick fix to look up things on the command line. \r\n\r\nMaybe \"When --program or --script is present, pass all remaining arguments through to scheme\".  The changes look solid to me, with one concern.  If a program registers a mutex or condition object with a guardian and attempts to use the mutex or condition object after retrieving it from the guardian, what happens?  We have a similar issue with file ports, for which we use a similar mechanism.  The port will be closed by the time it's retrieved and an attempt to read from or write to it will cause an exception to be raised.  That bothers me a bit, but not as much as, say, an invalid memory reference or memory corruption. Yes, I think so.  I downloaded zip from https://cisco.github.io/ChezScheme/#get   Extracted it. Following https://github.com/cisco/ChezScheme/blob/master/BUILDING for windows, I installed Wix toolset  and extension for Visual Studio 2015 that I have. cygwin is also installed and in Path. I renamed configure to configure.exe and ran it.  Nothing seems to happen. command shell doesn't do anything. > cygwin is also installed and in Path. I renamed configure to configure.exe and ran it. \r\n\r\nYou don't have to do so. Steps should be:\r\n\r\nUPDATE: It turned out following steps are not required on Git HEAD(see below).\r\n\r\n1. Open \"VS2015 x64 Native Tools Command Prompt\"\r\n2. Start Cygwin **on the \"VS2015 x64 Native Tools Command Prompt\" opened**,  with `c:\\cygwin64\\Cygwin.bat`\r\n3. (At this point, it would be nice to check cl.exe on the path; `which cl` -- \"Native Tools\" should configure `PATH` value for you so you don't have to change `PATH` by yourself)\r\n4. checkout Git repository / extract .zip somewhere and `cd` into it\r\n5. run `./configure` \r\n6. run `make`\r\n\r\nIn a nutshell, you will have to build ChezScheme on Cygwin shell; it does not provide Visual Studio project file. Don't forget installing `make`, `git` and other friends on your Cygwin install. (Step2 should look like this.)\r\n\r\n![snapcrab_noname_2017-4-2_18-9-37_no-00](https://cloud.githubusercontent.com/assets/100813/24585866/8f1f2ac0-17cf-11e7-9d4d-cacc9f8dcd27.png)\r\n Hi,\r\nFirst of all, I have 32-bit system. So I installed Native tools prompt accordingly.\r\n\r\nwhich cl and which make didn't show after Native tools and so I added the bin carrying those to PATH varaible. Even after adding, which cl and which make did't show, but I went ahead. The output of the remaining steps is as follows:\r\nnwe@nwe-PC /cygdrive/d/swbuilds/ChezScheme-9.4\r\n$ ./configure\r\nno suitable machine type found\r\ntry rerunning as ./configure -m=<machine type>\r\navailable machine types: a6le, a6nt, a6osx, i3le, i3nt, i3osx, ta6le, ta6nt, ta6\r\nosx, ti3le, ti3nt, and ti3osx\r\n\r\nnwe@nwe-PC /cygdrive/d/swbuilds/ChezScheme-9.4\r\n$ ./configure -m=i3nt\r\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\r\n                                 Dload  Upload   Total   Spent    Left  Speed\r\n100   140    0   140    0     0     65      0 --:--:--  0:00:02 --:--:--    84\r\n  0     0    0 3726k    0     0  36146      0 --:--:--  0:01:45 --:--:-- 58062\r\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\r\n                                 Dload  Upload   Total   Spent    Left  Speed\r\n100   119    0   119    0     0     59      0 --:--:--  0:00:02 --:--:--    77\r\n100  590k  100  590k    0     0  28594      0  0:00:21  0:00:21 --:--:-- 23863\r\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\r\n                                 Dload  Upload   Total   Spent    Left  Speed\r\n100   119    0   119    0     0     64      0 --:--:--  0:00:01 --:--:--    79\r\n  0     0    0  206k    0     0  18299      0 --:--:--  0:00:11 --:--:-- 27083\r\n\r\nnwe@nwe-PC /cygdrive/d/swbuilds/ChezScheme-9.4\r\n$\r\nI tried to run scheme.exe  and petite.exe from within git repository. They say Access is denied. I guess it isn't built properly.\r\n\r\nRupinder .zip distribution failed to me too.. Perhaps it would be better to use git source since it worked for me, both `i3nt` and `ti3nt`. You don't have to install Chez prior building git sources.\r\n\r\n> which cl and which make didn't show after Native tools and so I added the bin carrying those to PATH varaible.\r\n\r\nYou don't have to fiddle with `PATH` variable. The script should find correct tools based on environment variables. VS2015 installer should set `VS120COMNTOOLS` variable and [the script](https://github.com/cisco/ChezScheme/blob/master/c/Mf-i3nt) uses it.\r\n\r\n... actually I haven't aware they've fixed the script in the last year( https://github.com/cisco/ChezScheme/commit/11ac1ba5a8fc3f16b997c498d223328f73b31152 ).. Now my steps above are just redundant.\r\n\r\n1. Open Cygwin (Adding Cygwin tools to `PATH` do not work here. Always use Cygwin.bat or `mintty` short cut which Cygwin installed to invoke `bash` prompt and issue every command there.)\r\n2. `./configure -m=i3nt`\r\n3. `make`\r\n\r\nthat's it.\r\n\r\n> I tried to run scheme.exe and petite.exe from within git repository. They say Access is denied. I guess it isn't built properly.\r\n\r\nPerhaps it is just a symlink to somewhere. It won't work outside of Cygwin.\r\n\r\nI put my build at http://storage.osdev.info/pub/proj/yuni/Chez%20Scheme.msi I believe it is the expected output (built with VS2015pro). Hi.\r\n\r\nThe installer works, of course.\r\n\r\nHowever, I get the following output on building from source. I cleaned the installation directory once and re-cloned. It persists.\r\n\r\nnwe@nwe-PC /cygdrive/d/swbuilds/ChezScheme\r\n$ ./configure -m=i3nt\r\n./configure: line 2: $'\\r': command not found\r\n./configure: line 17: $'\\r': command not found\r\n./configure: line 18: $'\\r': command not found\r\n./configure: line 19: syntax error near unexpected token `$'do\\r''\r\n'/configure: line 19: `for fn in boot/*/scheme.boot ; do\r\n\r\nI get the same output with -m=ti3nt\r\nRupinder\r\n Thanks okuoku and Bob!\r\n\r\nDespite okuoku's reminder, I forgot to install git and make on Cygwin, which I did now and build seems ok. Again I forgot to give argument -m=i3nt, but make seems to have detected it. To be safe, re-ran with -m=i3nt. Both scheme.exe and petite.exe are available and run ok. I am attaching the complete ouput for record.\r\n[ouput.txt](https://github.com/cisco/ChezScheme/files/894834/ouput.txt)\r\n\r\n \r\nRupinder I am closing this issue by summarizing Okuoku's and Bob's suggestions for use by the other prospective beginners .\r\n1. Ensure that Cygwin is installed on your Windows with git and make packages. \r\n\r\n2. Open Cygwin by Cygwin shortcut (minty) or Cygwin.bat\r\n\r\n3. cd to some directory you want to install in.\r\n\r\n4. Clone current ChezScheme source from https://github.com/cisco/ChezScheme.git to that directory using \r\ngit clone https://github.com/cisco/ChezScheme.git \r\n-- a git repository will be created named ChezScheme.\r\n\r\n5. cd to ChezScheme directory cloned as above.\r\n\r\n6.  ./configure -m=i3nt \r\n\r\n7.  make\r\n\r\n8. scheme.exe and petite.exe should be available in newly created folders i3nt. \r\n\r\n9. Repeat steps 6. and 7. with -m=ti3nt, if you want threaded version too.\r\n\r\n\r\n  I\u2019m trying to add a field to the record `primref `in [s/primref.ss](https://github.com/cisco/ChezScheme/blob/master/s/primref.ss) but I get an error while compiling. I made a minimized version of my change: https://github.com/gus-massa/ChezScheme/commit/5545971fbc71016133fc6ca4f87040b276e3bb0a  /  [Tests in Travis](https://travis-ci.org/gus-massa/ChezScheme/jobs/216570350#L556).\r\n\r\nAm I missing something obvious, like updating the definition elsewhere, or do I have to recompile the intermediate files with an especial command?\r\n Thanks! I have to retry a few steps because I made a mistake, but finaly this worked. https://github.com/gus-massa/ChezScheme/commit/0ba66251c32cae43f5947962ea6d67ac27bf65d0\r\n([Tests](https://travis-ci.org/gus-massa/ChezScheme/builds/217855727)) \r\n\r\nSome minor details/remarks:\r\n\r\nI had to change `a6osx` to `a6nt` everywhere, and add `./` in front of `configure` and `workarea`.\r\n\r\n`checkin` offers to copy too many files. I selected only the `s/primref.ss`, `s/primvars.ss`, `boot/a6nt/petite.boot` and `boot/a6nt/scheme.boot`\r\n\r\n After this, I also run `make bootfiles` to update the other boot files.  This partial patch (no tests or docs, yet) adds support for immutable vectors, strings, and bytestrings, where `vector-set!` and similar operations check for mutability.\r\n\r\nNew `vector-set-immutable!`, `string-set-immutable!`, `bytevector-set-immutable!` operations change a value from mutable to immutable \u2013 as a one-way street \u2013 and `vector-immutable?`, etc., report whether a value is immutable.\r\n\r\nFor vectors, the high bit of the type+length field is used for an \"immutable\" flag. For strings and bytevectors, the length part of the field is shifted up by one to make room for the \"immutable\" bit. So, the runtime implications are:\r\n\r\n * halving of the maximum size of a vector, string, or bytevector \u2013 which could matter on a 32-bit platform;\r\n\r\n * adding a bit test in `vector-set!`, `string-set!`, etc.; and\r\n\r\n * adding a bitwise \"and\" to `vector-length` and the range check for `vector-ref` (but no new steps for `string-length` or `string-ref`, since a shift was needed already)\r\n\r\n * adding a range check in `make-vector`, etc., since the maximum size of a vector no longer matches the maximum fixnum.\r\n\r\nThe main question is whether those implications are acceptable enough to continue. I could also use help making sure that the generated code is a good as possible.\r\n\r\nIn case we get past those concerns: I didn't add an immutability bit to fxvectors, just because Racket doesn't have immutable fxvectors, but I could add it for consistency. Just to sync, I've updated the demo commit to include immutable fxvectors and fold the mutability test into the type test for strings, bytevectors, and fxvectors. I bet there's a better way to handle the vector tests, but I didn't find it. So, this commit still\r\n \r\n * halves the maximum size of a string, bytevector, or fxvector;\r\n\r\n * adds a bitwise \"and\" to vector-length and the range check for vector-ref; and\r\n\r\n * adds a range check in `make-string`, `make-bytevector`, and `make-fxvector.\r\n\r\nJust to clarify to anyone else reading this on why I haven't tried to do anything with pairs: Racket's mutable pair is a separate datatype from its immutable pair, so Racket can just not expose `set-car!` and `set-cdr!`. The problem with Racket vectors, etc., is that operations like `vector-ref` are supposed to work on mutable and immutable vectors alike, and we'd like to have `vector-ref`, `string-ref`, `bytevector-u8-ref`, bytevectoru8-set!`, etc., run as fast as possible. Immutable boxes are also a problem, but also not much use, so I'm happy to do something slow with them. Sync'ed to 564542d32bbae6b33cef808613238d5a4a2a8ee2, and changed the public interface to `vector->immutable-vector`, etc., instead of `vector-set-immutable!`.\r\n\r\nIssues and questions:\r\n\r\n * Since `(make-vector 0)` always returns the same vector, `vector->immutable-vector` doesn't yet work on the empty vector. Is there a better approach than adding a new hand-coded primitive to allocate a fresh 0-sized vector?\r\n\r\n * To support immutable boxes, is the right idea to add a type tag `#b10001110` (to go along with `#b00001110`) and use a suitable mask for testing for boxes?\r\n\r\n * The new commit adds support for immutable values to fasl, but writing is disabled because bootstrapping will need an extra step. I think I know how to do that and end up with suitable bootfiles, but is the disabled approach the right idea? Good point about constructing cyclic structures. Racket provides `make-reader-graph` as a primitive, so that the runtime system can construct cyclic immutable data. Is it better to keep the more restrictive interface (for future implementation flexibility) and add something like `make-reader-graph` to Chez, or is it better to keep the imperative interface after all?\r\n\r\nOn marking the empty string, etc. as immutable: Although the empty values are inherently immutable, making `...-immutable?` return true for them complicates the contract for functions like `make-string`, where the result should be mutable, or `string-copy!` (I forgot to add a check there, so far) where the destination string should be mutable and it makes sense to pass an empty string with a range of 0 characters to copy. On the whole, it worked better in Racket to keep the \"mutable\" empty values separate from the immutable ones.\r\n\r\nBootstrapping: when I uncomment the uses of `vector-immutable?`, etc., in \"fasl.ss\", then I got unbound-variable errors. I thought it was a bootstrapping issue, but maybe I'm doing something else wrong. Thanks for the comments. I'll look into those.\r\n\r\nMeanwhile, new issues with the latest commit:\r\n\r\n * I added the immutable empty vector to `S_G` and made it accessible\r\n   to `vector->immutable-vector` via a \"(cs)null_immutable_vector\"\r\n   foreign procedure, while \"fasl.c\" accesses\r\n   `S_G.null_immutable_vector` directly. Is there a better or more\r\n   canonical way?\r\n\r\n * To make `bytevector=?` treat immutable and mutable bytevectors as\r\n   equal, I had to introduce a new `len2` temporary. I don't know how\r\n   much that matters; I think I couldn't inline the expression for\r\n   `len2` in the `if` test because that position has a more restricted\r\n   grammar than the right-hand side of `set!, but I'm not certain.\r\n\r\n * What would be the process of adding a `set-box!` library entry? I\r\n   get a \"missing no headroom libspec\" if I just comment the `set-box!`\r\n   definition in \"library.ss\". This doesn't matter for the commit, but\r\n   I'm curious about the concept that I'm missing.\r\n\r\nTo be clear, when I referred to \"contracts\" before, I didn't mean the\r\nimplementation of a contract system like `racket/contract`, but instead\r\nthe way that programmers reason about contracts. For example, if a\r\nprogrammer decides to implement `string-reverse!`, should it accept the\r\nempty string? If so, and if the implementer includes defensive checks,\r\nthe implementer must be careful to check for the empty string in\r\naddition to whether the string is immutable. If not, clients must be\r\ncareful to never pass an empty string. The contracts are easier to\r\nreason about when mutability is independent of length (whether or not\r\nthe contracts are enforced or not at a given time through a contract\r\nsystem). @dybvig The latest commit follows your suggestions, including changing the error messages. I added both `mutable-vector?` and `immutable-vector?`, etc., to replace `vector-immutable?`, etc. Ok, that change is done. Unless I'm missing something, I don't have any pending issues at this point.\r\n\r\nMaking `mutable-vector?` and `immutable-vector?` both return true for the empty vector could make sense. I didn't pursue that, though, because it doesn't fit with Racket's existing API, where not-immutable => mutable.  This patch adds `record-equal+hash` for getting or setting a\r\ncustomization for `equal?` and `equal-hash` on an RTD to apply to its\r\ninstances.\r\n\r\nPotential issues:\r\n\r\n * The API explicitly uses a pair of functions, and the identity of the\r\n   pair is relevant for determining when the pair's `car` is used for\r\n   `equal?`. Any suggestions for a more tasteful data structure or API?\r\n\r\n * Relatedly, although there's a check when a pair is provided that its\r\n   `car` and `cdr` have procedures, the pair could be mutated at any\r\n   time. The effect of mutation is not particularly specified.\r\n\r\n * When using `record-equal+hash` to get an RTD's current mapping,\r\n   there's no way to distinguish an explicit mapping versus inheriting\r\n   and ancestor's mapping. The difference can matter if the ancestor's\r\n   mapping is changed (in which case the change is inherited).\r\n\r\n * The mapping is implemented by a property on the RTD's UID. Is there\r\n   a convention for property keys to avoid conflicts?\r\n\r\n * The code's indentation doesn't quite match the rest of the Chez\r\n   Scheme code. If that's important, what Emacs configuration would do\r\n   the right thing?\r\n @dybvig Thanks for the review and corrections!\r\n\r\nAs long as the thread-safety issues are also addressed, I think path compression should always work with the existing implementation due to an \"empty\" record that is installed when an RTD has no setting and no parent.\r\n\r\nIs using `with-tc-mutex` around the property manipulations (being sure to check for an existing system-property value within the mutex for an \"empty\" record) enough to avoid the thread-safety issues that you see? Of course, that wouldn't be enough to make equality-installing operations on RTD allowed concurrent to using `equal?` on instances of the RTD (or other installations on the RTD or its children), but that unsafety seems ok and consistent with other choices.\r\n\r\nThanks for the suggestions on excising pairs from the API. Relying on the identity of the customized RTD is closer to where I started, and I lost my way during some other bad turns. I have in mind making `record-equal+hash` return an RTD as well as the equality and hashing procedures,  which generally addresses the issue of distinguishing inherited versus direct results. Only `$sputprop` and not `$sgetprop`? Is there something like a TSO guarantee so that `$getprop` doesn't need to be wrapped? I tried to wrap all the `$sputprop`s that could affect uids, but maybe that's not right if any symbol can be a uid. If so, would it be better to put the `with-tc-mutex` in `$putprop`? On closer inspection, I see that `with-tc-mutex` was generally in place around `$sputprop`s and `$sremprop`s, except in initialization places where no threads can be running. I ended up keeping only 2 additions in existing code (in \"record.ss\").\r\n\r\nJust in case the patch is ready to merge, I've squashed and added a bootfiles commit. This patch now has Kent's split into separate functions for setting equality and hashing functions and separate functions for getting the procedures to be used for a given set of equality or hashing arguments.\r\n\r\n@dybvig - I noticed a few typos in the docs, and I added a small clarification on the default hashing function. Otherwise, this all works great for me.  The updated foreign.ms mats exposed a bug in the handling of floating-point varargs in 64-bit Windows. According to Microsoft, floating-point varargs values should be loaded into the XMM register as well as the integer register for the first four arguments: https://msdn.microsoft.com/en-us/library/dd2wa36c.aspx\r\n\r\n> (load-shared-object \"msvcrt.dll\")\r\n> (define f (foreign-procedure \"printf\" (string double) int))\r\n> (f \"(%g)\" 3.5)\r\n13\r\n> (exit)\r\n(1.4822e-323) I have a fix on the rgburger/varargs branch. I wanted to set! the integer register to be the floating-point register, but it looks as though the x86_64 code generator does not distinguish between integer and XMM registers in the reg record. So I added a new primitive %move-double that does the sse.movd instruction. If there's a better way to do this, please comment! Thanks, I updated rgburger/varargs with this change. I also found that Windows does not support single-precision floating-point arguments to varargs procedures, so I removed that change.\r\n\r\nIf this looks good, I'll update the suite of boot files. Thanks, I've tested the changes on Windows, Linux, and Mac OS X. They're now merged to master.  Accesses existing-but-hidden DST information in date records.\r\n\r\nThis PR does not provide a way to explicitly construct date\r\nobjects where `date-dst?` produces #t, since that would\r\nrequire a change to the `make-date` signature. Instead, only\r\ndates constructed with `current-date` or `time-utc->date`, or where the OS determines that the date provided to `make-date` is in DST\r\nwill have `date-dst?` as #t.\r\n\r\nTodo:\r\n\r\n- [x] rename to `date-dst?`\r\n- [x] fix test failures \r\n- [ ] test on Windows\r\n- [x] figure out whether `make-date` ever sets `isdst` to `#t`. I'll go with `date-dst?`, which is the name we use in Racket as well. I have not tested on Windows, I'll see about doing that, although that `#ifdef` block does not seem to change the `tm_isdst` value.\r\n\r\nReading [this man page for mktime](https://linux.die.net/man/3/mktime) suggests that it will only guess if the input is `-1` for `tm_isdst`, whereas we're setting it to 0 in `S_mktime` in `stats.c`. Should that be changed to `-1`? A note for the docs:  While \"Daylight Savings Time\" is certainly in widespread use, the official name is \"Daylight Saving Time\".\r\n\r\n(You can go learn all kinds of fascinating stuff by poking around on Wikipedia, but here's a link to the last US legislation that update DST, wherein you can find its reference to adjusting \"the Daylight Saving Time\": https://www.gpo.gov/fdsys/pkg/PLAW-109publ58/html/PLAW-109publ58.htm) I think that setting tm_isdst to -1 before calling mktime will eliminate the need for the WIN32 code. See https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/mktime-mktime32-mktime64 One question while I work on testing these changes -- how do I run a subset of the tests, say just `date.ms`? I think this is now done, except for testing on Windows. Why don't we add a tri-state dst argument to make-date? Then make-date would have all the options. I've written production code that uses make-date with UTC dates where I do not want the DST offset applied. I don't understand what the WIN32 code is doing. Why does it apply the time zone and DST offset of the _current time_ to the date/time specified? GetTimeZoneInformation doesn't look at the date specified. Unfortunately the #else part doesn't compile under Windows. I don't understand what's going on with the tz offsets in this code, so I don't know what to recommend. Racket has very similar code for Windows, see here: https://github.com/racket/racket/blob/master/racket/src/racket/src/fun.c#L10091-L10115 which it also uses to compute whether the date is in DST. The Racket code for Windows looks good. Can the S_mktime code set the tmx.tm_gmtoff before calling mktime and avoid the difftime? Unfortunately Windows doesn't have the tm_gmtoff member. I think the right repair for Windows is\r\n\r\n```\r\n  {\r\n    TIME_ZONE_INFORMATION tz;\r\n    long tzoff;\r\n\r\n    /* The ...ForYear() function is available on Windows Vista and later: */\r\n    GetTimeZoneInformationForYear(tmx.tm_year, NULL, &tz);\r\n    \r\n    if (tmx.tm_isdst)\r\n      tzoff = (tz.Bias + tz.DaylightBias) * -60;\r\n    else\r\n      tzoff = (tz.Bias + tz.StandardBias) * -60;\r\n\r\n    if (tzoff != orig_tzoff) tx = (time_t) difftime(tx, (time_t)(orig_tzoff - tzoff));\r\n  }\r\n```\r\n\r\nNote that it uses a function that's only available in Vista and later. Racket checks dynamically for the function and uses an older one on XP and earlier, but I don't know if XP an earlier is an issue anymore.\r\n\r\nA possible locale-independent test to demonstrate the problem with the old code: Get the difference between June 15 and January 15 in seconds, and check whether that difference is consistent with the DST results for each. There are 3 possible cases: no DST (or, more generally, same DST for January and June), shorter by an hour in the northern hemisphere with DST (i.e., January is not DST and June is), or longer by an hour in the southern hemisphere with DST \u2013 assuming that DST is always a 1-hour shift.\r\n\r\nThe `date-dst?` test in the current commit seems locale-specific, since June 15, 2016 was not in DST everywhere. The only idea I have for a test involves adding a way to lookup the time zone abbreviation (which would be handy for Racket on Chez Scheme), and then a test could work in a handful of recognized time zones. I've pushed a variant of Sam's patch to mflatt/ChezScheme@b92ae167fc91f377f64e218a4ca144c0616b0a19 (rebased to master).\r\n\r\nIt ended up being more of a change than I planned. While looking into time-zone names, I saw that there was no way to create a date with an arbitrary day such that the zone offset is set to be consistent with Daylight Saving for that day. (Instead, the zone offset would stay as provided to `make-date`.) Also, if you provide a time-zone offset to `make-date`, then the result of `date-dst?` doesn't match up with that offset.\r\n\r\nSo, I made the zone offset optional for `make-date`. When not provided, the offset is determined by the system time zone setting as appropriate for the target day, `date-dst?` is set appropriately, and `date-zone-name` is now set. When a zone offset is provided, then `date-dst?` and `date-zone-name` of the date both return #f.\r\n\r\nDate constructions without an explicit zone offset now allocate an extra string each time, but I expect that's ok. Similarly, there's a `copy-vector` in `date->time-utc` to avoid mutating the given date's time-zone information.\r\n\r\n@samth If the variant looks ok, then I suggest moving it to your branch for this pull request. (Note: I removed the `true` flag from the \"primdata.ss\" spec for `date-dst?`, since the selector doesn't always return a true value.) I've adopted @mflatt's changes, fixed an error on Linux discovered by @spall, and pushed here. Building bootfiles/running tests now, may need some line number fixes in the tests.  Bootfiles built, still some line number errors to repair, I think. @dybvig, any suggestion for how to maintain the mats files other than manually? The changes for Windows look good. The mat patch file changes are incorrect. They cause lots of false reports for o=0 spi=t p=t on a6nt. This is now done, and successfully passes `make test`. @samth, all of the patch files need to be updated. In particular, patch-compile-0-t-f-f, patch-interpret-0-f-f-f, and patch-interpret-0-f-t-f need to be updated for make allx to succeed in the mats directory. @burgerrg I tried running `make patches` in `ta6le/mats`, but I get errors like this:\r\n\r\n```\r\nrm -f patch-compile-0-t-f-f\r\ndiff --context errors-compile-0-f-f-f\\\r\n                        errors-compile-0-t-f-f\\\r\n                        > patch-compile-0-t-f-f\r\nMf-base:430: recipe for target 'xpatch-compile-0-t-f-f' failed\r\nmake[1]: [xpatch-compile-0-t-f-f] Error 1 (ignored)\r\n``` I haven't done this before, either, but I'm guessing that we need to run all the combinations first.\r\n\r\n```\r\nfor EVAL in compile interpret ; do\r\n  for O in 0 2 3 ; do\r\n    for SPI in f t ; do\r\n      for CP0 in f t ; do\r\n        for CIS in f t ; do\r\n          make report eval=$EVAL o=$O spi=$SPI cp0=$CP0 cis=$CIS\r\n        done\r\n      done\r\n    done\r\n  done\r\ndone\r\n```\r\n\r\nand then run `make patches`. I'm trying this on a6le now. Ok, trying that. That took quite a while, but didn't fix the errors in `make patches`. I don't think the ignored failures are relevant. Doing this procedure should have fixed several of the patch files and introduced a couple new ones. Be sure to `cp patch-* ../../mats` so that git observes the changes. When I ran this on both a6nt and a6le, I had several fixes to the patch files and a couple new ones. @dybvig, should we add an all-reports target to mats/Mf-base that does $(MAKE) report on every combination? Do we need every combination? I don't completely understand the patch system for mats. @samth, your updated patches worked for Windows. Please squash that commit with the original commit, rebase onto master, and then update the boot files. Thanks! @burgerrg Done. Thanks, Sam! I'm going to see if we can skip the bootfiles commit and combine with a fix for issue #182.  Hii @ChezScheme-team\r\n\r\nI find this project to be an amazing asset for learning, I've gone through the WIki ( not much here), Docs and the Book as well but I didn't see any reference to the `byte code` or the `VM` - having seen the `garbage collection` being documented so thoroughly I imagined ChezScheme has a VM or something.\r\n\r\nCould you please point me to the right resources? I'm not as proficient in reading the source code as of yet :) Thank you @dybvig for the wonderful response. I was wondering about what makes Chez different from Racket or Guile. \r\n\r\nAlso, could you please tell me more about the design decisions that the ChezScheme team has made regarding targeting LLVM - if at all?\r\n\r\nP.S. I love reading Source code and understanding the organization of project and I must say Chez has one of the cleanest code bases :+1:  Mm hmm, so I'll close the issue. I do hope to see a better documentation of the internals though soon :) @dybvig , I've been using Chez a lot and I can honestly say I look forward to using it more and more. \r\n\r\nHowever, I'd like to ask you whether it's possible to replace the C code with say, Rust or Go and make Chez a more native companion to that language? How much of the C-related code in interspersed in the `s` or other directory apart from `c` of course. It's mentioned in the csug that the `c` portion relies upon the header file generated by the `s` files. Does it mean more effort would be required in untangling Chez from C? +1 for the internal documentation. Look forward to learning Chez's architecture from it.\r\n\r\nBTW, does anyone know which files are related to  `macro expander` in Chez repository?\r\n  following this commit https://github.com/cisco/ChezScheme/commit/f81024e4979da28502ae634181b379083e419911. I got boot files for openbsd 'a64ob' from a linux.\r\n\r\nI copied boot/a6ob directory to openbsd (6.0)\r\n\r\nand run\r\n./configure\r\ngmake\r\n\r\nBuild fails at this step with below error:\r\n```\r\ngmake all\r\necho '(reset-handler abort)'\\\r\n             '(base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))'\\\r\n             '(keyboard-interrupt-handler (lambda () (display \"interrupted---aborting\\n\") (reset)))'\\\r\n             '(optimize-level 3)'\\\r\n             '(debug-level 0)'\\\r\n             '(generate-inspector-information #f)'\\\r\n             '(subset-mode (quote system))'\\\r\n             '(compile-file \"cmacros.ss\" \"cmacros.so\")'\\\r\n             | ../bin/a6ob/scheme -q\r\nsizeof(time_t) * 8 [8] != time_t_bits [32]\r\ngmake[4]: *** [Mf-base:312: cmacros.so] Error 1\r\ngmake[3]: *** [Mf-base:146: allx] Error 2\r\ngmake[2]: *** [Mf-base:157: bootstrap] Error 2\r\ngmake[1]: *** [Makefile:21: build] Error 2\r\ngmake: *** [Makefile:19: build] Error 2\r\n\r\n```\r\n\r\nbuild logs:\r\n1.  https://gist.github.com/rashadkm/123b40d014f5ca536f5350157d9f3a5b\r\nI replaced make -> gmake in c/Mf-a6ob, run gmake again and got  below error\r\n2. https://gist.github.com/rashadkm/c8cd26f8c0bbe2a1e18ccce1d31a0d5d\r\n\r\nuname -a\r\nOpenBSD ab.my.domain 6.0 GENERIC.MP#2319 amd64\r\n changing \r\n-#define time_t_bits 0x20\r\n+#define time_t_bits 0x40\r\nin boot/a6ob/equates.h\r\n\r\ngives segfault\r\n It looks like the netbsd .def also needs this change. thanks @akeep and @gwatt  for your replies.\r\n\r\nI tried your change but no luck. If I change boot/a6ob/equates.h \r\n-#define time_t_bits 0x20\r\n+#define time_t_bits 0x40\r\n\r\nThis changes error in compilation. now it is segfault.  see below gist.\r\nhttps://gist.github.com/rashadkm/380c2ee6bd0fa452c5b5b44574cc4d40\r\n\r\nAny idea on how to debug?\r\n\r\nbtw, I also change ChezScheme/s/a6ob.def\r\nI copied boot/a6ob from a linux  x86_64 machine using 'make bootfiles'. \r\nmy target openbsd machine is OpenBSD 6.0 amd64.\r\n here is the output from gdb\r\n\r\nhttps://gist.github.com/rashadkm/a80f03f095c88d01dda0b5f89397012a\r\nyou can see scheme was run with no arguments when it crashes.\r\n\r\nwhen I pass --version or --help it has below output\r\nhttps://gist.github.com/rashadkm/3c7a2fc298fc975f776a60b92710630e\r\n\r\npassing --script or during make it fails. I would appreciate if someone could provide any hints? the call is failing in mmap (see gdb output)\r\n`\r\nsegment.c: 151     \r\n  if ((addr = mmap(NULL, p_bytes, PROT_EXEC|PROT_WRITE|PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)) == (void *)-1) {`\r\n\r\nopenbsd 6.0 has wx enabled. so PROT_EXEC|PROT_WRITE|PROT_READ might be a start when debugging this issue. I will try to find more information later. But I need someone from chezscheme team to fix this issue.\r\n .... and I have this on dmesg\r\n\r\nscheme(36686): mmap W^X violation\r\nscheme(80674): mmap W^X violation\r\nscheme(64380): mmap W^X violation\r\nscheme(46225): mmap W^X violation\r\nscheme(57800): mmap W^X violation\r\nscheme(45901): mmap W^X violation\r\n\r\nadding -Wl,-z,wxneeded to LDFLAGS fixes the segfault issue. but still I cannot run this.\r\n```\r\n$ ./a6ob/bin/a6ob/scheme -b ./a6ob/boot/a6ob/petite.boot  \r\n./a6ob/bin/a6ob/scheme[1]: ELF: not found\r\n``` Weird, I was able to run scheme in an OpenBSD 6 VM. how!.  I tried to latest git master branch and last release archive.\r\n\r\ncan you tell how you generated bootfiles on what machine and steps etc.. ?\r\n I built the bootfiles on a linux amd64 machine and uploaded them: https://github.com/gwatt/ChezScheme/tree/new-bootfiles\r\nThen I cloned the repository to my VM. To actually build chez I had to delete some of the locale stuff in c/expeditor.c.\r\nAfter that, it worked fine.\r\nI should probably try on bare metal and not a vm, but I don't expect that to matter. the issue has to be with bootfiles I guess. I am still not able to make things work on my openbsd. can you give output of ldd ./a6ob/bin/a6ob/scheme\r\n\r\nuname -a (openbsd)\r\nOpenBSD my.domain 6.0 GENERIC.MP#2319 amd64\r\n\r\nuname -a (linux)\r\nLinux  3.13.0-108-generic #155-Ubuntu SMP Wed Jan 11 16:58:52 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\r\n ```\r\nOpenBSD openbsd 6.0 GENERIC#2148 amd64\r\n``` hmm. that is same.. \r\n\r\nerror keep changing. see here: \r\n\r\ngmake all\r\necho '(reset-handler abort)'\\\r\n             '(base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))'\\\r\n             '(keyboard-interrupt-handler (lambda () (display \"interrupted---aborting\\n\") (reset)))'\\\r\n             '(optimize-level 3)'\\\r\n             '(debug-level 0)'\\\r\n             '(generate-inspector-information #f)'\\\r\n             '(subset-mode (quote system))'\\\r\n             '(compile-file \"cmacros.ss\" \"cmacros.so\")'\\\r\n             | ../bin/a6ob/scheme -q\r\n../bin/a6ob/scheme[2]: syntax error: `(' unexpected\r\n I don't have an `all` target for gmake at the root directory. Where are you running gmake? i am running from root directory of repo. where should I run gmake ?\r\n\r\nI clone your repository, checkout out new-bootfiles branch. and\r\n./configure\r\ngmake (has to change c/expeditor.c for locale changes as you said)\r\n\r\n\r\n gmake\r\n(cd c ; gmake)\r\ngmake[1]: Nothing to be done for 'doit'.\r\n(cd s ; gmake bootstrap)\r\ngmake allx\r\nrm -f *.a6ob xpatch patch *.patch *.so *.asm script.all header.tmp *.html\r\nrm -rf nanopass\r\ncp -p -f ../boot/a6ob/petite.boot ../boot/a6ob/sbb\r\ncp -p -f ../boot/a6ob/scheme.boot ../boot/a6ob/scb\r\ngmake all\r\necho '(reset-handler abort)'\\\r\n             '(base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))'\\\r\n             '(keyboard-interrupt-handler (lambda () (display \"interrupted---aborting\\n\") (reset)))'\\\r\n             '(optimize-level 3)'\\\r\n             '(debug-level 0)'\\\r\n             '(generate-inspector-information #f)'\\\r\n             '(subset-mode (quote system))'\\\r\n             '(compile-file \"cmacros.ss\" \"cmacros.so\")'\\\r\n             | ../bin/a6ob/scheme -q\r\n../bin/a6ob/scheme[1]: syntax error: `(' unexpected\r\ngmake[3]: *** [Mf-base:321: cmacros.so] Error 1\r\ngmake[2]: *** [Mf-base:153: allx] Error 2\r\ngmake[1]: *** [Mf-base:166: bootstrap] Error 2\r\ngmake: *** [Makefile:21: build] Error 2\r\n That's where I'm running it, but if I try `gmake all` it tells me\r\n```\r\ngmake: *** No rule to make target 'all'. Stop.\r\n```\r\nEdit: After a second look, I think that's a recursive invocation of gmake in some subdirectory so my line of pursuit here is not useful. okay. \"syntax error: `(' unexpected\" could be signalling a difference target vs host arch ? That looks like a shell error to me.\r\nEdit:\r\n```\r\n572 $ ls ()\r\n-ksh: syntax error: `(' unexpected\r\n``` No. \r\n/a6ob/bin/a6ob/scheme  \r\n./a6ob/bin/a6ob/scheme[1]: syntax error: `(' unexpected\r\n$ file ./a6ob/bin/a6ob/scheme \r\n./a6ob/bin/a6ob/scheme: ELF 64-bit LSB shared object, x86-64, version 1\r\n\r\n\r\nEdit:\r\nrunning from bash gives this error\r\n/a6ob/bin/a6ob/scheme \r\nbash: ./a6ob/bin/a6ob/scheme: cannot execute binary file: Exec format error\r\n\r\n$ file ./a6ob/bin/a6ob/scheme \r\n./a6ob/bin/a6ob/scheme: ELF 64-bit LSB shared object, x86-64, version 1\r\n can you push your changes to expeditor.c in case changes weren't same on my side. just to be sure. Done. thanks. I checkout out the code and still not working.  I still believe there is something wroing with generated bootfiles and later using it to creating scheme binaries.\r\n\r\nsome more questions:\r\nis  ./a6ob/bin/a6ob/scheme are supposed to scripts or executable files ?\r\nbecause you see the output of file command on my system.\r\n\r\nand if that is a shell script then ldd gives some information depending on if there is any shared libraries. ?\r\nldd ./a6ob/bin/a6ob/scheme\r\n\r\ndoes nm ./a6ob/bin/a6ob/scheme gives you any undefined symbols?\r\nthanks again for your patience and good effort in helping ldd on ta6ob/bin/scheme yields fairly normal output: libiconv, libm, libncurses, libpthread, libc\r\nnm also looks normal. There are undefined symbols, but they're all provided by the shared libraries. ah. in my case ldd gives error\r\n$ ldd ./a6ob/bin/a6ob/scheme         \r\n./a6ob/bin/a6ob/scheme:\r\n./a6ob/bin/a6ob/scheme: Exec format error\r\n./a6ob/bin/a6ob/scheme: exit status 1 finally, it is working. the fix was silly..\r\n\r\nclone and  build your repo on /usr/local.  why? only this parttion is mounted with wxneeded and adding LDFLAGS won't help un running scheme binaries.. ufff Ha! That explains why I didn't have problems. My vm is small, and I just let the installer auto-partition the drive. /home was too small for the chez repo, so I moved it into /usr before building. ./ta6ob/bin/scheme -b ./boot/ta6ob/petite.boot  \r\nPetite Chez Scheme Version 9.4.1\r\nCopyright 1984-2016 Cisco Systems, Inc.\r\n\r\n> (printf \"hello world!\")\r\nhello world!\r\n> (exit)\r\n\r\n\r\nThanks a lot for your immense patience and support in helping me. You might merge changes to upstream. maybe add a ifdef openbsd for locale stuff? I could. I'd want to know upstream's interest in having and maintaining OpenBSD as a first class citizen before I do that. Sure. you have my +1. and hope they include in upstream.  Would be great to have *BSD support in Chez Scheme. +1. Hey All,\r\n\r\nJust a quick follow-up on this.  I'd love to get better support for the BSDs in as well.  Currently, the boot files are one of the limiting factors here.  Unfortunately, they are binary and already compressed, and each platform adds about 2 MB for each revision that requires a new boot file be built (which is essentially every time we make source code changes to the Scheme compiler or libraries).\r\n\r\nSo, we need to find a way to pair down our existing boot files, potentially going back to just having a single machine-type checked in, and then providing the other binaries for download after each check-in.  I don't have a solution for this yet, but it is something we're thinking about so that we can provide a larger set of boot files, including boot files for the BSDs.\r\n\r\nI do have a question for those of you using BSDs though, are you aware of any continuous integration resources for building on BSDs as commits come in?  I've been considering automating the Linux and macOS builds, and I'd really like to get all supported platforms on this, but I'm not sure where to look for BSD automation resources. @akeep \r\nIs there a way to provide a single boot file per architecture, regardless of operating system? If that's not possible, what about smaller OS dependent boot files and a large boot file containing portable code?\r\n\r\nAnother issue is building the C parts on the BSDs. Obviously OpenBSD requires source changes. I have built Chez on FreeBSD, but don't have that system installed anymore. I remember there were some issues with iconv, but cannot remember specifics. I also don't know if this was before https://github.com/cisco/ChezScheme/pull/83, which causes build failures on OpenBSD.\r\nI have never tried building Chez on NetBSD. Hey @gwatt \r\n\r\nNo, it is not possible to have one boot file per architecture.  The boot file has compiled in calls to the C runtime routines, so it needs to have the calling conventions for the OS for that machine type.  Even the threaded vs. non-threaded versions need to be independent because the handling of Scheme's context is different between the two and produces different boot files.\r\n\r\nThe C parts already make heavy use of ``#ifdef``s to control how code is built on different platforms, and I think this should be perfectly sufficient for keeping the BSD code compiling (especially since we also build for Windows from this source tree).\r\n\r\nUnfortunately, not having regular testing on the BSDs has lead to some code being added that has never been tested on a BSD, like the ``newlocale`` code for allowing the expression editor to accept unicode input.  The ``system.h`` file contains the selectors for features that are only available on some platforms.\r\n\r\nI've built Chez since the open source release on FreeBSD, OpenBSD, NetBSD, and DragonFlyBSD, but it is has probably been 6 months at least, and I've not gone through all the testing on these platforms.  This is part of the reason I'd like to get all of this stuff on regular continuous integration.  It is easy for me to drop the ball on this when I get busy with my day job, when the continuous integration isn't keeping my feet to the fire :). @akeep I feared that was the case for the bootfiles. Oh well. @akeep , If you can have OpenBSD VM (always last stable release),  is that enough to setup a daily CI build ?\r\nI have used ctest for continuous integration under obsd.\r\nLet me know what is required and I can try to setup this on my part\r\n @rkanavath, part of what I'm looking for is a service like Travis-CI that can be connected with GitHub to initiate these builds in an autonomous fashion.  Short of that, I can probably try to get a machine setup to do these builds, but I suspect a service will be a bit more reliable. @akeep, I am not aware of any service like travis-CI that support BSD systems. other than a VM to do continuous build, i don't see any other option.\r\n\r\nabout openbsd boot files, is it possible to include all boot files in git repo and using git submodule? @akeep, I am not aware of any service like travis-CI that support BSD systems. other than a VM to do continuous build, i don't see any other option.\r\n\r\nabout openbsd boot files, is it possible to include all boot files in git repo and using git submodule?  add cmake file,tested under x64 windows 10 @dybvig I try to build under Windows, but current build system not work well. I think cmake is a more convinient and universal solution, though I aware that the conversion cost from make to cmake is too much to be impossible, and everyone has his own preferred build system. I just have found that make/configure is unfriendly for windows user, and I have done some basic work. Perhaps someone needs it.   Just a typo fix I think this looks like a good change, but there is a unit test in the file ``format.ms`` that checks for the formatting of numbers which also needs to be updated with this change.  (Check line 669 of format.ms).\r\n\r\nPlease update the unit test and also add a comment to the LOG file.\r\n\r\nYou can run the unit test by running ``make test`` at the top-level directory if you've made your changes in the same directory created by ``make``.  You can also go directly into the machine type directory's ``mats`` directory (e.g. ``a6osx/mats`` for 64-bit Mac OS X or ``a6le/mats`` for 64-bit Linux) and run ``make all`` (which runs one set of tests) and check the ``report-*`` file or ``make allx`` (which runs several variations of the ``all`` tests) and check the ``summary`` file.\r\n\r\nThanks!  I am trying to define a foreign-procedure that directly returns a struct. As an example, from the C version of SFML:\r\n````\r\ntypedef struct\r\n{\r\n    sfInt64 microseconds;\r\n} sfTime;\r\n\r\nsfTime sfSeconds(float amount);\r\n````\r\n\r\nI have tried the following, but get the error shown:\r\n````\r\n(define-ftype sfTime\r\n  (struct (microseconds integer-64)))\r\n(define sf:seconds (foreign-procedure \"sfSeconds\" (float) sfTime))\r\n=> Exception: invalid (non-base) foreign-procedure result ftype sfTime\r\n````\r\n\r\nI hope I haven't missed how to do this while reading the csug. Is there any way to achieve this short of writing a custom C function that wraps the struct value in a pointer? Meet the same question for passing directly struct to a function.\r\n\r\n Passing and returning structs (rather than pointers to structs) is not presently supported.  To call a function that requires struct arguments or returns struct values, you'd need to create an appropriate C wrapper.  Or you'd need to extend `foreign-procedure` and `foreign-callable` to handle struct arguments and return values. How to extend foreign-procedure and foreign-callable? I need passing struct and return the struct value.Could you show detail? @dybvig  Oh,that maybe cost a lot of time, quickly I made of this [https://github.com/evilbinary/scheme-lib/blob/master/packages/cffi/cffi.ss](https://github.com/evilbinary/scheme-lib/blob/master/packages/cffi/cffi.ss).It can use struct parameter to call directly. @ecraven   Hi,\r\nIf I compile ChezScheme with CHEZSCHEMELIBDIRS environment variable set, then the compilation fails.\r\nIs this expected? If I unset it then the compilation succeeds.\r\n\r\n```\r\n[...]\r\n../bin/ta6le/scheme -q cmacros.so priminfo.so primvars.so env.so setup.so  --script script.all\r\ncompiling library.ss with output to library.ta6le\r\ncompiling prims.ss with output to prims.ta6le\r\ncompiling mathprims.ss with output to mathprims.ta6le\r\ncompiling record.ss with output to record.ta6le\r\ncompiling 5_1.ss with output to 5_1.ta6le\r\ncompiling 5_2.ss with output to 5_2.ta6le\r\ncompiling 5_3.ss with output to 5_3.ta6le\r\ncompiling strnum.ss with output to strnum.ta6le\r\ncompiling bytevector.ss with output to bytevector.ta6le\r\ncompiling 5_4.ss with output to 5_4.ta6le\r\ncompiling 5_6.ss with output to 5_6.ta6le\r\ncompiling 5_7.ss with output to 5_7.ta6le\r\ncompiling event.ss with output to event.ta6le\r\ncompiling 4.ss with output to 4.ta6le\r\ncompiling front.ss with output to front.ta6le\r\ncompiling foreign.ss with output to foreign.ta6le\r\ncompiling 6.ss with output to 6.ta6le\r\ncompiling print.ss with output to print.ta6le\r\ncompiling newhash.ss with output to newhash.ta6le\r\ncompiling format.ss with output to format.ta6le\r\ncompiling date.ss with output to date.ta6le\r\ncompiling 7.ss with output to 7.ta6le\r\nException: library (nanopass) not found\r\nmake[4]: *** [Mf-base:461: bootall] Error 255\r\nmake[3]: *** [Mf-base:153: allx] Error 2\r\nmake[2]: *** [Mf-base:166: bootstrap] Error 2\r\nmake[1]: *** [Makefile:21: build] Error 2\r\nmake: *** [Makefile:19: build] Error 2\r\n```\r\n If you set CHEZSCHEMELIBDIRS to `/xxx/you-lib-path`, Then `/xxx/you-lib-path` is the only path Chez Scheme to search. But if you plus a colon at the end of that variable, `/xxx/you-lib-path:`, Then `/xxx/you-lib-path` will be added in existing libraries path. Chez Scheme will first search in `/xxx/you-lib-path` and then the paths previously set. This will also fix https://github.com/cisco/ChezScheme/issues/40 This should be fixed by [this commit](https://github.com/cisco/ChezScheme/commit/1cccd56693911a38ece784da677e35f724950700).  Hello !\r\n5 years ago I bought Chez Scheme 8.4 for Solaris 11 OS x86_64 (ta6s2) and (as bonus) Chez Scheme 8.3 for Solaris SPARC (tsp64). Worked nice for me and my learners on Intel and SPARC, Thank You !\r\nNow, I found open source Chez Scheme 9.4, but without support Solaris OS. Despite the fact that the source files have Solaris specifics. I tried to create into the directory 'boot' subdirectory 'ta6s2' and copy 'petite.boot', 'scheme.boot' and 'scheme.h' files from 8.4 release into it. Poorly ((( I created/edited 'equated.h' from linux distr - poorly ((( Now the question - Why don't you make Solaris distribution ? Solaris isn't popular or what ? If you need help to do this, then I am willing to participate. I can even give one of my native (not virtual) Solaris 11.3 server for this. Via 'ssh'. With 'developerstudio' 12.5 c/c++ sun/oracle compilers or 'gcc'. Let's try to do it... Now SPARC not important to me because I have very old Sun SPARC servers (SunFire V210) without support Solaris 11. Now I am only interested x86_64 arch. When I buy a Oracle SPARC T or M based servers, then go back to the tsp64 release )))\r\n\r\nThank You.\r\n--\r\nsorry for bad english Issue resolved. Now Chez Scheme can run on Oracle Solaris 11 OS (x86_64). And on SPARC too, I think...\r\n\r\nSun Meddle ~ # uname -a\r\nSunOS Meddle 5.11 11.3 i86pc i386 i86pc\r\n\r\nSun Meddle ~ # isainfo -v\r\n64-bit amd64 applications\r\n\tavx xsave pclmulqdq aes movbe sse4.2 sse4.1 ssse3 amd_lzcnt popcnt tscp \r\n\tahf cx16 sse3 sse2 sse fxsr mmx cmov amd_sysc cx8 tsc fpu efs rtm hle \r\n\tbmi2 avx2 bmi1 f16c fma rdrand\r\n\r\nSun Meddle ~ # chez\r\nChez Scheme Version 9.4.1\r\nCopyright 1984-2016 Cisco Systems, Inc.\r\n\r\n> (+ 9 4 1)\r\n14\r\n> \r\n\r\nThanks to all ))) Thanks  in the standard libc function strcpy, we can't get destination from source;\r\nchar * strcpy ( char * destination, const char * source );\r\nand doing some test shows failing to transfer value out through function param in Foreign Interface\r\n(foreign-procedure entry-exp (param-type ...) res-type)\r\n\r\nthe following is the execution commands:\r\n```scheme\r\n (load-shared-object \"libc.so.6\")\r\n (define strcpy (foreign-procedure \"strcpy\" (string string) string))\r\n (define from \"some random texts\")\r\n (define to (make-string 1024))\r\n (strcpy to from)\r\n\"some random texts\"\r\n to\r\n\"\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\\x0;\r\n``` From http://cisco.github.io/ChezScheme/csug9.4/foreign.html#./foreign:h2 documentation on conversion of parameters done by the function returned by `foreign-procedure`:\n\n> `string`: This type is an alias for `utf-8`.\n> `utf-8`: The argument must be a Scheme string or `#f`. For `#f`, the null pointer (0) is passed to the foreign procedure. A string is converted into a bytevector, as if via `string->utf8`, with an added null byte, and the address of the first byte of the bytevector is passed to C.\n\nSo the pointer passed to the first argument of the C strcpy function is not the same as the pointer to the scheme string `to`... which is good, because scheme strings and C strings are not the same thing, and things would go horribly awry if C wrote all over the memory that was supposed to be a scheme string.\n Then, how to define strcpy in scheme foreign interface to make it work?\n In the example code of foreign interface: https://cisco.github.io/ChezScheme/csug9.4/foreign.html#./foreign:h9\nThe c_read also don't work as expected;\nint c_read(int fd, char *buf, unsigned n);\n\n``` scheme\n(define c-read\n  (foreign-procedure \"c_read\" (integer-32 string integer-32)\n    integer-32))\n\n (define get ; procedure to read data from client\n    (let ([buff (make-string 1024)])\n      (lambda ()\n        (let ([n (c-read client-socket buff (string-length buff))])\n          (printf \"client:~%~a~%server:~%\" (substring buff 0 n))))))\n```\n\nThe param value of buf can't pass out!\n The examples in the documentation are out of date, but the two files referenced (`examples/csocket.c` and `examples/socket.ss`) are up to date in the repository.\n after modify strcpy declaration as following, it works.\n\n``` scheme\n(define strcpy (foreign-procedure \"strcpy\" (u8* string) string))\n(define from \"some random texts\")\n(define to (make-bytevector (string-length from)))\n(strcpy to from)\n(utf8->string to)\n```\n\nbut it still doesn't work that reading out from a file through the foreign interface u8*:\n\n# \n\n``` cpp\n// native.c\n\n#include <fcntl.h>\n\nint myRead(char* filename, char* buf, int len) {\n        int fd = open(filename, O_RDONLY);\n        if(fd > 0) {\n                return read(fd, buf, len);\n        }\n        close(fd);\n        return -1; \n}\n```\n\n# \n\n``` scheme\n; native.ss\n\n(load-shared-object \"./libnative.so\")\n(define myRead (foreign-procedure \"myRead\" (string u8* int) int))\n\n(define buf (make-bytevector 1024))\n(define len (myRead \"./some-log\" buf (bytevector-length buf)))\n(printf \"len=~a\\n\" len)\n\n(define outBuf (make-bytevector len))\n(bytevector-copy! outBuf 0 buf 0 len)\n(printf \"the res is :~a\\n\" (utf8->string outBuf))\n```\n\n# \n\n``` bash\nscheme --script native.ss\nlen=23\nthe res is :\n```\n @akeep you're right, the problem has been fixed!\r\nthanks!  Hello!\r\n\r\nI found something strange when working on an extensible pattern matcher in Chez. Here's a minimal test case:\r\n\r\n```\r\n> (library (a)\r\n    (export a)\r\n    (import (scheme))\r\n\r\n    (define a (box #f)))\r\n(library (b)\r\n    (export foo a)\r\n    (import (scheme) (a))\r\n\r\n    (define (foo) (display 'hello-world))\r\n\r\n    (set-box! a #t))\r\n```\r\n\r\n```\r\n> (import (b))\r\n> a\r\n#&#f\r\n> (foo)\r\nhello-world\r\n> a\r\n#&#t\r\n```\r\n\r\nIs this the correct behavior?  Check both the beginning file pointer (bfp) and end file pointer (efp)\r\nof the source location associated with a profile counter when updating\r\nits count.\r\n\r\nAssuming that each expression has a unique bfp with respect to profiling\r\nseems to give accurate execution counts for s-expression-based source\r\nlocations as in Scheme, but causes problems when targeting other kinds\r\nof syntax. For instance, a C-style function call, referencing the called\r\nfunction by name, such as \"fn(arg)\", can logically have profile counters\r\nassociated with 1) the function name reference (\"fn\") and 2) the entire\r\nfunction call expression (\"fn(arg)\"), both of which begin at the same\r\nsource location. Only the bfp is checked when updating profile counters,\r\nso the two source locations are conflated, and only one counter is\r\nincremented, which gives inaccurate execution counts for both locations;\r\napproximately twice as many for one, and zero for the other. The changes in the pull request probably wouldn't be necessary if not for the ``(profile source-object)`` form (documented [here](https://cisco.github.io/ChezScheme/csug9.4/system.html#./system:s130)) which is intended for use cases in which Chez Scheme is the target language of another compiler or interpreter.\r\n\r\nI had written a longer explanation recapitulating the text of the original comment before I realized that the pull request never mentioned being able to leverage Chez Scheme's profiling from when compiling from other source languages. I believe your assertion that each expression's bfp is unique is correct in Scheme and similar s-expression-based languages. However, if the source language has a C-style ``function(argument [, argument]*)`` syntax, there can logically be a profiling counter for ``function`` and one for ``function(argument [, argument]*)``, both of which have a source object with the same bfp.  As implemented without the changes in the pull request, the profiling output code will increment whichever counter it finds first for both the reference to ``function``, as well as for the entire function call expression. This gives incorrect execution counts for both expressions.\r\n  Apparently Github detects .ms files as MAXscript, making the mats files look like they're not Scheme. It also thinks the .h files are C++ as opposed to C. This pull request simply adds a .gitattributes file to hint the correct languages to Github.\n  Originally it was a very tiny patch. But these commits also contain bootstrap images as well as some auto-generated files. Not sure you want all of them. If not, I can strip it down to a few-lines-patch, so that the DragonFly build will still be possible but only with help of a Linux machine.\n\nBtw, it was extremely easy to port. Thanks!\n Thanks for your answer.\nI will try to do what you've asked in the next few days.\n\nAs for the 32-bit version of DragonFly, they discontinued support for it since release 4.0 (see https://www.dragonflybsd.org/release40/). Neither do they support 32-bit tool chain on 64-bit version as far as I know, but I will double check this.\n I submitted Mf-a6df in mats and run the tests. Some failed. During the investigation I found a bug in DragonFly's version of clock_gettime. I filed a bug report (https://bugs.dragonflybsd.org/issues/2951), but there is definitely a workaround: instead of clock_gettime getrusage can be used. If the bug is not fixed quickly in DragonFly, I'll submit my workaround. \n  I found in the original `loop2` in `lookup`:\n\n```\n(let loop2 ([i 0])\n  (if (fx= i n)\n      (loop1 (env-next env))\n      (if (eq? (vector-ref old-rib i) id)\n          (vector-ref new-rib i)\n          (let ([i (fx+ i 1)])\n            (if (fx= i n)\n                (loop1 (env-next env))\n                (if (eq? (vector-ref old-rib i) id)\n                    (vector-ref new-rib i)\n                    (loop2 (fx+ i 1))))))))\n```\n\nthe last let-statement (`(let ([i (fx+ i 1)]) ...)`) is the duplicate one of the `loop2` and can be replaced with just the recursive call of `loop2`. It seems like a manual loop unrolling, but according to the third guidance mentioned in the _CONTRIBUTING.md_,\n\n> All other things equal, shorter code is preferable to longer code.\n\nI decide to open this pull request.\n  This commit fixes calls to syntax-error in case and exclusive-cond (s/syntax.ss) which had their arguments reversed causing exceptions like:\n`Exception in syntax-error: #<syntax ((0))> is not a string`\nInstead of:\n`Exception: invalid case clause ((0))`\nIn cases such as:\n`(case 0 ((0)))`\nAll tests pass on my machine, and there weren't any other obvious (ie static strings) cases of this.\n  I'm building an REPL myself. Here is some code:\n\n```\nptr scheme_eval(const char* expr_string)\n{\n    auto open_input_string = Stop_level_value(Sstring_to_symbol(\"open-input-string\"));\n    auto stream = Scall1(open_input_string, Sstring(expr_string));\n    auto read = Stop_level_value(Sstring_to_symbol(\"read\"));\n    auto expr = Scall1(read, stream);\n    auto eval = Stop_level_value(Sstring_to_symbol(\"eval\"));\n    return Scall1(eval, expr);\n}\n```\n\nBut when I call:\n`scheme_eval(\"(error 'a 'b)\");`\nIt will exit directly. So I added an exception handler:\n`scheme_eval(\"(base-exception-handler (lambda (x) (display-condition x) (debug)))\");`\nBut in debug console, I can't input \"e\" or \"q\", It will raise another exception:\n  **Exception occurred with condition components:**\n  **0. &non-continuable**\n\nHow do I return to the context which calls the scheme_eval, please?\n Thanks very much.\nNow I use call/cc and with-exception-handler to capture exceptions when eval, it works well.\n  - make libchezscheme.a from kernel.o\n- install Mf-embed and libchezscheme.a to os\n#92\n Commit log have been amended as follows:\n\nAdded libchezscheme.a and Mf-embed\n- Make libchezscheme.a from kernel.o, which can be used for compiling programs with ChezScheme embeded.\n- Add Mf-embed, which will help setup CFLAGS, LDFLAGS and LDLIBS for compiling ChezScheme embeded programs\n- Install Mf-embed and libchezscheme.a to OS, path is the same as scheme.boot file, so it will have seperate paths for 32bit and 64bit installation\n- examples/crepl.c has changed comments\n\nAn example of using libchezscheme.a and Mf-embed\n  in examples dir of chez source, run\n  make -f /usr/local/lib/csv9.4.1/a6le/Mf-embed CFLAGS='${ChezCFLAGS}' LDFLAGS='${ChezLDFLAGS}' LDLIBS='${ChezLDLIBS}' crepl\n  and then\n  bash -c 'exec -a scheme ./crepl'\ncommit da4866d16bad66a289827f7aa6b67f3894afabc6\n I've been using this PR recently to great effect! I wanted to write a custom Scheme kernel (for extra diagnostics, debugging, etc) and this worked great. Thanks for writing it. I left some review comments.\r\n\r\nAlso: The changes to `LOG` don't actually seem to be in this PR?\r\n\r\nRegarding the stuff about `Mf-embed`, I would do this: let the user supply the final link flags, but the `Mf-embed` makefile provides the libraries itself. The way I work around it is like this (inside my `Makefile`):\r\n\r\n```make\r\n# LDLIBS are the libraries we need to pass to $(CC) in order to link the\r\n# executable shell\r\nLDLIBS=chezscheme m dl ncurses rt pthread\r\n\r\nsome-rule:\r\n        ...\r\n        gcc $(CFLAGS) -fPIC -o $@ $<-L\"$(CHEZBOOTDIR)\" $(LDLIBS:%=-l%)\r\n```\r\n\r\nThe real relevant part is `LDLIBS`, which is simply an unadorned list, and I use `$(LDLIBS:%=-l%)` to provide the actual link flags. `$(CHEZBOOTDIR)` points to the right place for linking `-lchezscheme` (I calculate this myself because my build system does a lot of stuff and has that information elsewhere).\r\n\r\nAlso: because you must include `Mf-embed`, I would also shorten, and enhance some of the variable names, so that it does not pollute the variable namespace for Makefiles.\r\n\r\nSo, in other words, I'd make `Mf-embed.in` look more like\r\n\r\n```make\r\nChezMachineType=none\r\nChezVersion=csv9.4.1\r\nChezInstallLib=none\r\n\r\nChezIncDir=${ChezInstallLib}/${ChezVersion}/${ChezMachineType}\r\nChezLibDir=${ChezInstallLib}/${ChezVersion}/${ChezMachineType}\r\nChezLdLibs=chezscheme m dl ncurses rt\r\n```\r\n\r\nThe rule to transform `Mf-embed.in` would then only need two substitutions: one for `ChezMachineType`, and one for `ChezInstallLib` (because we do not care about the prefix, only the lib directory, so I believe this is more correct):\r\n\r\n```\r\nsed -e \"s;^ChezMachineType=none\\$;ChezMachineType=$m;\" \\\r\n    -e \"s;^ChezInstallLib=none\\$;ChezInstallLib=$installlib;\"\r\n```\r\n\r\nThus, the user has all the necessary information from the `Chez*` variables to calculate the arguments to the compiler on their own. I think this is a bit simpler.\r\n\r\nI'd like to see this PR merged upstream so end-users can write their own C kernels as specified in Chapter 4 of the user guide. @dybvig - if you have any further suggestions, I'd be willing to help address them, too. Is there any update on this yet? I would like to know this too! I'd be more than willing to help get this PR upstream with LOG entries, tests, documentation, however possible (if needed by resubmitting, or giving patches to @ChaosEternal) I've been using the basic functionality successfully for a while, and it *does* address the gap in the users manual.\r\n\r\n@dybvig Do you think a resubmission is necessary for this PR, including docs/tests etc -- to make code review easier for you? @ChaosEternal You seem to still be using this -- I'd be more than willing to help finish up the last bits unless you'd like to do it yourself. Thanks guys, and apologies that I am recently very busy and my mind is in a mess. \r\n@thoughtpolice  your suggestion are very helpful, but I really need weeks to understand your patch.\r\n\r\nAnd I guess we need add windows support for this pr to make it complete ( @dybvig is this right?)   Hey Guys,\r\n\r\n@dybvig and I discussed this a little and I think I understand part of the request, but not the full request here.\r\n\r\nSo, part of what it sounds like you are looking for is an embeddable version of Chez Scheme that is a statically compiled library instead of just the ``kernel.o`` file that is already produced.  This ``libchezscheme.a`` just seems to be an archive wrapped around the ``kernel.o``, is that correct?  I'm assuming this is so you can say:\r\n\r\n```\r\ngcc my-entry-point.c -lchezscheme\r\n```\r\n\r\ninstead of\r\n\r\n```\r\ngcc my-entry-point.c kernel.o\r\n```\r\n\r\nIt also looks like the ``libchezscheme.a`` file would also be written into the install directory with the ``*.boot`` files in it.\r\n\r\nWhat is the advantage of the ``*.a`` over a ``*.o``?\r\n\r\nI don't really understand the ``Mf-embed`` file, and from the comments others have made, it looks like it might not quite capture everything it needs to capture.\r\n\r\nIs all of this based on the ``crepl.c`` example in the ``examples`` directory?\r\n\r\nSome clarification might help us understand what the benefits of this are over what is already provided.\r\n\r\nThanks!\r\n\r\n-andy:) If you're satisfied with simply using kernel.o, then commit fd7812d updated Chez Scheme to include it on unix-like systems. On Windows systems, the necessary libraries are already included for static and dynamic linking.  The expression '(\\* 0 +inf.0)' evaluates to '0' while it should evaluate to '+nan.0'.\nEvaluation of '(\\* 0.0 +inf.0)' gives the expected result.\n\nSimilarly with '-inf.0'.\n (\\* 0 0.0) => 0\n(\\* 0 whatever-in-numeric-tower) => 0 ;; I am not sure, but I think so\n\nhence\n(\\* 0 +inf.0) => 0\n\nmathematically, it is correct. \n Yes, @ChaosEternal is correct, the R6RS standard allows `(* 0 +inf.0)` to return either `0` or `+nan.0`.  The description for `*` in section 11.7.4.  It includes the explicit examples:\n\n```\n(* 0 +inf.0) => 0 or +nan.0\n(* 0 +nan.0) => 0 or +nan.0\n```\n Thanks for your answer and the reference to the R6RS standard with an\nexample.  Still, _mathematically_ '0 \\* Infinity' is not defined ('Infinity'\nis not a number!). Consider the example: define f(x) = x and g(x) = 1/x.\nThen you have\n\nlim x->Infinity f(x) = Infinity\nlim x->Infinity g(x) = 0\n\nFrom this, if you assume that 0_Infinity is 0 you would conclude that lim\nx->Infinity f(x)_g(x) = 0, but this is clearly wrong as\n\nlim x->Infinity f(x)*g(x) = lim x->Infinity x/x = 1\n\nI can imagine that the allowance for '(\\* 0 +inf.0)' in the standard comes\nfrom a remove past where '+nan.0' didn't exist and people doing numerical\ncomputations wanted to avoid their procedures blowing up.  But now, with\n'+nan.0' we can do better and avoid (in some situations) getting wrong\nresults.\n\nOn Fri, Aug 19, 2016 at 4:44 AM, Andy Keep notifications@github.com wrote:\n\n> Yes, @ChaosEternal https://github.com/ChaosEternal is correct, the R6RS\n> standard allows (\\* 0 +inf.0) to return either 0 or +nan.0. The\n> description for \\* in section 11.7.4. It includes the explicit examples:\n> \n> (\\* 0 +inf.0) => 0 or +nan.0\n> (\\* 0 +nan.0) => 0 or +nan.0\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/cisco/ChezScheme/issues/94#issuecomment-240913637,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AHUKsk9aHzYUPtVAVRhlzh3Q4tRBAFVzks5qhRhwgaJpZM4Jn2qO\n> .\n The thing is that `+inf.0` does not represent infinity. It represents a number which happen to be so large that it can't be represented in floating point. So `(*  0 +inf.0)` just means \"exact zero times a very large number\" - and then it makes sense to make the result exact zero.\n Well, Section 4.2.8 of R6RS appears to say otherwise:\n\n\"... The literals +inf.0 and -inf.0 represent positive and negative\ninfinity, respectively. ...\"\n\nLater (Section 11.7.4) it says that you _may_ use it for the purpose\nthat you describe.\n I see your point of view.  However, in my opinion it is dangerous to give\nas result of a computation a definitive answer which may or may not be\ncorrect. By returning +nan.0 instead of 0 one would warn the user that\nsomething may be wrong. If somebody is trying to use finite numbers that\ncan't be represented by the computer system, from my point of view\nsomething is definitely wrong.\n\nBy the way, out of curiosity, I've checked MATLAB, Numpy and Octave which\nare the most widely used systems for numerical computations and they all\nreturn NaN.\n\nOn Fri, Aug 19, 2016 at 2:58 PM, R. Kent Dybvig notifications@github.com\nwrote:\n\n> For the most part, R6RS tries to remain representation-agnostic to allow a\n> wide variety of implementation choices for inexact arithmetic. One choice\n> is to use arbitrary-precision inexact arithmetic in which all finite\n> numbers are representable, albeit imprecisely, and in which +inf.0 and\n> -inf.0 represent only non-finite numbers.\n> \n> An implementation may, however, choose to treat finite numbers as +inf.0\n> and -inf.0 if they are out of that implementation's representable range.\n> The exact zero value of (\\* 0 +inf.0) derives from that choice: in such an\n> implementation, +inf.0 and -inf.0 most often represent out-of-range finite\n> numbers, and multiplying such numbers by exact 0 should produce exact 0.\n> \n> A program needing infinities that never represent mere out-of-range finite\n> numbers isn't well served by this. My guess is such programs aren't common,\n> aren't well-served anyway by a single pair of infinities representing all\n> cardinalities, and might even require some form of symbolic arithmetic.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/cisco/ChezScheme/issues/94#issuecomment-241011441,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AHUKspeFl8U8MlPgyUIoXwNJi0aO-bvzks5qhaiCgaJpZM4Jn2qO\n> .\n @fedeinthemix, as long as you use inexact (floating-point) numbers, it behaves as you'd expect, namely, (\\* 0.0 +inf.0) => +nan.0\n\nIn my experience, the most common scenario is code that multiples two variables, each of which is bound to an inexact number.\n Mathematically,\n0 \\* limit(x->0, 1/x) => 0 rather than undefined.\n\nand infinite-small \\* infinite-large  => Undefined  \n Of course there are _examples_ where a careful mathematical analysis gives\na result which looks like 0*infinity = 0.\n\nHowever, when you only see 0_infinity you do not have enough information to\ntell if this is one of those examples or not. In particular, given the\napplicative-order evaluation of Scheme, '(_ 0 +inf.0)' can be a partial\nevaluation of some arbitrary expression.\nHere an example:\n\n(define (f x) x)\n(define (g x) (/ 1.0 x))\n(\\* (f 0) (g 0))\n=> 0 ;; wrong!!\n\nOn Sat, Aug 20, 2016 at 7:28 AM, ChaosEternal notifications@github.com\nwrote:\n\n> Mathematically,\n> 0 \\* limit(x->0, 1/x) => 0 rather than undefined.\n> \n> and infinite-small \\* infinite-large => Undefined\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/cisco/ChezScheme/issues/94#issuecomment-241180716,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AHUKsmY5J0IPRGNSjPeu-_4MJiZUW-saks5qhpBrgaJpZM4Jn2qO\n> .\n From my point of view, as somebody who was not involved in writing R6RS,\nbut who reads its outcome, section 4.2.8 and the requirement that (/ 1.0 0)\nshould evaluate to +inf.0 implies that the latter means infinity (and not\narbitrarily large, but not infinity). The matter of sign comes down to\nconvention (this must be for every function with discontinuities).\n\nMaking a distinction between infinity and a symbol which stands for\n\"arbitrarily large, but not infinity\", and zero and \"arbitrarily small but\nnot exact zero\" leads to more problematic cases. For example why does (= 0\n0.0) evaluates to #t if (\\* 0 +inf.0) gives a result different from (\\* 0.0\n+inf.0)? Should this (< -0.0 0 0.0) evaluate to #t then?\n\nIf you treat 0.0 as 0 and not \"arbitrarily close to zero\" (the limit of 1/x\nfor x->0 is exactly zero, not arbitrarily close to it) and +inf.0 as\ninfinity then (= 0.0 0) is naturally #t, (< -0.0 0 0.0) naturally #f and (*\n0 +inf.0) and (\\* 0.0 +inf.0) should both evaluate to +nan.0 without\ninconsistencies.\n\nMaybe I just didn't come across cases where this interpretation would lead\nto difficulties. In that case I would be grateful for concrete examples.\n\nOn Sat, Aug 20, 2016 at 3:45 PM, R. Kent Dybvig notifications@github.com\nwrote:\n\n> What's wrong here is that (/ 1.0 0) evaluates to +inf.0. It should be an\n> error or at least +nan.0 since (a) it is division by exact zero, not\n> something arbitrarily close to zero, and (b) the sign is indeterminate\n> since exact 0 is neither positive nor negative. R6RS, however, requires (/\n> 1.0 0) to return +inf.0 under the assumption that 0 is first converted to\n> +0.0.\n> \n> +inf.0and -inf.0 shouldn't be used when something \"went wrong\", as in\n> this example.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/cisco/ChezScheme/issues/94#issuecomment-241200958,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AHUKst7f5FEBYkjILJqrUI5q3_4CvipDks5qhwUDgaJpZM4Jn2qO\n> .\n Yes, like it is common in mathematics 0.0 should mean 0 reached from the\npositive side (lim x->+0 f(x)) and -0.0 should mean 0 reached from the\nnegative side (lim x->-0 f(x)). This adds a piece of information to help\nwith the evaluation of functions with discontinuities and in particular\nwith singularities.\n\nOn Sun, Aug 21, 2016 at 6:55 AM, R. Kent Dybvig notifications@github.com\nwrote:\n\n> Should -0.0 also be treated as 0?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/cisco/ChezScheme/issues/94#issuecomment-241239008,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AHUKsvWoprfQx0YU85gjxC3wPUEaG3Vjks5qh9pPgaJpZM4Jn2qO\n> .\n The value of (/ 1.0 -0.0) should be -inf.0 as currently given and in\naccordance with lim x->-0 1/x.\n\nOn Sun, Aug 21, 2016 at 4:01 PM, R. Kent Dybvig notifications@github.com\nwrote:\n\n> And what is the value of (/ 1.0 -0.0)?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/cisco/ChezScheme/issues/94#issuecomment-241259335,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AHUKstvGj82O6MGcma9eYwPuTV7AcgM6ks5qiFosgaJpZM4Jn2qO\n> .\n On Mon, Aug 22, 2016 at 5:44 AM, R. Kent Dybvig notifications@github.com\nwrote:\n\n> Your third note back claims it's problematic for (\\* 0 +inf.0) to give a\n> different result from (\\* 0.0 +inf.0) when (= 0 0.0) evaluates to #t. By\n> the same logic, it's equally problematic for (/ 1.0 0) to give a\n> different result from (/ 1.0 -0.0) when (= 0 -0.0) evaluates to #t, yet\n> that's what your second and first notes back require.\n> \n> Not exactly: I said that (/ 1.0 0) and (/ 1.0 0.0) should mean lim x->+0\n> 1/x, while (/ 1.0 -0.0) should mean lim x->-0 1/x. The numbers 0, 0.0 and\n> -0.0 should all be the same exact number but they carry an extra piece of\n> information to tell from which side you reached it. That's just borrowing\n> notation from mathematics.\n> \n> So your interpretation is problematic or your logic is flawed. In this\n> issue, your logic is flawed: numeric equality is inherently imprecise when\n> inexact numbers are involved and does not imply identical behavior. There\n> are many cases where the behavior of numerically equal numbers can differ.\n> For example, (= 10 10.0) => #t, but (= (/ 1 10) (/ 1 10.0)) => #f.\n> \n> That's very revealing! It seems that mixing exact and inexact numbers\n> always leads to surprises.\n> \n> Your interpretation has a flaw as well, because R6RS calculations treat\n> 0.0 differently from 0 in more than the one case you brought up\n> originally, precisely because 0 is exactly 0 and 0.0 is not. A trivial\n> example is that (- 0) => 0 while (- 0.0) => -0.0. A particularly relevant\n> example is that (/ 1 0) raises an exception while (/ 1 0.0) does not.\n> Also, as has been observed recently\n> https://github.com/cisco/ChezScheme/issues/95, an inexact zero\n> imaginary part makes a complex number non-real, while an exact zero\n> imaginary part does not. This difference shows up in calculations, too,\n> e.g., (cos 0.0+0i) = (cos 0.0) => 1.0 while (cos 0.0+0.0i) => 1.0-0.0.\n> \n> Thanks for the examples.\n> \n> The possibility of other interpretations aside, I remain comfortable with\n> the interpretation that +0.0 and -0.0 are close to but not quite zero and\n> +inf.0 and -inf+0 are large but not quite infinity. My preference for\n> this interpretation reflects (a) the fact that +inf.0 and -inf.0 can\n> arise through overflow or through underflow followed by division and (b) my\n> suspicion that they arise this way much more often than through the\n> intentional introduction of a true infinity. So I remain convinced that, in\n> Chez Scheme, (\\* 0 <any number>) should continue to evaluate to 0, which\n> R6RS allows, and (/ <any number> 0) should raise an exception, which R6RS\n> does not allow---though I'm tempted to arrange for the version of /\n> exported from the (chezscheme) library to do so.\n> \n> I decided to open an issue by seeing the result of (\\* (f 0) (g 0)) with f\n> and g as given on a previous note which is definitely a wrong result. I\n> thought that changing (\\* 0 +inf.0) from 0 to +nan.0 was a simple solution,\n> but I see that peoples disagree. To me what matters is to minimize the\n> number of times that a computation can lead to a wrong result. Rising an\n> exception as you suggest is one such method and is fine with me.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/cisco/ChezScheme/issues/94#issuecomment-241308975,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AHUKstDLkszJTV2rLQOaJt1TNo3p4V_jks5qiRsPgaJpZM4Jn2qO\n> .\n I'm closing this discussion but welcome a pull request that causes `(/ <any number> 0)` to raise an exception when `/` is imported from `(chezscheme)` rather than `(rnrs)`.  A change in #83 broken build on 32bit glibc. The function `s_ee_write_char` has `s_ee_write_char(INT)` prototype.\n\nDespite it fixes build on 32bit Linux, perhaps, the correct fix is doing opposite; define some type for character-in-expeditor and change `s_ee_write_char` prototype. (Sorry, but i'm too lazy to explore on this.)\n\ncc @eraserhd \n    R6RS and SRFI-34 say that if there is no matching handler clause in the guard form for a particular exception, the exception condition is re-raised as if by raise.  Kent Dybvig's TSPL says that it is re-raised as if by raise-continuable, which is wrong if intended to follow R6RS.  R7RS initially said it was re-raised as if by raise-continuable, but this was corrected in an erratum so as to be the same as R6RS and SRFI-34 (erratum 17).\n\nIt is rare for a situation to arise where this is relevant, as on re-raising an exception condition, that would usually be handled in another guard form further up the stack, or if there is none terminate the program.  But there are situations where the outcome (raise versus raise-continuable) makes a difference, such as in the code below.\n\nThe code below shows that in fact chez-scheme does neither what R6RS says (re-raise with raise) nor what TCPL says (re-raise with raise-continuable).  It ends up re-raising a non-continuable exception with raise, and re-raises a continuable exception with raise-continuable.\n\nAlthough, when a non-continuable exception is thrown by the code below within a guard form, the program exits with a &non-continuable exception error when the with-exception-handler handler lambda finally exits, it is in fact a little more complicated than that.  If extra instrumentation is added, it seems that the with-exception-handler handler lambda is entered as many times as there are nested guard forms further down the stack (twice in the code below) with what appear to be continuable exceptions and then, after the exception handlers established by the guard forms have been exhausted, by a non-continuable exception.)\n\n```\n(define (raise-proc1)\n  (raise-continuable 'test)\n  (display \"Returning from raise-proc1\\n\"))\n\n(define (raise-proc2)\n  (raise 'test)\n  ;; we will never reach here\n  (display \"Returning from raise-proc2\\n\"))\n\n(define (guard-proc-inner f)\n  (guard (c\n      (#f #f))\n     (f))\n  (display \"Returning from inner re-raised continuable exception\\n\"))\n\n(define (guard-proc-outer f)\n  (guard (c\n      (#f #f))\n     (guard-proc-inner f))\n  (display \"Returning from outer re-raised continuable exception\\n\"))\n\n(with-exception-handler\n (lambda (k)\n   #f)\n (lambda ()\n   (guard-proc-outer raise-proc1)))\n\n(display \"Normal exit\\n\\n\")\n\n(with-exception-handler\n (lambda (k)\n   #f)\n (lambda ()\n   (guard-proc-outer raise-proc2)))\n\n;; never executed\n(display \"Normal exit\\n\\n\")\n```\n Hey @ChrisVine,\n\nThanks for the bug report.  This is actually something that was changed in the Errata for R6RS (see the errata for section 7.1) http://www.r6rs.org/r6rs-errata.html\n\nIt actually does specify that raise-continuable should be used:\n\n> The sentence\n> \"If every <cond clause>'s <test> evaluates to #f and there is no else clause, then raise is re-invoked on the raised object [...]\"\n> \n> should be replaced by\n> \"If every <cond clause>'s <test> evaluates to #f and there is no else clause, then raise-continuable is invoked on the raised object [...]\"\n\nChez Scheme is consistent with the Errata.\n What a mess.  R6RS and R7RS issuing errata in opposite directions.\n\nHowever, the test case posted appears to show that with non-continuable exceptions, raise is (in the end) re-invoked on the raised object.  Is that consistent with the Errata?\n The interesting thing is that the R7RS errata seems to indicate it was changed to be compatible with R6RS, so I think there was some miscommunication on that part of the standard (and the errata).\n\nSo, I believe the test shows the correct behavior.  Adding a print statement to your handlers might make it a little bit more clear what is going on.  Here is my understanding after reading the R6RS documentation on `guard`, `raise`, `raise-continuable`, and `with-exception-handler`.\n\nSo, imagine a simpler situation:\n\n```\n(with-exception-handler\n  (lambda (x) (printf \"first handler invoked with ~s\\n\" x) #f)\n  (lambda ()\n    (guard (c [#f #f]) (raise-continuable 'a))))\n\n(printf \"returned from continuable exception\\n\")\n\n(with-exception-handler\n  (lambda (x) (printf \"second handler invoked with ~s\\n\" x) #f)\n  (lambda ()\n    (guard (c [#f #f]) (raise 'b))))\n\n(printf \"I should never be printed!\\n\")\n```\n\nThis prints:\n\n```\nfirst handler invoked with a\nreturned from continuable exception\nsecond handler invoked with b\nsecond handler invoked with #<condition &non-continuable>\nException occurred with condition components:\n  0. &non-continuable\nType (debug) to enter the debugger.\n```\n\nAs I read the standard, this is what I expect.  The first expression invokes `raise-continuable` with `'a` which causes the exception handler created by `guard` to be invoked.  Because the `guard` expression does not handle the exception, it re-raises `'a` with `raise-continuable` causing the handler established by the first `with-exception-handler` to be invoked with `'a`.  This prints:\n\n```\nfirst handler invoked with a\n```\n\nSince the inner-most call was a `raise-continuable` we're done and we print our next line out:\n\n```\nreturned from continuable exception\n```\n\nNow we head into the second exception handler which has a `raise` at the core.  So, the `raise` is called with `'b` invoking the handler established by the `guard` expression.  Since the `guard` again doesn't know how to handle the exception it calls `raise-continuable` on `'b` invoking the handler established by the second `with-exception-handler`, and we get:\n\n```\nsecond handler invoked with b\n```\n\nNow, we're done with that handler, but the inner-most `raise` is not done, it still needs to call `raise` on a non-continuable condition on the handler one level up from the handler we established with `guard`.  This recursive call to `raise` immediately invokes the handler established in the second `with-exception-handler` and we get:\n\n```\nsecond handler invoked with #<condition &non-continuable>\n```\n\nSince `raise` called itself recursively, and there are still more handlers on the handler stack (in this case Chez Scheme's outer-most handler.  The recursive call to `raise` with the non-continuable condition recurs to `raise` again on the next handler in the handler stack (the outer-most handler),  and we get:\n\n```\nException occurred with condition components:\n  0. &non-continuable\nType (debug) to enter the debugger.\n```\n\nThe `Type (debug)` line is there because I ran this within the REPL and it establishes a handler that prints this message and returns to the REPL prompt.\n\nI think the core idea here is that even though `guard` calls `raise-continuable` (and you can see that for yourself in `s/exception.ss` in the `$guard` procedure), this cannot make a non-continuable raise continuable.\n\nWith all of this said, this doesn't prevent us from catching a non-continuable exception, determining what we want to do with it, and carrying on execution.  We just cannot continue from the point at which the `raise` was invoked.\n OK I am grateful for your analysis.  I assumed the explanation for chez-scheme's behaviour was something like that.  However the idea that \"... the inner-most raise is not done, it still needs to call raise on a non-continuable condition on the handler one level up from the handler we established with guard\" does not seem to me to be the more obvious reading of R6RS with the erratum applied to it.\n\nOn an ordinary reading of the R6RS text (with erratum) \"... If every <cond clause>'s <test> evaluates to #f and there is no else clause, then raise-continuable is invoked on the raised object within the dynamic environment of the original call to raise except that the current exception handler is that of the guard expression\", it seems to me that the re-invocation is intended to be substitutional: that is how it behaves where the original exception was raised with raise-continuable - a continuable exception is not handled twice in your example (or three times in mine); nor is it intended that there would be multiple exceptions in my example of two nested guard forms if the inner form does not handle a non-continuable exception (so generating a continuable exception) but the outer form does handle the exception.\n\nAnyway, testing guile and kawa, the only other schemes to which I have access which purport to have some measure of R6RS support, they in fact re-raise with raise rather than raise-continuable.\n\nIn addition they re-raise without, when doing so, restoring the dynamic environment to that of the original call to raise (the failure to do so is both sensible and more efficient if the exception is re-raised with raise).  Thus, the following code:\n\n``` scheme\n(guard (c\n    [#t #f])\n       (guard (c\n           [#f #f])\n          (dynamic-wind\n          (lambda () (display \"in \"))\n          (lambda ()\n            (raise 'test))\n          (lambda () (display \"out \")))))\n```\n\ncorrectly prints 'in out in out' with chez-scheme by virtue of re-entry into the dynamic-wind block when the inner guard form fails to handle the exception, but only 'in out' with guile or kawa (the kawa documentation quotes R6RS with erratum applied, but does not in fact comply with it).  From its documentation, racket also appears to behave like guile and kawa when in R6RS mode, although I have not tested that.\n\nAs a side issue, raise-continuable is in my opinion more or less useless.  The idea that code further up the stack will have a better idea about how to handle an exception _before continuing back down the stack again_ than the code which _is_ down the stack, is contrary to all practical experience.  It seems to be inspired by common lisp restarts, the only practical use of which I have seen is in REPLs and debuggers.\n\nFrom that point of view, apart from efficiency the issue disappears.  Decent code employing with-exception-handler will either carry out clean-up and logging before terminating the program if it cannot handle the exception, or handle the exception and then continue by invoking an explicit continuation object.  For such code, it doesn't matter whether the exception is continuable or not.\n @dybig: Thanks, I can see the sense in that, so long as it is thought that continuable exceptions may actually be used.\n\nAnyway, the implementation in section 7.3 of R7RS (in the absence of the possibly incorrect R7RS erratum) behaves in the way chez-scheme does so I think it must be taken to be what R6RS, with the erratum to which akeep has referred, intends to occur.  It is the only scheme which, as far as I can see, actually does so.\n\nI'll therefore close this.\n  I'm working on making ChezScheme availible in macports. Unfortunately this requires linking against macports zlib, not the vendored one. Is there a configuration option for this/is there a reason it is vendored? \n\nAlso it seems the $CC environmental variable is not honored, and we'd like it to be.  There was also a problem with build and configure downloading things, but that seems to be a more a nice to avoid. We have our own mirroring system.\n\nThe ticket in Macports is https://trac.macports.org/ticket/51863. \n I will try to modify the Makefile.in appropriately to honor CC. \n\nI see your point about zlib, and will add X as a dependency. I think that will be enough, but will check with the committers to Macports.\n MacPorts contains all of Xquartz, in separate ports for each X library, so it's no problem for the ChezScheme port @wbl is developing to declare dependencies on whatever X libraries it needs.\n\nMacPorts, and macOS in general, prefers dynamic linking over static linking. ChezScheme should dynamically link to MacPorts zlib, not download and build its own copy.\n\nGenerally, all fetching of data from the Internet should be done by MacPorts during the fetch phase, not by the build system during later phases.\n Looks like I won't get to the CC issues anytime soon, so you might be able to solve them faster.\n Okay, I have some more time now to work on this. Are all of @ryandesign's things still issues? I've got the X dependence declared, but am unsure how to fix the fetch issue.\n With https://github.com/macports/macports-ports/commit/d4ef3b6f3b36379d28f7c26dc67ec7d767efd66b I think this issue is fixed.\r\n\r\ncc @wbl @ryandesign @dybvig   Chez Scheme  doesn't recognize umlauts read by command-line' and  'command-line-arguments'. Tested with version 9.4 and 9.4.1 commit a6643352.\n\nLink to mailing list [discussion](https://groups.google.com/forum/?_escaped_fragment_=topic/chez-scheme/-hwg9KLYHH8#!topic/chez-scheme/-hwg9KLYHH8).\n I've tested this out on my Mac using the standard terminal, and it also fails here if the expression editor is enabled:\n\n```\n% scheme\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\n> (define ;; <option-u>u which should produce \u00fc, produces nothing.\n```\n\nHowever, when I turn the expeditor off, it seems to work fine:\n\n```\n[akeep@hawkeye ~]% scheme --eedisable\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\n> (define \u00fc 5)\n> \u00fc\n5\n```\n\nAdditionally, echoing the instructions in from the terminal worked in both cases:\n\n```\n% echo '(define \u00fc 5) \u00fc' | scheme\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\n> > 5\n> \n```\n\nand with `--eedisable`:\n\n```\necho '(define \u00fc 5) \u00fc' | scheme --eedisable\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\n> > 5\n> \n```\n\nHowever, command line arguments (which allow us to name files to load also fails). So, for instance if we have two files `u.ss` and `\u00fc.ss` with the contents:\n\n`u.ss`:\n\n```\n(define u 9)\n(pretty-print u)\n```\n\nand `\u00fc.ss`:\n\n```\n(define \u00fc 5)\n(pretty-print \u00fc)\n```\n\nThen Chez can load `u.ss`:\n\n```\n% scheme u.ss\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\n9\n> \n```\n\nBut not `\u00fc.ss`:\n\n```\n% scheme \u00fc.ss\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\nException in load: failed for ????????.ss: no such file or directory\n```\n\nHowever, Chez can load the `\u00fc.ss` and execute it correctly, if we disable the expression editor.\n\n```\n% scheme --eedisable\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\n> (load \"\u00fc.ss\")\n5\n> \n```\n\nSo, anyway, it seems like there are two problems here:\n1. The expression editor isn't able to take in unicode characters.\n2. The command line arguments aren't being processed in a  way that accepts unicode characters.\n\nI think in both cases OS X is probably providing the characters in UTF-8, but I was a little surprised by the number of ? characters in the load error report.\n\nSo, there are some work arounds (though not being able to use the expression editor is a pretty big bummer).  Worth noting though is that file and console IO seem to do the right thing when the expression editor isn't involved.\n\nI'll also try to take a look into this and see what I can figure out.\n The inability to enter non-latin characters in the expression editor is #32.\n\nThis issue would be more accurately titled \"Command line arguments always treated as bytes\".  The C spec (at least as of C99) says that `argv` contains \"strings\", which by definition are made up of characters, not wide characters.  It is silent on whether those strings can be \"multi-byte strings\" (which of course it would be, since they're the same pointer type).  It appears that it's up to the OS (or maybe even the particular shell) to fill in `argv` however it sees fit, and it's not always consistent.  See, e.g., http://stackoverflow.com/questions/5408730/what-is-the-encoding-of-argv\n\nIn any case, if you want to take a stab at making things better, looks like `scheme.c:1112` is the place to start... possibly using the `mbstowcs` c library function and a new function like `Sstring` that takes wide character strings instead.\n Yes, I was just looking at that file and the that stack overflow article.\n\nThe pertinent code for the expression editor is in `expeditor.c` at lines 639, 644, 653, 657, and 662, where we use read (through the READ macro) to read a single byte (lines 639, 644, 653, and 657) and then convert it into a character with `Schar` (line 662).\n\nThe `mbstowcs` and `mbrtowc` seem like they may help for this and #32.\n @akeep You will probably also have to use `newlocale()` and `uselocale()` in a way similar to PR #83.\n The command-line arguments are converted to Scheme strings using `Sstring`. `Sstring` does not process UTF-8, which explains the behavior you're experiencing.\r\n\r\nThe command-line argument handling should account for the encoding used by the operating system. For unix-like systems, it is UTF-8. For Windows, it's UTF-16LE when the arguments are obtained from `CommandLineToArgvW`. It would be helpful to add `Sstring_utf8` and `Sstring_utf16le` to `scheme.h`. Thank you for fixing this issue. Closed.  Hello, I'm trying to learn how to debug programs with chezscheme.\nIn this case I have an exception while loading some code. But I cannot easily find from where the error is coming.  There is some way to show a backtrace to see the context from where the variable is referenced?\nFollows my attempt to inspect the code\n\n```\n> (load \"sdl2.sls\")\n\nException: variable sdl-pixeltype is not bound\nType (debug) to enter the debugger.\n> (debug)\ndebug> i\n#<continuation>                                                   : s\n  continuation:          #<system continuation in ksrc>\n  call code:             sdl-pixeltype\n#<continuation>                 \n#<continuation>                                                   : c\nsource code not available\n#<continuation>                                                   : sl\n  continuation:          #<system continuation in ksrc>\n  call code:             sdl-pixeltype\n#<continuation>                                                   : sf\n  0: #<continuation>\n  1: #<system continuation in ksrc>\n  2: #<system continuation>\n  3: #<system continuation in dynamic-wind>\n  4: #<system continuation in dynamic-wind>\n  5: #<system continuation in $reset-protect>\n  6: #<system continuation in new-cafe>\n#<continuation>                                                   : cp\nthis frame has no closure\n\nsdl-pixeltype                                                     : ?\n\n   ref(r) .............. inspect value field [n] of symbol\n   value(v) ............ inspect top-level-value of symbol\n   name(n) ............. inspect name of symbol\n   property-list(pl) ... inspect property-list of symbol\n   show(s) ............. show fields of symbol\n   ?? .................. display more options\n\nsdl-pixeltype                                                     : s\n  0. top level value:    #<unbound object>\n  1. name:               \"sdl-pixeltype\"\n  2. properties:         ()\n```\n  On Windows there does not appear to be a way to limit a process's memory usage.  In 64-bit mode, if I write bad code which allocates a lot of memory, Windows will cause the rest of the system to become unresponsive -- making it difficult to terminate the current Scheme process.  Would it be useful to have a (maximum-heap-size) parameter that is checked and allows Chez to display \"out of memory\" and call S_abnormal_exit?\n\nIf a parameter were to exist, would the checks be limited to where membytes is incremented in segment.c?  Are there other allocations that need to be considered? Does this have any unintentional impact on threaded mode?  Could this be useful in low-memory environments too?\n That's fair. I have run into a similar issue with a foreign library that liked to do large allocations.  You're right, I would need that mechanism for that foreign code as well.\n  Inside c/thread.c, the malloc of the tc structure is not checked.  I believe forking a large amount of threads in 32-bit mode should cause the malloc to fail, then the memcpy that follows to crash the system.\n\nBased on the notes above S_create_thread_object, it is not clear that the normal error handling procedures work here as they may allocate memory along the way.  The tc_mutex is also currently allocated and would likely not be released without special effort.\n\nCan the call sites adequately handle a malloc failure properly? Perhaps the caller should allocate the memory, and pass the resulting pointer into S_create_thread_object.  If it's NULL, then there's no need to copy.\n\nI haven't chased the details of vector_in or cons_in, but is it possible they can also return invalid values for thread creation?\n Reviewing more code, there is another unguarded malloc in io.c at the bottom of `S_malloc_pathname`, again followed by memcpy.  And one in schlib.c, `S_call_help` the usage of `CREATEJMPBUF` which appears to be defined as `malloc`. \n I'll take this one.  I've got the changes to the three files underway right now.\n\nI need to run tests and make sure I've not broken anything with this change (but, I'd be surprised if this small change creates problems).\n The most recent commit fixes these three unchecked malloc locations, thanks for reporting the problem!\n  The `(chezscheme)` library is large and monolithic.\n\nIt would be helpful to split it up into:\n- Implementations of SRFIs, in their respective libraries.\n- Chez-specific code that does not depend on Chez-specific primitives (and thus could be used elsewhere), which might belong in an external library.  One such library that has already been factored out is the nanopass framework.\n- Libraries tightly integrated with Chez Scheme that cannot be reasonably provided elsewhere.  These should stay under `(chezscheme)`, or perhaps split into smaller libraries under `(chezscheme)`.\n\nThe libraries that are split out of `(chezscheme)` should probably be reexported from `(chezscheme)` for backwards compatibility.\n  Is there a way to obtain the arity of procedures? I've tried with, e.g,\n(((inspect/object proc) 'code) 'source)\nbut it returns #f for build-in procedures such as 'car', '+', ...\n\nI've tried changing the line 'i = f' to 'i = t' in 'Mf-base' before compiling Chez, but it doesn't seem to have any effect on this.\n  For example, is it possible to have a new \"foreign-procedure\" which could automatically deactivate and reactivate threads and a new \"foreign-callable\" which could automatically activate and deactivate threads?\n https://github.com/cisco/ChezScheme/commit/2230e5adcb61ac8b27c9deee682270f4e17fbafb fixed this  fixes #58 \n  A.ss:\n\n```\n(library (A)\n  (export A)\n  (import (scheme))\n  (define A 12))\n```\n\n```\n% scheme\nChez Scheme Version 9.4.1\nCopyright 1984-2016 Cisco Systems, Inc.\n\n> (compile-file \"A\")\ncompiling A.ss with output to A.so\n> (make-boot-file \"A.boot\" '(\"scheme\") \"A.so\")\n> (exit)\n% scheme -b ./A.boot\nException in compiler-internal: install-library/rt-code: unable to install invoke code for non-existant library #{A eldnidvc3vkegxvd5huz435gj-0}\n```\n\nThis worked in Chez Scheme 8.4.1. Also, _non-existent_ is misspelled.\n Perhaps the load procedure in c/scheme.c does not handle the library/rt-info and library/ct-info records that run-inner of do-load-binary in s/7.ss does?\n The first commit on [this branch](https://github.com/owaddell/ChezScheme/commits/owaddell/library-boot-poc) is a quick stab at this. I restricted it to the non-procedure case of non-base boot files to limit overhead in the common case. Thanks, pull request https://github.com/cisco/ChezScheme/pull/288 fixed this. The [`load`](https://github.com/cisco/ChezScheme/blob/master/c/scheme.c#L887) and [`handle_visit_revisit`](https://github.com/cisco/ChezScheme/blob/master/c/scheme.c#L820) code in scheme.c silently ignore unexpected values, but my change has us now going through [`run-inner`](https://github.com/cisco/ChezScheme/blob/master/s/7.ss#L211), which is not so forgiving.\r\n\r\nShould `$make-load-binary` take a `for-boot?` flag that makes `run-inner` tolerate unexpected values?  http://cisco.github.io/ChezScheme/csug9.4/system.html#./system:s204\n\nThe times are no longer milliseconds but time records.\n Thanks! I updated the web pages and PDF.\n  hi there, \nwhen data are read/write through normal binary port, they should be able to pack/unpack using the same function that ftype has. naturally, if ftype-ref/ftype-set!  family can have bytevectors as argument will be make life easier.\n Partially agree, but defining a struct for bytevectors and foreign-pointer shares something in common:\nname, size(type, sign ), position and padding(align).\n\ncurrent  syntax ftype-&ref can give position information(using form: (ftype-&ref type 0)\n, but others are not very handy to achieve.\n  `\n; the library code \"linux/abc.ss\"\n(library (linux abc)\n  (export getenv1)\n  (import (chezscheme)\n          (rnrs bytevectors))\n\n  (define getenv1\n    (foreign-procedure \"getenv\" (string) string)\n    )\n\n  (begin\n    (load-shared-object \"libc.so.6\")) ;; seems putting load-shared-object here has no effect\n)\n`\n\nthe test code:\n;; the test code\n`\n(import (linux abc))\n\n(display (getenv1 \"HOME\"))\n\n`\n;; the error message:\nException in foreign-procedure: no entry for \"getenv\" \n\nThe behavior of Chez is (maybe) different to  r6rs :\n\nhttp://www.r6rs.org/final/html/r6rs/r6rs-Z-H-10.html#node_sec_7.1\n\nThe <library body> is the library body, consisting of a sequence of definitions followed by a sequence of expressions. The definitions may be both for local (unexported) and exported bindings, and the expressions are initialization expressions to be evaluated for their effects.\n You'll need to move the `load-shared-object` call above any foreign-procedure definitions. I realize that r6rs requires library definitions to appear above arbitrary code, but thankfully you can do still do this:\n\n```\n(library (linux abc)\n  (export getenv1)\n  (import (chezscheme)\n    (rnrs bytevectors))\n\n  (define init\n    (begin (load-shared-object \"libc.so.6\"))\n    ; anything else you may need\n  )\n\n  (define getenv1\n    (foreign-procedure \"getenv\" (string) string))\n)\n```\n The relevant section is [4.2](http://cisco.github.io/ChezScheme/csug9.4/foreign.html#./foreign:h2):\n\n> Two steps are necessary before foreign procedures can be invoked from Scheme. First, the foreign procedure must be compiled and loaded, either statically or dynamically, as described in Section [4.6](http://cisco.github.io/ChezScheme/csug9.4/foreign.html#g32). Then, access to the foreign procedure must be established in Scheme, as described in this section. Once access to a foreign procedure has been established it may be called as an ordinary Scheme procedure.\n\nYour original approach (understandably!) reversed the two steps.\n actually, i misunderstood r6rs\n\nthanks !\n Here's another method I've ever used.\nYou may define multiple libraries in a file, so you do this:\n\n``` scheme\n(library (init) (import) (export)\n  (load-shared-object \"xxx.so\")\n  '' do other related init work\n  )\n\n(library (your-module)\n  (import (init) (chezscheme) (rnrs))\n  (export ...)\n  ;; put your definitions here\n  )\n```\n\nThis method is useful especially if you have record-type to be defined first.\n  The makefile doesn't have an uninstall target.\n I've just run\n\n```\nsudo rm -rf /usr/bin/scheme /usr/bin/petite /usr/bin/scheme-script /usr/lib/csv9.4/ /usr/share/man/man1/scheme.1.gz /usr/share/man/man1/petite.1.gz\n```\n\nHopefully I haven't messed anything up...\n @burgerrg could you take a look at this?\r\n\r\n1. if the process above sufficient for \"totally\" removing\r\n2. whether we introduce a `uninstall` target or mentioned somewhere, like BUILDING @burgerrg nice job! then could we just close this thread?  I have found a piece of code in 'configure' file about FreeBSD \n\n```\nif uname -a | egrep 'i386|i686|amd64|athlon|x86_64' > /dev/null 2>&1 ; then\n    m32=i3fb\n    m64=a6fb\n    tm32=ti3fb\n    tm64=ta6fb\nfi \ninstallprefix=/usr/local\nnstallmansuffix=man\n```\n\nbut when I run the './configure' command , it tell me 'available machine types: a6le, a6nt, a6osx, i3le, i3nt, i3osx, ta6le, ta6nt, ta6osx, ti3le, ti3nt, and ti3osx' and my question is: what is the right machine type for FreeBSD amd 64. And what is i3fb, a6fb, ti3fb, ta6fb that mentioned in that piece of code ?\n  Detailed notes about the changes are in the [commit](https://github.com/cisco/ChezScheme/commit/f7d7109de6845f6e91d4a7d77063d46e7e0dff3f). Some other notes:\n- These changes are meant to be conservative.\n- Two other improvements could be done. Any interest?\n  - Use CSS classes rather than inline styles\n  - Use CSS classes rather than tables\n- You may want to consider a lighter color scheme; just change the first palette entry pair to #EEEEEE/black.\n\n![profilehtml-white](https://cloud.githubusercontent.com/assets/176481/15331648/480c9776-1c30-11e6-82c9-0f42ab9393fd.png)\n\n![fatfibhtml-white](https://cloud.githubusercontent.com/assets/176481/15331654/4e1f46fe-1c30-11e6-8093-138a00a5ac5a.png)\n\nPS If you create new screenshots, note that the timestamp is an Easter egg. :-)\n Hmmm, I just noticed that the old screenshots have a \"/tmp/fatfib\" prefix in the file paths. Let me know if you'd like new ones that match.\n I added the paths to the screenshots. Sorry about the noise!\n I might recommend avoiding whitespace-only changes, such as the removal of trailing spaces, which make it harder to find the more interesting differences for review.  There were many of these, for example, in system.stex.\n Yes, I've been wondering about that. Btw, in case you weren't aware, you can ask GitHub to ignore whitespace in its diffs by adding \"?w=1\", like this: https://github.com/cisco/ChezScheme/pull/51/files?w=1.\n Whitespace changes are fine with me if they help keep the code clean or eliminate tabs from source files (as I've just done).  It can be helpful to put the whitespace-only changes in a different commit, particularly if there are a lot of them or a lot of other changes.\n Should I close this...?\n Right.\n\nThe colors I chose were from the [Material Design palette](https://material.google.com/style/color.html#color-color-palette). There's nothing magical about Material, it just has the benefit of being well specified. For example, there are tints and shades of each hue of blue. Convenient!\n\nChanging the palette will mean re-doing the screenshots. I can do that or you can, but if you do it: I made the two screenshots exactly the same size in order to make them feel more like screenshots (and less like rectangles copied from a screenshot).\n Btw, I asked if there was interest in two other possible changes. The first would be to switch from inline styles to CSS classes; the second would be to use CSS for layout rather than tables. (On the first point, I was going to use an Atomic CSS approach, along the lines of [Basscss](http://www.basscss.com). Atomic CSS is highly modular and composable. The result would look and feel somewhat like the current inline styles but be more DRY.)\n\nThose changes may well be past the point of diminishing returns, but: I thought the idea of using HTML for visualization was interesting, and I was thinking that we could slowly make all of this a better foundation for other visualizations.\n I've added a LOG entry. I'll consider creating a separate pull request for the other color scheme at some point, but it may be enough to simply say somewhere that you can switch color schemes by changing the first palette pair to #EEEEEE/black.\n  thanks to rain1 and hyln9 on #chez\n although this makes some of the output better,\nbut there still problems about pretty-print.\n\n``` scheme\n(pretty-print\n '(match {'a 2 3}\n    [{'a b c}\n     (let ([a 1])       \n       {{a b c} a {a b c} b {a b c} c {a b c}})]))\n```\n\nI expect to get ::\n\n``` scheme\n(match {'a 2 3}\n    [{'a b c}\n     (let ([a 1])\n       {{a b c} a {a b c} b {a b c} c {a b c}})])\n```\n\nbut I actually get ::\n\n``` scheme\n(match {\n  [quote a]\n  2\n  3\n  }\n  [{\n   'a\n   b\n   c\n   }\n   (let ([a 1])\n     {\n     {\n     a\n     b\n     c\n     }\n     a\n     {\n     a\n     b\n     c\n     }\n     b\n     {\n     a\n     b\n     c\n     }\n     c\n     {\n     a\n     b\n     c\n     }\n     })])\n```\n the use of {} is not specified by r6rs.\nwhile chez is using it as normal symbol,\nfor example, '({}) is viewed as a list of two symbols -- '{ and '}\n\nthis makes it possible for a user to define his/her own macros\nto use {} in anyway he/she wishs.\n\nit will be great to see this fact documented in the documents of chez.\n\nalso, it is really necessary for those printer functions, such as pretty-print,\nto handle {} in a proper way.\n This change would introduce an incompatibility with R6RS, so I would want it enabled only when a parameter (say `print-extended-identifier-syntax`)  is `#t`.  If we had such a parameter, I would want `write` to handle other Chez Scheme extensions to the syntax of identifiers as well, such as the identifier `1+`.   This would require wrsymbol to make two passes over the symbol's name: one to determine whether the symbol falls into the extended category and another to do the printing.\n\n(These extensions are available outside libraries and top-level programs except when prefixed by `#!r6rs` and inside libraries and top-level-programs only when prefixed by `#!chezscheme` ).\n\nExtending `pretty-print` to handle braces the way you want when the parameter is set probably wouldn't make anyone unhappy.\n sounds like a homework assignment, sir.\nI will try after I finish the porgram I am working on.\n  I have no idea if ChezScheme's REPL support unicode. Is there any good way to solve this problem now?\n The expression editor uses 8-bit characters and 8-bit ncurses functions.  It might not be too challenging to modify it to use wide characters and the wide ncursesw functions, though it might take more than cosmetic changes.  If you disable the expression editor (`scheme --eedisable``) Unicode should already work in a terminal emulator that supports it.\n I've spent a bunch of time today reading code, and I think I have a straightforward way of doing this, but I wanted to check here first.  There are three parts to it.\n1. Write characters to the console using wctombs, which will respect the current locale (and should output utf8 in anything modern).\n2. Read characters from the console, covering with mbrtowc() tracking an mbstate_t in static variables in s_ee_read_char() (the windows code does something similar), with care to respect the blocking flag.  This will require handling a few different cases (like EWOULDBLOCK in the middle of a Unicode sequence).\n3. Make the key mapping in expeditor.ss allow characters over 255.  (We could survive without this, but seems like a good idea.) ???\n\nNone of this handles Unicode character composition, but it would allow all precomposed characters, emoji, and what not.  AFAICT, character composition would require retrofitting a significant about of math in expeditor.ss.\n\nSo, before I embark, is this a decent approach? Can you think of anything specific I'll need to address to get this code accepted?\n @dybvig I did, but I found [this](https://github.com/cisco/ChezScheme/blob/master/s/expeditor.ss#L134) which suggested a different approach.\n\nIt looks like I have a bug to work out, but I'll push what I have, which is mostly working for review.\n I believe this has since been fixed.  For example:\n- https://github.com/cisco/ChezScheme/blob/master/csug/Makefile\n- https://github.com/cisco/ChezScheme/blob/master/release_notes/Makefile\n Including `Makefile` in `.gitignore` only hides any `Makefile` found in the top directory of the project; it does not apply to subdirectories. The `.gitignore` file would only hide the files you list if a pattern like `**/Makefile` was included.\n\nThe top-level Makefile is generated by the `configure` script, so hiding it is appropriate.\n Thanks, you're right; the problem was that my editor was applying .gitignore incorrectly.\n  I have to create `bin/$m`folder under ChezScheme,if not I'll get this error:\n`LINK : fatal error LNK1104: cannot open file 'csv94.dll' NMAKE : fatal error U1077: 'link.exe' : return code '0x450'`\nbuild under windows10 x64, $m=a6nt\nAm I did it in a wrong way?\n I met the same error. I tried to compile `a6nt` in my Linux virtual machine, there is `csv94.dll` in `bin`folder, but it is a symlink. So if you do this on Windows, there will not be `csv94.dll`.\nI guess it is impossible to compile the executable on Windows now.\n @akeep \nDoes it mean that you cannot use the compiled binary in a REAL Windows system (not a guest OS) now?\nCan we figure out a way to compile without using symlinks?\n same problem\n can we just release an pre-build exe then we can use this to build our production!\n I updated the build procedure for Windows so that a virtual machine is no longer required. It uses the Cygwin software on Windows to provide bash, make, etc.\n  It seems that this project can be configured and built with a Visual Studio shell running a POSIX compatible shell:\n- Enter the VS shell.\n- Enter the compatible shell.\n- Run `./configure -m=$M`.\n- Exit the compatible shell.\n- Do the remained things of \"Build step (Windows build machine)\" in the `BUILDING` document.\n\nTechnically, they can be executed in the same host.\n\nThere are several distributions providing the compatible shell like `bash`. They should be considerable to ease the build process. They may also provide `gcc`, `make` and other POSIX-compliant tools, which makes the Microsoft toolchain (`nmake`, `cl`, `link`, etc) optional and results in kinds of smoother experience of migration between Windows and POSIX platforms.\n\nI suggest two candidates to support:\n- The `bash` environment provided by Windows 10 (currently still in preview).\n- MSYS2. It is noticeable that with the package management mechanism, 3rdparty dependencies like `libiconv` (and even `gcc` for i686/x86-64 targets) can be installed automatically by the build script.\n I updated the build procedure to use Cygwin. I suspect that MSYS2 may also work, but I haven't tried it.\n\nI think the Windows 10 POSIX environment does not allow one to call native Windows executables, so it cannot be used with Microsoft Visual Studio. You could use gcc, but you'll have to port Chez Scheme to this new machine type, because the POSIX environment does not support the Windows API. I suspect that the POSIX environment is very close to Linux.\n I've succeded compiling with  (Microsoft Visual C++ Build Tools 2015 + windows sdk 8.1) as explained by @FrankHB . I avoided installing the full visual studio but installed only the \"Tools for Visual Studio\" compiler tools - still 7gb of disk space)\nI used MSYS2 instead of cygwin without any problem.\nThe only thing I had problems was maybe a bug in a Makefile\n`/bin/sh: line 6: ../bin/scheme: No such file or directory`\n`Mf-base:275: recipe for target 'checkboot' failed`\n\nI've changed the line at s/Mf-Base:281\nfrom             `| ../bin/scheme -b ../boot/$m/sbb -q`\nto `| ../bin/$m/scheme -b ../boot/$m/sbb -q`\nthen the compilation succeded. I don't know if this is correct though.\n\nWould be nice to support also mingw64 as an option instead of Visual C++\n @ovenpasta, thanks for pointing out the makefile's use of the symbolic link ../bin/scheme instead of the file ../bin/$m/scheme. I've fixed that.\n\nWith regard to using the mingw64 compiler, give it a try. I'd recommend looking at the c/Mf-a6le makefile and porting it to mingw64. Be sure to run the mats to check that the mingw run-time library handles all the floating-point library edge cases in the way Chez Scheme expects.\n Hello! [I'm trying to package Chez Scheme for msys2](https://github.com/matheusmoreira/MSYS2-packages/tree/master/chez-scheme-git). Currently, I have a patch that adjusts `configure` so it recognizes `MSYS_NT-*` in `uname`'s output.\n\nThe build fails with the following output:\n\n```\n==> Starting build()...\n(cd ta6nt && make build)\n(cd c ; make)\n./make.bat\nC:/dev/MSYS2-packages/chez-scheme-git/src/ChezScheme/ta6nt/c/make.bat: error while loading shared libraries: ?: cannot open shared object file: No such file or directory\nmake[2]: *** [Makefile:28: ../bin/ta6nt/scheme] Error 127\nmake[1]: *** [Makefile:20: build] Error 2\nmake: *** [Makefile:19: build] Error 2\n==> ERROR: A failure occurred in build().\n    Aborting...\n```\n\nI'm not sure where the problem is or where the `?` came from. I read the makefiles mentioned in the log but was unable to figure it out. \n\n@ovenpasta you were able to build using msys2; what could the above mean? Can you reproduce this behavior?\n Just very few steps... of course depends if you want 32 or 64 bit build, threaded or not, but just for example:\nexecute Visual C++ 2015 x86 Native Build Tools Command Prompt\nfrom there run c:\\msys64\\msys2_shell.bat\nthen cd to the ChezScheme source directory and run ./configure -m=i3nt\nthem run make\n I launched msys2 from the Native Build Tools Prompt and followed those exact steps but still got the same error:\n\n``` bash\n$ cd ChezScheme\n$ ./configure -m=i3nt\n$ make\n(cd i3nt && make build)\n(cd c ; make)\n./make.bat\nC:/Users/Matheus/Downloads/dev/package/MSYS2-packages/chez-scheme-git/src/ChezScheme/i3nt/c/make.bat: error while loading shared libraries: ?: cannot open shared object file: No such file or directory\nmake[2]: *** [Makefile:28: ../bin/i3nt/scheme] Error 127\nmake[1]: *** [Makefile:20: build] Error 2\nmake: *** [Makefile:19: build] Error 2\n```\n\nYour msys2 environment appears to be different. You have an `msys2_shell.bat` file; here it is called `msys2_shell.cmd`. Can you please post the output of `uname -a` on your system?\n\n``` bash\n$ uname -a\nMSYS_NT-6.3 Irlene-PC 2.5.1(0.297/5/3) 2016-05-16 10:51 x86_64 Msys\n```\n\n---\n\nI noticed that Chez Scheme's Windows build target depends on `nmake`. This is probably the reason why msys2 had to be launched from the Visual Studio prompt.\n\nOn my system, the Native Build Tools Prompt adds the following directories to the `PATH`:\n1. `C:\\Program Files (x86)\\MSBuild\\14.0\\bin\\amd64`\n2. `C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\amd64`\n3. `C:\\Program Files (x86)\\Windows Kits\\10\\bin\\x64`\n4. `C:\\Program Files (x86)\\Windows Kits\\10\\bin\\x86`\n\nThe second entry is the directory which contains `nmake` and it is not present in my msys2's `PATH`, even when it is launched from the Build Tools Prompt:\n\n``` bash\n$ nmake\nbash: nmake: command not found\n```\n\nI found the cause of the shared library error when I tried to execute `nmake` via absolute path:\n\n``` bash\n$ C:/'Program Files (x86)/Microsoft Visual Studio 14.0'/VC/BIN/amd64/nmake\nC:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/BIN/amd64/nmake.exe: error while loading shared libraries: api-ms-win-crt-math-l1-1-0.dll: cannot open shared object file: No such file or directory\n```\n\nSo my Windows build system is probably defective for some reason.\n\nStill, I wonder if it is possible to build Chez Scheme without relying on tools outside of msys2. [Recent updates](https://sourceforge.net/p/msys2/discussion/general/thread/dbe17030/) have rendered user configuration necessary to make msys2 inherit the full Windows `PATH`:\n\n> To void this, either launch start shell command using start_shell.cmd -use-full-path or inside Windows directly, set an environment variable for your user with name MSYS2_PATH_TYPE and value inherit.\n\nThis reflects the sentiment expressed in [msys2's introduction](https://sourceforge.net/p/msys2/wiki/MSYS2%20introduction/):\n\n> When using the shells, try to remove as many entries from PATH as you can, ideally only leaving something like C:\\Windows\\system32. Mixing in programs from other MSYS2 installations, Cygwin installations or compiler toolchains is not supported and will probably break things in unexpected ways. Do not have these things in PATH when running MSYS2 unless you know exactly what you're doing.\n\nBeing able to simply execute `pacman -S chez-scheme-git` would make it really easy for Windows users to get the bleeding edge Chez Scheme implementation. However, that would mean building it as an msys2 package.\n In my attempt to make Chez Scheme build as an msys2 package on my machine, I started developing patches that will create a new `ta6msys2` machine type based on `ta6nt`.\n\nI'm not sure if this is the best approach, but I got it to successfully compile several source files before failing with missing definition errors.\n Hi @matheusmoreira I've succeded building chez with mingw32. there is still some work to do but the basics are there. I've created some new targets, i3mw ti3mw a6mw ta6mw. By now I've finished only ti3mw.\nhere is the branch\nhttps://github.com/ovenpasta/ChezScheme/tree/mingw\n @ovenpasta [I've set up a branch on my package repository](https://github.com/matheusmoreira/MSYS2-packages/commit/7ded663512b14abee4f89db13495ff14e47da675) for your version. The build still fails because it's trying to compile Chez Scheme as a Windows package. On msys2, it should build as a POSIX package.\n\n`````` bash\n==> Starting build()...\n(cd ti3mw && make build)\n(cd c ; make)\ncp -p ../../c/statics.c statics.c\ncp -p ../../c/system.h system.h\ncp -p ../../c/types.h types.h\ncp -p ../../c/version.h version.h\ncp -p ../../c/externs.h externs.h\ncp -p ../../c/globals.h globals.h\ncp -p ../../c/segment.h segment.h\ncp -p ../../c/thread.h thread.h\ncp -p ../../c/sort.h sort.h\ncp -p ../../c/segment.c segment.c\ncp -p ../../c/alloc.c alloc.c\ncp -p ../../c/symbol.c symbol.c\ncp -p ../../c/intern.c intern.c\ncp -p ../../c/gcwrapper.c gcwrapper.c\ncp -p ../../c/gc-ocd.c gc-ocd.c\ncp -p ../../c/gc.c gc.c\ncp -p ../../c/gc-oce.c gc-oce.c\ncp -p ../../c/number.c number.c\ncp -p ../../c/schsig.c schsig.c\ncp -p ../../c/io.c io.c\ncp -p ../../c/new-io.c new-io.c\ncp -p ../../c/print.c print.c\ncp -p ../../c/fasl.c fasl.c\ncp -p ../../c/stats.c stats.c\ncp -p ../../c/foreign.c foreign.c\ncp -p ../../c/prim.c prim.c\ncp -p ../../c/prim5.c prim5.c\ncp -p ../../c/flushcache.c flushcache.c\ncp -p ../../c/schlib.c schlib.c\ncp -p ../../c/thread.c thread.c\ncp -p ../../c/expeditor.c expeditor.c\ncp -p ../../c/scheme.c scheme.c\ncp -p ../../c/itest.c itest.c\ncp -p ../../c/windows.c windows.c\n(cd ../zlib; CFLAGS=-m32 make -f win32/Makefile.gcc)\ncp -p ../../c/main.c main.c\ngcc -D_FORTIFY_SOURCE=2 -m32 -msse2 -Wpointer-arith -Wall -Wextra -O2 -D_REENTRANT -pthread -march=x86-64 -mtune=generic -O2 -pipe -c -DI386 -I../boot/ti3mw -I../zlib statics.c\ngcc -D_FORTIFY_SOURCE=2 -m32 -msse2 -Wpointer-arith -Wall -Wextra -O2 -D_REENTRANT -pthread -march=x86-64 -mtune=generic -O2 -pipe -c -DI386 -I../boot/ti3mw -I../zlib segment.c\ngcc -D_FORTIFY_SOURCE=2 -m32 -msse2 -Wpointer-arith -Wall -Wextra -O2 -D_REENTRANT -pthread -march=x86-64 -mtune=generic -O2 -pipe -c -DI386 -I../boot/ti3mw -I../zlib alloc.c\ngcc -D_FORTIFY_SOURCE=2 -m32 -msse2 -Wpointer-arith -Wall -Wextra -O2 -D_REENTRANT -pthread -march=x86-64 -mtune=generic -O2 -pipe -c -DI386 -I../boot/ti3mw -I../zlib symbol.c\nmake[3]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nmake[3]: win32/Makefile.gcc: No such file or directory\nmake[3]: *** No rule to make target 'win32/Makefile.gcc'.  Stop.\nmake[2]: *** [Makefile:40: ../zlib/configure.log] Error 2\nmake[2]: *** Waiting for unfinished jobs....\nIn file included from system.h:43:0,\n                 from alloc.c:17:\nexterns.h:44:38: fatal error: direct.h: No such file or directory\nIn file included from system.h:43:0,\n                 from segment.c:35:\nexterns.h:44:38: fatal erro\n```r: direct.h: No such file or directory\nIn file included from system.h:43:0,\n                 from statics.c:18:\nexterns.h:44:38: fatal error: direct.h: No such file or directory\nIn file included from system.h:43:0,\n                 from symbol.c:17:\nexterns.h:44:38: fatal error: direct.h: No such file or directory\ncompilation terminated.\ncompilation terminated.\ncompilation terminated.\ncompilation terminated.\nmake[2]: *** [Makefile:29: symbol.o] Error 1\nmake[2]: *** [Makefile:29: statics.o] Error 1\nmake[2]: *** [Makefile:29: segment.o] Error 1\nmake[2]: *** [Makefile:29: alloc.o] Error 1\nmake[1]: *** [Makefile:20: build] Error 2\nmake: *** [Makefile:19: build] Error 2\n==> ERROR: A failure occurred in build().\n    Aborting...\n``````\n yes I know, you should use the mingw32 toolchain from msys2. I saw there are many msys2 packages compiled that way\n @ovenpasta Success!\n\n[I created a `mingw32` version of the package](https://github.com/matheusmoreira/MINGW-packages/commit/a758eed4f10815e9795871330b8cd3470e97199c), as you suggested. I tested the build on the MINGW32 shell and it works. It even links against the system `zlib` instead of using the submodule. I'll tidy up the installation procedure later.\n\nAre you planning on adding support for the other machine variants? You made more progress on that front than I did.\n Great ;)\nActually the thing need some testing... I'll try to finish it this week. \nThe actual variants will be i3mw a6mw ti3mw ta6mw.\nAnyone has ideas on the naming convention for the machine type? I used \nmw instead of nt. Does it sound good? :)\n\nIl 04/07/2016 12:57, Matheus Moreira ha scritto:\n\n> @ovenpasta https://github.com/ovenpasta Success!\n> \n> I created a |mingw32| version of the package \n> https://github.com/matheusmoreira/MINGW-packages/commit/a758eed4f10815e9795871330b8cd3470e97199c, \n> as you suggested. I tested the build on the MINGW32 shell and it \n> works. It even links against the system |zlib| instead of using the \n> submodule. I'll tidy up the installation procedure later.\n> \n> Are you planning on adding support for the other machine variants? You \n> made more progress on that front than I did.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> https://github.com/cisco/ChezScheme/issues/19#issuecomment-230264421, or \n> mute the thread \n> https://github.com/notifications/unsubscribe/AI2neFNQGAVD1HZYRnzMYNTB6aWY3voWks5qSOczgaJpZM4IRiU5.\n `mw` seems fine to me. I used `msys2` for my POSIX build because I couldn't think of a good two letter abbreviation for it.\n\nTo track progress:\n- [ ] `i3mw`\n- [ ] `a6mw`\n- [x] `ti3mw`\n- [ ] `ta6mw`\n Hi... after 2 years, I've finally enabled also i3mw. Not that it took that much to do it.. ;)\r\nI've even did a small change (excluded getenv_s for the i3mw build) to be able to run chez scheme even in windows xp (only the unthreaded version). \r\nI could cross compile from linux and even run the mats with wine.  There was a minor issue configuring zlib.\r\nAt this point only the 64 bit version is missing, then I could create a pull request, are you interested in integrating this in master?\r\nYou can see the code in this branch: https://github.com/ovenpasta/ChezScheme/tree/mingw \r\n  This fixes a variety of duplicated articles (`the the`) and the like.\n in  csug/system.stex on line 2294, the correction should be \"an the application\" -> \"the application\", not \"and the application\".\n I was curious about how `the the` comes out ;)\n @david135 Thanks! I had misread that. Fixed.\n  - The test Program:\n\n;; the fib iterative\n(import (rnrs))\n\n(define (fib n)\n  (define (iter a b c)\n    (cond ((= c 0) b)\n          (#t (iter (+ a b) a (- c 1)))))\n  (iter 1 0 n)\n)\n\n(display (fib 1000000))\n- Run with Chez:\n\nChez Scheme Version 9.4\nCopyright 1984-2016 Cisco Systems, Inc.\n\n$ time scheme --program fib.scm  >/dev/null\n\nreal    0m23.007s\nuser    0m22.956s\nsys     0m0.076s\n- Run with vicare\n  Vicare Scheme version 0.4d0, 64-bit\n  Build 2015-10-19\n\nCopyright (c) 2006-2010 Abdulaziz Ghuloum and contributors\nCopyright (c) 2011-2015 Marco Maggi and contributors\n\n$ time vicare fib.scm  >/dev/null                                                                                                                                             \n\nreal    0m6.372s\nuser    0m5.900s\nsys     0m0.468s\n lrwxrwxrwx 1 chaos chaos      6 Apr 27 10:59 petite -> scheme\n This is not strange.\nRun same program under petite, you'll find that the running time is not changed so much.\nTherefore it's not compiler's issue but runtime library's.\nChez Scheme's bignum operation is indeed not as optimized as Vicare's which is powered by GMP.\n @dybvig  what's the reason not use GMP? maybe because of licenses?\n @hyln9 Thanks for point out it.\n\nI updated the test program:\n\n```\n(import (rnrs (6)))\n\n\n(define (fib n)\n  (define (iter a b c)\n    (cond ((= c 0) b)\n          (#t (iter (mod (+ a b) 10232123) a (- c 1)))))\n  (iter 1 0 n)\n)\n\n(display (fib 1000000000))\n```\n\nand the output becames:\n\n```\n$ time scheme --script fib.scm\n8461706\nreal    0m15.524s\nuser    0m15.528s\nsys     0m0.008s\n```\n\n```\n$ time vicare --r6rs-script fib.scm                                                                                                                                           \n\nreal    0m24.490s\nuser    0m24.480s\nsys     0m0.028s\n```\n I'm actually happy to see issues related to performance.  Good performance is, after all, one of our primary goals.  It's true that a thorough comparison would involve a lot more and more careful benchmarking, but it's nice to have examples where we aren't doing as well as we could, especially if it motivates contributors to submit fixes.\n\nUsing gmp would indeed speed up programs that operate on large numbers, particularly programs that multiply and divide very large numbers.  Licensing is the primary issue blocking us from using it.  Another is that our own, different representation of bignums is baked into the compiler and run-time system in a couple of ways.\n @dybvig Thanks for explaining! Now that Chez has its own bignum system, maybe it's unnecessary to do porting contribution for it, and there's license issue, maybe it's just need polishing if any possible. That's the reason why I ask.\n The original motivation makes me submitting this issue is that I am suspecting whether the code released here is the same as  Chez used to be, blame me.\n\nThanks to @hyln9 's help, I finally realize that the performance difference is introduced by GMP. \nSo i changed the subject to the current one. If it subject is still inappropriate, I can change it to anything else.\n\nBut My opinion is that the issue is valid and awaits to be resolved.\n I think gmplib is LGPLv3 hence it is compatible with apache2.0 license.\n libgmp is an extremely large and complex body of code that would weigh down the rest of the system, making it larger, compiling would take longer. I don't think it is necessarily a good idea to include it. Are you planning on implementing this @ChaosEternal? If so I would urge you to consider other bignum libraries.\n Apache 2.0 licensed software can be used in LGPLv3 licensed projects, but not the other way around.\n For what it's worth, the Scheme48 library (also used in the Chicken numbers egg) is written in Scheme.\n Sorry about my comment. I have seen many biased and premature benchmark comparisons recently, so I tend to be sensitive such things may get into the issue system, converting github into a discussion forum ;)\n\nIt seems this one is sorta valid question about bignums. I'd still suggest removing the word \"poor\" from the title, because the performance is not poor as compared to similar languages with bignum implementations (such as Java).\n\n### Bignum results\n\nJust for interest, I implemented the semantically same iterative fib function in three languages: Scheme, Java(using java's `BigInteger` class) and Python.\n\n``` racket\n(define fib\n  (lambda (n)\n    (define iter\n      (lambda (a b n)\n        (cond\n         [(= n 0) b]\n         [else\n          (iter (+ a b) a (- n 1))])))\n    (iter 1 0 n)))\n```\n\nThe running results are quite interesting. I couldn't get Vicare built properly on the Mac after fixing several things in its build system, but it is essentially just Ikarus.\n\nHere are the results running `(fib 1000000)` on my Macbook Pro.\n\n```\nIkarus 0.0.3:   7.69s\nChez Scheme:   16.69s\nPetite Chez:   17.66s\nJava 8:        15.71s\nPython:         9.86s\n```\n\nSo Chez's bignum performance is similar to that of Java. It's interesting how Python stands out in performance for bignums. \n\nThe performance of bignums in Ikarus is due to GMP. I took a look at the code of GMP and there is lots of processor specific optimizations done using assembly language and fancy instructions! Given how rarely people want super fast bignum arithmetic, I doubt Chez Scheme would want to have all that nasty details in the compiler ;)\n\n### Recursive fib results\n\nBut if you write a recursive implementation of fib:\n\n``` racket\n(define fib\n  (lambda (n)\n    (cond\n     [(< n 2) n]\n     [else\n      (+ (fib (- n 1)) (fib (- n 2)))])))\n```\n\nand run `(fib 48)`, you will get very different results.\n\n```\nIkarus 0.0.3:      52.10s\nChez Scheme:       36.55s\nPetite Chez:      409.53s\nRacket 6.5:        62.46s\nJava 8:            20.39s\nC#(.net core):    191.82s\nC#(VS):            40.10s\nC(clang):          30.52s\nC(gcc):            18.56s\nGo:                31.56s\nSwift:             36.37s\nPython(PyPy):     189.47s\nPython(CPython):   >20 mins and still not finished\n```\n\nTake a look at Python's performance and compare with its bignum times :)\n\nDo you want super fast bignum arithmetic that normal programs rarely use, and sacrifice everyday performance on function calls, data structures, closures? After all, you can still call GMP and fast C code for such rare computations with FFI, so I don't think this is a big issue.\n @yinwang0 Agree. People often misunderstand where Chez's progressiveness lies, so toy code benchmark seems popular :)\n\nHowever, efficient numeric tower operation is also essential. For bignum addition, GMP maybe wins on hardware specific optimization which is not generic and may not suitable for current Chez, but for multiplication and division, Chez's algorithm is already not desirable, which can be improved by a wide margin in common c.\n There might be a way...\n\nI found that Ruby and Python both use GMP, which makes them quite fast in this test. But Ruby is BSD license, and they seem to be able to call GMP, which is LGPL.\n\nFrom this line, you can see that Ruby is using GMP:\n\n> https://github.com/ruby/ruby/blob/trunk/doc/NEWS-2.1.0#L73\n\nBut from `doc/ChangeLog-1.9.3` (line 14778), you can see that they removed all LGPL code from the source:\n\n> https://github.com/ruby/ruby/blob/trunk/doc/ChangeLog-1.9.3\n\nSince Chez Scheme is Apache license which is very similar to BSD, I wonder if Chez Scheme can do the same thing as Ruby, link to GMP library but not include its code. Just ask the users install GMP by themselves if they need it.\n That might be an option.  It would require conversions from Chez Scheme's representation to GMP's and back for each call into GMP and presumably used only in cases where that overhead is justified.  Or Chez Scheme's representation could be changed to match GMP's if GMP's representation is part of the public interface and the change doesn't add undue overhead of some other sort.\n Gambit Scheme's Bignums are pure scheme and quite fast (not as fast as GMP right now but it has been faster on certain operations for brief periods in the past). Maybe porting their algorithms would be better than adding a dependency on GMP.\n I just tried the bignum fib program on Gambit, and it's slower than Chez. I'm not sure if I got the right way of running it, but running both `gsi fib.ss` and `gsc fib.ss; gsi fib.o1` got similar results. It takes at least twice as much time as Chez.\n I have run my second program with chicken scheme, it cost around 1 minutes to finish as a compiled chicken program.\n You have to add some declarations to have gambit actually enable most of its optimizations. At minimum (declare (block) (standard-bindings)). It also depends on how you built gambit's own runtime.\n\nA micro benchmark like this might be testing the allocator more than the bignum routines anyway.\n I also wonder if I enabled Chez Scheme's optimizations properly. Any suggestions?\n My only real suggestion is, to properly test bignum implementations head to head, it makes sense to find some real bignum benchmarks. Like I said above, this fib function is properly more aaffected by the allocation and grabage collection policies than the implementation of bignum+ \n Aubrey Jaffer's note \"The Distribution of Integer Magnitudes in Polynomial Arithmetic\" is worth a read:  http://people.csail.mit.edu/jaffer/CNS/DIMPA\n\nUsing a symbolic algebra system he examines the sizes of the integers used in the program. The conclusion is that it is the performance of small bignums that is the most important. He adds:\n\n> The large reduction in frequency of occurrence versus bit-length means that small improvements in asymptotic running times for exotic bignum algorithms would bring negligible benefit in running this computer algebra program.\n I have similar opinion, the fib example is more like a GC stress test. \nGuile (use libgmp for bignum) will be faster for fib if disabled GC. The note given by @soegaard reveals that Guile will do more collecting work if GC enabled, which seems the main reason of the loss.\n\n```\nIf gc is activated however, guile performs the calculation within 200KB and calls gc several times. The whole thing takes about 25 seconds (!),\n```\n\nI don't know the difference of GC strategy between Chez and Vicare yet. But obviously this fib issue contains two parts:\n1. operation efficiency of bignum (related to bignum system)\n2. alloc/collect efficiency of bignum (related to GC)\n\nIMO, it is too early to come to a conclusion about the bottleneck before deeper research.\n Well, I have some results after simple research.\nI was planning to disable GC in Chez, but seems no option for it. Fortunately, Chez provides useful functions for tweaking GC.\nThe original result is:\n\n```\n    1749 collections\n    17.650081080s elapsed cpu time, including 0.096985402s collecting\n    17.651558134s elapsed real time, including 0.099052668s collecting\n    43407533616 bytes allocated, including 43366316784 bytes reclaimed\n```\n\nThe I tweaked these two:\n\n```\n(collect-trip-bytes (* 10 (collect-trip-bytes))) ; enlarge the allocate block each time\n(collect-generation-radix 1000000) ; set to very large to avoid collect frequently\n```\n\nThen the result is:\n\n```\n    439 collections\n    18.025043206s elapsed cpu time, including 0.081797687s collecting\n    18.026762123s elapsed real time, including 0.082575259s collecting\n    43406709264 bytes allocated, including 43316982624 bytes reclaimed\n```\n\nWell, the collection and the cost time reduce effectively, but the cpu time seems almost unchanged.\nI don't know if it's the reasonably tweaking, but if it's correct for decreasing GC's activity, then my assumption is wrong: GC has little effect on this issue, and bignum operation matters.\n The fib test will indeed stress the GC a little, but this will only make the bignum calculation time worse for Chez Scheme, because Ikarus spends a lot more time in GC (1.5s Ikarus vs 0.1s Chez). Actually I doubt if you can do bignum benchmarks without using GC because bignums are allocated in the heap.\n\nTo be sure what we are talking about, this is the code:\n\n```\n(define fib-it\n  (lambda (n)\n    (define iter\n      (lambda (a b n)\n        (cond\n         [(= n 0) b]\n         [else\n          (iter (+ a b) a (- n 1))])))\n    (iter 1 0 n)))\n```\n\nIt is iterative (tail recursive), so in principle we could allocate all stuff on stack and don't really need heap allocations or GC. But GC does happen because bignums are stored in the heap. I guess we can put them on the stack with the help of escape analysis.\n\nRunning (fib-it 1000000) cost Chez only 0.1 seconds in GC time (thanks to the generational collector?). So most of the time (17s) was spent in bignum calculations.\n\nRunning bignum test in Chez Scheme (0.1s GC time):\n\n```\n> (time (display (< 1 (fib-it 1000000))))\n#t(time (display (< 1 ...)))\n    1750 collections\n    17.173180000s elapsed cpu time, including 0.100478000s collecting\n    17.178098000s elapsed real time, including 0.102999000s collecting\n    43407456912 bytes allocated, including 43407730416 bytes reclaimed\n```\n\nIn comparison, Ikarus spends significantly more time (1.5s) in GC:\n\n```\n> (time (display (< 1 (fib-it 1000000))))\n#trunning stats for (display (< 1 (fib-it 1000000))):\n    10421 collections\n    7171 ms elapsed cpu time, including 1512 ms collecting\n    7172 ms elapsed real time, including 1521 ms collecting\n    43402029744 bytes allocated\n```\n\nThis means that Chez Scheme has a superior garbage collector than Ikarus. To be sure, you can test Ikarus with a simple factorial program, but written in two different ways (recursive and iterative):\n\nRecursive factorial in Ikarus (caused 8.9s GC time):\n\n```\n(define fact\n  (lambda (n)\n    (cond\n     [(= n 0) 1]\n     [else (* n (fact (- n 1)))])))\n```\n\n```\n> (time (< 1 (fact 200000)))\nrunning stats for (< 1 (fact 200000)):\n    9518 collections\n    15006 ms elapsed cpu time, including 8915 ms collecting\n    15013 ms elapsed real time, including 8930 ms collecting\n    38616435792 bytes allocated\n```\n\nIterative factorial in Ikarus (caused only 3s GC time):\n\n```\n(define fact-it\n  (lambda (n)\n    (define fact1\n      (lambda (n prod)\n        (cond\n         [(= n 0) prod]\n         [else (fact1 (- n 1) (* n prod))])))\n    (fact1 n 1)))\n```\n\n```\n> (time (< 1 (fact-it 200000)))\nrunning stats for (< 1 (fact-it 200000)):\n    10425 collections\n    9874 ms elapsed cpu time, including 3020 ms collecting\n    9883 ms elapsed real time, including 3035 ms collecting\n    42222965144 bytes allocated\n```\n\nRunning both fact and fact-it in Chez, you won't notice much difference in GC time. Both are about 0.1s!\n\nRecursive factorial in Chez (0.11s GC time):\n\n```\n> (time (< 1 (fact 200000)))\n(time (< 1 ...))\n    195 collections\n    25.422836000s elapsed cpu time, including 0.110350000s collecting\n    25.465419000s elapsed real time, including 0.110865000s collecting\n    38622551408 bytes allocated, including 38222576752 bytes reclaimed\n```\n\nIterative factorial in Chez (0.11s GC time):\n\n```\n> (time (< 1 (fact-it 200000)))\n(time (< 1 ...))\n    390 collections\n    27.385098000s elapsed cpu time, including 0.115547000s collecting\n    27.442736000s elapsed real time, including 0.116543000s collecting\n    42224402672 bytes allocated, including 42222535536 bytes reclaimed\n```\n\nSo indeed Ikarus's garbage collector is not as good as Chez's, which makes bignum calculation time even worse for Chez ;) Since factorial uses multiplication, we can see GMP does make a big difference.\n\nI agree that we need a better bignum benchmark, but a simple example seems good enough to demonstrate what's going on.\n @lemaster @NalaGinrut @akeep @yinwang0 \n\nFirstly I think for multiplication and division there is no maze.\n\nFor addition I quickly wrote a benchmark for GMP:\n\n```\n#include <stdio.h>\n#include <gmp.h>\n\nint main()\n{\n  mpz_t a, b, c;\n  mpz_init(a);\n  mpz_init(b);\n  mpz_init(c);\n  mpz_ui_pow_ui(a, 2, 1000000);\n  mpz_ui_pow_ui(b, 2, 1000000);\n  printf(\"start!\\n\");\n  for(int i = 0; i < 1000000; i++)\n  {\n    mpz_add(c, a, b);\n  }\n}\n```\n\nWe can hardly do in-place bignum addition in scheme, so allocation could be more a problem than collection because we can combine multiple collections in GC. However we do not know the allocation time in Chez Scheme, but seems it can also be ignored according to comparison between Ikarus and Chez (see below) which is inspired by @yinwang0 's work.\n\nFor clarification, scheme version is also available:\n\n```\n; for Chez\n(run-cp0 (lambda (cp0 x) x))\n(optimize-level 0)\n\n; for Ikarus\n(cp0-effort-limit 0)\n(optimize-level 0)\n\n; for both\n(let [(a (expt 2 1000000))\n      (b (expt 2 1000000))]\n  (time\n    (do [(i 0 (+ i 1))\n         (c 0 (+ a b))]\n        [(= i 1000000)])))\n```\n\nOn my machine, results are as below(warming-up done):\n\nGMP: (time before \"start\" is too short so included)\n\n```\nreal    0m10.100s\nuser    0m10.096s\nsys     0m0.000s\n```\n\nChez:\n\n```\n2000 collections\n55.476879137s elapsed cpu time, including 0.244292071s collecting\n55.481766220s elapsed real time, including 0.247766474s collecting\n125025280000 bytes allocated, including 125028249216 bytes reclaimed\n```\n\nIkarus:\n\n```\n14925 collections\n14660 ms elapsed cpu time, including 896 ms collecting\n14663 ms elapsed real time, including 902 ms collecting\n125024000032 bytes allocated\n```\n\nSo addition performance is still low compared to GMP.\n I wrote a similar Java program doing `(fact 200000)`. It shows that Java's BigInteger has better multiplication performance than Chez's. It took Java 12.8s. \n\nIn summary:\n\n```\nIkarus: 9.9s\nJava: 12.8s\nChez: 27.4s\n```\n\nGMP is still the best among the three, for obvious reasons.\n Another interesting thing I observed is that if we use higher `optimize-level`, Ikarus can perform DCE on my benchmark code above while Chez cannot whether in REPL or command line, with \"--program\" or without, or with `cp0` or without.\n What does \"DCE\" stand for?\n @yinwang0 \"dead code elimination\", my bad.\n @akeep Nice information. Personally, I don't like GNU MP for its license. If we want to make Chez reliable and clean, I'd prefer directly improving implementations in `number.c` instead of being dependent on 3rd party libraries. I can help with it if appropriate.\n @yinwang0: This is Scheme, where fixnum overflow (using the term \"fixnum\" broadly) can return an exact non-fixnum, or an inexact approximation, or raise an implementation-restriction error, depending on the implementation.  This is true of all standards from R4RS onwards at least, and most .  See http://trac.sacrideo.us/wg/wiki/NumericTower for what many existing Schemes actually do.\n @hyln9  @akeep I think this fib case is too simple to take advantage of DCE, so maybe raise another issue?\n Personally, I'm not interested in porting libgmp to Chez. What I'm afraid is that is that very big number operation is optimized to be faster while small number is slower for a compromise. \nFor Chez, I think the strategy could be less extreme. Maybe we could find a way to improve big number operation in a limited expectation (say, not as fast as libgmp), but it shouldn't drag the small number operation.\nWell, I confess it sounds idealism. Anyway, if we can't find a way to improve big number without effecting small number, I prefer keep it as it is.\n @NalaGinrut \n\nChez obviously do DCE, so it is whether a bug or misunderstanding, rather than a performance issue which needs complex benchmark.\n\nAs far as I know, there is no evidence which shows that GMP has drawbacks on relatively small (i.e. mid-size) numbers. I agree with your opinions on performance but fixnum is managed by compiler itself without overhead while there are numbers of algorithms or strategies on mid-size bignum operations.\n @hyln9 \nAlright, I've taken a look again, GMP use different algorithm for different operand size. So maybe not the case I'm afraid of. I apologize for confusing here.\n I looked at the code of Chez's number.c and wonder if there is a simple way of make addition faster for 64-bit machines.\n\nI see that the `bigit` type is always defined as U32, and `big_add` operates on bigits, so it's not going to use 64-bit addition instruction, thus is doing twice as many additions.\n @yinwang0 In addition, since adc instruction (or intrinsic) is widely available, the EADDC macro is unnecessary. In the end we are getting farther and farther from standard c\u2026\n @hyln9 Indeed, it is the ADC instruction doing the trick in GMP. I played with GMP's configuration again, and found that Ikarus can't use GMP's 64-bit ABI. I had to compile GMP with ABI=32, so Ikarus was not utilizing the 64-bit instructions. But it's still a lot faster because it's using x86's ADC instruction.\n\nThe code that is in actual use by Ikarus on my machine is in this file:\n\n```\nmpn/x86/p6/aors_n.asm\n```\n\nIt's symbol linked to `mpn/add_n.asm` after running `./configure ABI=32`.\n\nThe assembly code looks like this, where `ADCSBB` is defined to be `adc` earlier. It's just repeatedly calling adc.\n\n```\ndefine(ADCSBB,        adc)\n... ...\n\nL(top):\n    jecxz   L(end)\nL(ent):\nZdisp(  mov,    0,(up,n,4), %eax)\nZdisp(  ADCSBB, 0,(vp,n,4), %eax)\nZdisp(  mov,    %eax, 0,(rp,n,4))\n\n    mov 4(up,n,4), %edx\n    ADCSBB  4(vp,n,4), %edx\n    mov %edx, 4(rp,n,4)\n\n    mov 8(up,n,4), %eax\n    ADCSBB  8(vp,n,4), %eax\n    mov %eax, 8(rp,n,4)\n\n    mov 12(up,n,4), %edx\n    ADCSBB  12(vp,n,4), %edx\n    mov %edx, 12(rp,n,4)\n\n    mov 16(up,n,4), %eax\n    ADCSBB  16(vp,n,4), %eax\n    mov %eax, 16(rp,n,4)\n\n    mov 20(up,n,4), %edx\n    ADCSBB  20(vp,n,4), %edx\n    mov %edx, 20(rp,n,4)\n\n    mov 24(up,n,4), %eax\n    ADCSBB  24(vp,n,4), %eax\n    mov %eax, 24(rp,n,4)\n\n    mov 28(up,n,4), %edx\n    ADCSBB  28(vp,n,4), %edx\n    mov %edx, 28(rp,n,4)\n\n    lea 8(n), n\n    jmp L(top)\n```\n @yinwang0 \n\nGMP's implementation of addition above combines adc with loop unrolling, which increases the ratio of arithmetic instructions.\n\nOn the other hand 64bit and 32 bit adc have same throughput on x86_64, therefore double the potential performance.\n\nBut all these might be off-topic.\n It would be great for someone to add the requisite ifdefs and asm instructions to use more efficient operators, and for someone to implement fancier algorithms, but please be careful in the process not to copy (or even study) code from GNU-licensed systems like GMP and Ikarus.  Though Aziz would probably be willing to put the portions of the code you want to use under the Apache 2.0 license.\n @dybvig \n\nYeah, that the reason why I haven't look at GMP's code yet except for the above one, so I cannot know GMP's algorithms. My major references are wikipedia pages and academic papers without code (since I am an undergraduate I do have access). Considering the known nine-line code court case we indeed need a clean room implementation.\n\nAs for Ikarus, things might be different because the techniques are different.\n @hyln9 GMP detected my processor as Haswell correctly and configured to use 64bit instructions and registers. It's just Ikarus 0.0.3 that can't use 64bit. So it's using adc with unrolling only with addition. It's using some mmx and sse instructions with other operations. Addition seems fast enough with just ADC and easy to implement with GCC's extended asm.\n @yinwang0 It seems that there are no SIMD instructions for adding with carry on x86 yet.\n I doubt there will be SIMD addition with carry because the carry propagation is hard to do in parallel. If you suceed then you effectively made a 128 bit machine or higher.\n\nhttp://stackoverflow.com/questions/27923192/practical-bignum-avx-sse-possible\n It sounds like we have to rewrite all bignum operations and maintain related assembly code for all supported platforms, which is  already done by libgmp. \nTake an example of addition operation. If we don't care about x86, maybe just rewrite EADDC is enough (no?). For X86 or certain platform doesn't contain needed AVX in the future, it's necessary to keep current EADDC.\nWell, maybe libgmp is still an option.\n I wrote a small demo program using GCC's extended assembly and the ADC instruction.\n\n>  https://gist.github.com/yinwang0/290f34bb567a896eada4745173aa4477\n\nThe main part of the demo is exactly following the names in `big_add_pos` so it's easy to swap the code into Chez Scheme.\n\nThe demo itself seems to be correct, but after swapping the code into `big_add_pos` and rebuild Chez Scheme after \"make clean\", I got some error saying \"nonrecoverable invalid memory reference\".\n\nIt looks like a good starting point. I'm going to look more, but to make the development \"parallel\", some of you may want to try and find out how to make it work.\n\nFor your convenience of offering help, I committed the changes to my fork:\n\n>  https://github.com/yinwang0/ChezScheme/commits/improve-big-add\n @NalaGinrut It looks Scheme doesn't provide that many bignum operators, and the open sourced Chez Scheme doesn't support that many architectures. I think it's worthwhile enough if we can just make the few operations fast under x86, because that's what most people use.\n The operations on bignums that are needed are those listed in section 11.7.4 of R6RS that are meaningful when applied to exact integers, namely `inexact = < > <= >= zero? positive? negative? odd? even? max min + - * / div mod div-and-mod div0 mod0 div0-and-mod0 gcd lcm expt number->string string->number`.\n @yinwang0 I haven't read the code carefully, but the inlined assembly code contains side-effects, it is  generally to add `volatile` or `__volatile__` to avoid the compiler breaking assembly code block while optimizing.\nhttps://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#ss5.4\nOr it may not safe:\n\n```\n[nalaginrut@debian:tmp] cc ba.c -o ba\n[nalaginrut@debian:tmp] ./ba\nz[0] = 1\nz[1] = 0\nz[2] = 0\nz[3] = 0\nz[4] = 0\n[nalaginrut@debian:tmp] cc ba.c -o ba -O3\n[nalaginrut@debian:tmp] ./ba\nz[0] = 0\nz[1] = 0\nz[2] = 0\nz[3] = 0\nz[4] = 0\n```\n\n@johnwcowan Maybe we don't have to optimize them all, and it is necessary to do more benchmarks first.\n @NalaGinrut Indeed not having `__volatile__` is one of the reasons that it's not right. Adding `__volatile__` and I see other kinds of issue. But it seems I'm getting closer to get it work.\n @NalaGinrut @yinwang0 On an inline assembly block, `volatile` basically means that the block has effects other than those explicitly indicated to GCC using the extended asm syntax input and output specifiers; indeed one of the reasons for the extended syntax is to allow GCC to do CSE, DCE and similar optimizations on inline assembly blocks. Writing `asm volatile` is basically giving up on explaining to the compiler what the assembly block does (think `mov cr3`); I don\u2019t see how this should be required here. A smaller but still probably excessive hammer is the `memory` output.\n\nOn the other hand, it looks like the function signature may need some `restrict` qualifiers (i.e. the code doesn\u2019t work correctly unless the pointers don\u2019t alias each other), but I\u2019ll leave that to the person that wrote it. (If you require GCC/ICC/clang you might as well assume support for `restrict` I think.)\n @alex-shpilkin I don't see why it's needed there but I got wrong results with gcc optimizations (-O1 and above) if there is no `__volatile__`. Maybe that's a hint why the code is still not correct.\n I fixed bugs in my code and now it can be built with Chez and produce correct results. The `__volatile__` can be removed and still produce correct results with `-O3`.\n\nThe code is here in my fork:\n\n> https://github.com/yinwang0/ChezScheme/commits/improve-big-add\n\nIt's basically a translation of Chez's original code, but using ADC instruction to handle the carry.\n\nUnfortunately the performance of the assembly code is not even as good as Chez's original C code. The timing is about 28s (my change) vs 17s (chez's original). So I'm no longer sure about ADC instruction is the real reason that GMP is fast. We could do some loop unrolling and see if that helps.\n Slowness fixed. That's because I used x86's `loop` instruction. Changed loop control to use `jecxz` and `lea`, and now it's faster than Chez's original code, although not much: 14s vs 18s.\n\nI have no idea why `loop` instruction is so slow, maybe just old circuit leftover in the processor ;)\n @yinwang0 Indeed, as [Agner Fog\u2019s tables](http://www.agner.org/optimize/instruction_tables.pdf) show,  `LOOP` (which existed in 8086 already) is a whopping 11 cycles on Sandy Bridge compared to two cycles for `JECXZ` (introduced in 80486 IIRC). In turn, `JECXZ` is not needed, because (recent Intel) processors are able to fuse the `CMP`/`JNE` pair into one microinstruction internally.\n\nMost probably the loop would benefit from unrolling, but the degree of it is to be determined empirically, preferably on benchmarks with realistic number magnitudes. (Would the tail dominate? Can we just declare that bignums are allocated in 4x32/64 chunks? Should we align to 128-bit memory fetch lines [C11 `alignas`]? &c.)\n @alex-shpilkin I unrolled the loops and adjusted the way for indexing into the arrays. Now the timing is reduced to about 10.5s (as compared to its original 18s). It's still a little long as compared to Ikarus's 6.75s.\n\nI can't use `CMP / JNE` because `CMP` may change the `CF` flag, which `ADC` will need. It's quite some tricks that it does by using `LEA` for addition into `ECX`, and `JECXZ` for looping.\n\nThe unrolling is done only 2x. I tried to unroll the loops using 4x32 chunks but it didn't improve over 2x32, so I'm currently keeping it at 2x just for clarity of the code. Some other things can be done for example using 64-bit addition. Also it needs some `#if`'s for targeting correct architecture.\n @dybvig I got some endianness problems when trying to use 64-bit instructions. Since the 32-bit chunks of bignums are stored in a big-endian way, I got wrong byte order when using `movq` instruction of x86 which assumes little-endian. I could do my own byte order swapping back and forth, but this may not be efficient.\n\nI wonder if Chez already conditionally handles the endianness regarding bignums? Is there an easy variable to change so can I switch it to 64-bit mode?\n @NalaGinrut ADC has nothing to do with AVX, but indeed EADDC should be preserved for fallback.\n@yinwang0 Currently bigit_bits is always 32 regardless of machine type.\n I'd like to discuss some design decisions here before going any further.\n\nI'd prefer to use assembly source file directly instead of inline assembly or intrinsics which is not portable (e.g. x86_64 inline assembly is not available in msvc), stable (depends on compiler behavior) or optimal (e.g. adc intrinsics are not well-optimized). We can create a folder called \"a\" and put assembly code into different folders distinguished by machine types.\n\nIn c sources, we can use ifdefs to tell whether a function is implemented in asm or c.\n @hyln9 Indeed inline assembly is not as good as separate assembly files. My implementation can be considered a proof of concept that ADC can run faster. GCC's inline assembly is also quirky to get right, and is thus just for small snippets. It's better to use a portable assembly language line NASM to write those.\n @hyln9 \nI thought we may choose AVX for bignum, but seems it's more inconvenient than ADC.\nAnd libgmp proves ADC is enough. My bad English.\nI agree with you to create folder for assembly code. But maybe we could find better way to optimize the current prove of concept first. It is not as fast as expected.\n @NalaGinrut You are right. My code is still not as fast as GMP's although they look very similar, so you may want to play with it and see if there is easy way to improve. I also unrolled it 4 and 8 times, but it didn't improve the performance. I don't know yet what other tricks are in GMP for addition.\n @yinwang0 After a quick look at `number.c`, I found that maybe the copy operation of `copy_normalize` is not optimized.\n Tried to use ROL and ROR for switching endians, but unfortunately they change the carry flag CF. Keep in mind the trick with ADC lies in that you can't use instructions that can change the CF flag between the ADCs.\n\nSo it seems we really need to store the bignum in different order with 64-bit machines.\n @akeep After some investigations into Ikarus, I think the DCE issue is actually a loop-invariant hoisting one.\n Actually I don't see where this code is related to DCE.\n @yinwang0 It has no return values or side effects.\n @hyln9 Are we talking about the same piece of code?\n\n```\n(define fib-it\n  (lambda (n)\n    (define iter\n      (lambda (a b n)\n        (cond\n         [(= n 0) b]\n         [else\n          (iter (+ a b) a (- n 1))])))\n    (iter 1 0 n)))\n\n(time (display (< 1 (fib-it 1000000))))\n```\n\nI don't see where the dead code is.\n @yinwang0 @akeep Sorry for the confusion I made. I meant this: https://github.com/cisco/ChezScheme/issues/14#issuecomment-215851686\n I'm going to take the opportunity in the lull between posts to close this issue and suggest that further discussion either be held privately amongst the thread contributors or on the mailing list.\n  IRC users now have a channel #chez on Freenode, which technically should be called ##chez because it is unofficial.  Please leave a comment blessing it as official so that we can point to this if Freenode staff ask us.  Thanks.\n (bless #chez 'official)\n blessed!\n All blessings are welcome, but it is the blessings of core Chez development folks that Freenode needs.\n Of course you and all members of the Chez team are entirely welcome at #chez, but your presence is not at all required.  We merely need some documentation that we are acting with, rather than totally independently of, the Chez team.\n\nYou can connect to Freenode IRC channels without an IRC client using http://webchat.freenode.net.\n There is a form to fill out, but according to reports, freenode is no longer actually looking at the form.  The channel is registered with ChanServ and I can become an op when needed, so the channel won't be hijacked.  I have made you an op as well; if you need to exercise your powers (such as to change the topic), type \"/msg chanserv op #chez\".\n\nOtherwise, yes, go ahead and close the issue.\n Oops, actually you need to register yourself.  Next time you are on, type \"/msg nickserv register <weak-password> <email-address>\" so that I can make you an op.\n That barfed.  It's /msg nickserv register password email-address\n  This is on Linux with gcc 6.0.0, the same conditions as issue #1.  The contains of a6le/mats/summary is:\n\n```\n-------- o=0 --------\n0a1,2\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=3 --------\n0a1,2\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=0 cp0=t --------\n0a1,2\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=3 cp0=t --------\n0a1,2\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=0 spi=t p=t --------\n0a1,2\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=3 spi=t p=t --------\n0a1,2\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=0 eval=interpret --------\n6a7,8\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=3 eval=interpret --------\n6a7,8\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=0 cp0=t eval=interpret --------\n6a7,8\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=3 cp0=t eval=interpret --------\n6a7,8\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=0 ehc=t eoc=f --------\n0a1,2\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n-------- o=3 ehc=t eval=interpret --------\n6a7,8\n> 6.mo:Bug in mat filesystem-operations clause 104 at line 2888, char 3 of 6.ms\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n```\n\nI can supply additional files if needed.\n I have only \"data.mo bug\".\nHere's some information:\n\n```\nLinux debian 4.5.0 #4 SMP PREEMPT Mon Apr 25 13:45:56 CST 2016 x86_64 GNU/Linux\ngcc (Debian 5.3.1-14) 5.3.1 20160409\n```\n The 6.ms bug likely occurs because of file permissions that are different from our test environment, and the mat will need to be removed or replaced.  The date.ms bug is presumably caused by differences in the C library asctime_r function.  I'd be interested in knowing what\n\n```\n(write (time-utc->date (make-time 'time-utc 708626501 1427137297)))\n```\n\nprints on your systems to help determine whether there is some pattern we could be checking in place of the specific one that works in our test environment.\n On my mac, this prints:\n\n```\n> (with-output-to-string (lambda () (write (time-utc->date (make-time 'time-utc 708626501 1427137297)))))\n\"#<date Tue Mar 24 03:01:37 2015>\"\n\n> the value compared with in the test is:  \"#<date Mon Mar 23 15:01:37 2015>\"\n\n```\n\nIt seems that it has an offset of 12 hours. (I am in timezone +0800)\n Similar issue in my mats testing also, but restricted to line 565.\ndate-time output:  \n`#<date Mon Mar 23 12:01:37 2015>`\n\nI am pacific time as well, OS X, 10.10.2\n\nA. \n-------- o=0 --------\n0a1\n\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=3 --------\n> 0a1\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=0 cp0=t --------\n> 0a1\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=3 cp0=t --------\n> 0a1\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=0 spi=t p=t --------\n> 0a1\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=3 spi=t p=t --------\n> 0a1\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=0 eval=interpret --------\n> 6a7\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=3 eval=interpret --------\n> 6a7\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=0 cp0=t eval=interpret --------\n> 6a7\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=3 cp0=t eval=interpret --------\n> 6a7\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=0 ehc=t eoc=f --------\n> 0a1\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n> -------- o=3 ehc=t eval=interpret --------\n> 6a7\n> date.mo:Bug in mat time&date-printing clause 2 at line 565, char 3 of date.ms\n ```\n> (write (time-utc->date (make-time 'time-utc 708626501 1427137297)))\n#<date Tue Mar 24 03:01:37 2015>\n```\n Here's what I see:\n\n```\n> (write (time-utc->date (make-time 'time-utc 708626501 1427137297)))\n#<date Mon Mar 23 12:01:37 2015>\n```\n\nIn case it is useful, here is the output of `timedatectl`:\n\n```\n      Local time: Wed 2016-04-27 08:14:25 PDT\n  Universal time: Wed 2016-04-27 15:14:25 UTC\n        RTC time: n/a\n       Time zone: America/Los_Angeles (PDT, -0700)\n Network time on: yes\nNTP synchronized: yes\n RTC in local TZ: no\n```\n\nThe `TZ` environment variable is not set.\n\nAnd here's my `uname -a` output:\n\n```\nLinux vrici.digitalkingdom.org 4.6.0-0.rc4.git0.1.fc25.x86_64 #1 SMP Mon Apr 18 16:09:22 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux\n```\n I have the date test failing on openbsd too:\n\n```\n> (with-output-to-string (lambda () (write (time-utc->date (make-time 'time-utc 708626501 1427137297)))))\n\"#<date Mon Mar 23 19:01:37 2015>\"\n```\n I committed a change that should address the 6.ms problem.  Looks like Andy is working on the date.ms one.\n @akeep: I don't think this is exactly what you are asking for, but if I change my time zone to EDT (I am usually in MDT), the error goes away.\n", "text_all_count": 73213, "text_word_token": ["Building", "the", "compiler", "in", "safe", "mode", "for", "NUMBER", "bit", "x", "NUMBER", "reveals", "incorrect", "uses", "of", "fxzero", "in", "x", "NUMBER", "ss", "a", "NUMBER", "bit", "immediate", "be", "not", "necessarily", "a", "fixnum", "NUMBER", "For", "example", "compilation", "of", "newhash", "NUMBER", "ss", "triggers", "an", "error", "since", "it", "involves", "an", "fx", "on", "NUMBER", "which", "turns", "into", "an", "inline", "on", "the", "immediate", "NUMBER", "The", "misuses", "of", "fxzero", "cause", "no", "trouble", "when", "compiled", "as", "unsafe", "since", "that", "turns", "into", "a", "eq", "that", "works", "as", "intended", "in", "this", "case", "NUMBER", "This", "patch", "add", "a", "compress", "level", "parameter", "that", "can", "be", "use", "to", "control", "the", "amount", "of", "effort", "expended", "compressing", "whether", "with", "the", "default", "LZ", "NUMBER", "compression", "or", "gzip", "compression", "NUMBER", "The", "parameter", "can", "take", "on", "one", "of", "the", "symbolic", "values", "low", "medium", "high", "or", "maximum", "NUMBER", "The", "default", "be", "medium", "which", "for", "LZ", "NUMBER", "currently", "maps", "to", "LZ", "NUMBER", "HC_CLEVEL_MIN", "and", "be", "both", "more", "effective", "and", "slower", "at", "compression", "but", "not", "decompression", "than", "the", "previous", "default", "NUMBER", "The", "patch", "also", "makes", "several", "change", "to", "the", "LZ", "NUMBER", "support", "code", "add", "in", "NUMBER", "in", "particular", "it", "restructures", "the", "code", "a", "bit", "puts", "the", "compress", "format", "directly", "in", "the", "thread", "context", "which", "now", "also", "holds", "the", "compress", "level", "and", "change", "how", "the", "compressed", "bytevector", "compression", "format", "and", "length", "be", "stored", "in", "the", "header", "word", "NUMBER", "I", "have", "test", "the", "change", "on", "OSX", "and", "Linux", "but", "not", "Windows", "NUMBER", "These", "change", "look", "good", "to", "me", "NUMBER", "Just", "to", "confirm", "Racket", "on", "Chez", "build", "fine", "with", "the", "patch", "its", "boot", "file", "size", "goes", "down", "by", "about", "NUMBER", "and", "load", "time", "remains", "about", "the", "same", "and", "maybe", "slightly", "faster", "NUMBER", "Thanks", "for", "the", "corrections", "Thanks", "for", "all", "the", "change", "on", "this", "branch", "Valgrind", "s", "memcheck", "tool", "be", "happy", "now", "NUMBER", "Note", "typo", "on", "line", "NUMBER", "of", "compress", "io", "NUMBER", "c", "lcoal", "local", "NUMBER", "At", "least", "I", "think", "it", "s", "a", "typo", "NUMBER", "If", "not", "can", "someone", "explain", "what", "it", "means", "LINK", "NUMBER", "syntax", "h", "NUMBER", "says", "in", "the", "next", "to", "last", "bullet", "TAG", "TAG", "P", "TAG", "TAG", "be", "of", "the", "form", "TAG", "TAG", "P", "TAG", "NUMBER", "TAG", "TAG", "nbsp", "NUMBER", "nbsp", "TAG", "P", "TAG", "k", "TAG", "TAG", "nbsp", "TAG", "P", "TAG", "e", "TAG", "TAG", "nbsp", "TAG", "ellipsis", "TAG", "nbsp", "TAG", "P", "TAG", "TAG", "m", "TAG", "NUMBER", "TAG", "TAG", "nbsp", "NUMBER", "nbsp", "TAG", "P", "TAG", "n", "TAG", "TAG", "TAG", "where", "TAG", "TAG", "ellipsis", "TAG", "TAG", "be", "the", "identifier", "TAG", "NUMBER", "TAG", "and", "TAG", "TAG", "F", "TAG", "TAG", "be", "a", "vector", "of", "TAG", "n", "TAG", "or", "more", "elements", "whose", "first", "TAG", "k", "TAG", "elements", "match", "TAG", "TAG", "P", "TAG", "NUMBER", "TAG", "TAG", "TAG", "through", "TAG", "TAG", "P", "TAG", "k", "TAG", "TAG", "TAG", "whose", "next", "TAG", "m", "TAG", "TAG", "k", "TAG", "elements", "each", "match", "TAG", "TAG", "P", "TAG", "e", "TAG", "TAG", "TAG", "and", "whose", "remaining", "TAG", "n", "TAG", "TAG", "m", "TAG", "elements", "match", "TAG", "TAG", "P", "TAG", "TAG", "m", "TAG", "NUMBER", "TAG", "TAG", "TAG", "through", "TAG", "TAG", "P", "TAG", "n", "TAG", "TAG", "TAG", "Shouldn", "t", "_n_", "or", "more", "elements", "be", "just", "_n_", "elements", "instead", "Section", "NUMBER", "of", "R", "NUMBER", "RS", "says", "the", "same", "thing", "NUMBER", "Hmm", "NUMBER", "That", "doesn", "t", "seem", "right", "either", "NUMBER", "If", "the", "first", "_k_", "elements", "match", "_P", "TAG", "NUMBER", "TAG", "_", "through", "_P", "TAG", "k", "TAG", "_", "and", "the", "last", "_m_", "match", "_S", "TAG", "NUMBER", "TAG", "_", "through", "_S", "TAG", "m", "TAG", "_", "and", "there", "be", "_n_", "altogether", "the", "number", "of", "elements", "left", "to", "match", "_P", "TAG", "e_", "be", "_n_", "_k_", "_m_", "not", "_n_", "_m_", "NUMBER", "This", "seems", "like", "a", "good", "idea", "NUMBER", "I", "would", "go", "for", "squashing", "in", "variation", "NUMBER", "NUMBER", "c", "NUMBER", "with", "experimental", "hg", "support", "NUMBER", "This", "patch", "speeds", "up", "compressed", "code", "loading", "and", "decompression", "in", "general", "by", "use", "LZ", "NUMBER", "in", "place", "of", "zlib", "NUMBER", "Loading", "LZ", "NUMBER", "compressed", "code", "on", "my", "machine", "takes", "about", "the", "same", "time", "as", "loading", "uncompressed", "code", "in", "contrast", "to", "decompression", "via", "zlib", "which", "makes", "loading", "take", "about", "twice", "as", "long", "NUMBER", "This", "patch", "do", "not", "remove", "the", "use", "of", "zlib", "but", "it", "add", "LZ", "NUMBER", "and", "makes", "it", "the", "default", "NUMBER", "Setting", "the", "compress", "format", "parameter", "to", "gzip", "makes", "compression", "use", "zlib", "instead", "of", "LZ", "NUMBER", "Reading", "a", "compressed", "file", "infers", "the", "compression", "format", "so", "compress", "format", "has", "no", "effect", "on", "loading", "reading", "NUMBER", "The", "LZ", "NUMBER", "implementation", "be", "pull", "in", "via", "a", "submodule", "analogous", "to", "zlib", "but", "I", "add", "ZLIB", "and", "LZ", "NUMBER", "options", "to", "configure", "to", "enable", "selecting", "an", "exist", "zlib", "and", "or", "lz", "NUMBER", "build", "NUMBER", "The", "LZ", "NUMBER", "source", "do", "not", "appear", "to", "have", "support", "for", "a", "non", "DLL", "Windows", "build", "so", "that", "part", "s", "especially", "ugly", "NUMBER", "How", "do", "we", "build", "the", "Scheme", "side", "I", "get", "invalid", "memory", "accesses", "when", "use", "make", "and", "with", "the", "patch", "file", "technique", "I", "get", "unexpect", "primref", "records", "from", "uncprep", "NUMBER", "burgerrg", "Thanks", "for", "the", "repair", "and", "I", "ll", "rename", "compress", "NUMBER", "soon", "NUMBER", "I", "expect", "a", "build", "in", "a", "clean", "checkout", "to", "work", "i", "NUMBER", "e", "NUMBER", "with", "the", "old", "checked", "in", "bootfiles", "NUMBER", "Assuming", "that", "you", "don", "t", "already", "have", "some", "older", "bootfiles", "in", "your", "checkout", "I", "don", "t", "know", "what", "went", "wrong", "NUMBER", "Technically", "the", "checked", "in", "boot", "file", "will", "call", "some", "kernel", "function", "without", "a", "new", "boolean", "argument", "while", "bootstrapping", "but", "a", "random", "value", "for", "that", "boolean", "should", "be", "harmless", "and", "merely", "cause", "a", "compression", "format", "to", "be", "selected", "at", "random", "for", "some", "intermediate", "steps", "NUMBER", "I", "did", "a", "clean", "build", "on", "both", "macOS", "and", "Windows", "but", "couldn", "t", "get", "it", "to", "work", "NUMBER", "On", "macOS", "make", "in", "the", "s", "directory", "yields", "echo", "reset", "handler", "abort", "base", "exception", "handler", "lambda", "c", "fresh", "line", "display", "condition", "c", "newline", "reset", "keyboard", "interrupt", "handler", "lambda", "display", "interrupted", "aborting", "n", "reset", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "commonization", "level", "commonization", "level", "generate", "inspector", "information", "f", "subset", "mode", "quote", "system", "compile", "file", "cmacros", "NUMBER", "ss", "cmacros", "NUMBER", "so", "NUMBER", "bin", "a", "NUMBER", "osx", "scheme", "q", "compile", "cmacros", "NUMBER", "ss", "with", "output", "to", "cmacros", "NUMBER", "so", "Exception", "in", "fasl", "write", "invalid", "fasl", "object", "TAG", "On", "Windows", "make", "in", "the", "s", "directory", "yields", "echo", "reset", "handler", "abort", "base", "exception", "handler", "lambda", "c", "fresh", "line", "display", "condition", "c", "newline", "reset", "keyboard", "interrupt", "handler", "lambda", "display", "interrupted", "aborting", "n", "reset", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "commonization", "level", "commonization", "level", "generate", "inspector", "information", "f", "subset", "mode", "quote", "system", "compile", "file", "cmacros", "NUMBER", "ss", "cmacros", "NUMBER", "so", "NUMBER", "bin", "a", "NUMBER", "nt", "scheme", "NUMBER", "exe", "q", "Error", "in", "foreign", "procedure", "no", "entry", "for", "s", "cs", "find_pcode", "burgerrg", "Still", "no", "idea", "about", "the", "build", "problem", "since", "things", "work", "for", "me", "from", "a", "clean", "build", "on", "macOS", "Windows", "WSL", "and", "Linux", "and", "the", "build", "works", "on", "Travis", "CI", "NUMBER", "I", "note", "that", "find_pcode", "was", "remove", "in", "NUMBER", "e", "NUMBER", "f", "NUMBER", "and", "the", "bootfiles", "were", "update", "in", "NUMBER", "b", "NUMBER", "Maybe", "it", "will", "help", "somehow", "that", "I", "rebased", "to", "pull", "in", "yesterday", "s", "commit", "NUMBER", "I", "see", "that", "I", "overlooked", "lots", "of", "C", "compiler", "warnings", "on", "Windows", "NUMBER", "I", "ll", "fix", "those", "NUMBER", "Thanks", "Rebased", "NUMBER", "This", "looks", "good", "to", "me", "just", "a", "couple", "of", "nits", "In", "primdata", "NUMBER", "ss", "the", "second", "signature", "for", "compress", "format", "should", "be", "sub", "symbol", "void", "NUMBER", "The", "copyright", "notice", "on", "compress", "io", "NUMBER", "c", "identifies", "the", "file", "as", "system", "NUMBER", "h", "NUMBER", "The", "copyright", "notice", "on", "compress", "io", "NUMBER", "h", "be", "miss", "NUMBER", "I", "like", "the", "new", "mat", "parameters", "subform", "NUMBER", "I", "run", "some", "quick", "test", "on", "my", "machine", "with", "solid", "state", "drive", "start", "up", "time", "presumably", "mostly", "loading", "the", "boot", "file", "drop", "by", "about", "NUMBER", "with", "the", "change", "NUMBER", "Bootstrapping", "time", "also", "drop", "by", "NUMBER", "NUMBER", "Nice", "Though", "start", "up", "time", "still", "took", "nearly", "twice", "as", "long", "for", "me", "with", "lz", "NUMBER", "compressed", "boot", "file", "as", "with", "uncompressed", "boot", "file", "NUMBER", "Correction", "start", "up", "time", "with", "lz", "NUMBER", "compression", "be", "actually", "NUMBER", "faster", "for", "me", "than", "with", "zlib", "compression", "and", "just", "NUMBER", "slower", "than", "with", "no", "compression", "NUMBER", "It", "turns", "out", "I", "was", "get", "zlib", "compressed", "boot", "file", "as", "a", "result", "of", "bootstrapping", "in", "an", "exist", "workarea", "NUMBER", "Thanks", "for", "the", "copyright", "and", "primdata", "NUMBER", "ss", "repairs", "now", "push", "NUMBER", "Looks", "good", "thanks", "for", "putting", "in", "those", "change", "NUMBER", "NUMBER", "evaluates", "to", "NUMBER", "I", "m", "not", "sure", "this", "be", "a", "bug", "but", "I", "was", "expecting", "NUMBER", "like", "NUMBER", "NUMBER", "NUMBER", "Is", "there", "a", "good", "reason", "for", "the", "current", "behavior", "NUMBER", "NUMBER", "evaluates", "to", "NUMBER", "I", "m", "not", "sure", "this", "be", "a", "bug", "but", "I", "was", "expecting", "NUMBER", "like", "NUMBER", "NUMBER", "NUMBER", "Is", "there", "a", "good", "reason", "for", "the", "current", "behavior", "R", "NUMBER", "RS", "has", "the", "following", "example", "NUMBER", "NUMBER", "NUMBER", "LINK", "Z", "H", "NUMBER", "html", "node_sec_", "NUMBER", "Thanks", "NUMBER", "After", "thinking", "about", "it", "some", "more", "I", "guess", "the", "argument", "be", "that", "NUMBER", "as", "an", "inexact", "number", "could", "conceivably", "be", "so", "inaccurate", "that", "it", "s", "actually", "zero", "in", "which", "case", "the", "quotient", "be", "undefined", "not", "zero", "NUMBER", "Hello", "After", "the", "commit", "NUMBER", "be", "NUMBER", "d", "NUMBER", "a", "fresh", "build", "of", "Chez", "Scheme", "fail", "with", "the", "following", "error", "cannot", "find", "compatible", "scheme", "NUMBER", "boot", "in", "search", "path", "InstallPrefix", "lib", "csv", "v", "m", "Here", "s", "the", "replication", "process", "for", "a", "NUMBER", "le", "bash", "git", "clone", "LINK", "cd", "ChezScheme", "NUMBER", "configure", "make", "install", "cd", "NUMBER", "echo", "printf", "Works", "n", "scheme", "It", "looks", "like", "the", "change", "to", "configure", "broke", "the", "way", "w", "c", "config", "NUMBER", "h", "generates", "DEFAULT_HEAP_PATH", "on", "non", "Windows", "systems", "NUMBER", "In", "particular", "installlib", "contains", "the", "literal", "InstallPrefix", "instead", "of", "resolving", "it", "NUMBER", "That", "fix", "it", "thanks", "NUMBER", "And", "thank", "you", "for", "the", "quick", "response", "NUMBER", "The", "following", "code", "works", "as", "expected", "in", "a", "terminal", "REPL", "but", "not", "from", "an", "Emacs", "REPL", "fork", "thread", "lambda", "let", "loop", "sleep", "make", "time", "time", "duration", "NUMBER", "NUMBER", "display", "Hello", "flush", "output", "port", "loop", "I", "ve", "tried", "run", "scheme", "comint", "run", "shell", "and", "ansi", "term", "NUMBER", "Strangely", "if", "I", "evaluate", "some", "stuff", "at", "the", "Emacs", "REPL", "the", "thread", "seems", "to", "run", "briefly", "then", "stops", "again", "NUMBER", "This", "isn", "t", "a", "problem", "with", "printing", "or", "output", "ports", "NUMBER", "My", "actual", "code", "pushes", "OSC", "via", "UDP", "to", "SuperCollider", "so", "the", "side", "effect", "be", "audible", "the", "behaviour", "be", "the", "same", "NUMBER", "I", "have", "be", "looking", "at", "similar", "issue", "such", "as", "this", "one", "LINK", "where", "ovenpasta", "mentions", "this", "exact", "problem", "but", "I", "don", "t", "really", "understand", "the", "conclusions", "NUMBER", "Apologies", "if", "this", "be", "obvious", "If", "you", "use", "scheme", "eedisable", "you", "should", "see", "the", "same", "blocking", "behavior", "at", "a", "terminal", "REPL", "NUMBER", "I", "think", "the", "problem", "be", "cause", "by", "the", "REPL", "s", "blocking", "read", "to", "stdin", "holding", "the", "tc", "mutex", "although", "I", "m", "not", "yet", "sure", "why", "that", "happens", "NUMBER", "Any", "other", "thread", "that", "needs", "this", "mutex", "and", "it", "s", "use", "for", "lots", "of", "operations", "would", "have", "to", "wait", "for", "the", "read", "to", "complete", "NUMBER", "Thanks", "for", "the", "quick", "reply", "Yes", "I", "do", "see", "the", "same", "behaviour", "in", "that", "case", "NUMBER", "I", "suppose", "enabling", "the", "expression", "editor", "be", "probably", "a", "pretty", "bad", "idea", "in", "the", "Emacs", "environment", "if", "it", "s", "even", "possible", "NUMBER", "It", "s", "a", "shame", "as", "this", "be", "the", "only", "thing", "holding", "me", "back", "from", "a", "very", "nice", "live", "code", "music", "environment", "NUMBER", "I", "don", "t", "suppose", "there", "be", "any", "other", "workarounds", "you", "can", "think", "of", "I", "m", "looking", "into", "the", "root", "cause", "of", "the", "problem", "NUMBER", "In", "the", "meantime", "you", "could", "try", "Swish", "LINK", "an", "extension", "of", "the", "single", "threaded", "Chez", "Scheme", "that", "performs", "asynchronous", "I", "O", "NUMBER", "Swish", "doesn", "t", "support", "UDP", "so", "you", "d", "have", "to", "code", "it", "NUMBER", "Wonderful", "I", "ll", "give", "Swish", "a", "try", "NUMBER", "I", "put", "together", "the", "UDP", "myself", "anyway", "with", "modifcations", "to", "this", "socket", "implementation", "LINK", "NUMBER", "I", "can", "t", "thank", "you", "enough", "for", "your", "response", "I", "ve", "be", "stuck", "on", "this", "for", "a", "few", "days", "NUMBER", "Here", "s", "a", "work", "around", "for", "Chez", "Scheme", "define", "fix", "stdin", "let", "stdin", "transcoded", "port", "standard", "input", "port", "make", "transcoder", "utf", "NUMBER", "codec", "current", "input", "port", "stdin", "console", "input", "port", "stdin", "fix", "stdin", "fork", "thread", "lambda", "let", "loop", "sleep", "make", "time", "time", "duration", "NUMBER", "NUMBER", "display", "Hello", "flush", "output", "port", "loop", "Chez", "Scheme", "sets", "the", "console", "input", "and", "output", "ports", "to", "be", "the", "same", "input", "output", "port", "NUMBER", "The", "port", "handler", "see", "s", "io", "NUMBER", "ss", "holds", "the", "tc", "mutex", "around", "blocking", "calls", "NUMBER", "As", "a", "result", "you", "must", "create", "a", "separate", "port", "if", "you", "want", "to", "do", "blocking", "reads", "without", "holding", "the", "tc", "mutex", "NUMBER", "Section", "NUMBER", "of", "the", "user", "guide", "LINK", "NUMBER", "threads", "h", "NUMBER", "explains", "this", "The", "initial", "console", "and", "current", "input", "and", "output", "ports", "be", "thread", "safe", "as", "be", "transcript", "ports", "so", "it", "be", "safe", "for", "multiple", "threads", "to", "print", "error", "and", "or", "debugging", "message", "to", "the", "console", "NUMBER", "The", "output", "may", "be", "interleaved", "even", "within", "the", "same", "line", "but", "the", "port", "will", "not", "become", "corrupted", "NUMBER", "Thread", "safety", "for", "these", "ports", "be", "accomplished", "at", "the", "high", "cost", "of", "acquiring", "a", "mutex", "for", "each", "I", "O", "operation", "NUMBER", "dybvig", "perhaps", "the", "guide", "should", "also", "say", "that", "the", "same", "mutex", "be", "use", "for", "other", "system", "operations", "NUMBER", "As", "a", "result", "if", "you", "re", "doing", "a", "blocking", "read", "on", "the", "initial", "console", "input", "port", "beware", "that", "operations", "on", "other", "threads", "that", "require", "this", "mutex", "will", "block", "NUMBER", "Here", "s", "a", "work", "around", "for", "Chez", "Scheme", "It", "works", "thank", "you", "so", "much", "I", "did", "read", "that", "line", "in", "the", "user", "guide", "while", "investigating", "the", "issue", "but", "I", "didn", "t", "realise", "it", "applied", "here", "NUMBER", "I", "ll", "take", "a", "look", "at", "Swish", "anyway", "though", "I", "m", "still", "downloading", "mactex", "NUMBER", "GB", "NUMBER", "burgerrg", "You", "enable", "me", "to", "get", "going", "and", "I", "m", "make", "terrific", "progress", "on", "my", "music", "system", "thanks", "I", "m", "run", "into", "a", "problem", "now", "that", "I", "believe", "be", "relate", "NUMBER", "If", "anything", "goes", "wrong", "on", "my", "background", "thread", "it", "stops", "altogether", "and", "doesn", "t", "print", "any", "error", "message", "NUMBER", "I", "d", "like", "it", "to", "print", "an", "error", "and", "continue", "gracefully", "by", "simply", "resetting", "the", "thunk", "that", "it", "s", "performing", "regularly", "NUMBER", "I", "tried", "this", "define", "my", "thread", "thunk", "with", "exception", "handler", "lambda", "x", "display", "x", "newline", "flush", "output", "port", "define", "top", "level", "value", "p", "NUMBER", "lambda", "void", "p", "NUMBER", "Where", "my", "thread", "thunk", "be", "the", "thunk", "pass", "to", "fork", "thread", "and", "p", "NUMBER", "be", "a", "thunk", "that", "do", "my", "work", "NUMBER", "But", "no", "dice", "the", "thread", "just", "stops", "as", "before", "with", "no", "printout", "if", "p", "NUMBER", "raises", "an", "exception", "NUMBER", "The", "exception", "handler", "needs", "to", "invoke", "a", "continuation", "so", "that", "Chez", "Scheme", "doesn", "t", "subsequently", "raise", "a", "non", "continuable", "error", "NUMBER", "fork", "thread", "lambda", "call", "cc", "lambda", "do", "with", "exception", "handler", "lambda", "e", "pretty", "print", "e", "flush", "output", "port", "do", "void", "lambda", "let", "loop", "sleep", "make", "time", "time", "duration", "NUMBER", "NUMBER", "display", "Hello", "flush", "output", "port", "error", "f", "boom", "loop", "Using", "the", "guard", "form", "be", "more", "succinct", "fork", "thread", "lambda", "guard", "x", "else", "display", "condition", "x", "newline", "flush", "output", "port", "let", "loop", "sleep", "make", "time", "time", "duration", "NUMBER", "NUMBER", "display", "Hello", "flush", "output", "port", "error", "f", "boom", "loop", "The", "thread", "now", "seems", "to", "behave", "nicely", "although", "I", "don", "t", "see", "an", "error", "printout", "NUMBER", "Actually", "a", "simple", "call", "to", "display", "or", "write", "in", "the", "guard", "handler", "doesn", "t", "seem", "to", "work", "either", "NUMBER", "I", "m", "sure", "I", "can", "figure", "that", "out", "though", "NUMBER", "This", "prevents", "me", "needing", "to", "restart", "Chez", "when", "something", "goes", "wrong", "which", "be", "a", "huge", "improvement", "NUMBER", "Thanks", "so", "much", "That", "didn", "t", "seem", "to", "be", "it", "NUMBER", "Welcome", "to", "the", "Ouroboros", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "It", "s", "a", "reference", "to", "itself", "NUMBER", "But", "what", "be", "its", "type", "pair", "NUMBER", "NUMBER", "f", "boolean", "NUMBER", "NUMBER", "f", "procedure", "NUMBER", "NUMBER", "f", "eq", "void", "NUMBER", "NUMBER", "f", "No", "idea", "NUMBER", "But", "it", "s", "still", "a", "thing", "this", "Ouroboros", "and", "in", "fact", "it", "s", "a", "unique", "thing", "there", "s", "only", "one", "like", "it", "and", "you", "can", "place", "it", "in", "a", "list", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "The", "Ouroboros", "be", "in", "fact", "so", "unique", "and", "special", "that", "you", "can", "t", "have", "other", "Ouroboroi", "with", "mutually", "point", "edges", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "C", "c", "C", "c", "This", "be", "an", "infinite", "loop", "out", "of", "which", "you", "exit", "only", "with", "a", "break", "i", "NUMBER", "e", "NUMBER", "control", "C", "NUMBER", "I", "ll", "say", "it", "again", "This", "be", "an", "infinite", "loop", "in", "a", "mechanism", "that", "was", "specifically", "designed", "to", "avoid", "infinite", "loops", "that", "be", "inherent", "to", "naive", "processing", "of", "circular", "data", "structures", "NUMBER", "What", "did", "I", "step", "on", "just", "now", "Is", "this", "a", "bug", "Is", "this", "a", "feature", "Why", "do", "it", "exist", "and", "what", "do", "it", "mean", "The", "entire", "documentation", "on", "the", "reader", "be", "able", "to", "understand", "this", "syntax", "be", "the", "sentence", "The", "graph", "syntax", "be", "understood", "by", "the", "procedure", "read", "allowing", "graph", "structures", "to", "be", "printed", "and", "read", "consistently", "NUMBER", "in", "the", "documentation", "for", "print", "graph", "so", "unless", "you", "can", "construct", "any", "of", "those", "examples", "as", "normal", "scheme", "objects", "and", "write", "outputs", "them", "as", "you", "ve", "shown", "I", "d", "say", "this", "be", "an", "example", "of", "undefined", "behavior", "i", "NUMBER", "e", "NUMBER", "neither", "a", "bug", "nor", "a", "feature", "NUMBER", "That", "s", "not", "to", "say", "that", "the", "behavior", "_shouldn", "t_", "be", "either", "documented", "explicitly", "or", "change", "so", "that", "it", "s", "handle", "as", "an", "error", "like", "other", "invalid", "syntax", "in", "the", "reader", "NUMBER", "Undefined", "behaviour", "be", "a", "great", "term", "but", "when", "the", "evaluation", "of", "NUMBER", "NUMBER", "terminates", "and", "the", "evaluation", "of", "the", "very", "similar", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "results", "in", "an", "infinite", "loop", "isn", "t", "that", "sufficient", "reason", "to", "call", "it", "a", "bug", "For", "example", "the", "order", "of", "evaluation", "of", "procedure", "argument", "be", "also", "undefined", "NUMBER", "This", "gives", "the", "implementer", "license", "to", "pick", "an", "order", "NUMBER", "It", "do", "not", "give", "the", "implementer", "license", "to", "do", "something", "else", "If", "there", "be", "two", "orders", "of", "evaluation", "possible", "and", "one", "gives", "the", "value", "NUMBER", "and", "the", "other", "NUMBER", "then", "returning", "NUMBER", "cannot", "be", "justified", "just", "because", "the", "behaviour", "be", "undefined", "NUMBER", "If", "I", "compile", "this", "file", "top", "level", "program", "import", "chezscheme", "define", "main", "let", "code", "foreign", "callable", "lambda", "display", "Hello", "world", "n", "void", "display", "back", "from", "foreign", "callable", "n", "lock", "object", "code", "foreign", "callable", "entry", "point", "code", "exit", "NUMBER", "scheme", "start", "lambda", "main", "like", "so", "begin", "generate", "wpo", "file", "t", "compile", "file", "testit", "NUMBER", "scm", "and", "then", "create", "a", "boot", "file", "begin", "compile", "whole", "program", "testit", "NUMBER", "wpo", "testit", "NUMBER", "so", "make", "boot", "file", "testit", "NUMBER", "boot", "petite", "testit", "NUMBER", "so", "and", "run", "the", "boot", "file", "I", "get", "dca", "dido", "tmp", "scheme", "b", "testit", "NUMBER", "boot", "Petite", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "Exception", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "But", "if", "I", "replace", "the", "setting", "of", "scheme", "start", "with", "a", "call", "to", "main", "compile", "and", "load", "the", "NUMBER", "so", "it", "works", "dca", "dido", "tmp", "scheme", "testit", "NUMBER", "so", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "back", "from", "foreign", "callable", "dca", "dido", "tmp", "I", "suspect", "this", "has", "something", "to", "do", "with", "the", "code", "in", "the", "boot", "file", "be", "loaded", "into", "static", "memory", "as", "discussed", "in", "Section", "NUMBER", "of", "the", "User", "Guide", "NUMBER", "Regardless", "of", "whether", "my", "guess", "be", "right", "I", "be", "trying", "to", "build", "an", "application", "that", "involves", "callbacks", "from", "gtk", "NUMBER", "and", "calling", "to", "Scheme", "from", "C", "be", "essential", "NUMBER", "I", "would", "also", "like", "to", "use", "the", "packaging", "efficiency", "and", "invocation", "advantages", "of", "boot", "file", "NUMBER", "This", "do", "not", "appear", "to", "be", "possible", "unless", "there", "be", "a", "workaround", "for", "this", "problem", "or", "I", "have", "do", "something", "incorrect", "NUMBER", "I", "would", "appreciate", "some", "guidance", "NUMBER", "Thank", "you", "NUMBER", "On", "Wed", "NUMBER", "Feb", "NUMBER", "at", "NUMBER", "NUMBER", "R", "NUMBER", "Kent", "Dybvig", "TAG", "write", "You", "suspicion", "that", "this", "be", "connected", "with", "static", "memory", "be", "correct", "NUMBER", "When", "any", "code", "object", "be", "relocated", "into", "the", "static", "generation", "its", "relocation", "table", "be", "drop", "since", "it", "won", "t", "ever", "need", "to", "be", "relocated", "again", "NUMBER", "Each", "time", "a", "foreign", "callable", "form", "be", "evaluated", "however", "a", "copy", "of", "the", "original", "code", "object", "be", "created", "with", "a", "pointer", "to", "the", "Scheme", "procedure", "to", "be", "invoked", "embedded", "in", "it", "NUMBER", "The", "relocation", "table", "be", "needed", "both", "to", "find", "the", "proper", "location", "for", "the", "embedded", "pointer", "and", "because", "the", "freshly", "allocated", "code", "object", "might", "be", "relocated", "by", "the", "collector", "NUMBER", "Since", "the", "static", "code", "object", "in", "your", "example", "be", "miss", "its", "relocation", "table", "the", "code", "that", "creates", "the", "copy", "of", "the", "foreign", "callable", "code", "object", "crashes", "NUMBER", "Thanks", "for", "figuring", "this", "out", "so", "quickly", "NUMBER", "Rather", "than", "use", "the", "workaround", "below", "which", "would", "involve", "some", "re", "arrangement", "of", "my", "code", "because", "the", "callbacks", "I", "be", "write", "reference", "things", "defined", "in", "main", "as", "free", "variables", "I", "can", "just", "temporarily", "not", "use", "a", "boot", "file", "and", "instead", "test", "it", "by", "loading", "the", "application", "NUMBER", "so", "file", "into", "petite", "and", "call", "main", "instead", "of", "setting", "scheme", "start", "NUMBER", "This", "will", "allow", "me", "to", "continue", "development", "NUMBER", "I", "can", "switch", "back", "to", "use", "of", "the", "boot", "file", "when", "your", "fix", "becomes", "available", "NUMBER", "Don", "Solving", "this", "probably", "involves", "setting", "a", "flag", "on", "each", "foreign", "callable", "code", "object", "to", "say", "its", "relocation", "table", "should", "not", "be", "drop", "NUMBER", "In", "the", "meantime", "a", "workaround", "be", "to", "arrange", "for", "the", "foreign", "callable", "form", "to", "be", "evaluated", "at", "boot", "time", "before", "the", "relocation", "table", "has", "be", "drop", "not", "when", "scheme", "start", "be", "invoked", "NUMBER", "For", "example", "the", "following", "variation", "of", "your", "example", "doesn", "t", "crash", "top", "level", "program", "import", "chezscheme", "define", "code", "foreign", "callable", "lambda", "display", "Hello", "world", "n", "void", "define", "main", "display", "back", "from", "foreign", "callable", "n", "lock", "object", "code", "foreign", "callable", "entry", "point", "code", "exit", "NUMBER", "scheme", "start", "lambda", "main", "You", "be", "receiving", "this", "because", "you", "authored", "the", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "On", "Thu", "NUMBER", "Feb", "NUMBER", "at", "NUMBER", "NUMBER", "R", "NUMBER", "Kent", "Dybvig", "TAG", "write", "This", "should", "be", "fix", "by", "this", "commit", "TAG", "NUMBER", "Wow", "that", "was", "fast", "I", "have", "an", "appointment", "this", "first", "thing", "this", "morning", "but", "I", "should", "be", "able", "to", "test", "this", "later", "in", "the", "morning", "NUMBER", "I", "will", "let", "you", "know", "how", "things", "go", "NUMBER", "You", "be", "receiving", "this", "because", "you", "authored", "the", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "On", "Thu", "NUMBER", "Feb", "NUMBER", "at", "NUMBER", "NUMBER", "Donald", "Allen", "TAG", "write", "On", "Thu", "NUMBER", "Feb", "NUMBER", "at", "NUMBER", "NUMBER", "R", "NUMBER", "Kent", "Dybvig", "TAG", "write", "This", "should", "be", "fix", "by", "this", "commit", "TAG", "NUMBER", "Wow", "that", "was", "fast", "I", "have", "an", "appointment", "this", "first", "thing", "this", "morning", "but", "I", "should", "be", "able", "to", "test", "this", "later", "in", "the", "morning", "NUMBER", "I", "will", "let", "you", "know", "how", "things", "go", "NUMBER", "I", "ve", "test", "it", "with", "the", "code", "I", "ve", "write", "thus", "far", "with", "just", "one", "callback", "NUMBER", "This", "be", "the", "code", "that", "previously", "fail", "which", "led", "to", "my", "open", "this", "issue", "NUMBER", "That", "code", "now", "works", "correctly", "with", "the", "latest", "github", "version", "of", "Chez", "NUMBER", "Thanks", "again", "for", "the", "quick", "turn", "around", "on", "this", "NUMBER", "Don", "You", "be", "receiving", "this", "because", "you", "authored", "the", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "Sketch", "of", "a", "fix", "for", "NUMBER", "Is", "there", "any", "point", "in", "trying", "NUMBER", "apply", "in", "fold", "primref", "NUMBER", "when", "app", "convention", "be", "not", "call", "Seems", "that", "if", "objs", "if", "constant", "succeeds", "here", "but", "the", "apply", "handler", "didn", "t", "turn", "apply", "into", "call", "then", "we", "re", "going", "to", "end", "up", "residualizing", "anyway", "so", "I", "m", "inclined", "to", "check", "the", "convention", "earlier", "in", "that", "first", "cond", "clause", "and", "simplify", "NUMBER", "x", "get", "review", "from", "someone", "who", "has", "be", "in", "this", "code", "more", "recently", "x", "do", "we", "need", "more", "test", "x", "update", "LOG", "That", "sounds", "right", "NUMBER", "What", "about", "apply", "NUMBER", "Is", "that", "not", "the", "same", "story", "An", "error", "test", "for", "apply", "zero", "NUMBER", "might", "be", "nice", "NUMBER", "Thanks", "NUMBER", "I", "ve", "update", "my", "branch", "to", "add", "some", "test", "and", "to", "bail", "earlier", "if", "app", "convention", "be", "not", "call", "NUMBER", "I", "may", "be", "bailing", "too", "early", "since", "inline", "handlers", "won", "t", "be", "able", "to", "special", "case", "based", "on", "app", "convention", "NUMBER", "Offhand", "I", "m", "not", "sure", "who", "would", "want", "to", "do", "that", "maybe", "to", "avoid", "a", "value", "visit", "somewhere", "NUMBER", "Edit", "silly", "me", "the", "original", "code", "also", "prevented", "this", "NUMBER", "Travis", "will", "be", "unhappy", "since", "I", "haven", "t", "yet", "update", "the", "expected", "error", "NUMBER", "Attempted", "to", "update", "expected", "error", "and", "restored", "original", "indentation", "to", "minimize", "diffs", "from", "master", "NUMBER", "Added", "a", "test", "for", "the", "effect", "unrestricted", "discard", "case", "update", "LOG", "and", "squashed", "NUMBER", "Re", "push", "to", "update", "the", "release", "note", "NUMBER", "In", "some", "cases", "apply", "will", "throw", "an", "exception", "if", "the", "last", "argument", "isn", "t", "a", "list", "as", "required", "in", "r", "NUMBER", "rs", "while", "in", "other", "cases", "it", "executes", "just", "fine", "NUMBER", "For", "instance", "apply", "NUMBER", "Exception", "in", "apply", "NUMBER", "be", "not", "a", "proper", "list", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "apply", "zero", "NUMBER", "t", "This", "appears", "to", "be", "an", "issue", "with", "cp", "NUMBER", "which", "be", "enable", "by", "default", "NUMBER", "apply", "null", "hypothesis", "f", "apply", "zero", "NUMBER", "t", "But", "if", "we", "disable", "cp", "NUMBER", "run", "cp", "NUMBER", "lambda", "f", "x", "x", "disable", "cp", "NUMBER", "apply", "null", "hypothesis", "Exception", "in", "apply", "hypothesis", "be", "not", "a", "proper", "list", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "apply", "zero", "NUMBER", "Exception", "in", "apply", "NUMBER", "be", "not", "a", "proper", "list", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "Tue", "Jan", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "GMT", "NUMBER", "Correct", "mitpress", "link", "for", "book", "NUMBER", "Will", "close", "issue", "LINK", "A", "repair", "for", "NUMBER", "The", "dofretu", "NUMBER", "intrinsics", "use", "ac", "NUMBER", "without", "declaring", "it", "as", "killed", "which", "effectively", "broke", "register", "allocation", "for", "handle", "string", "bytevector", "foreign", "call", "results", "or", "callable", "argument", "NUMBER", "There", "was", "a", "FIXME", "in", "the", "implementation", "of", "dofretu", "NUMBER", "that", "suggests", "avoiding", "ac", "NUMBER", "so", "maybe", "that", "intent", "be", "why", "ac", "NUMBER", "never", "get", "declared", "NUMBER", "With", "respect", "to", "the", "FIXME", "though", "get", "room", "do", "preserve", "td", "and", "ts", "but", "I", "didn", "t", "find", "a", "way", "to", "avoid", "ac", "NUMBER", "on", "x", "NUMBER", "because", "alloc", "involve", "ts", "and", "xp", "NUMBER", "So", "that", "s", "why", "the", "repair", "declares", "ac", "NUMBER", "as", "killed", "by", "dofretu", "NUMBER", "instead", "of", "trying", "to", "avoid", "it", "NUMBER", "Related", "to", "issue", "NUMBER", "Now", "make", "mutex", "and", "make", "condition", "accept", "an", "optional", "argument", "name", "which", "must", "be", "a", "symbol", "NUMBER", "When", "the", "mutex", "or", "condition", "be", "printed", "the", "name", "be", "also", "printed", "NUMBER", "The", "name", "be", "immutable", "and", "can", "be", "accessed", "by", "mutex", "name", "and", "condition", "name", "NUMBER", "LINK", "This", "looks", "good", "to", "me", "thanks", "Please", "add", "an", "entry", "to", "LOG", "NUMBER", "If", "you", "feel", "like", "update", "the", "release", "note", "and", "the", "user", "s", "guide", "as", "well", "go", "ahead", "or", "I", "ll", "make", "the", "change", "after", "pulling", "the", "change", "NUMBER", "Added", "entries", "to", "LOG", "and", "release", "note", "and", "update", "CSUG", "NUMBER", "What", "do", "you", "think", "of", "allowing", "f", "for", "the", "optional", "second", "argument", "of", "make", "mutex", "and", "make", "condition", "This", "would", "make", "the", "definitions", "of", "the", "single", "argument", "cases", "simpler", "and", "make", "it", "easier", "to", "write", "function", "that", "take", "an", "optional", "name", "NUMBER", "That", "s", "probably", "a", "good", "idea", "NUMBER", "I", "don", "t", "see", "how", "it", "simplifies", "the", "single", "argument", "cases", "however", "NUMBER", "In", "fact", "they", "would", "need", "to", "explicitly", "allow", "f", "as", "well", "as", "symbols", "and", "the", "error", "message", "would", "have", "to", "be", "adjusted", "NUMBER", "jessymilare", "if", "you", "use", "set", "who", "rather", "than", "set", "for", "make", "mutex", "mutex", "name", "make", "condition", "and", "condition", "name", "you", "can", "replace", "the", "quoted", "names", "with", "who", "in", "the", "error", "message", "and", "just", "put", "each", "of", "the", "test", "on", "one", "line", "to", "tighten", "up", "the", "code", "NUMBER", "I", "ve", "be", "doing", "that", "with", "most", "of", "the", "things", "I", "ve", "add", "recently", "NUMBER", "For", "the", "single", "argument", "cases", "I", "meant", "that", "one", "could", "simply", "call", "the", "two", "argument", "case", "with", "f", "and", "wouldn", "t", "need", "to", "duplicate", "the", "body", "NUMBER", "Ah", "I", "guess", "you", "mean", "the", "zero", "argument", "cases", "NUMBER", "Yes", "but", "that", "would", "send", "the", "zero", "argument", "case", "through", "an", "unnecessary", "check", "NUMBER", "Although", "if", "one", "the", "zero", "argument", "case", "calls", "the", "one", "argument", "case", "the", "case", "lambda", "form", "should", "be", "wrapped", "in", "a", "rec", "e", "NUMBER", "g", "NUMBER", "rec", "make", "mutex", "TAG", "to", "make", "the", "call", "local", "in", "which", "case", "cp", "NUMBER", "would", "presumably", "inline", "the", "one", "argument", "code", "into", "the", "zero", "argument", "code", "and", "discard", "the", "check", "NUMBER", "Though", "I", "would", "probably", "instead", "just", "add", "a", "helper", "that", "both", "cases", "use", "to", "make", "clear", "the", "test", "isn", "t", "necessary", "in", "the", "zero", "argument", "case", "NUMBER", "Thanks", "I", "get", "my", "argument", "counts", "off", "by", "one", "Yes", "a", "helper", "without", "checks", "that", "be", "use", "by", "both", "front", "doors", "would", "be", "a", "good", "way", "to", "implement", "it", "NUMBER", "Sorry", "for", "the", "polution", "in", "the", "commit", "NUMBER", "I", "use", "aggressive", "indent", "mode", "and", "I", "forgot", "to", "disable", "it", "before", "editing", "NUMBER", "If", "the", "code", "be", "OK", "I", "can", "recreate", "the", "commit", "or", "create", "one", "single", "commit", "for", "all", "change", "NUMBER", "The", "build", "system", "find", "an", "error", "while", "build", "the", "threaded", "version", "of", "Chez", "Scheme", "Details", "LINK", "ci", "NUMBER", "org", "cisco", "ChezScheme", "build", "NUMBER", "utm_source", "github_status", "utm_medium", "notification", "TAG", "Warning", "undeclared", "variable", "assignment", "to", "make", "mutex", "at", "line", "NUMBER", "char", "NUMBER", "of", "prims", "NUMBER", "ss", "TAG", "The", "build", "system", "find", "an", "error", "while", "build", "the", "threaded", "version", "of", "Chez", "Scheme", "Details", "LINK", "ci", "NUMBER", "org", "cisco", "ChezScheme", "build", "NUMBER", "utm_source", "github_status", "utm_medium", "notification", "Warning", "undeclared", "variable", "assignment", "to", "make", "mutex", "at", "line", "NUMBER", "char", "NUMBER", "of", "prims", "NUMBER", "ss", "Fixed", "NUMBER", "The", "good", "news", "be", "that", "this", "patch", "can", "cut", "startup", "time", "in", "half", "when", "loading", "uncompressed", "boot", "file", "NUMBER", "The", "bad", "news", "be", "that", "it", "s", "a", "significant", "addition", "to", "the", "kernel", "about", "NUMBER", "NUMBER", "the", "size", "of", "the", "GC", "implementation", "and", "duplicating", "some", "of", "the", "GC", "code", "in", "its", "current", "form", "NUMBER", "On", "my", "machine", "startup", "time", "from", "uncompressed", "petite", "NUMBER", "boot", "and", "scheme", "NUMBER", "boot", "file", "be", "reduced", "from", "NUMBER", "ms", "to", "NUMBER", "ms", "NUMBER", "With", "Racket", "on", "Chez", "s", "racket", "NUMBER", "boot", "in", "addition", "which", "be", "a", "little", "larger", "than", "petite", "NUMBER", "boot", "and", "scheme", "NUMBER", "boot", "combined", "startup", "goes", "from", "NUMBER", "ms", "to", "NUMBER", "ms", "NUMBER", "The", "extra", "code", "seems", "worth", "it", "to", "save", "NUMBER", "ms", "on", "every", "Racket", "s", "startup", "unless", "of", "course", "something", "simpler", "can", "provide", "the", "same", "benefit", "NUMBER", "The", "vfasl", "format", "implement", "by", "this", "patch", "be", "mostly", "an", "image", "of", "the", "code", "and", "data", "that", "can", "read", "directly", "into", "a", "GC", "managed", "memory", "space", "NUMBER", "Just", "as", "important", "as", "loading", "the", "image", "directly", "it", "can", "be", "loaded", "into", "the", "static", "generation", "saving", "work", "to", "compact", "loaded", "code", "into", "the", "static", "generation", "NUMBER", "The", "vfasl", "loader", "do", "not", "update", "object", "counts", "for", "static", "content", "NUMBER", "The", "vfasl", "format", "can", "also", "cut", "loading", "non", "boot", "code", "in", "half", "at", "least", "for", "relatively", "large", "code", "file", "but", "the", "benefit", "of", "vfasl", "loading", "be", "limited", "if", "the", "code", "has", "to", "be", "traversed", "later", "by", "the", "GC", "NUMBER", "Also", "the", "in", "memory", "format", "of", "data", "be", "larger", "than", "the", "fasl", "format", "and", "the", "size", "difference", "tends", "to", "defeat", "any", "benefit", "of", "vfasl", "for", "small", "code", "file", "NUMBER", "Use", "vfasl", "convert", "file", "to", "convert", "to", "the", "vfasl", "format", "something", "like", "this", "compile", "compressed", "f", "vfasl", "convert", "file", "orig", "petite", "NUMBER", "boot", "new", "petite", "NUMBER", "boot", "vfasl", "convert", "file", "orig", "scheme", "NUMBER", "boot", "new", "scheme", "NUMBER", "boot", "petite", "vfasl", "convert", "file", "orig", "mine", "NUMBER", "boot", "new", "mine", "NUMBER", "boot", "petite", "scheme", "This", "looks", "potentially", "relate", "to", "work", "in", "GHC", "LINK", "I", "wonder", "if", "they", "managed", "to", "avoid", "the", "complexity", "you", "re", "worried", "about", "NUMBER", "samth", "That", "work", "doesn", "t", "deal", "with", "code", "shared", "objects", "like", "symbols", "and", "record", "type", "descriptors", "or", "mutable", "values", "such", "as", "symbols", "that", "have", "property", "lists", "all", "ways", "to", "reduce", "complexity", "certainly", "but", "not", "applicable", "to", "the", "problem", "of", "loading", "and", "link", "Scheme", "code", "NUMBER", "Note", "on", "the", "revised", "patch", "Corrected", "to", "ensure", "that", "an", "object", "either", "do", "not", "span", "multiple", "or", "segments", "or", "resides", "at", "start", "of", "a", "segment", "which", "be", "needed", "when", "loading", "directly", "to", "the", "static", "generation", "NUMBER", "For", "many", "years", "Chez", "Scheme", "support", "the", "notion", "of", "saved", "heaps", "and", "incremental", "saved", "heaps", "which", "be", "similar", "to", "this", "NUMBER", "Saved", "heaps", "were", "essentially", "pre", "build", "heap", "images", "NUMBER", "There", "was", "a", "saved", "heap", "that", "corresponded", "to", "the", "base", "boot", "file", "and", "incremental", "saved", "heaps", "that", "corresponded", "to", "non", "base", "boot", "file", "NUMBER", "With", "mmap", "d", "saved", "heaps", "startup", "time", "was", "practically", "zero", "and", "sharing", "of", "memory", "between", "processes", "cut", "total", "memory", "usage", "considerably", "when", "many", "Scheme", "processes", "were", "use", "NUMBER", "We", "ended", "up", "abandoning", "saved", "heaps", "when", "address", "randomization", "became", "ubiquitous", "NUMBER", "Perhaps", "it", "s", "time", "to", "come", "up", "with", "a", "new", "implementation", "of", "saved", "heaps", "NUMBER", "One", "approach", "be", "to", "have", "a", "live", "saved", "heap", "in", "the", "form", "of", "a", "background", "process", "created", "upon", "the", "first", "invocation", "of", "Chez", "Scheme", "or", "Racket", "and", "have", "each", "subsequent", "invocations", "merely", "fork", "a", "new", "copy", "of", "the", "background", "process", "NUMBER", "This", "has", "the", "downside", "that", "the", "forked", "process", "be", "a", "child", "of", "the", "background", "process", "rather", "than", "the", "program", "e", "NUMBER", "g", "NUMBER", "shell", "of", "invocation", "and", "its", "environment", "but", "it", "s", "not", "unlike", "how", "other", "applications", "work", "these", "days", "NUMBER", "Another", "approach", "be", "to", "save", "an", "image", "as", "we", "use", "to", "and", "adjust", "all", "the", "pointers", "on", "start", "up", "to", "account", "for", "the", "new", "random", "base", "address", "NUMBER", "Of", "course", "we", "can", "always", "request", "the", "original", "address", "when", "mmap", "ing", "and", "avoid", "the", "adjustment", "if", "we", "get", "it", "NUMBER", "If", "machines", "support", "EA", "relative", "addressing", "like", "PC", "relative", "jumps", "add", "in", "the", "address", "of", "the", "jump", "EA", "relative", "loads", "would", "add", "the", "effective", "address", "of", "a", "loaded", "pointer", "to", "the", "loaded", "pointer", "we", "could", "avoid", "the", "adjustment", "entirely", "NUMBER", "We", "could", "of", "course", "do", "the", "add", "ourselves", "at", "the", "cost", "of", "an", "extra", "instruction", "or", "two", "at", "each", "ptr", "load", "NUMBER", "dybvig", "You", "might", "find", "it", "interesting", "to", "compare", "with", "Daniel", "Colascione", "s", "work", "on", "the", "Emacs", "Portable", "Dumper", "which", "had", "to", "deal", "with", "a", "lot", "of", "the", "same", "issue", "NUMBER", "It", "uses", "the", "relocate", "on", "startup", "approach", "and", "it", "has", "be", "work", "relatively", "well", "I", "believe", "he", "mention", "it", "as", "taking", "a", "dozen", "milliseconds", "or", "so", "NUMBER", "Emacs", "has", "for", "years", "relied", "on", "unexec", "to", "implement", "saved", "heap", "functionality", "but", "for", "various", "reasons", "it", "has", "be", "less", "and", "less", "viable", "as", "a", "solution", "including", "the", "inability", "to", "support", "ASLR", "and", "the", "desire", "of", "glibc", "to", "phase", "out", "support", "for", "unexec", "NUMBER", "The", "portable", "dumper", "be", "the", "new", "implementation", "of", "saved", "heaps", "and", "recently", "past", "month", "get", "merge", "into", "master", "so", "it", "will", "likely", "be", "rolling", "out", "in", "emacs", "NUMBER", "Anyhow", "the", "following", "be", "his", "overview", "of", "the", "implementation", "LINK", "Brand", "new", "to", "chezscheme", "trying", "to", "make", "a", "new", "condition", "use", "make", "condition", "from", "chezscheme", "user", "guide", "LINK", "NUMBER", "threads", "h", "NUMBER", "but", "other", "chezscheme", "library", "function", "work", "PS", "C", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "import", "chezscheme", "make", "condition", "Exception", "variable", "make", "condition", "be", "not", "bound", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "pretty", "print", "define", "factorial", "lambda", "n", "let", "fact", "i", "n", "a", "NUMBER", "if", "i", "NUMBER", "a", "fact", "i", "NUMBER", "a", "i", "define", "factorial", "lambda", "n", "let", "fact", "i", "n", "a", "NUMBER", "if", "i", "NUMBER", "a", "fact", "i", "NUMBER", "a", "i", "Running", "this", "on", "scheme", "build", "for", "Windows", "NUMBER", "from", "this", "repo", "less", "than", "a", "week", "ago", "NUMBER", "Also", "the", "commonly", "linked", "chezscheme", "debug", "pdf", "be", "no", "longer", "hosted", "LINK", "make", "debugging", "even", "more", "difficult", "NUMBER", "It", "sounds", "like", "you", "be", "use", "a", "non", "threaded", "version", "of", "Chez", "Scheme", "the", "default", "build", "NUMBER", "configure", "build", "non", "thread", "version", "make", "cd", "a", "NUMBER", "osx", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "build", "cd", "c", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "ln", "s", "NUMBER", "NUMBER", "c", "statics", "NUMBER", "c", "statics", "NUMBER", "c", "NUMBER", "NUMBER", "NUMBER", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "resetbootlinks", "touch", "bootstrap", "cd", "a", "NUMBER", "osx", "s", "NUMBER", "bin", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "threaded", "note", "this", "version", "be", "not", "threaded", "we", "can", "check", "use", "threaded", "f", "make", "condition", "make", "condition", "be", "only", "defined", "in", "the", "threaded", "version", "Exception", "variable", "make", "condition", "be", "not", "bound", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "To", "build", "the", "threaded", "version", "just", "specify", "threads", "NUMBER", "configure", "threads", "make", "cd", "ta", "NUMBER", "osx", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "build", "cd", "c", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "ln", "s", "NUMBER", "NUMBER", "c", "statics", "NUMBER", "c", "statics", "NUMBER", "c", "NUMBER", "NUMBER", "NUMBER", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "resetbootlinks", "touch", "bootstrap", "cd", "ta", "NUMBER", "osx", "s", "note", "the", "t", "here", "which", "means", "it", "be", "the", "threaded", "version", "NUMBER", "bin", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "threaded", "this", "time", "we", "be", "run", "the", "threaded", "version", "t", "make", "condition", "and", "make", "condition", "be", "defined", "NUMBER", "TAG", "Aha", "that", "was", "the", "problem", "NUMBER", "Incidentally", "the", "windows", "build", "automatically", "made", "the", "threaded", "version", "for", "me", "alongside", "the", "non", "threaded", "version", "a", "NUMBER", "nt", "and", "ta", "NUMBER", "nt", "folders", "NUMBER", "I", "don", "t", "see", "anything", "for", "threads", "in", "the", "BUILDING", "file", "could", "something", "be", "add", "to", "that", "file", "to", "clarify", "this", "issue", "When", "use", "the", "USE_MALLOC", "allocator", "instead", "of", "USE_MMAP", "valgrind", "gives", "warnings", "NUMBER", "The", "merge", "request", "silences", "the", "warnings", "NUMBER", "Maybe", "better", "to", "initialize", "the", "relevant", "field", "explicitly", "instead", "of", "zeroing", "the", "whole", "segment", "NUMBER", "NUMBER", "Conditional", "jump", "or", "move", "depends", "on", "uninitialised", "value", "s", "NUMBER", "at", "NUMBER", "x", "NUMBER", "E", "NUMBER", "copy", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "BCD", "S_gc_oce", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "A", "NUMBER", "Scompact_heap", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "AAD", "NUMBER", "Sbuild_heap", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "F", "NUMBER", "D", "NUMBER", "main", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "Uninitialised", "value", "was", "created", "by", "a", "heap", "allocation", "NUMBER", "at", "NUMBER", "x", "NUMBER", "F", "malloc", "vg_replace_malloc", "NUMBER", "c", "NUMBER", "NUMBER", "by", "NUMBER", "x", "NUMBER", "E", "S_getmem", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "B", "NUMBER", "S_find_segments", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "S_find_more_room", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "F", "S_alloc_init", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "A", "NUMBER", "D", "NUMBER", "Sbuild_heap", "in", "home", "chn", "chez", "install", "bin", "scheme", "NUMBER", "by", "NUMBER", "x", "NUMBER", "F", "NUMBER", "D", "NUMBER", "main", "in", "home", "chn", "chez", "install", "bin", "scheme", "Can", "the", "code", "actually", "reference", "uninitialized", "values", "i", "NUMBER", "e", "NUMBER", "be", "the", "chunk", "not", "fully", "initialized", "by", "the", "call", "that", "follows", "the", "getmem", "call", "Yes", "the", "copy", "function", "reads", "the", "uninitialized", "values", "as", "seen", "on", "the", "valgrind", "log", "NUMBER", "Thanks", "Dybvig", "for", "the", "reply", "NUMBER", "Please", "try", "valgrind", "yourself", "I", "add", "these", "two", "lines", "after", "the", "include", "statements", "in", "segment", "NUMBER", "c", "define", "USE_MALLOC", "undef", "USE_MMAP", "Then", "I", "pass", "CFLAGS", "O", "NUMBER", "g", "to", "make", "to", "get", "valgrind", "to", "pinpoint", "the", "line", "number", "as", "well", "NUMBER", "I", "get", "warnings", "on", "the", "trigger_empherons", "field", "and", "I", "also", "get", "a", "warning", "on", "the", "sorted", "field", "of", "seginfo", "by", "run", "this", "small", "program", "with", "scheme", "program", "empty", "NUMBER", "scm", "import", "chezscheme", "Thanks", "for", "verifying", "a", "clean", "valgrind", "run", "for", "you", "as", "well", "NUMBER", "Would", "you", "like", "to", "alter", "your", "pull", "request", "to", "replace", "zero", "filling", "with", "these", "two", "lines", "If", "so", "please", "also", "add", "a", "brief", "entry", "in", "LOG", "NUMBER", "Done", "However", "feel", "free", "to", "brush", "up", "the", "merge", "request", "yourself", "since", "I", "m", "not", "familiar", "with", "the", "code", "style", "and", "the", "right", "level", "of", "details", "in", "LOG", "NUMBER", "Possibly", "the", "repair", "for", "NUMBER", "I", "believe", "this", "new", "commit", "be", "much", "more", "likely", "to", "be", "the", "repair", "for", "NUMBER", "If", "receiving", "argument", "to", "a", "callable", "involves", "allocation", "such", "as", "when", "receiving", "a", "flonum", "bignum", "or", "pointer", "then", "the", "value", "in", "the", "cp", "field", "of", "the", "thread", "context", "can", "get", "change", "when", "cp", "be", "a", "real", "register", "and", "the", "register", "value", "gets", "saved", "in", "the", "thread", "context", "NUMBER", "In", "particular", "if", "the", "caller", "or", "a", "callable", "has", "set", "that", "register", "then", "the", "cp", "field", "in", "the", "thread", "context", "will", "have", "that", "wrong", "value", "NUMBER", "Guard", "against", "the", "problem", "by", "claiming", "cp", "as", "live", "and", "initialized", "by", "cp", "from", "the", "thread", "context", "while", "unpacking", "argument", "NUMBER", "I", "can", "redefine", "function", "in", "the", "interaction", "environment", "via", "eval", "while", "a", "program", "be", "run", "NUMBER", "Is", "there", "any", "way", "to", "redefine", "function", "in", "a", "library", "I", "d", "love", "to", "run", "two", "threads", "one", "with", "the", "program", "one", "with", "a", "repl", "where", "I", "can", "redefine", "export", "function", "inside", "libraries", "NUMBER", "Is", "there", "a", "way", "to", "find", "all", "libraries", "directly", "or", "indirectly", "depending", "upon", "a", "given", "library", "so", "I", "can", "automatically", "reload", "them", "all", "LINK", "NUMBER", "binding", "h", "NUMBER", "says", "These", "form", "be", "describe", "in", "Chatper", "NUMBER", "Chatper", "should", "be", "Chapter", "NUMBER", "LINK", "NUMBER", "binding", "h", "NUMBER", "also", "says", "This", "algorithm", "be", "describe", "in", "Section", "NUMBER", "of", "TAG", "The", "Scheme", "Programming", "Language", "NUMBER", "Edition", "TAG", "NUMBER", "As", "a", "result", "some", "code", "and", "more", "code", "both", "result", "in", "the", "giving", "TAG", "x", "TAG", "the", "value", "NUMBER", "even", "though", "an", "unbound", "variable", "reference", "to", "TAG", "a", "TAG", "would", "result", "if", "the", "two", "form", "within", "the", "latter", "TAG", "begin", "TAG", "expression", "where", "run", "independently", "at", "top", "level", "NUMBER", "NUMBER", "links", "to", "the", "Chez", "Scheme", "User", "s", "Guide", "not", "to", "The", "Scheme", "Programming", "Language", "NUMBER", "And", "section", "NUMBER", "of", "TSPL", "doesn", "t", "discuss", "that", "algorithm", "either", "NUMBER", "I", "think", "section", "NUMBER", "of", "TSPL", "be", "the", "right", "one", "NUMBER", "Also", "where", "should", "be", "were", "NUMBER", "LINK", "NUMBER", "binding", "h", "NUMBER", "says", "TAG", "syntax", "TAG", "TAG", "define", "values", "nbsp", "formals", "nbsp", "TAG", "expr", "TAG", "TAG", "TAG", "formals", "TAG", "should", "be", "italicized", "NUMBER", "LINK", "NUMBER", "io", "h", "NUMBER", "says", "The", "codec", "returned", "by", "TAG", "utf", "NUMBER", "codec", "TAG", "can", "be", "use", "to", "create", "process", "data", "write", "UFT", "NUMBER", "format", "NUMBER", "UFT", "NUMBER", "should", "be", "UTF", "NUMBER", "NUMBER", "And", "I", "think", "there", "should", "be", "an", "or", "between", "create", "and", "process", "NUMBER", "The", "Posix", "native", "threads", "be", "awefully", "slow", "on", "OS", "X", "NUMBER", "The", "code", "provide", "NUMBER", "shows", "some", "toy", "example", "with", "corresponding", "outputs", "NUMBER", "The", "threaded", "version", "ist", "NUMBER", "NUMBER", "times", "slower", "than", "the", "normal", "version", "NUMBER", "OS", "X", "Version", "NUMBER", "NUMBER", "G", "NUMBER", "NUMBER", "thread_slowdown", "NUMBER", "txt", "LINK", "_slowdown", "NUMBER", "txt", "It", "also", "appears", "to", "be", "unique", "to", "Mac", "OS", "X", "NUMBER", "The", "Linux", "version", "be", "much", "closer", "in", "performance", "UNTHREADED", "time", "for", "each", "lambda", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "time", "for", "each", "lambda", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "time", "for", "each", "lambda", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "THREADED", "time", "for", "each", "lambda", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "time", "for", "each", "lambda", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "time", "for", "each", "lambda", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "Thanks", "the", "fix", "made", "the", "program", "above", "run", "much", "faster", "under", "Windows", "and", "macOS", "First", "call", "to", "gensym", "takes", "about", "NUMBER", "s", "on", "macOS", "and", "time", "do", "not", "handle", "it", "right", "NUMBER", "e", "NUMBER", "g", "NUMBER", "time", "gensym", "no", "collections", "NUMBER", "s", "elapse", "cpu", "time", "NUMBER", "s", "elapse", "real", "time", "NUMBER", "bytes", "allocated", "Actually", "above", "takes", "about", "NUMBER", "s", "NUMBER", "After", "the", "first", "call", "gensym", "works", "well", "NUMBER", "Chez", "Scheme", "version", "NUMBER", "macOS", "version", "Mojave", "This", "could", "be", "relate", "to", "NUMBER", "if", "takes", "five", "seconds", "because", "your", "computer", "s", "hostname", "be", "invalid", "and", "the", "DNS", "query", "to", "resolve", "it", "times", "out", "NUMBER", "The", "code", "that", "I", "suspect", "be", "here", "LINK", "L", "NUMBER", "L", "NUMBER", "Does", "the", "five", "second", "delay", "go", "away", "if", "you", "add", "return", "NUMBER", "on", "line", "NUMBER", "and", "rebuild", "weinholt", "Thanks", "and", "yes", "this", "relate", "to", "NUMBER", "The", "five", "seconds", "delay", "go", "away", "after", "the", "return", "NUMBER", "add", "NUMBER", "This", "issue", "can", "be", "bypassed", "by", "add", "hostname", "into", "etc", "hosts", "NUMBER", "burgerrg", "Thanks", "NUMBER", "Should", "be", "close", "see", "NUMBER", "and", "NUMBER", "fd", "NUMBER", "db", "NUMBER", "Currently", "the", "build", "instructions", "here", "LINK", "Mention", "WSL", "as", "possible", "build", "environment", "NUMBER", "It", "neglects", "to", "mention", "however", "that", "the", "way", "the", "build", "works", "by", "calling", "cmd", "NUMBER", "exe", "c", "with", "a", "make", "NUMBER", "bat", "file", "in", "the", "build", "directory", "will", "only", "work", "on", "a", "location", "under", "mnt", "c", "or", "d", "or", "e", "etc", "NUMBER", "This", "be", "because", "cmd", "NUMBER", "exe", "can", "only", "interact", "with", "file", "outside", "the", "Linux", "environment", "which", "mnt", "c", "and", "friends", "be", "considered", "to", "be", "NUMBER", "In", "other", "words", "anything", "outside", "mnt", "c", "or", "d", "or", "e", "etc", "cannot", "be", "translated", "to", "a", "windows", "path", "and", "hence", "cmd", "NUMBER", "exe", "will", "fail", "to", "find", "the", "make", "NUMBER", "bat", "pass", "to", "it", "NUMBER", "More", "background", "here", "LINK", "between", "windows", "and", "bash", "_FYI", "_", "I", "get", "a", "new", "computer", "and", "I", "install", "Visual", "Studio", "NUMBER", "Community", "and", "Cygwin", "NUMBER", "When", "I", "compiled", "Chez", "Scheme", "I", "get", "this", "error", "make", "cd", "a", "NUMBER", "nt", "make", "build", "cd", "c", "make", "cmd", "NUMBER", "exe", "c", "make", "NUMBER", "bat", "cygwin", "NUMBER", "cygwin", "tmp", "dd_vsdevcmd", "NUMBER", "_preinit_env", "NUMBER", "log", "was", "unexpect", "at", "this", "time", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "NUMBER", "bin", "a", "NUMBER", "nt", "scheme", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "build", "Error", "NUMBER", "After", "a", "lot", "of", "debugging", "guessing", "and", "searches", "in", "Google", "I", "discover", "that", "the", "problem", "was", "that", "I", "install", "Cygwin", "as", "an", "administrator", "and", "I", "was", "trying", "to", "compile", "with", "a", "normal", "user", "NUMBER", "The", "problem", "was", "that", "the", "temporary", "folder", "was", "not", "writable", "by", "my", "user", "so", "some", "of", "the", "NUMBER", "bat", "file", "get", "a", "weird", "error", "when", "trying", "to", "save", "some", "temporary", "data", "NUMBER", "The", "problem", "was", "in", "VsDevCmd", "NUMBER", "bat", "that", "be", "call", "by", "vcvarsall", "NUMBER", "bat", "NUMBER", "I", "fix", "the", "problem", "following", "the", "advice", "of", "LINK", "ug", "net", "use", "NUMBER", "html", "usertemp", "i", "NUMBER", "e", "NUMBER", "The", "usertemp", "file", "system", "can", "be", "configured", "in", "etc", "fstab", "like", "this", "none", "tmp", "usertemp", "binary", "posix", "NUMBER", "NUMBER", "NUMBER", "So", "I", "think", "my", "problem", "was", "a", "case", "of", "a", "bad", "cygwin", "configuration", "not", "a", "bug", "in", "the", "Chez", "Scheme", "compilation", "NUMBER", "Anyway", "the", "error", "be", "too", "cryptic", "and", "it", "was", "very", "difficult", "to", "find", "the", "solution", "so", "I", "m", "posting", "this", "in", "case", "someone", "else", "has", "the", "same", "problem", "in", "the", "future", "NUMBER", "I", "think", "you", "can", "just", "close", "this", "issue", "unless", "you", "know", "a", "much", "better", "solution", "NUMBER", "I", "build", "error", "on", "windows", "cygwin", "or", "Microsoft", "Ubuntu", "at", "first", "with", "output", "message", "not", "find", "NUMBER", "NUMBER", "configure", "not", "find", "NUMBER", "NUMBER", "configure", "not", "find", "NUMBER", "NUMBER", "configure", "NUMBER", "configure", "NUMBER", "NUMBER", "configure", "Syntax", "error", "word", "unexpect", "expecting", "do", "I", "guess", "it", "s", "windows", "text", "file", "endline", "different", "from", "linux", "txt", "file", "so", "to", "fix", "this", "problem", "by", "use", "vi", "vi", "configure", "set", "fileformat", "unix", "wq", "vi", "workarea", "set", "fileformat", "unix", "wq", "burgerrg", "you", "be", "right", "NUMBER", "it", "s", "git", "settting", "cause", "this", "problem", "NUMBER", "after", "I", "set", "git", "config", "git", "config", "global", "core", "NUMBER", "autocrlf", "false", "then", "git", "clone", "again", "NUMBER", "It", "can", "build", "right", "Hello", "schemers", "While", "going", "over", "the", "code", "for", "porting", "to", "GNU", "Hurd", "yeah", "I", "know", "I", "find", "that", "gensyms", "may", "contain", "public", "IP", "address", "NUMBER", "This", "isn", "t", "mention", "in", "the", "documentation", "anywhere", "that", "I", "could", "find", "and", "it", "surprised", "me", "NUMBER", "I", "m", "probably", "not", "alone", "so", "I", "m", "open", "this", "issue", "to", "have", "a", "discussion", "about", "whether", "it", "s", "ok", "or", "not", "NUMBER", "Here", "s", "code", "that", "extracts", "the", "info", "in", "gensyms", "with", "some", "examples", "from", "csug", "LINK", "People", "may", "wish", "to", "keep", "their", "public", "IP", "address", "hidden", "and", "be", "likely", "not", "aware", "that", "gensyms", "can", "contain", "them", "NUMBER", "This", "isn", "t", "mention", "in", "the", "documentation", "anywhere", "that", "I", "could", "find", "You", "mean", "like", "in", "the", "description", "for", "gensym", "Globally", "unique", "names", "be", "constructed", "lazily", "see", "below", "from", "some", "combination", "of", "a", "unique", "machine", "identifier", "such", "as", "the", "network", "address", "the", "current", "process", "identifier", "PID", "and", "the", "time", "at", "which", "the", "Scheme", "session", "began", "along", "with", "an", "internal", "counter", "LINK", "NUMBER", "objects", "s", "NUMBER", "which", "be", "not", "to", "say", "that", "I", "disagree", "with", "change", "the", "source", "for", "the", "seed", "use", "for", "the", "unique", "prefix", "just", "that", "it", "be", "in", "the", "documentation", "Oops", "my", "eyes", "skipped", "right", "over", "that", "NUMBER", "burgerrg", "If", "you", "were", "use", "apt", "directly", "you", "could", "do", "this", "apt", "get", "install", "uuid", "dev", "i", "NUMBER", "Maybe", "you", "can", "add", "uuid", "dev", "i", "NUMBER", "to", "the", "travis", "NUMBER", "yml", "file", "NUMBER", "This", "patch", "add", "a", "hashtable", "cells", "procedure", "that", "be", "mostly", "the", "obvious", "companion", "to", "hashtable", "keys", "and", "hashtable", "values", "but", "with", "an", "extra", "twist", "hashtable", "cells", "takes", "an", "optional", "second", "argument", "to", "limit", "the", "resulting", "vector", "size", "and", "therefore", "limit", "the", "amount", "of", "work", "performed", "by", "hashtable", "cells", "NUMBER", "Calling", "hashtable", "cells", "with", "a", "size", "of", "N", "takes", "O", "N", "time", "even", "if", "the", "hashtable", "contains", "more", "than", "O", "N", "entries", "NUMBER", "To", "iterate", "over", "N", "entries", "in", "O", "N", "time", "when", "N", "be", "not", "know", "in", "advance", "get", "Q", "cells", "for", "the", "first", "Q", "iterations", "for", "some", "small", "Q", "then", "NUMBER", "Q", "cells", "to", "continue", "for", "roughly", "up", "to", "NUMBER", "Q", "iterations", "and", "so", "on", "NUMBER", "The", "second", "set", "of", "iterations", "will", "actually", "go", "to", "somewhere", "between", "NUMBER", "Q", "and", "NUMBER", "Q", "iterations", "since", "the", "call", "to", "get", "NUMBER", "Q", "cells", "be", "not", "guaranteed", "to", "include", "the", "same", "cells", "as", "the", "first", "Q", "NUMBER", "An", "intervening", "collection", "can", "change", "the", "order", "for", "an", "eq", "based", "table", "for", "example", "NUMBER", "Still", "the", "first", "Q", "cells", "and", "second", "NUMBER", "Q", "cells", "can", "be", "merge", "in", "O", "Q", "time", "to", "produce", "a", "vector", "of", "NUMBER", "Q", "to", "NUMBER", "Q", "cells", "and", "so", "on", "NUMBER", "Meanwhile", "get", "cells", "instead", "of", "keys", "and", "values", "accommodates", "iterations", "that", "change", "the", "hash", "table", "without", "exposing", "stale", "mappings", "and", "without", "needlessly", "retaining", "keys", "and", "values", "from", "a", "weak", "ephemeron", "hash", "table", "NUMBER", "I", "don", "t", "understand", "how", "you", "can", "merge", "the", "first", "Q", "and", "second", "NUMBER", "Q", "cells", "in", "O", "Q", "time", "given", "the", "lists", "aren", "t", "necessarily", "in", "the", "same", "order", "and", "with", "the", "addition", "of", "and", "so", "on", "I", "think", "it", "gets", "beyond", "O", "Q", "time", "regardless", "of", "the", "order", "NUMBER", "However", "I", "like", "the", "idea", "of", "provide", "a", "hashtable", "cells", "procedure", "and", "I", "don", "t", "object", "to", "allowing", "the", "max", "size", "limit", "to", "be", "specified", "NUMBER", "Does", "it", "make", "sense", "to", "add", "optional", "max", "size", "argument", "to", "hashtable", "values", "hashtable", "keys", "and", "hashtable", "entries", "for", "consistency", "The", "code", "for", "hashtable", "cells", "do", "some", "redundant", "test", "and", "hashtable", "size", "calls", "which", "lead", "to", "additional", "redundant", "test", "and", "unnecessary", "memory", "references", "NUMBER", "Plus", "I", "don", "t", "like", "going", "back", "through", "the", "top", "level", "for", "case", "lambda", "clauses", "NUMBER", "Instead", "I", "prefer", "use", "a", "rec", "wrapper", "so", "the", "call", "be", "local", "or", "use", "a", "shared", "helper", "NUMBER", "Here", "be", "a", "version", "that", "uses", "a", "shared", "helper", "and", "eliminates", "the", "redundant", "test", "and", "calls", "to", "hashtable", "size", "but", "I", "haven", "t", "tried", "it", "to", "make", "sure", "it", "actually", "works", "NUMBER", "set", "who", "hashtable", "cells", "let", "define", "dispatch", "h", "max", "sz", "unless", "xht", "h", "oops", "who", "s", "be", "not", "a", "hashtable", "h", "case", "xht", "type", "h", "eq", "eq", "hashtable", "cells", "h", "max", "sz", "eqv", "eqv", "hashtable", "cells", "h", "max", "sz", "else", "ht", "hashtable", "cells", "h", "max", "sz", "define", "invalid", "length", "max", "sz", "oops", "who", "s", "be", "not", "a", "valid", "length", "max", "sz", "case", "lambda", "h", "max", "sz", "cond", "fixnum", "max", "sz", "unless", "fx", "max", "sz", "NUMBER", "invalid", "length", "max", "sz", "dispatch", "h", "max", "sz", "bignum", "max", "sz", "unless", "max", "sz", "NUMBER", "invalid", "length", "max", "sz", "dispatch", "h", "most", "positive", "fixnum", "else", "invalid", "length", "max", "sz", "h", "dispatch", "h", "most", "positive", "fixnum", "Thanks", "for", "the", "improved", "hashtable", "cells", "NUMBER", "I", "ll", "look", "into", "similar", "version", "of", "hashtable", "values", "hashtable", "keys", "and", "hashtable", "entries", "NUMBER", "Merging", "a", "first", "Q", "and", "second", "NUMBER", "Q", "cells", "in", "O", "Q", "time", "works", "by", "use", "a", "eq", "based", "hashtable", "in", "the", "general", "case", "NUMBER", "Fair", "enough", "in", "amortized", "terms", "NUMBER", "Still", "the", "process", "you", "describe", "takes", "O", "N", "time", "as", "you", "say", "so", "it", "s", "the", "same", "asymptotically", "as", "calling", "hashtable", "cells", "without", "the", "max", "size", "argument", "with", "a", "larger", "constant", "factor", "in", "general", "so", "this", "doesn", "t", "seem", "like", "a", "good", "use", "of", "the", "max", "size", "argument", "NUMBER", "I", "can", "see", "wanting", "to", "process", "and", "remove", "at", "most", "Q", "elements", "at", "a", "time", "from", "a", "hashtable", "whose", "size", "might", "be", "greater", "than", "Q", "so", "I", "can", "see", "why", "the", "max", "size", "argument", "might", "be", "useful", "NUMBER", "The", "update", "commit", "add", "an", "optional", "size", "argument", "to", "hashtable", "keys", "hashtable", "values", "and", "hashtable", "entries", "which", "involved", "splitting", "out", "a", "separate", "R", "NUMBER", "RS", "variant", "for", "hashtable", "keys", "and", "hashtable", "entries", "NUMBER", "I", "see", "that", "I", "haven", "t", "explained", "my", "use", "of", "hashtable", "cells", "well", "NUMBER", "Maybe", "it", "doesn", "t", "matter", "anyway", "but", "I", "ll", "give", "it", "one", "more", "try", "NUMBER", "My", "overall", "goal", "be", "to", "adapt", "hashtables", "to", "a", "generic", "sequence", "iteration", "interface", "NUMBER", "The", "interface", "include", "operations", "to", "get", "a", "starting", "index", "to", "increment", "an", "index", "functionally", "so", "the", "previous", "index", "remains", "usable", "as", "long", "as", "the", "hash", "table", "doesn", "t", "change", "in", "certain", "ways", "and", "to", "get", "the", "value", "key", "at", "an", "index", "NUMBER", "Those", "operations", "all", "need", "to", "be", "amortized", "constant", "time", "NUMBER", "So", "it", "s", "ok", "to", "take", "O", "N", "time", "overall", "to", "get", "to", "the", "Nth", "index", "key", "value", "but", "it", "must", "be", "O", "N", "time", "even", "if", "the", "size", "of", "the", "table", "be", "greater", "than", "O", "N", "and", "there", "s", "no", "way", "to", "predict", "N", "in", "advance", "because", "N", "corresponds", "to", "the", "number", "of", "iterations", "steps", "that", "be", "performed", "before", "the", "iteration", "be", "abandoned", "NUMBER", "Adding", "hashtable", "cells", "with", "a", "size", "argument", "be", "enough", "to", "achieve", "that", "goal", "but", "it", "wasn", "t", "obvious", "to", "me", "until", "I", "thought", "of", "the", "merge", "piece", "so", "that", "s", "why", "I", "commented", "on", "the", "merge", "strategy", "NUMBER", "Some", "test", "need", "repair", "for", "different", "evaluation", "modes", "such", "as", "interpret", "instead", "of", "compiled", "which", "doesn", "t", "preserve", "names", "NUMBER", "This", "will", "close", "NUMBER", "The", "main", "issue", "be", "that", "on", "current", "OS", "X", "X", "NUMBER", "be", "no", "more", "provide", "default", "NUMBER", "cc", "burgerrg", "burgerrg", "thanks", "for", "the", "comment", "then", "I", "will", "close", "this", "PR", "and", "take", "a", "try", "to", "implement", "as", "your", "comment", "later", "NUMBER", "I", "did", "that", "in", "check", "in", "f", "NUMBER", "cf", "NUMBER", "fe", "NUMBER", "d", "NUMBER", "ca", "NUMBER", "d", "NUMBER", "e", "NUMBER", "bd", "NUMBER", "c", "NUMBER", "a", "So", "I", "think", "we", "re", "good", "there", "the", "only", "miss", "part", "was", "the", "X", "NUMBER", "autodetect", "NUMBER", "andy", "On", "July", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "NUMBER", "AM", "Bob", "Burger", "notifications", "github", "NUMBER", "com", "write", "Thanks", "it", "would", "be", "great", "if", "you", "could", "unentangle", "the", "X", "NUMBER", "clipboard", "and", "macOS", "pasteboard", "in", "the", "expression", "editor", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "akeep", "I", "check", "the", "commit", "it", "seems", "we", "can", "reopen", "this", "pr", "and", "merge", "it", "and", "then", "things", "go", "well", "doesn", "t", "it", "add", "an", "option", "disable", "x", "NUMBER", "to", "configure", "which", "allows", "you", "to", "build", "Chez", "Scheme", "with", "X", "NUMBER", "disabled", "now", "you", "can", "build", "Chez", "Scheme", "like", "this", "NUMBER", "configure", "installprefix", "HOME", "scheme", "disable", "x", "NUMBER", "make", "make", "install", "see", "help", "by", "NUMBER", "configure", "help", "Relevant", "NUMBER", "and", "NUMBER", "Looks", "good", "thanks", "NUMBER", "ss", "scheme", "NUMBER", "in", "comments", "of", "many", "file", "This", "will", "close", "NUMBER", "burgerrg", "I", "think", "this", "PR", "be", "a", "net", "win", "could", "you", "please", "review", "it", "when", "you", "be", "free", "My", "inclination", "would", "be", "to", "update", "the", "copyright", "notice", "in", "a", "source", "file", "only", "when", "we", "modify", "it", "and", "to", "update", "the", "copyright", "date", "in", "the", "greeting", "and", "readme", "file", "around", "the", "beginning", "of", "the", "year", "or", "possibly", "when", "we", "produce", "a", "release", "NUMBER", "NUMBER", "by", "dybvig", "suggestion", "LINK", "a", "NUMBER", "osx", "L", "NUMBER", "Actually", "it", "be", "in", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "Platforms", "MacOSX", "NUMBER", "platform", "Developer", "SDKs", "MacOSX", "NUMBER", "sdk", "System", "Library", "Frameworks", "Tk", "NUMBER", "framework", "Headers", "there", "be", "not", "a", "symbol", "link", "from", "opt", "include", "X", "NUMBER", "NUMBER", "See", "LINK", "us", "ht", "NUMBER", "This", "causes", "cd", "a", "NUMBER", "osx", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "build", "cd", "c", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "usr", "bin", "make", "gcc", "m", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Wno", "implicit", "fallthrough", "Werror", "O", "NUMBER", "I", "opt", "X", "NUMBER", "include", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "osx", "I", "NUMBER", "zlib", "expeditor", "NUMBER", "c", "expeditor", "NUMBER", "c", "NUMBER", "NUMBER", "fatal", "error", "X", "NUMBER", "Xlib", "NUMBER", "h", "file", "not", "find", "include", "TAG", "NUMBER", "error", "generate", "NUMBER", "make", "NUMBER", "expeditor", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "build", "Error", "NUMBER", "make", "build", "Error", "NUMBER", "I", "can", "locally", "change", "I", "opt", "X", "NUMBER", "include", "to", "I", "Applications", "Xcode", "NUMBER", "app", "Contents", "Developer", "Platforms", "MacOSX", "NUMBER", "platform", "Developer", "SDKs", "MacOSX", "NUMBER", "sdk", "System", "Library", "Frameworks", "Tk", "NUMBER", "framework", "Headers", "and", "make", "do", "NUMBER", "But", "wondering", "whether", "there", "be", "a", "more", "compatible", "approach", "NUMBER", "burgerrg", "any", "idea", "ummm", "assume", "users", "be", "able", "to", "fix", "it", "by", "themselves", "be", "well", "One", "can", "install", "XQuartz", "LINK", "to", "fix", "this", "and", "I", "think", "it", "might", "worth", "a", "troubleshooting", "document", "README", "INSTALL", "Relevant", "NUMBER", "W", "NUMBER", "anD", "NUMBER", "eR", "NUMBER", "NUMBER", "has", "bug", "while", "build", "with", "X", "NUMBER", "and", "it", "should", "not", "be", "merge", "NUMBER", "I", "will", "try", "to", "fix", "it", "NUMBER", "But", "you", "can", "try", "the", "solution", "in", "NUMBER", "burgerrg", "and", "I", "had", "discussed", "this", "a", "little", "offline", "and", "I", "was", "planning", "to", "take", "a", "look", "at", "a", "fix", "this", "weekend", "NUMBER", "For", "a", "little", "context", "X", "NUMBER", "be", "use", "by", "the", "expression", "editor", "to", "interact", "with", "the", "X", "NUMBER", "clipboard", "and", "currently", "on", "macOS", "the", "LIBX", "NUMBER", "flag", "be", "also", "use", "to", "decide", "if", "the", "expression", "editor", "should", "interact", "with", "the", "macOS", "pasteboard", "NUMBER", "In", "many", "cases", "on", "macOS", "at", "least", "the", "paste", "support", "isn", "t", "really", "needed", "because", "if", "you", "be", "just", "use", "the", "expression", "editor", "within", "the", "macOS", "terminal", "the", "terminal", "itself", "will", "trap", "the", "paste", "key", "combination", "and", "paste", "for", "you", "however", "if", "you", "be", "in", "either", "an", "Xquartz", "terminal", "or", "if", "you", "be", "run", "inside", "another", "terminal", "emulator", "that", "do", "not", "do", "this", "for", "you", "it", "would", "be", "nice", "to", "support", "the", "macOS", "pasteboard", "even", "when", "X", "NUMBER", "be", "not", "available", "NUMBER", "Additionally", "I", "d", "prefer", "that", "the", "decision", "to", "build", "in", "support", "for", "X", "NUMBER", "be", "something", "the", "configure", "script", "decide", "similar", "to", "the", "way", "autoconfig", "decides", "these", "things", "NUMBER", "I", "have", "some", "ideas", "on", "how", "this", "should", "work", "but", "I", "ll", "need", "to", "test", "it", "out", "NUMBER", "So", "I", "d", "like", "to", "make", "two", "change", "as", "part", "of", "this", "NUMBER", "Have", "X", "NUMBER", "support", "be", "detected", "by", "configure", "NUMBER", "Unentangle", "the", "X", "NUMBER", "clipboard", "and", "macOS", "pasteboard", "in", "the", "expression", "editor", "NUMBER", "NUMBER", "also", "mentions", "ncurses", "NUMBER", "Unlike", "X", "NUMBER", "which", "be", "primarily", "use", "for", "clipboard", "support", "ncurses", "be", "needed", "to", "support", "the", "expression", "editor", "NUMBER", "It", "be", "possible", "to", "turn", "off", "the", "expression", "editor", "though", "I", "ve", "not", "test", "this", "aspect", "yet", "it", "should", "turn", "off", "cleanly", "if", "we", "can", "detect", "it", "be", "not", "available", "in", "configure", "however", "it", "be", "worth", "noting", "that", "interacting", "with", "REPL", "be", "a", "lot", "less", "pleasant", "when", "the", "expression", "editor", "which", "gives", "you", "multi", "line", "editing", "history", "search", "auto", "indent", "tab", "completion", "and", "configurable", "keyboard", "macros", "see", "sections", "Section", "NUMBER", "Expression", "Editor", "LINK", "NUMBER", "use", "h", "NUMBER", "and", "Chapter", "NUMBER", "Expression", "Editor", "LINK", "g", "NUMBER", "for", "details", "NUMBER", "I", "m", "not", "oppose", "to", "having", "configure", "determine", "that", "it", "could", "not", "support", "the", "expression", "editor", "though", "I", "d", "probably", "want", "configure", "to", "raise", "a", "warning", "or", "perhaps", "require", "a", "flag", "to", "indicate", "it", "was", "okay", "to", "leave", "it", "off", "NUMBER", "Update", "New", "PR", "NUMBER", "add", "an", "option", "disable", "x", "NUMBER", "to", "configure", "which", "allows", "you", "to", "build", "Chez", "Scheme", "with", "X", "NUMBER", "disabled", "I", "m", "still", "looking", "at", "this", "one", "but", "I", "haven", "t", "be", "able", "to", "provoke", "it", "by", "run", "make", "foreign", "NUMBER", "so", "by", "itself", "only", "by", "run", "make", "test", "NUMBER", "Do", "you", "have", "a", "shorter", "way", "that", "make", "test", "that", "crashes", "Is", "it", "possible", "that", "in", "S_call_help", "copying", "the", "tc", "argument", "to", "a", "volatile", "variable", "will", "help", "From", "my", "understanding", "of", "the", "C", "spec", "neither", "code", "nor", "tc", "need", "to", "be", "declared", "volatile", "because", "they", "don", "t", "change", "after", "the", "setjmp", "NUMBER", "But", "I", "think", "GCC", "declares", "an", "incompatibility", "with", "the", "standard", "and", "requires", "code", "and", "tc", "to", "be", "volatile", "NUMBER", "Maybe", "MSVC", "has", "a", "similar", "limitation", "NUMBER", "Concretely", "after", "change", "S_call_help", "to", "void", "S_call_help", "tc_in", "singlep", "lock_ts", "ptr", "tc_in", "IBOOL", "singlep", "IBOOL", "lock_ts", "declaring", "code", "volatile", "should", "be", "unnecessary", "but", "it", "quiets", "gcc", "void", "jb", "volatile", "ptr", "code", "volatile", "ptr", "tc", "tc_in", "then", "I", "can", "no", "longer", "provoke", "a", "crash", "with", "make", "test", "NUMBER", "But", "since", "the", "crashes", "be", "less", "consistent", "for", "me", "I", "m", "not", "sure", "that", "means", "anything", "NUMBER", "The", "change", "be", "probably", "a", "good", "idea", "to", "accommodate", "GCC", "s", "stated", "limitations", "in", "any", "case", "NUMBER", "PS", "I", "can", "get", "invalid", "references", "with", "VS", "NUMBER", "just", "not", "as", "easily", "as", "you", "apparently", "do", "with", "VS", "NUMBER", "This", "be", "a", "repair", "for", "the", "main", "bug", "report", "in", "NUMBER", "I", "have", "not", "yet", "run", "the", "update", "test", "on", "ppc", "NUMBER", "le", "but", "I", "ll", "do", "that", "tomorrow", "NUMBER", "burgerrg", "Ok", "I", "ll", "make", "that", "improvement", "but", "allocating", "two", "pages", "before", "adjusting", "the", "second", "one", "NUMBER", "The", "main", "problem", "wasn", "t", "so", "much", "be", "unlucky", "with", "the", "next", "page", "though", "but", "that", "the", "return", "type", "test", "weren", "t", "use", "malloc_at_boundary", "before", "NUMBER", "The", "foreign", "NUMBER", "ms", "test", "pass", "on", "ppc", "NUMBER", "le", "and", "malloc_on_boundary", "be", "update", "for", "Windows", "so", "I", "think", "this", "be", "ready", "for", "review", "NUMBER", "mflatt", "it", "appears", "that", "the", "ftype", "return", "code", "writes", "past", "the", "end", "of", "ftypes", "whose", "size", "be", "less", "than", "the", "native", "pointer", "size", "NUMBER", "See", "the", "valgrind", "report", "below", "NUMBER", "NUMBER", "Invalid", "write", "of", "size", "NUMBER", "NUMBER", "NUMBER", "Address", "NUMBER", "x", "NUMBER", "be", "NUMBER", "bytes", "inside", "a", "block", "of", "size", "NUMBER", "alloc", "d", "NUMBER", "at", "NUMBER", "x", "NUMBER", "C", "NUMBER", "CB", "NUMBER", "B", "malloc", "vg_replace_malloc", "NUMBER", "c", "NUMBER", "NUMBER", "by", "NUMBER", "x", "NUMBER", "F", "NUMBER", "s_malloc", "in", "usr", "bin", "scheme", "NUMBER", "The", "output", "above", "was", "generate", "by", "run", "the", "following", "excerpt", "from", "foreign", "NUMBER", "ms", "in", "an", "a", "NUMBER", "le", "workarea", "NUMBER", "cd", "mats", "make", "foreign", "NUMBER", "so", "valgrind", "NUMBER", "bin", "scheme", "load", "shared", "object", "NUMBER", "foreign", "NUMBER", "so", "define", "get", "foreign", "procedure", "f", "NUMBER", "_get_i", "NUMBER", "integer", "NUMBER", "let", "v", "make", "ftype", "pointer", "integer", "NUMBER", "foreign", "alloc", "ftype", "sizeof", "integer", "NUMBER", "get", "v", "ftype", "ref", "integer", "NUMBER", "v", "Perhaps", "change", "foreign", "NUMBER", "c", "s", "malloc_at_boundary", "as", "follows", "so", "that", "the", "system", "will", "raise", "an", "invalid", "memory", "reference", "when", "we", "exceed", "the", "boundary", "EXPORT", "void", "malloc_at_boundary", "int", "sz", "intptr_t", "alloc_size", "getpagesize", "char", "p", "p", "mmap", "NULL", "NUMBER", "alloc_size", "PROT_READ", "PROT_WRITE", "MAP_ANON", "MAP_PRIVATE", "NUMBER", "NUMBER", "mprotect", "p", "alloc_size", "alloc_size", "PROT_NONE", "return", "p", "alloc_size", "sz", "The", "repair", "in", "NUMBER", "seems", "unlikely", "to", "be", "relate", "to", "the", "a", "NUMBER", "nt", "failure", "since", "that", "test", "happens", "before", "any", "of", "the", "result", "test", "but", "I", "ll", "investigate", "more", "NUMBER", "I", "was", "reading", "the", "Chez", "Scheme", "documentation", "Section", "NUMBER", "Example", "Socket", "Operations", "LINK", "NUMBER", "foreign", "h", "NUMBER", "and", "was", "a", "bit", "surprised", "by", "the", "following", "code", "scheme", "Requires", "csocket", "NUMBER", "so", "build", "from", "csocket", "NUMBER", "c", "NUMBER", "case", "machine", "type", "i", "NUMBER", "le", "ti", "NUMBER", "le", "load", "shared", "object", "libc", "NUMBER", "so", "NUMBER", "i", "NUMBER", "osx", "ti", "NUMBER", "osx", "load", "shared", "object", "libc", "NUMBER", "dylib", "else", "load", "shared", "object", "libc", "NUMBER", "so", "Requires", "from", "C", "library", "close", "dup", "execl", "fork", "kill", "listen", "tmpnam", "unlink", "load", "shared", "object", "libc", "NUMBER", "so", "Shouldn", "t", "it", "be", "this", "instead", "scheme", "Requires", "from", "C", "library", "close", "dup", "execl", "fork", "kill", "listen", "tmpnam", "unlink", "case", "machine", "type", "i", "NUMBER", "le", "ti", "NUMBER", "le", "load", "shared", "object", "libc", "NUMBER", "so", "NUMBER", "i", "NUMBER", "osx", "ti", "NUMBER", "osx", "load", "shared", "object", "libc", "NUMBER", "dylib", "else", "load", "shared", "object", "libc", "NUMBER", "so", "Requires", "csocket", "NUMBER", "so", "build", "from", "csocket", "NUMBER", "c", "NUMBER", "load", "shared", "object", "csocket", "NUMBER", "so", "It", "seems", "to", "be", "necessary", "to", "load", "our", "own", "library", "and", "doesn", "t", "make", "sense", "to", "load", "the", "libc", "twice", "NUMBER", "yes", "If", "I", "understand", "correctly", "it", "will", "be", "update", "on", "the", "Chez", "Scheme", "project", "homepage", "at", "the", "next", "stable", "release", "of", "Chez", "Scheme", "NUMBER", "I", "totally", "miss", "the", "fact", "that", "the", "documentation", "was", "stored", "in", "the", "csug", "folder", "NUMBER", "Anyway", "thanks", "for", "taking", "time", "to", "fix", "and", "improve", "the", "examples", "I", "be", "sure", "it", "will", "help", "me", "and", "others", "a", "lot", "smile", "I", "don", "t", "know", "if", "you", "want", "to", "keep", "the", "issue", "opened", "until", "the", "website", "be", "update", "if", "not", "feel", "free", "to", "close", "it", "NUMBER", "The", "mrvs", "case", "of", "boot_call", "uses", "a", "zero", "based", "index", "when", "it", "looks", "like", "it", "intends", "a", "NUMBER", "based", "index", "but", "fix", "that", "doesn", "t", "help", "since", "the", "value", "it", "s", "going", "after", "isn", "t", "saved", "NUMBER", "Since", "boot_call", "already", "handles", "the", "case", "of", "zero", "return", "values", "and", "otherwise", "ignores", "all", "but", "the", "first", "return", "value", "it", "seem", "simpler", "to", "set", "up", "ac", "NUMBER", "which", "be", "already", "covered", "by", "the", "save", "scheme", "state", "in", "the", "hand", "code", "invoke", "NUMBER", "Maybe", "there", "be", "a", "better", "fix", "Either", "way", "perhaps", "we", "can", "add", "a", "fix", "for", "this", "the", "next", "time", "we", "have", "a", "compelling", "reason", "to", "rebuild", "the", "boot", "file", "NUMBER", "If", "we", "take", "this", "change", "we", "can", "make", "the", "obvious", "simplification", "in", "boot_call", "omitted", "here", "to", "minimize", "the", "diff", "NUMBER", "Before", "echo", "exit", "NUMBER", "scheme", "q", "echo", "NUMBER", "echo", "exit", "NUMBER", "NUMBER", "NUMBER", "scheme", "q", "echo", "NUMBER", "echo", "exit", "NUMBER", "NUMBER", "NUMBER", "scheme", "q", "echo", "NUMBER", "After", "the", "latter", "two", "print", "NUMBER", "and", "NUMBER", "respectively", "NUMBER", "I", "m", "not", "sure", "what", "to", "do", "about", "the", "additional", "test", "cases", "in", "the", "commit", "at", "the", "tip", "of", "this", "branch", "NUMBER", "The", "documentation", "LINK", "NUMBER", "system", "s", "NUMBER", "says", "they", "should", "return", "NUMBER", "but", "Sscheme_start", "returns", "NUMBER", "which", "be", "simpler", "in", "cross", "platform", "case", "so", "maybe", "it", "s", "better", "to", "update", "CSUG", "there", "Clarification", "The", "example", "output", "shown", "above", "was", "generate", "on", "a", "NUMBER", "le", "NUMBER", "On", "a", "NUMBER", "nt", "the", "multiple", "value", "examples", "both", "return", "NUMBER", "before", "patching", "NUMBER", "Simplified", "so", "it", "doesn", "t", "need", "to", "wait", "for", "next", "boot", "file", "update", "NUMBER", "Bob", "and", "I", "put", "a", "couple", "alternatives", "on", "owaddell", "alt", "invoke", "LINK", "invoke", "That", "seems", "reasonable", "NUMBER", "Having", "the", "invoke", "code", "object", "save", "the", "argument", "registers", "shouldn", "t", "cause", "a", "problem", "as", "far", "as", "I", "know", "NUMBER", "I", "agree", "with", "owaddel", "that", "the", "documentation", "should", "change", "to", "reflect", "the", "correct", "behavior", "NUMBER", "By", "my", "reading", "of", "the", "code", "and", "documentation", "the", "documentation", "be", "also", "wrong", "in", "the", "single", "value", "case", "both", "in", "the", "handle", "of", "a", "single", "Svoid", "value", "and", "in", "the", "handle", "of", "non", "NUMBER", "bit", "NUMBER", "bit", "integer", "values", "on", "NUMBER", "bit", "machines", "NUMBER", "In", "both", "cases", "the", "documentation", "says", "the", "result", "should", "be", "NUMBER", "but", "the", "actual", "value", "for", "Svoid", "be", "NUMBER", "and", "the", "actual", "value", "for", "a", "non", "NUMBER", "bit", "NUMBER", "bit", "integer", "value", "on", "a", "NUMBER", "bit", "machine", "be", "the", "result", "of", "casting", "the", "value", "to", "an", "int", "NUMBER", "Calling", "library", "export", "on", "a", "compiled", "library", "raises", "an", "exception", "if", "the", "library", "has", "not", "yet", "be", "imported", "NUMBER", "If", "we", "compile", "testfile", "li", "NUMBER", "ss", "and", "start", "a", "new", "session", "we", "get", "load", "library", "testfile", "li", "NUMBER", "so", "library", "export", "testfile", "li", "NUMBER", "Exception", "in", "library", "export", "unexpect", "binding", "global", "NUMBER", "testfile", "li", "NUMBER", "dxvp", "NUMBER", "u", "NUMBER", "nmy", "NUMBER", "h", "NUMBER", "a", "NUMBER", "skcx", "NUMBER", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "With", "the", "change", "on", "this", "branch", "if", "we", "recompile", "testfile", "li", "NUMBER", "ss", "and", "start", "a", "new", "session", "we", "get", "load", "library", "testfile", "li", "NUMBER", "so", "library", "export", "testfile", "li", "NUMBER", "x", "Is", "this", "approach", "misguided", "If", "not", "maybe", "we", "can", "tidy", "up", "and", "cherry", "pick", "the", "next", "time", "we", "have", "a", "compelling", "reason", "to", "rebuild", "the", "boot", "file", "NUMBER", "Right", "now", "it", "s", "mingled", "with", "the", "change", "for", "NUMBER", "The", "original", "chi", "top", "library", "had", "install", "the", "interface", "binding", "with", "different", "values", "for", "token", "in", "the", "call", "to", "sc", "put", "cte", "f", "vs", "NUMBER", "the", "call", "to", "build", "cte", "install", "system", "NUMBER", "I", "moved", "the", "work", "of", "the", "residual", "call", "into", "import", "library", "and", "preserved", "the", "system", "but", "perhaps", "that", "should", "have", "be", "f", "originally", "based", "on", "the", "comment", "in", "chi", "top", "library", "LINK", "L", "NUMBER", "NUMBER", "akeep", "do", "this", "look", "like", "a", "reasonable", "way", "to", "address", "the", "issue", "outlined", "above", "The", "build", "failure", "on", "ta", "NUMBER", "osx", "LINK", "ci", "NUMBER", "org", "cisco", "ChezScheme", "jobs", "NUMBER", "be", "puzzling", "NUMBER", "We", "could", "not", "reproduce", "this", "on", "a", "MacBook", "Pro", "run", "OS", "X", "Sierra", "NUMBER", "The", "travis", "build", "exceeded", "the", "maximum", "time", "limit", "for", "jobs", "because", "it", "seems", "to", "have", "become", "overly", "fond", "of", "run", "unix", "NUMBER", "ms", "examples", "NUMBER", "ms", "ieee", "NUMBER", "ms", "date", "NUMBER", "ms", "exception", "NUMBER", "ms", "and", "oop", "NUMBER", "ms", "NUMBER", "owaddell", "this", "seems", "like", "a", "nice", "interface", "improvement", "in", "that", "it", "allows", "a", "certain", "amount", "if", "inspection", "without", "actually", "needing", "to", "execute", "any", "of", "the", "code", "in", "the", "library", "NUMBER", "I", "have", "mix", "feelings", "about", "pulling", "the", "interface", "binding", "code", "scheme", "sc", "put", "cte", "uid", "libdesc", "interface", "binding", "desc", "system", "out", "of", "the", "import", "code", "thunk", "because", "it", "feels", "like", "we", "be", "in", "a", "bit", "of", "a", "strange", "point", "in", "the", "space", "when", "you", "add", "up", "my", "change", "to", "put", "the", "visit", "code", "bindings", "in", "the", "libdesc", "visit", "id", "so", "that", "I", "could", "restore", "them", "in", "visit", "library", "fail", "NUMBER", "It", "means", "we", "have", "the", "library", "interface", "and", "visit", "ids", "as", "data", "in", "the", "libdesc", "record", "really", "the", "ctdesc", "record", "we", "have", "the", "code", "for", "installing", "the", "interface", "in", "import", "library", "and", "the", "code", "for", "setting", "the", "visit", "id", "in", "the", "thunk", "but", "also", "the", "visit", "identifier", "list", "in", "the", "ctdesc", "export", "id", "NUMBER", "It", "makes", "me", "wonder", "if", "we", "should", "just", "get", "rid", "of", "the", "import", "code", "thunk", "entirely", "and", "add", "the", "invoke", "identifiers", "to", "the", "ctdesc", "data", "structure", "as", "well", "NUMBER", "The", "other", "interesting", "piece", "of", "this", "be", "that", "you", "and", "I", "have", "made", "different", "decisions", "about", "where", "to", "put", "this", "information", "NUMBER", "I", "made", "the", "visit", "ids", "part", "of", "the", "install", "library", "ct", "code", "call", "where", "you", "ve", "add", "the", "interface", "information", "to", "the", "library", "ct", "info", "record", "NUMBER", "It", "may", "be", "it", "just", "has", "to", "be", "separated", "this", "way", "because", "the", "binding", "expressions", "be", "potentially", "not", "data", "but", "effectively", "I", "think", "they", "be", "currently", "all", "data", "for", "the", "bindings", "created", "in", "the", "import", "code", "thunk", "NUMBER", "It", "makes", "me", "wonder", "if", "we", "should", "handle", "all", "of", "this", "information", "the", "same", "way", "NUMBER", "Sorry", "for", "the", "somewhat", "disconnected", "observations", "I", "m", "just", "wondering", "if", "moving", "to", "a", "more", "data", "structural", "representation", "for", "all", "of", "this", "and", "treating", "the", "import", "consistently", "would", "have", "some", "benefits", "for", "us", "NUMBER", "compile", "NUMBER", "ss", "Should", "we", "revise", "the", "flush", "output", "port", "change", "to", "fetch", "parameter", "values", "once", "per", "when", "NUMBER", "syntax", "NUMBER", "ss", "I", "left", "a", "WIP", "commit", "at", "the", "tip", "hoping", "that", "akeep", "can", "sanity", "check", "it", "NUMBER", "Here", "be", "the", "error", "message", "issue", "note", "that", "it", "be", "masked", "by", "the", "WIP", "commit", "import", "notify", "t", "generate", "wpo", "file", "t", "compile", "imported", "libraries", "t", "with", "output", "to", "file", "B", "NUMBER", "ss", "lambda", "pretty", "print", "library", "B", "export", "b", "import", "scheme", "define", "b", "NUMBER", "replace", "with", "output", "to", "file", "prog", "NUMBER", "ss", "lambda", "for", "each", "pretty", "print", "import", "B", "scheme", "import", "notify", "t", "define", "run", "args", "guard", "c", "t", "display", "condition", "c", "newline", "pretty", "print", "top", "level", "value", "car", "args", "environment", "cdr", "args", "when", "b", "NUMBER", "reference", "export", "let", "args", "map", "string", "symbol", "command", "line", "argument", "if", "length", "args", "NUMBER", "begin", "run", "args", "run", "args", "error", "f", "expected", "NUMBER", "args", "replace", "compile", "program", "prog", "NUMBER", "ss", "compile", "whole", "program", "prog", "NUMBER", "wpo", "prog", "visible", "t", "compile", "whole", "program", "prog", "NUMBER", "wpo", "prog", "not", "visible", "f", "Before", "scheme", "program", "prog", "not", "visible", "b", "B", "Exception", "in", "visit", "library", "B", "be", "not", "visible", "Exception", "unknown", "module", "B", "b", "NUMBER", "zzvxtl", "NUMBER", "z", "NUMBER", "jmjgbh", "NUMBER", "vh", "NUMBER", "q", "NUMBER", "After", "the", "clarify", "unknown", "module", "error", "message", "NUMBER", "commit", "scheme", "program", "prog", "not", "visible", "b", "B", "Exception", "in", "visit", "library", "B", "be", "not", "visible", "Exception", "unknown", "library", "B", "After", "the", "WIP", "commit", "scheme", "program", "prog", "not", "visible", "b", "B", "Exception", "in", "visit", "library", "B", "be", "not", "visible", "Exception", "in", "visit", "library", "B", "be", "not", "visible", "Thanks", "for", "point", "me", "to", "the", "other", "code", "NUMBER", "I", "update", "the", "on", "reset", "for", "import", "library", "and", "add", "a", "mat", "in", "NUMBER", "ms", "NUMBER", "I", "don", "t", "think", "you", "miss", "anything", "in", "the", "generate", "code", "when", "you", "made", "the", "change", "in", "NUMBER", "dbd", "NUMBER", "nothing", "in", "the", "import", "code", "thunk", "should", "have", "raise", "an", "error", "NUMBER", "My", "change", "in", "NUMBER", "dca", "NUMBER", "broke", "that", "assumption", "NUMBER", "Now", "the", "body", "of", "the", "import", "code", "thunk", "be", "either", "NUMBER", "a", "call", "to", "oops", "or", "NUMBER", "a", "sequence", "installing", "compile", "time", "bindings", "as", "before", "quoted", "data", "NUMBER", "In", "the", "first", "case", "no", "compile", "time", "bindings", "be", "install", "so", "there", "be", "nothing", "to", "roll", "back", "NUMBER", "In", "the", "second", "nothing", "should", "raise", "an", "error", "NUMBER", "There", "be", "a", "call", "to", "syntax", "error", "in", "the", "do", "import", "case", "of", "sc", "put", "cte", "but", "chi", "top", "library", "doesn", "t", "generate", "such", "bindings", "NUMBER", "I", "could", "be", "miss", "something", "but", "it", "looks", "like", "we", "don", "t", "need", "to", "capture", "anything", "more", "for", "this", "NUMBER", "Maybe", "it", "needs", "a", "comment", "in", "the", "code", "akeep", "could", "you", "look", "at", "this", "again", "I", "fix", "the", "placement", "of", "the", "on", "reset", "and", "rebased", "NUMBER", "I", "think", "my", "reply", "above", "address", "your", "other", "feedback", "NUMBER", "owaddell", "I", "think", "these", "change", "make", "sense", "NUMBER", "It", "took", "me", "a", "little", "while", "to", "look", "through", "the", "code", "base", "a", "bit", "and", "see", "what", "all", "might", "appear", "in", "the", "import", "code", "thunk", "NUMBER", "After", "looking", "I", "m", "pretty", "sure", "there", "be", "nothing", "in", "that", "thunk", "that", "can", "raise", "an", "error", "since", "it", "be", "just", "setting", "up", "compile", "time", "environment", "bindings", "and", "none", "of", "the", "expressions", "in", "the", "bindings", "do", "anything", "that", "can", "raise", "an", "exception", "so", "I", "think", "it", "be", "probably", "unnecessary", "to", "roll", "back", "the", "side", "effect", "in", "that", "code", "NUMBER", "So", "yeah", "I", "think", "this", "looks", "good", "NUMBER", "akeep", "thanks", "for", "looking", "at", "this", "NUMBER", "hello", "be", "it", "interpreter", "still", "available", "It", "would", "be", "nice", "to", "have", "embeddable", "scheme", "on", "ios", "NUMBER", "thanks", "for", "info", "NUMBER", "closing", "NUMBER", "As", "LibBin", "be", "expanded", "to", "TempRoot", "InstallLibBin", "if", "we", "create", "a", "symlink", "with", "a", "source", "point", "to", "the", "TempRoot", "path", "once", "install", "for", "example", "in", "an", "RPM", "the", "symlink", "will", "still", "point", "to", "the", "TempRoot", "path", "NUMBER", "That", "s", "why", "we", "must", "use", "the", "final", "path", "InstallLibBin", "NUMBER", "Another", "solution", "could", "have", "be", "to", "use", "a", "relative", "path", "NUMBER", "Thanks", "for", "your", "review", "indeed", "I", "only", "encountered", "a", "problem", "with", "ln", "sf", "LibBin", "scheme", "NUMBER", "boot", "LibBin", "InstallScriptName", "NUMBER", "boot", "and", "totally", "miss", "the", "fact", "that", "the", "other", "lines", "were", "hard", "links", "NUMBER", "I", "will", "try", "to", "replace", "only", "the", "previously", "mentionned", "line", "by", "a", "hard", "link", "and", "update", "this", "PR", "if", "it", "works", "NUMBER", "I", "have", "backported", "the", "patch", "to", "my", "RPM", "package", "and", "it", "looks", "like", "it", "works", "the", "build", "succeeded", "on", "all", "platforms", "see", "on", "copr", "LINK", "scheme", "build", "NUMBER", "see", "on", "github", "LINK", "NUMBER", "I", "have", "also", "update", "this", "PR", "accordingly", "NUMBER", "However", "I", "be", "not", "sure", "of", "scheme", "script", "behaviour", "should", "it", "act", "like", "scheme", "script", "Because", "it", "s", "not", "the", "case", "for", "me", "but", "it", "looks", "like", "another", "problem", "as", "even", "with", "the", "symlink", "scheme", "script", "doesn", "t", "act", "like", "scheme", "script", "NUMBER", "Indeed", "I", "compared", "the", "following", "program", "usr", "bin", "scheme", "script", "display", "hello", "Fails", "with", "Exception", "invalid", "top", "level", "program", "import", "subform", "display", "hello", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "test", "usr", "bin", "scheme", "script", "display", "hello", "Works", "I", "think", "it", "could", "be", "that", "I", "don", "t", "understand", "what", "be", "scheme", "script", "purpose", "or", "I", "fail", "something", "in", "my", "packaging", "scripts", "so", "probably", "not", "relate", "but", "I", "prefer", "ask", "before", "breaking", "something", "in", "ChezScheme", "via", "a", "broken", "PR", "scheme", "script", "be", "equivalent", "to", "scheme", "program", "Ok", "so", "it", "works", "as", "intended", "smiley", "I", "currently", "have", "autocomplete", "work", "via", "company", "but", "autodoc", "be", "not", "work", "with", "company", "quickhelp", "NUMBER", "Here", "be", "what", "I", "have", "install", "Ubuntu", "NUMBER", "GNU", "Emacs", "NUMBER", "Chez", "Scheme", "Version", "NUMBER", "Geiser", "NUMBER", "Here", "be", "my", "setup", "emacs", "lisp", "use", "package", "geiser", "ensure", "t", "config", "defvar", "geiser", "active", "implementations", "setq", "geiser", "active", "implementations", "chez", "setq", "geiser", "mode", "start", "repl", "p", "t", "setq", "geiser", "repl", "history", "filename", "NUMBER", "emacs", "NUMBER", "d", "geiser", "history", "add", "to", "list", "company", "backends", "geiser", "company", "use", "package", "company", "ensure", "t", "config", "add", "hook", "prog", "mode", "hook", "company", "mode", "setq", "company", "dabbrev", "downcase", "NUMBER", "setq", "company", "idle", "delay", "NUMBER", "use", "package", "company", "quickhelp", "ensure", "t", "config", "company", "quickhelp", "mode", "NUMBER", "define", "key", "company", "active", "map", "kbd", "C", "c", "h", "company", "quickhelp", "manual", "begin", "and", "the", "error", "I", "get", "be", "Error", "run", "timer", "company", "quickhelp", "show", "error", "No", "buffer", "named", "No", "documentation", "available", "for", "default", "exception", "handler", "And", "here", "be", "a", "screenshot", "of", "the", "autodoc", "failure", "screenshot", "from", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "LINK", "images", "NUMBER", "githubusercontent", "NUMBER", "com", "NUMBER", "NUMBER", "NUMBER", "e", "NUMBER", "fe", "NUMBER", "NUMBER", "c", "NUMBER", "d", "NUMBER", "e", "NUMBER", "NUMBER", "fc", "NUMBER", "NUMBER", "dcb", "NUMBER", "ec", "NUMBER", "png", "Geiser", "uses", "Chez\u02bcs", "inspect", "object", "functionality", "NUMBER", "For", "procedures", "that", "you", "created", "you", "need", "to", "evaluate", "them", "before", "you", "can", "see", "autodoc", "NUMBER", "For", "build", "in", "procedures", "you", "need", "to", "compile", "Chez", "with", "generate", "inspector", "information", "set", "to", "t", "NUMBER", "By", "setting", "generate", "inspector", "information", "to", "t", "will", "we", "be", "able", "to", "get", "the", "minibuffer", "strings", "that", "show", "a", "function", "parameters", "like", "_map", "f", "l", "f", "l", "l", "NUMBER", "_", "NUMBER", "etc", "Silverbeard", "NUMBER", "yes", "I", "get", "this", "work", "by", "editing", "the", "following", "lines", "in", "the", "build", "file", "s", "Mf", "base", "i", "determines", "whether", "inspector", "information", "be", "generate", "f", "for", "false", "t", "for", "true", "i", "f", "I", "change", "i", "f", "to", "i", "t", "and", "then", "rebuilt", "Chez", "with", "NUMBER", "configure", "sudo", "make", "sudo", "make", "bootfiles", "sudo", "make", "install", "After", "that", "Geiser", "began", "showing", "argument", "for", "some", "build", "in", "procedures", "like", "printf", "but", "not", "all", "NUMBER", "For", "instance", "nothing", "be", "shown", "for", "map", "NUMBER", "I", "think", "this", "be", "a", "problem", "with", "Geiser", "s", "handle", "of", "procedures", "defined", "by", "lambda", "case", "with", "multiple", "arities", "but", "I", "m", "not", "sure", "NUMBER", "I", "figured", "I", "should", "document", "this", "here", "because", "I", "didn", "t", "find", "how", "to", "compile", "Chez", "with", "generate", "inspector", "information", "anywhere", "NUMBER", "On", "Wed", "Sep", "NUMBER", "NUMBER", "andregrigon", "write", "After", "that", "Geiser", "began", "showing", "argument", "for", "some", "build", "in", "procedures", "like", "printf", "but", "not", "all", "NUMBER", "For", "instance", "nothing", "be", "shown", "for", "map", "NUMBER", "I", "think", "this", "be", "a", "problem", "with", "Geiser", "s", "handle", "of", "procedures", "defined", "by", "lambda", "case", "with", "multiple", "arities", "but", "I", "m", "not", "sure", "NUMBER", "I", "haven", "t", "looked", "so", "I", "might", "be", "miss", "something", "but", "geiser", "s", "elisp", "doesn", "t", "guess", "any", "argument", "by", "itself", "it", "just", "asks", "the", "scheme", "process", "chezscheme", "in", "this", "case", "for", "a", "list", "of", "arities", "of", "the", "given", "procedure", "NUMBER", "So", "Geiser", "s", "elisp", "doesn", "t", "even", "know", "in", "general", "whether", "the", "function", "was", "defined", "as", "a", "lambda", "case", "or", "in", "any", "other", "form", "or", "even", "if", "it", "s", "a", "macro", "for", "that", "matter", "as", "long", "as", "the", "arities", "be", "report", "in", "the", "expected", "format", "which", "be", "fix", "multiple", "arities", "be", "support", "NUMBER", "That", "arity", "list", "be", "generate", "somewhere", "in", "Geiser", "s", "scheme", "code", "for", "ChezScheme", "so", "maybe", "that", "s", "the", "code", "that", "be", "not", "handle", "correctly", "report", "of", "arities", "for", "lambda", "case", "NUMBER", "Oh", "right", "that", "s", "what", "I", "meant", "NUMBER", "I", "think", "the", "problem", "be", "in", "the", "following", "procedure", "from", "geiser", "scheme", "chez", "geiser", "geiser", "NUMBER", "ss", "define", "procedure", "parameter", "list", "p", "same", "as", "inspect", "object", "then", "hitting", "c", "let", "s", "inspect", "object", "p", "code", "source", "if", "s", "let", "form", "s", "value", "if", "and", "list", "form", "length", "form", "NUMBER", "eq", "car", "form", "lambda", "cadr", "form", "f", "f", "It", "seems", "to", "look", "at", "the", "procedure", "source", "to", "determine", "the", "parameter", "list", "and", "only", "treats", "lambdas", "NUMBER", "Sorry", "for", "the", "confusion", "Here", "be", "what", "I", "have", "scheme", "amirouche", "neitram", "src", "scheme", "chez", "tmp", "cat", "foo", "NUMBER", "scm", "import", "rnrs", "define", "foo", "example", "let", "bar", "NUMBER", "bar", "foo", "NUMBER", "amirouche", "neitram", "src", "scheme", "chez", "tmp", "scheme", "debug", "on", "exception", "program", "foo", "NUMBER", "scm", "Exception", "attempt", "to", "apply", "non", "procedure", "NUMBER", "debug", "i", "TAG", "sl", "continuation", "TAG", "procedure", "code", "lambda", "letrec", "NUMBER", "NUMBER", "NUMBER", "call", "code", "bar", "TAG", "Is", "it", "possible", "to", "know", "in", "which", "module", "bar", "be", "defined", "Also", "be", "it", "possible", "to", "have", "traceback", "on", "error", "instead", "of", "having", "to", "enter", "the", "debugger", "the", "debugger", "be", "very", "crude", "it", "doesn", "t", "support", "sexp", "editor", "nor", "readline", "history", "autocomplete", "Also", "this", "article", "be", "helpful", "LINK", "If", "you", "want", "an", "error", "handler", "to", "print", "a", "stack", "trace", "then", "install", "an", "error", "handler", "that", "prints", "stack", "traces", "NUMBER", "NUMBER", "If", "you", "want", "the", "inspector", "to", "support", "the", "expression", "editor", "which", "seems", "like", "a", "pretty", "good", "idea", "to", "me", "then", "you", "might", "have", "better", "luck", "open", "an", "issue", "specifically", "for", "that", "NUMBER", "I", "m", "a", "little", "surprised", "that", "there", "isn", "t", "one", "already", "NUMBER", "As", "for", "knowing", "where", "bar", "be", "defined", "NUMBER", "well", "first", "your", "question", "as", "write", "doesn", "t", "make", "sense", "since", "there", "be", "no", "modules", "at", "all", "in", "your", "example", "NUMBER", "Presuming", "you", "meant", "that", "you", "wanted", "to", "know", "where", "the", "variable", "was", "introduce", "into", "scope", "which", "still", "won", "t", "necessarily", "tell", "you", "where", "it", "was", "assigned", "the", "bad", "value", "that", "s", "a", "good", "question", "NUMBER", "Perhaps", "one", "of", "the", "maintainers", "will", "chime", "in", "and", "tell", "us", "if", "that", "information", "be", "retained", "in", "the", "compiled", "code", "when", "inspector", "information", "be", "enable", "NUMBER", "Frankly", "I", "m", "a", "little", "surprised", "that", "it", "keep", "enough", "information", "to", "know", "that", "there", "was", "a", "bar", "in", "the", "first", "place", "since", "expand", "optimize", "gets", "rid", "of", "it", "completely", "NUMBER", "NUMBER", "prim", "NUMBER", "c", "In", "function", "s_showalloc", "prim", "NUMBER", "c", "NUMBER", "NUMBER", "error", "td", "of", "directive", "output", "may", "be", "truncated", "write", "NUMBER", "bytes", "into", "a", "region", "of", "size", "between", "NUMBER", "and", "NUMBER", "Werror", "format", "truncation", "snprintf", "fmtbuf", "FMTBUFSIZE", "NUMBER", "dtx", "NUMBER", "dtx", "NUMBER", "dtx", "bytes", "NUMBER", "dtx", "dtd", "of", "dtd", "n", "prim", "NUMBER", "c", "NUMBER", "NUMBER", "note", "snprintf", "output", "between", "NUMBER", "and", "NUMBER", "bytes", "into", "a", "destination", "of", "size", "NUMBER", "snprintf", "fmtbuf", "FMTBUFSIZE", "NUMBER", "dtx", "NUMBER", "dtx", "NUMBER", "dtx", "bytes", "NUMBER", "dtx", "dtd", "of", "dtd", "n", "addrwidth", "byteswidth", "headerbyteswidth", "headeraddrwidth", "segswidth", "segswidth", "cc", "NUMBER", "all", "warnings", "be", "treated", "as", "error", "make", "NUMBER", "Makefile", "NUMBER", "prim", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "install", "Error", "NUMBER", "I", "can", "t", "find", "any", "other", "similar", "error", "online", "NUMBER", "I", "m", "not", "knowledgeable", "enough", "to", "determine", "whether", "this", "be", "an", "issue", "with", "s_showalloc", "in", "prim", "NUMBER", "c", "or", "GCC", "s", "snprintf", "NUMBER", "G", "NUMBER", "Thank", "you", "NUMBER", "NUMBER", "still", "won", "t", "build", "after", "patching", "because", "it", "can", "t", "find", "xlocale", "NUMBER", "h", "NUMBER", "However", "master", "build", "fine", "NUMBER", "make", "CFLAGS", "Wno", "format", "truncation", "can", "temporarily", "disable", "the", "warning", "but", "not", "the", "final", "solution", "NUMBER", "arm", "NUMBER", "le", "dose", "not", "support", "thread", "I", "went", "crash", "NUMBER", "SIGSEGV", "signal", "SIGSEGV", "invalid", "address", "fault", "address", "NUMBER", "x", "NUMBER", "in", "source", "file", "alloc", "NUMBER", "c", "line", "NUMBER", "thread_find_room", "tc", "type_typed_object", "d", "p", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "A", "DEBUG", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "A", "DEBUG", "Build", "fingerprint", "Xiaomi", "sagit", "sagit", "NUMBER", "OPR", "NUMBER", "V", "NUMBER", "OCACNFA", "user", "release", "keys", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "A", "DEBUG", "Revision", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "A", "DEBUG", "ABI", "arm", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "A", "DEBUG", "pid", "NUMBER", "tid", "NUMBER", "name", "Thread", "NUMBER", "org", "NUMBER", "evilbinary", "NUMBER", "chez", "TAG", "NUMBER", "mo", "Error", "in", "mat", "locate", "source", "caching", "clause", "NUMBER", "source", "cache", "test", "loading", "lots", "of", "let", "values", "form", "seems", "to", "take", "too", "long", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "System", "Info", "Linux", "Mint", "NUMBER", "ubuntu", "NUMBER", "base", "gcc", "NUMBER", "Thanks", "for", "quick", "reply", "Forget", "mention", "I", "be", "use", "v", "NUMBER", "release", "rather", "than", "master", "branch", "NUMBER", "I", "just", "tried", "master", "branch", "which", "can", "pass", "all", "test", "NUMBER", "were", "reversed", "in", "csug", "flipped", "to", "be", "correct", "NUMBER", "define", "syntax", "json", "reduce", "lambda", "x", "syntax", "case", "x", "_", "j", "v", "NUMBER", "p", "reduce", "j", "v", "NUMBER", "p", "_", "j", "v", "NUMBER", "v", "NUMBER", "p", "json", "reduce", "j", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "_", "j", "v", "NUMBER", "v", "NUMBER", "v", "NUMBER", "p", "NUMBER", "json", "reduce", "j", "v", "NUMBER", "v", "NUMBER", "lambda", "x", "y", "json", "reduce", "y", "v", "NUMBER", "lambda", "n", "m", "p", "cons", "n", "x", "m", "NUMBER", "reduce", "accept", "NUMBER", "args", "a", "list", "or", "vector", "a", "t", "and", "a", "procedure", "need", "two", "args", "NUMBER", "there", "be", "the", "problem", "json", "reduce", "y", "t", "lambda", "x", "y", "x", "be", "ok", "json", "reduce", "y", "t", "t", "lambda", "x", "y", "x", "be", "ok", "json", "reduce", "y", "t", "t", "t", "lambda", "x", "y", "x", "be", "ok", "but", "json", "reduce", "y", "t", "t", "t", "t", "lambda", "x", "y", "x", "Exception", "incorrect", "number", "of", "argument", "to", "TAG", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "code", "origin", "of", "reduce", "LINK", "for", "define", "the", "y", "LINK", "akeep", "don", "t", "use", "the", "macro", "json", "reduce", "of", "the", "file", "json", "NUMBER", "sc", "use", "the", "code", "json", "reduce", "which", "I", "post", "in", "here", "NUMBER", "the", "code", "json", "reduce", "in", "the", "file", "json", "NUMBER", "sc", "isn", "t", "record", "all", "the", "key", "that", "the", "filter", "pass", "NUMBER", "It", "s", "a", "semi", "finished", "product", "that", "I", "didn", "t", "complete", "the", "design", "goal", "akeep", "thx", "a", "lot", "I", "get", "much", "from", "it", "as", "a", "newbie", "of", "scheme", "I", "don", "t", "know", "how", "to", "use", "debug", "expand", "and", "trace", "define", "syntax", "NUMBER", "even", "i", "don", "t", "find", "the", "define", "of", "NUMBER", "NUMBER", "I", "try", "to", "move", "it", "after", "one", "night", "and", "one", "day", "of", "trying", "I", "put", "the", "problem", "here", "and", "I", "get", "more", "than", "I", "expect", "NUMBER", "When", "I", "use", "Chezscheme", "to", "run", "a", "scheme", "file", "whose", "absolute", "path", "contain", "utf", "NUMBER", "encoding", "in", "sublime_text", "Chez", "will", "report", "an", "error", "Exception", "in", "load", "the_file_absolute_path", "no", "such", "file", "or", "directory", "But", "if", "I", "run", "the", "file", "with", "Chez", "in", "a", "terminal", "with", "a", "relative", "path", "it", "well", "do", "NUMBER", "Please", "tell", "me", "whether", "Chez", "doesn", "t", "support", "a", "utf", "NUMBER", "encoding", "directory", "or", "I", "didn", "t", "set", "it", "well", "to", "work", "You", "be", "correct", "NUMBER", "Chez", "Scheme", "currently", "handles", "only", "ASCII", "encoded", "paths", "as", "command", "line", "argument", "NUMBER", "See", "Issue", "LINK", "for", "details", "NUMBER", "I", "plan", "to", "fix", "this", "NUMBER", "Thanks", "Thanks", "I", "test", "it", "on", "linux", "it", "worked", "well", "NUMBER", "Can", "any", "boy", "integrate", "the", "GMP", "Bignum", "Library", "into", "ChezScheme", "I", "find", "that", "ChezScheme", "be", "so", "fast", "in", "simple", "addition", "and", "subtraction", "almost", "fast", "as", "C", "but", "too", "slow", "in", "bignum", "s", "operation", "What", "about", "use", "bsdnt", "LINK", "or", "LibBF", "LINK", "akeep", "Thank", "you", "very", "much", "I", "be", "so", "foolish", "I", "be", "learning", "SICP", "book", "recently", "when", "i", "try", "to", "compute", "fib", "function", "ChezScheme", "took", "about", "NUMBER", "sec", "for", "n", "NUMBER", "NUMBER", "and", "more", "than", "NUMBER", "sec", "for", "n", "NUMBER", "NUMBER", "NUMBER", "be", "slower", "than", "mit", "scheme", "NUMBER", "I", "tried", "to", "use", "python", "NUMBER", "for", "the", "same", "algorithm", "it", "takes", "about", "NUMBER", "sec", "for", "n", "NUMBER", "NUMBER", "NUMBER", "I", "also", "tried", "to", "use", "GMP", "Library", "to", "compute", "fib", "function", "it", "takes", "about", "NUMBER", "sec", "for", "n", "NUMBER", "NUMBER", "NUMBER", "I", "was", "use", "Chez", "to", "compute", "the", "sum", "of", "NUMBER", "n", "find", "it", "be", "so", "fast", "even", "faster", "than", "use", "C", "language", "NUMBER", "So", "I", "think", "Chez", "be", "really", "very", "fast", "but", "could", "be", "improved", "at", "bignum", "s", "computation", "NUMBER", "I", "just", "think", "Chez", "be", "limited", "at", "bignum", "s", "computation", "no", "other", "meanings", "NUMBER", "maybe", "I", "should", "learn", "more", "about", "git", "github", "and", "variant", "Open", "Source", "Licenses", "and", "improve", "English", "before", "come", "here", "to", "ask", "question", "LINK", "NUMBER", "numeric", "h", "NUMBER", "says", "The", "Revised", "TAG", "NUMBER", "TAG", "Report", "distinguishes", "two", "types", "of", "special", "numeric", "objects", "fixnums", "and", "flonums", "NUMBER", "TAG", "Chez", "nbsp", "Scheme", "TAG", "additionally", "distinguishes", "TAG", "bignums", "TAG", "exact", "integers", "outside", "of", "the", "bignum", "range", "and", "TAG", "ratnums", "TAG", "ratios", "of", "exact", "integers", "NUMBER", "Bignums", "be", "outside", "the", "fixnum", "range", "not", "outside", "the", "bignum", "range", "NUMBER", "I", "believe", "LINK", "and", "so", "on", "be", "the", "source", "of", "csug", "maybe", "if", "you", "add", "a", "pull", "request", "that", "might", "be", "easier", "to", "merge", "LINK", "NUMBER", "use", "h", "NUMBER", "says", "TAG", "For", "example", "assuming", "that", "TAG", "yin", "TAG", "and", "TAG", "yang", "TAG", "have", "not", "be", "defined", "TAG", "TAG", "TAG", "define", "nbsp", "yin", "nbsp", "lambda", "nbsp", "nbsp", "nbsp", "yang", "nbsp", "NUMBER", "TAG", "TAG", "defines", "TAG", "yin", "TAG", "at", "top", "level", "as", "a", "variable", "to", "a", "procedure", "that", "calls", "the", "value", "of", "the", "top", "level", "variable", "TAG", "yang", "TAG", "even", "though", "TAG", "yang", "TAG", "has", "not", "yet", "be", "defined", "NUMBER", "TAG", "Probably", "a", "variable", "to", "a", "procedure", "should", "be", "a", "variable", "bound", "to", "a", "procedure", "NUMBER", "LINK", "NUMBER", "objects", "h", "NUMBER", "says", "bytevector", "copy", "overwrites", "the", "_n_", "bytes", "of", "_dst_", "starting", "at", "_dst", "start_", "with", "the", "_n_", "bytes", "of", "_dst_", "starting", "at", "_src", "start_", "NUMBER", "The", "second", "_dst_", "should", "be", "_src_", "instead", "NUMBER", "LINK", "NUMBER", "objects", "h", "NUMBER", "says", "_Fixnums_", "represent", "exact", "integers", "in", "the", "fixnum", "range", "which", "be", "required", "to", "be", "a", "close", "range", "NUMBER", "TAG", "_w_", "NUMBER", "TAG", "NUMBER", "TAG", "_w_", "NUMBER", "TAG", "NUMBER", "where", "_w_", "the", "_fixnum", "width_", "be", "at", "least", "NUMBER", "The", "right", "endpoint", "of", "the", "range", "should", "be", "NUMBER", "TAG", "_w_", "NUMBER", "TAG", "NUMBER", "not", "NUMBER", "TAG", "_w_", "NUMBER", "TAG", "NUMBER", "LINK", "NUMBER", "objects", "h", "NUMBER", "says", "A", "mantissa", "width", "TAG", "TAG", "w", "TAG", "TAG", "may", "appear", "as", "the", "suffix", "of", "a", "real", "number", "or", "the", "real", "components", "of", "a", "complex", "number", "write", "in", "floating", "point", "or", "scientific", "notation", "NUMBER", "The", "mantissa", "width", "TAG", "TAG", "m", "TAG", "TAG", "represents", "the", "number", "of", "significant", "bits", "in", "the", "representation", "of", "the", "number", "NUMBER", "TAG", "TAG", "m", "TAG", "TAG", "should", "be", "TAG", "TAG", "w", "TAG", "TAG", "NUMBER", "Or", "vice", "versa", "NUMBER", "Are", "the", "sources", "of", "TSPL", "online", "anywhere", "like", "csug", "be", "That", "might", "make", "actual", "PRs", "easier", "NUMBER", "LINK", "NUMBER", "objects", "s", "NUMBER", "says", "If", "TAG", "TAG", "exint", "TAG", "NUMBER", "TAG", "TAG", "TAG", "be", "negative", "TAG", "bitwise", "arithmetic", "shift", "TAG", "returns", "the", "result", "of", "arithmetically", "shifting", "TAG", "TAG", "exint", "TAG", "NUMBER", "TAG", "TAG", "TAG", "right", "by", "TAG", "TAG", "exint", "TAG", "NUMBER", "TAG", "TAG", "TAG", "bits", "NUMBER", "The", "last", "TAG", "TAG", "exint", "TAG", "NUMBER", "TAG", "TAG", "TAG", "should", "be", "TAG", "TAG", "exint", "TAG", "NUMBER", "TAG", "TAG", "TAG", "NUMBER", "LINK", "NUMBER", "objects", "s", "NUMBER", "For", "both", "bytevector", "uint", "list", "and", "bytevector", "sint", "list", "in", "the", "description", "of", "the", "return", "value", "_", "size", "_", "bit", "should", "be", "_", "size", "_", "byte", "NUMBER", "LINK", "NUMBER", "objects", "s", "NUMBER", "says", "TAG", "TAG", "start", "TAG", "TAG", "and", "TAG", "TAG", "end", "TAG", "TAG", "must", "be", "exact", "nonnegative", "integers", "TAG", "TAG", "start", "TAG", "TAG", "must", "be", "less", "than", "the", "length", "of", "TAG", "TAG", "string", "TAG", "TAG", "while", "TAG", "TAG", "end", "TAG", "TAG", "may", "be", "less", "than", "or", "equal", "to", "the", "length", "of", "TAG", "TAG", "string", "TAG", "TAG", "NUMBER", "If", "TAG", "TAG", "end", "TAG", "TAG", "nbsp", "le", "nbsp", "TAG", "TAG", "start", "TAG", "TAG", "a", "string", "of", "length", "zero", "be", "returned", "NUMBER", "But", "R", "NUMBER", "RS", "allows", "TAG", "TAG", "start", "TAG", "TAG", "to", "be", "equal", "to", "the", "length", "of", "TAG", "TAG", "string", "TAG", "TAG", "and", "do", "not", "allow", "it", "to", "be", "greater", "than", "TAG", "TAG", "end", "TAG", "TAG", "NUMBER", "The", "actual", "behavior", "of", "Chez", "Scheme", "follows", "R", "NUMBER", "RS", "and", "not", "TSPL", "NUMBER", "The", "last", "example", "at", "LINK", "NUMBER", "objects", "s", "NUMBER", "be", "TAG", "string", "ci", "nbsp", "Stra", "sse", "nbsp", "Strasse", "TAG", "I", "guess", "it", "should", "be", "TAG", "string", "ci", "nbsp", "Stra\u00dfe", "nbsp", "Strasse", "TAG", "LINK", "NUMBER", "io", "s", "NUMBER", "says", "The", "buffer", "mode", "TAG", "TAG", "b", "mode", "TAG", "TAG", "defaults", "to", "TAG", "block", "TAG", "which", "differs", "from", "TAG", "block", "TAG", "in", "TAG", "Chez", "nbsp", "Scheme", "TAG", "only", "for", "textual", "output", "ports", "NUMBER", "See", "the", "lead", "in", "to", "Section", "nbsp", "TAG", "NUMBER", "TAG", "of", "TAG", "The", "Scheme", "Programming", "Language", "NUMBER", "Edition", "TAG", "for", "a", "description", "of", "the", "constraints", "on", "and", "effect", "of", "the", "other", "argument", "NUMBER", "The", "Revised", "TAG", "NUMBER", "TAG", "Report", "version", "of", "this", "procedure", "do", "not", "accept", "the", "optional", "TAG", "TAG", "b", "mode", "TAG", "TAG", "and", "TAG", "TAG", "transcoder", "TAG", "TAG", "argument", "which", "limits", "it", "to", "an", "implementation", "dependent", "buffering", "mode", "TAG", "block", "TAG", "in", "TAG", "Chez", "nbsp", "Scheme", "TAG", "and", "binary", "output", "NUMBER", "NUMBER", "TAG", "block", "TAG", "differs", "from", "TAG", "block", "TAG", "NUMBER", "We", "re", "describing", "TAG", "standard", "input", "port", "TAG", "here", "so", "why", "talk", "about", "textual", "output", "ports", "or", "binary", "output", "NUMBER", "There", "be", "no", "other", "argument", "NUMBER", "LINK", "NUMBER", "libraries", "h", "NUMBER", "says", "If", "code", "be", "intended", "for", "use", "with", "systems", "that", "do", "not", "automatically", "determine", "when", "a", "library", "s", "bindings", "must", "be", "made", "available", "however", "the", "TAG", "for", "TAG", "must", "be", "use", "if", "the", "importing", "library", "s", "bindings", "would", "not", "otherwise", "be", "available", "at", "the", "right", "time", "NUMBER", "I", "m", "not", "sure", "but", "I", "think", "importing", "should", "be", "imported", "NUMBER", "LINK", "NUMBER", "libraries", "h", "NUMBER", "says", "Similarly", "a", "TAG", "lt", "TAG", "TAG", "TAG", "subversion", "reference", "TAG", "TAG", "matches", "a", "TAG", "TAG", "version", "TAG", "TAG", "s", "TAG", "TAG", "subversion", "TAG", "TAG", "if", "the", "TAG", "TAG", "version", "TAG", "TAG", "s", "TAG", "TAG", "subversion", "TAG", "TAG", "be", "less", "than", "or", "equal", "to", "the", "TAG", "TAG", "subversion", "TAG", "TAG", "appearing", "within", "the", "TAG", "gt", "TAG", "form", "NUMBER", "the", "TAG", "gt", "TAG", "form", "should", "be", "the", "TAG", "lt", "TAG", "form", "NUMBER", "LINK", "NUMBER", "libraries", "h", "NUMBER", "says", "The", "syntactic", "extension", "TAG", "set", "TAG", "expands", "into", "a", "reference", "to", "the", "variable", "TAG", "list", "gt", "set", "TAG", "and", "TAG", "member", "TAG", "similarly", "expands", "into", "a", "reference", "to", "the", "variable", "TAG", "member", "TAG", "NUMBER", "While", "TAG", "list", "gt", "set", "TAG", "be", "explicitly", "export", "TAG", "member", "TAG", "be", "not", "NUMBER", "This", "makes", "TAG", "member", "TAG", "an", "indirect", "export", "NUMBER", "There", "be", "no", "variable", "call", "TAG", "member", "TAG", "NUMBER", "Apparently", "it", "was", "change", "to", "TAG", "member", "help", "TAG", "NUMBER", "I", "m", "having", "a", "bit", "of", "trouble", "wrapping", "C", "function", "like", "recv", "and", "send", "which", "can", "block", "for", "arbitrarily", "long", "times", "NUMBER", "I", "m", "trying", "to", "wrap", "them", "use", "only", "Scheme", "code", "and", "the", "FFI", "no", "C", "code", "NUMBER", "I", "ve", "be", "successful", "in", "non", "threaded", "build", "or", "threaded", "build", "with", "only", "a", "single", "thread", "but", "I", "m", "seeing", "strange", "blocking", "behaviour", "of", "other", "threads", "in", "threaded", "build", "NUMBER", "I", "have", "code", "similar", "to", "lock", "object", "buffer", "foreign", "procedure", "recv", "NUMBER", "buffer", "NUMBER", "unlock", "object", "buffer", "From", "reading", "csug", "I", "think", "I", "might", "have", "to", "call", "Sactivate_thread", "and", "Sdeactivate_thread", "somewhere", "here", "but", "can", "I", "even", "do", "that", "from", "inside", "Scheme", "I", "want", "to", "avoid", "build", "and", "link", "C", "code", "at", "all", "costs", "NUMBER", "Thanks", "for", "any", "assistance", "with", "this", "or", "clarifications", "on", "what", "I", "m", "doing", "wrong", "You", "could", "do", "this", "LINK", "lib", "blob", "master", "package", "cffi", "cffi", "NUMBER", "ss", "L", "NUMBER", "wrap", "Sdeactivate_thread", "and", "Sactivate_thread", "NUMBER", "cffi", "be", "a", "usefull", "lib", "to", "call", "c", "with", "thread", "NUMBER", "I", "ll", "close", "this", "it", "should", "be", "solve", "if", "NUMBER", "be", "merge", "NUMBER", "scheme", "define", "request", "lambda", "info", "let", "code", "foreign", "callable", "info", "string", "string", "string", "string", "lock", "object", "code", "foreign", "callable", "entry", "point", "code", "define", "handle_get", "request", "lambda", "request_header", "path_info", "payload", "here_back_the_value_of_respone_to_C_function", "c", "typedef", "char", "res", "char", "request_header", "char", "path_info", "char", "payload", "res", "res_get", "int", "handle_request", "res", "response_get", "res_get", "response_get", "scheme", "handle_request", "req_get", "in", "a", "C", "function", "c", "char", "respone", "res_get", "request_header", "path_info", "query_stirng", "if", "strcpy", "the", "respone", "bash", "Exception", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "I", "can", "t", "do", "any", "thing", "to", "operate", "to", "respone", "or", "get", "its", "value", "NUMBER", "thx", "for", "your", "response", "NUMBER", "akeep", "so", "here", "be", "the", "original", "code", "that", "I", "get", "the", "problem", "NUMBER", "LINK", "line", "NUMBER", "char", "respone", "res_get", "request_header", "path_info", "query_stirng", "when", "I", "use", "strcpy", "to", "respone", "or", "anything", "to", "operate", "it", "NUMBER", "like", "char", "end", "respone", "end", "end", "NUMBER", "the", "programme", "will", "crash", "NUMBER", "akeep", "I", "can", "t", "reproduce", "the", "problem", "maybe", "it", "because", "define", "handle", "request", "foreign", "procedure", "handle_request", "void", "int", "i", "have", "use", "iptr", "instead", "of", "void", "NUMBER", "I", "have", "change", "it", "since", "LINK", "now", "i", "can", "use", "char", "end", "respone", "end", "end", "NUMBER", "but", "the", "strcpy", "isn", "t", "work", "LINK", "NUMBER", "if", "STATIC_PATH", "NUMBER", "NUMBER", "char", "file_path", "respone", "NUMBER", "file_path", "line", "NUMBER", "change", "to", "char", "file_path", "strcpy", "file_path", "respone", "and", "change", "LINK", "line", "NUMBER", "NUMBER", "define", "sendfile", "lambda", "type", "content", "string", "append", "content", "change", "procedure", "to", "define", "sendfile", "lambda", "type", "content", "string", "append", "content", "application", "octet", "stream", "now", "use", "this", "code", "to", "run", "set", "a", "path", "and", "a", "file", "import", "igropyr", "http", "define", "test", "lambda", "request", "header", "path", "info", "query", "string", "sendfile", "NUMBER", "filename", "NUMBER", "postfix", "server", "request", "test", "request", "test", "set", "staticpath", "file", "path", "listen", "NUMBER", "open", "localhost", "NUMBER", "you", "will", "get", "Exception", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "By", "the", "way", "would", "you", "please", "to", "look", "a", "little", "line", "NUMBER", "NUMBER", "LINK", "NUMBER", "static", "void", "after_uv_write", "uv_write_t", "w", "int", "status", "NUMBER", "NUMBER", "if", "w", "data", "NUMBER", "free", "w", "data", "NUMBER", "uv_close", "uv_handle_t", "w", "handle", "after_uv_close_client", "NUMBER", "free", "w", "NUMBER", "if", "I", "free", "the", "memory", "by", "hand", "the", "programme", "will", "crash", "NUMBER", "the", "programme", "run", "good", "if", "I", "don", "t", "free", "it", "NUMBER", "I", "m", "not", "sure", "if", "it", "s", "Chez", "Scheme", "manage", "this", "memory", "or", "here", "will", "cause", "a", "memory", "leak", "NUMBER", "thx", "When", "build", "threaded", "version", "unthreaded", "build", "and", "installs", "normally", "I", "encouter", "this", "error", "needless", "to", "say", "that", "libz", "NUMBER", "a", "be", "present", "cd", "ta", "NUMBER", "le", "make", "install", "cd", "c", "make", "gcc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "D_REENTRANT", "pthread", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "ta", "NUMBER", "le", "I", "NUMBER", "zlib", "scheme", "NUMBER", "c", "cd", "NUMBER", "zlib", "make", "Please", "use", "NUMBER", "configure", "first", "NUMBER", "Thank", "you", "NUMBER", "ld", "melf_x", "NUMBER", "_", "NUMBER", "r", "X", "o", "NUMBER", "boot", "ta", "NUMBER", "le", "kernel", "NUMBER", "o", "statics", "NUMBER", "o", "segment", "NUMBER", "o", "alloc", "NUMBER", "o", "symbol", "NUMBER", "o", "intern", "NUMBER", "o", "gcwrapper", "NUMBER", "o", "gc", "ocd", "NUMBER", "o", "gc", "oce", "NUMBER", "o", "number", "NUMBER", "o", "schsig", "NUMBER", "o", "io", "NUMBER", "o", "new", "io", "NUMBER", "o", "print", "NUMBER", "o", "fasl", "NUMBER", "o", "stats", "NUMBER", "o", "foreign", "NUMBER", "o", "prim", "NUMBER", "o", "prim", "NUMBER", "o", "flushcache", "NUMBER", "o", "schlib", "NUMBER", "o", "thread", "NUMBER", "o", "expeditor", "NUMBER", "o", "scheme", "NUMBER", "o", "i", "NUMBER", "le", "NUMBER", "o", "NUMBER", "zlib", "libz", "NUMBER", "a", "ld", "cannot", "find", "NUMBER", "zlib", "libz", "NUMBER", "a", "No", "such", "file", "or", "directory", "make", "NUMBER", "Makefile", "NUMBER", "NUMBER", "boot", "ta", "NUMBER", "le", "kernel", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "install", "Error", "NUMBER", "LINK", "NUMBER", "foreign", "h", "NUMBER", "in", "exemple", "include", "TAG", "typedef", "void", "CB", "char", "CB", "callbacks", "NUMBER", "void", "cb_init", "void", "int", "i", "for", "i", "NUMBER", "i", "TAG", "list", "NUMBER", "The", "problem", "be", "that", "in", "the", "PR", "of", "cptypes", "NUMBER", "LINK", "uses", "the", "signature", "to", "mark", "p", "as", "a", "procedure", "after", "this", "expression", "assuming", "that", "otherwise", "map", "would", "have", "raise", "an", "error", "NUMBER", "The", "code", "to", "show", "the", "problem", "should", "be", "a", "mix", "of", "some", "reductions", "of", "cp", "NUMBER", "and", "some", "reduction", "of", "cptypes", "define", "f", "p", "b", "unbox", "b", "map", "p", "if", "box", "b", "NUMBER", "NUMBER", "NUMBER", "list", "p", "procedure", "p", "f", "NUMBER", "box", "NUMBER", "NUMBER", "f", "in", "the", "current", "version", "of", "Chez", "Scheme", "error", "in", "Chez", "Schem", "this", "patch", "NUMBER", "t", "in", "Chez", "Scheme", "cptypes", "wrong", "I", "think", "that", "the", "best", "behavior", "be", "to", "raise", "an", "error", "NUMBER", "This", "patch", "remove", "one", "of", "the", "reductions", "in", "cp", "NUMBER", "so", "the", "other", "reduction", "be", "triggered", "and", "an", "error", "be", "raise", "NUMBER", "But", "I", "think", "it", "s", "also", "ok", "to", "not", "raise", "an", "error", "but", "in", "this", "case", "the", "signature", "of", "map", "should", "be", "weaker", "and", "allow", "the", "first", "argument", "to", "be", "any", "pointer", "NUMBER", "The", "patch", "to", "do", "this", "be", "in", "my", "alternative", "branch", "LINK", "massa", "ChezScheme", "commit", "NUMBER", "NUMBER", "Map", "Null", "Alternative", "NUMBER", "But", "I", "think", "that", "the", "result", "list", "p", "procedure", "p", "NUMBER", "t", "be", "wrong", "and", "it", "can", "cause", "further", "problem", "in", "cptypes", "in", "more", "complex", "and", "realistic", "examples", "NUMBER", "Fixed", "NUMBER", "I", "also", "change", "lines", "NUMBER", "LINK", "diff", "b", "NUMBER", "abff", "NUMBER", "de", "NUMBER", "bd", "NUMBER", "f", "NUMBER", "c", "NUMBER", "cc", "NUMBER", "dR", "NUMBER", "and", "NUMBER", "LINK", "diff", "b", "NUMBER", "abff", "NUMBER", "de", "NUMBER", "bd", "NUMBER", "f", "NUMBER", "c", "NUMBER", "cc", "NUMBER", "dR", "NUMBER", "so", "make", "seq", "and", "make", "seq", "get", "the", "right", "value", "NUMBER", "Fixed", "NUMBER", "I", "copied", "the", "long", "example", "about", "the", "reduction", "of", "NUMBER", "map", "in", "a", "o", "NUMBER", "environment", "to", "NUMBER", "for", "each", "but", "I", "also", "add", "the", "small", "examples", "like", "map", "NUMBER", "to", "all", "the", "similar", "constructions", "like", "andmap", "NUMBER", "Threads", "be", "often", "use", "in", "event", "handle", "libraries", "like", "the", "one", "shown", "in", "the", "documentation", "for", "foreign", "callable", "NUMBER", "Prior", "to", "this", "patch", "activating", "and", "deactivating", "a", "thread", "to", "make", "an", "event", "based", "pattern", "thread", "friendly", "required", "glue", "C", "code", "to", "call", "Sdeactivate_thread", "and", "Sactivate_thread", "NUMBER", "This", "patch", "add", "__thread", "as", "a", "convention", "modifier", "for", "foreign", "procedure", "and", "foreign", "callable", "On", "a", "foreign", "procedure", "__thread", "causes", "the", "calling", "thread", "to", "be", "deactivated", "at", "the", "last", "moment", "after", "argument", "to", "the", "procedure", "be", "unpacked", "and", "the", "thread", "be", "re", "activated", "when", "the", "foreign", "procedure", "returns", "NUMBER", "On", "a", "foreign", "callable", "__thread", "causes", "the", "calling", "thread", "to", "be", "activated", "and", "the", "activation", "state", "be", "revert", "when", "the", "callable", "returns", "NUMBER", "Reverted", "has", "no", "effect", "if", "the", "thread", "was", "already", "activated", "but", "revert", "can", "mean", "destroyed", "if", "the", "thread", "had", "not", "be", "registered", "when", "the", "callable", "was", "invoked", "NUMBER", "As", "an", "example", "use", "a", "pair", "of", "__thread", "annotations", "in", "the", "event", "loop", "example", "for", "foreign", "callable", "makes", "the", "example", "play", "nicely", "with", "threads", "instead", "of", "cause", "threads", "to", "block", "when", "they", "try", "to", "GC", "NUMBER", "A", "__thread", "annotation", "on", "a", "callable", "can", "also", "make", "the", "callable", "work", "when", "invoked", "by", "an", "unspecified", "thread", "instead", "of", "requiring", "that", "that", "the", "thread", "be", "first", "activated", "NUMBER", "This", "patch", "build", "on", "NUMBER", "The", "change", "could", "stand", "alone", "but", "since", "the", "modifications", "overlap", "and", "since", "Racket", "needs", "both", "patches", "it", "seems", "easiest", "to", "combine", "the", "change", "and", "it", "may", "make", "sense", "to", "review", "them", "together", "NUMBER", "Nice", "feature", "EDIT", "has", "this", "be", "merge", "into", "the", "struct", "PR", "be", "this", "obsolete", "I", "get", "compile", "error", "NUMBER", "Do", "I", "need", "to", "also", "apply", "the", "ftype", "patches", "before", "compile", "gcc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "D_REENTRANT", "pthread", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "ta", "NUMBER", "le", "I", "NUMBER", "zlib", "foreign", "NUMBER", "c", "gcc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "D_REENTRANT", "pthread", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "ta", "NUMBER", "le", "I", "NUMBER", "zlib", "prim", "NUMBER", "c", "prim", "NUMBER", "c", "In", "function", "create_c_entry_vector", "prim", "NUMBER", "c", "NUMBER", "NUMBER", "error", "CENTRY_activate_thread", "undeclared", "first", "use", "in", "this", "function", "did", "you", "mean", "S_activate_thread", "install_c_entry", "CENTRY_activate_thread", "proc", "NUMBER", "ptr", "S_activate_thread", "S_activate_thread", "prim", "NUMBER", "c", "NUMBER", "NUMBER", "note", "each", "undeclared", "identifier", "be", "report", "only", "once", "for", "each", "function", "it", "appears", "in", "prim", "NUMBER", "c", "NUMBER", "NUMBER", "error", "CENTRY_deactivate_thread", "undeclared", "first", "use", "in", "this", "function", "did", "you", "mean", "CENTRY_activate_thread", "install_c_entry", "CENTRY_deactivate_thread", "proc", "NUMBER", "ptr", "Sdeactivate_thread", "CENTRY_activate_thread", "prim", "NUMBER", "c", "NUMBER", "NUMBER", "error", "CENTRY_unactivate_thread", "undeclared", "first", "use", "in", "this", "function", "did", "you", "mean", "CENTRY_deactivate_thread", "install_c_entry", "CENTRY_unactivate_thread", "proc", "NUMBER", "ptr", "S_unactivate_thread", "CENTRY_deactivate_thread", "make", "NUMBER", "Makefile", "NUMBER", "prim", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "build", "Error", "NUMBER", "gcc", "version", "gcc", "GCC", "NUMBER", "NUMBER", "Copyright", "C", "NUMBER", "Free", "Software", "Foundation", "Inc", "NUMBER", "This", "be", "free", "software", "see", "the", "source", "for", "copying", "conditions", "NUMBER", "There", "be", "NO", "warranty", "not", "even", "for", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "NUMBER", "ecraven", "The", "problem", "be", "that", "the", "boot", "file", "aren", "t", "update", "where", "boot", "file", "include", "headers", "that", "have", "change", "and", "be", "needed", "to", "compile", "the", "C", "part", "NUMBER", "So", "you", "need", "to", "cross", "compile", "to", "try", "it", "out", "NUMBER", "To", "build", "for", "a", "platform", "M", "e", "NUMBER", "g", "NUMBER", "ta", "NUMBER", "osx", "if", "you", "have", "an", "exist", "build", "for", "platform", "M", "in", "ORIG", "then", "cross", "compile", "with", "NUMBER", "configure", "cd", "M", "s", "make", "f", "Mf", "cross", "m", "M", "xm", "M", "base", "ORIG", "M", "cd", "M", "c", "make", "cd", "M", "s", "make", "allx", "Rebased", "but", "the", "cross", "compile", "steps", "be", "still", "needed", "to", "build", "NUMBER", "For", "NUMBER", "bit", "Windows", "I", "assume", "__thread", "uses", "the", "__cdecl", "calling", "convention", "Is", "there", "any", "convenient", "way", "to", "be", "able", "to", "specify", "both", "__thread", "and", "__stdcall", "or", "__com", "I", "m", "not", "write", "new", "code", "against", "NUMBER", "bit", "Windows", "any", "more", "so", "this", "be", "not", "important", "to", "me", "but", "I", "ask", "in", "order", "to", "make", "you", "aware", "of", "the", "issue", "NUMBER", "burgerrg", "Yes", "the", "patch", "generalizes", "the", "syntax", "of", "foreign", "prcedure", "etc", "NUMBER", "to", "accept", "multiple", "conventions", "although", "__thread", "be", "the", "only", "one", "that", "be", "allow", "in", "combination", "with", "any", "other", "NUMBER", "Thanks", "that", "leaves", "a", "good", "way", "to", "support", "__thread", "with", "the", "other", "conventions", "if", "the", "need", "arises", "NUMBER", "burgerrg", "I", "start", "to", "reply", "I", "mean", "that", "__thread", "already", "works", "with", "__stdcall", "and", "__com", "but", "then", "I", "realized", "that", "I", "forgot", "to", "add", "test", "NUMBER", "So", "of", "course", "it", "didn", "t", "work", "for", "all", "combinations", "NUMBER", "I", "ve", "add", "test", "and", "repairs", "so", "that", "__thread", "works", "with", "__stdcall", "and", "__com", "NUMBER", "Great", "thanks", "I", "ve", "test", "this", "with", "run", "my", "SLIME", "swank", "and", "a", "web", "server", "in", "parallel", "and", "it", "seems", "to", "solve", "the", "problem", "I", "had", "very", "well", "Is", "there", "any", "way", "I", "can", "help", "with", "get", "this", "merge", "dybvig", "be", "you", "planning", "to", "review", "this", "pull", "request", "I", "haven", "t", "looked", "at", "it", "in", "detail", "because", "I", "know", "you", "ve", "recently", "inspected", "change", "relate", "to", "the", "foreign", "procedure", "interface", "and", "may", "already", "be", "planning", "to", "review", "it", "NUMBER", "Hey", "burgerrg", "dybvig", "and", "I", "talked", "a", "bit", "about", "it", "last", "week", "and", "I", "volunteered", "to", "pick", "this", "up", "but", "I", "ve", "not", "had", "time", "to", "review", "the", "code", "in", "any", "level", "of", "detail", "and", "I", "probably", "won", "t", "have", "a", "chance", "until", "next", "weekend", "NUMBER", "One", "of", "the", "concerns", "we", "had", "about", "this", "be", "that", "any", "Scheme", "object", "pass", "as", "an", "argument", "to", "this", "function", "would", "need", "to", "be", "locked", "before", "the", "thread", "be", "deactivated", "otherwise", "there", "be", "a", "chance", "that", "the", "collector", "might", "start", "between", "when", "the", "thread", "deactivation", "occur", "and", "the", "argument", "be", "pass", "to", "the", "underlying", "C", "function", "NUMBER", "A", "foreign", "procedure", "marked", "with", "__thread", "would", "need", "to", "be", "at", "least", "somewhat", "responsible", "for", "this", "because", "in", "some", "cases", "like", "string", "argument", "which", "be", "copied", "to", "a", "bytevector", "and", "the", "pointer", "into", "the", "bytevector", "data", "be", "pass", "to", "the", "underlying", "function", "the", "programmer", "never", "actually", "has", "their", "hands", "on", "the", "object", "to", "lock", "NUMBER", "We", "also", "discussed", "a", "little", "bit", "having", "a", "different", "name", "for", "this", "which", "be", "a", "little", "more", "descriptive", "NUMBER", "Something", "like", "__thread_safe", "or", "__collector_safe", "since", "the", "property", "we", "be", "trying", "to", "express", "be", "that", "it", "be", "safe", "for", "the", "collector", "to", "run", "while", "the", "underlying", "C", "call", "be", "blocking", "NUMBER", "This", "do", "sound", "dangerous", "NUMBER", "What", "would", "you", "think", "if", "it", "locked", "all", "Scheme", "objects", "before", "deactivating", "and", "unlocked", "them", "after", "re", "activating", "That", "s", "what", "my", "custom", "C", "code", "do", "in", "Swish", "NUMBER", "Isn", "t", "this", "only", "relevant", "for", "strings", "I", "m", "passing", "bytevectors", "to", "recv", "and", "send", "which", "I", "lock", "myself", "so", "that", "isn", "t", "so", "bad", "NUMBER", "Are", "there", "any", "other", "datatypes", "except", "for", "strings", "that", "get", "copied", "internally", "Locking", "all", "objects", "seems", "excessive", "as", "the", "FFI", "call", "could", "potentially", "block", "for", "a", "very", "long", "time", "resulting", "in", "nothing", "be", "collected", "right", "ecraven", "Yes", "I", "think", "the", "automatic", "object", "creation", "copying", "be", "only", "for", "strings", "so", "if", "you", "have", "non", "string", "argument", "and", "you", "be", "locking", "them", "already", "you", "should", "be", "good", "to", "go", "NUMBER", "The", "procedure", "code", "for", "the", "scheme", "wrapper", "be", "also", "created", "but", "I", "think", "that", "should", "already", "be", "automatically", "locked", "before", "the", "C", "call", "NUMBER", "I", "d", "have", "to", "double", "check", "to", "be", "sure", "NUMBER", "burgerrg", "Yes", "dybvig", "and", "I", "talked", "about", "having", "it", "auto", "lock", "unlock", "NUMBER", "I", "think", "where", "we", "landed", "on", "this", "was", "that", "it", "might", "be", "nice", "to", "lock", "unlock", "automatically", "but", "provide", "a", "syntax", "for", "specify", "that", "an", "argument", "be", "already", "locked", "though", "now", "that", "I", "think", "about", "it", "you", "d", "probably", "want", "that", "at", "the", "call", "site", "for", "the", "foreign", "procedure", "and", "we", "were", "thinking", "of", "this", "at", "the", "foreign", "procedure", "definition", "site", "NUMBER", "akeep", "Checking", "whether", "I", "understand", "the", "issue", "with", "strings", "Even", "before", "this", "PR", "that", "can", "be", "an", "issue", "with", "a", "foreign", "function", "that", "invokes", "a", "callbable", "and", "be", "also", "pass", "a", "converted", "string", "which", "it", "might", "access", "after", "the", "callable", "right", "mflatt", "Yes", "if", "the", "C", "function", "holds", "onto", "the", "pointer", "into", "the", "bytevector", "across", "the", "call", "to", "the", "foreign", "callable", "NUMBER", "Wouldn", "t", "it", "suffice", "to", "automatically", "lock", "the", "temporary", "bytevector", "of", "string", "argument", "for", "each", "__thread", "foreign", "procedure", "and", "unlock", "it", "afterwards", "Everything", "else", "would", "stay", "the", "same", "as", "right", "now", "wouldn", "t", "it", "ecraven", "The", "idea", "with", "the", "automatic", "locking", "be", "to", "allow", "programmers", "to", "use", "this", "feature", "without", "needing", "to", "lock", "the", "argument", "themselves", "NUMBER", "So", "you", "wouldn", "t", "need", "to", "lock", "the", "bytevector", "around", "the", "call", "yourself", "you", "could", "just", "let", "the", "foreign", "procedure", "code", "take", "care", "of", "it", "for", "you", "NUMBER", "I", "think", "mflatt", "s", "struct", "parameter", "change", "add", "automatic", "locking", "and", "unlocking", "of", "foreign", "callable", "argument", "for", "the", "same", "reason", "NUMBER", "i", "m", "not", "against", "automatic", "locking", "but", "if", "anyone", "be", "I", "think", "automatic", "locking", "of", "only", "the", "temporary", "string", "bytevectors", "should", "be", "sufficient", "NUMBER", "Personally", "I", "d", "welcome", "automatic", "locking", "of", "all", "relevant", "objects", "NUMBER", "akeep", "FWIW", "there", "was", "no", "new", "argument", "locking", "for", "callables", "only", "some", "new", "locking", "of", "the", "callable", "itself", "since", "a", "return", "address", "to", "the", "callable", "stays", "on", "the", "stack", "more", "than", "it", "use", "to", "NUMBER", "I", "m", "not", "oppose", "to", "extra", "automatic", "locking", "but", "given", "that", "the", "rule", "be", "already", "don", "t", "do", "that", "when", "a", "foreign", "procedure", "might", "invoke", "a", "callable", "don", "t", "do", "that", "seems", "equally", "workable", "with", "__thread", "or", "its", "replacement", "NUMBER", "That", "be", "string", "types", "could", "be", "considered", "conveniences", "that", "only", "work", "in", "simple", "cases", "and", "use", "__thread", "creates", "obligations", "for", "a", "caller", "in", "the", "same", "way", "as", "use", "callables", "do", "NUMBER", "Whereas", "C", "code", "call", "without", "__thread", "can", "safely", "use", "unlocked", "Scheme", "objects", "C", "code", "with", "the", "__thread", "calling", "convention", "cannot", "safely", "use", "an", "unlocked", "Scheme", "object", "NUMBER", "Consequently", "it", "seems", "appropriate", "that", "the", "system", "handles", "the", "locking", "and", "unlocking", "automatically", "of", "all", "argument", "types", "that", "need", "to", "be", "locked", "NUMBER", "If", "a", "particular", "application", "cannot", "tolerate", "the", "overhead", "it", "can", "use", "uptr", "and", "object", "address", "to", "pass", "the", "address", "of", "a", "locked", "Scheme", "object", "to", "the", "C", "code", "NUMBER", "In", "case", "it", "helps", "I", "ve", "add", "a", "commit", "to", "change", "__thread", "to", "__collect_safe", "and", "to", "report", "an", "error", "if", "a", "string", "type", "be", "misused", "with", "__collect_safe", "as", "an", "argument", "for", "foreign", "procedures", "or", "result", "for", "foreign", "callables", "NUMBER", "I", "could", "squash", "the", "commit", "if", "that", "s", "helpful", "NUMBER", "I", "didn", "t", "muster", "enough", "interest", "in", "automatic", "locking", "to", "try", "that", "direction", "myself", "so", "__collect_safe", "as", "implement", "be", "an", "assertion", "of", "safety", "not", "a", "request", "to", "make", "the", "call", "safe", "NUMBER", "Thanks", "I", "like", "the", "name", "change", "and", "disallowing", "string", "types", "NUMBER", "Not", "having", "automatic", "locking", "unlocking", "be", "fine", "with", "me", "NUMBER", "Thank", "you", "for", "proposing", "this", "important", "feature", "addition", "NUMBER", "With", "it", "I", "ll", "be", "able", "to", "avoid", "wrapper", "code", "when", "make", "blocking", "calls", "that", "be", "collector", "safe", "NUMBER", "akeep", "Thanks", "for", "the", "feedback", "NUMBER", "It", "will", "be", "a", "week", "or", "two", "before", "I", "can", "work", "on", "this", "more", "NUMBER", "Could", "you", "send", "post", "your", "change", "to", "use", "conv", "NUMBER", "instead", "of", "make", "conv", "mean", "a", "sequence", "It", "seem", "tedious", "when", "I", "tried", "that", "originally", "but", "maybe", "I", "didn", "t", "pick", "the", "right", "approach", "NUMBER", "akeep", "Thanks", "for", "the", "conv", "conversion", "NUMBER", "I", "ve", "add", "your", "commit", "here", "and", "further", "adjusted", "some", "conv", "names", "to", "conv", "NUMBER", "For", "the", "error", "when", "use", "a", "string", "type", "with", "__collect_safe", "report", "the", "original", "type", "name", "would", "mean", "add", "to", "the", "function", "RTD", "and", "more", "which", "seems", "heavyweight", "for", "an", "error", "that", "will", "be", "rarely", "seen", "NUMBER", "I", "made", "the", "error", "message", "slightly", "more", "generic", "by", "always", "use", "string", "instead", "of", "naming", "a", "specific", "type", "NUMBER", "Meanwhile", "report", "be", "now", "consistent", "from", "a", "non", "threaded", "build", "NUMBER", "Finally", "I", "update", "the", "docs", "as", "you", "suggested", "NUMBER", "Thanks", "to", "everyone", "concerned", "for", "the", "hard", "work", "great", "that", "this", "was", "merge", "The", "most", "nearly", "stuff", "I", "ve", "find", "be", "LINK", "NUMBER", "foreign", "h", "NUMBER", "However", "for", "what", "reason", "chez", "itself", "do", "not", "support", "procedure", "on", "network", "programming", "OK", "so", "I", "could", "either", "write", "it", "by", "myself", "or", "use", "an", "exist", "lib", "NUMBER", "Thank", "you", "NUMBER", "I", "feel", "good", "with", "such", "philosophy", "NUMBER", "Chez", "scheme", "be", "a", "real", "pleasure", "to", "use", "I", "m", "especially", "fond", "of", "the", "expression", "editor", "on", "the", "command", "line", "for", "some", "interactive", "code", "NUMBER", "But", "I", "have", "one", "question", "I", "understand", "that", "chez", "be", "know", "for", "be", "quite", "efficient", "why", "do", "it", "take", "so", "long", "to", "start", "up", "echo", "exit", "time", "chez", "q", "chez", "q", "NUMBER", "s", "user", "NUMBER", "s", "system", "NUMBER", "cpu", "NUMBER", "total", "time", "ruby", "e", "exit", "ruby", "e", "exit", "NUMBER", "s", "user", "NUMBER", "s", "system", "NUMBER", "cpu", "NUMBER", "total", "time", "python", "NUMBER", "c", "exit", "python", "NUMBER", "c", "exit", "NUMBER", "s", "user", "NUMBER", "s", "system", "NUMBER", "cpu", "NUMBER", "total", "Is", "this", "possibly", "a", "bug", "You", "be", "comparing", "the", "python", "and", "ruby", "interpreter", "with", "the", "chez", "scheme", "compiler", "NUMBER", "Interpreters", "have", "generally", "a", "faster", "startup", "time", "NUMBER", "Try", "it", "with", "the", "chez", "scheme", "interpreter", "time", "petite", "q", "NUMBER", "I", "was", "playing", "around", "with", "this", "and", "it", "seems", "like", "the", "majority", "of", "the", "startup", "time", "be", "spent", "inflating", "the", "boot", "file", "NUMBER", "I", "add", "some", "logging", "around", "parts", "of", "the", "load", "process", "and", "use", "already", "inflated", "boot", "file", "I", "reduced", "the", "load", "time", "a", "fair", "bit", "gmw", "ash", "home", "gmw", "software", "ChezScheme", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "ta", "NUMBER", "le", "bin", "scheme", "q", "b", "NUMBER", "ta", "NUMBER", "le", "boot", "ta", "NUMBER", "le", "petite", "NUMBER", "boot", "b", "NUMBER", "ta", "NUMBER", "le", "boot", "ta", "NUMBER", "le", "scheme", "NUMBER", "boot", "TAG", "chez", "NUMBER", "boot", "gmw", "ash", "home", "gmw", "software", "ChezScheme", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "ta", "NUMBER", "le", "bin", "scheme", "q", "b", "NUMBER", "chez", "NUMBER", "boot", "TAG", "u", "NUMBER", "The", "argument", "must", "be", "a", "Scheme", "bytevector", "or", "f", "NUMBER", "For", "f", "the", "null", "pointer", "NUMBER", "be", "pass", "to", "the", "foreign", "procedure", "NUMBER", "For", "a", "bytevector", "a", "pointer", "to", "the", "first", "byte", "of", "the", "bytevector", "s", "data", "be", "pass", "NUMBER", "If", "the", "C", "routine", "to", "which", "the", "data", "be", "pass", "requires", "the", "input", "to", "be", "null", "terminated", "a", "null", "NUMBER", "byte", "must", "be", "include", "explicitly", "in", "the", "bytevector", "NUMBER", "The", "bytevector", "should", "not", "be", "retained", "in", "foreign", "variables", "or", "data", "structures", "since", "the", "memory", "management", "system", "may", "relocate", "or", "discard", "them", "between", "foreign", "procedure", "calls", "and", "use", "their", "storage", "for", "some", "other", "purpose", "NUMBER", "Ideally", "I", "d", "like", "to", "not", "have", "to", "write", "C", "code", "that", "would", "mean", "I", "cannot", "deploy", "the", "Scheme", "code", "without", "also", "having", "a", "C", "compiler", "NUMBER", "recv", "and", "send", "be", "standard", "C", "networking", "function", "I", "d", "prefer", "not", "having", "to", "wrap", "them", "just", "for", "some", "pointer", "arithmetic", "NUMBER", "be", "the", "problem", "that", "the", "bytevector", "might", "be", "moved", "around", "by", "the", "GC", "while", "I", "m", "trying", "to", "calculate", "the", "correct", "address", "in", "Scheme", "code", "Yes", "you", "can", "get", "the", "address", "in", "Scheme", "but", "you", "ll", "need", "to", "either", "lock", "the", "bytevector", "before", "get", "its", "address", "or", "enter", "a", "critical", "section", "so", "that", "the", "garbage", "collector", "won", "t", "move", "the", "bytevector", "at", "the", "wrong", "time", "NUMBER", "If", "you", "go", "with", "the", "C", "wrapper", "approach", "you", "would", "compile", "the", "wrapper", "on", "your", "machine", "and", "distribute", "the", "shared", "library", "NUMBER", "The", "target", "machine", "won", "t", "need", "a", "C", "compiler", "NUMBER", "See", "LINK", "for", "an", "example", "of", "a", "wrapper", "and", "C", "code", "that", "locks", "scheme", "objects", "when", "it", "stores", "their", "address", "and", "unlocks", "them", "when", "it", "s", "finished", "NUMBER", "Yes", "you", "can", "get", "the", "address", "in", "Scheme", "but", "you", "ll", "need", "to", "either", "lock", "the", "bytevector", "before", "get", "its", "address", "or", "enter", "a", "critical", "section", "so", "that", "the", "garbage", "collector", "won", "t", "move", "the", "bytevector", "at", "the", "wrong", "time", "NUMBER", "If", "you", "go", "with", "the", "C", "wrapper", "approach", "you", "would", "compile", "the", "wrapper", "on", "your", "machine", "and", "distribute", "the", "shared", "library", "NUMBER", "The", "target", "machine", "won", "t", "need", "a", "C", "compiler", "NUMBER", "See", "LINK", "for", "an", "example", "of", "a", "wrapper", "and", "C", "code", "that", "locks", "scheme", "objects", "when", "it", "stores", "their", "address", "and", "unlocks", "them", "when", "it", "s", "finished", "NUMBER", "Can", "all", "that", "be", "do", "from", "inside", "Scheme", "without", "C", "What", "function", "be", "I", "looking", "for", "to", "lock", "down", "objects", "and", "to", "get", "the", "bytevectors", "address", "Thanks", "for", "any", "help", "with", "this", "lock", "object", "and", "unlock", "object", "be", "describe", "here", "LINK", "NUMBER", "smgmt", "s", "NUMBER", "NUMBER", "To", "get", "the", "address", "you", "ll", "need", "an", "undocumented", "procedure", "object", "address", "and", "knowledge", "of", "how", "bytevectors", "be", "represented", "NUMBER", "The", "code", "below", "disables", "interrupts", "and", "hence", "garbage", "collection", "determines", "the", "address", "of", "bytevector", "bv", "at", "NUMBER", "based", "index", "index", "and", "pass", "it", "to", "f", "NUMBER", "It", "doesn", "t", "do", "type", "or", "bounds", "checking", "NUMBER", "with", "interrupts", "disabled", "f", "object", "address", "bv", "foreign", "sizeof", "ptr", "NUMBER", "index", "The", "C", "wrapper", "option", "be", "support", "without", "the", "use", "of", "undocumented", "system", "procedures", "and", "may", "not", "even", "need", "to", "lock", "the", "bytevector", "so", "I", "recommend", "the", "C", "wrapper", "NUMBER", "burgerrg", "thank", "you", "that", "looks", "exactly", "what", "I", "had", "in", "mind", "akeep", "how", "would", "I", "use", "them", "to", "allocate", "a", "bytevector", "that", "C", "cod", "can", "write", "into", "I", "can", "only", "use", "it", "to", "allocate", "an", "array", "which", "I", "still", "have", "to", "convert", "to", "a", "Scheme", "object", "if", "I", "want", "to", "easily", "access", "it", "right", "Thanks", "for", "clarifying", "this", "burgerrg", "I", "ve", "use", "your", "suggestions", "things", "seem", "to", "work", "fine", "so", "far", "Thanks", "to", "both", "of", "you", "for", "helping", "me", "with", "this", "we", "start", "a", "project", "A", "Package", "Manager", "for", "Chez", "Scheme", "it", "can", "easily", "download", "initial", "the", "Scheme", "library", "and", "automatelly", "compile", "c", "library", "NUMBER", "GitHub", "LINK", "Officiel", "Web", "Site", "LINK", "And", "there", "be", "the", "problem", "if", "the", "current", "project", "depends", "lib", "A", "and", "lib", "B", "and", "lib", "A", "depends", "lib", "C", "NUMBER", "lib", "B", "depends", "lib", "C", "NUMBER", "we", "can", "t", "import", "two", "different", "version", "of", "one", "same", "library", "in", "a", "same", "project", "As", "was", "posted", "LINK", "topic", "chez", "scheme", "X", "NUMBER", "z", "NUMBER", "coCurj", "NUMBER", "in", "the", "chez", "scheme", "google", "group", "less", "than", "a", "week", "ago", "this", "be", "expected", "behavior", "for", "an", "r", "NUMBER", "rs", "compliant", "scheme", "implementation", "NUMBER", "Graham", "Watt", "Dec", "NUMBER", "You", "cannot", "import", "two", "libraries", "with", "different", "version", "into", "the", "same", "runtime", "NUMBER", "See", "this", "for", "info", "LINK", "Z", "H", "NUMBER", "html", "node_idx_", "NUMBER", "The", "relevant", "sentence", "be", "To", "avoid", "problem", "such", "as", "incompatible", "types", "and", "replicated", "state", "implementations", "should", "prohibit", "the", "two", "libraries", "whose", "library", "names", "consist", "of", "the", "same", "sequence", "of", "identifiers", "but", "whose", "version", "do", "not", "match", "to", "co", "exist", "in", "the", "same", "program", "NUMBER", "That", "said", "the", "r", "NUMBER", "rs", "spec", "says", "should", "not", "must", "so", "it", "may", "be", "possible", "to", "come", "up", "with", "some", "semantics", "that", "make", "sense", "and", "allow", "multiple", "version", "of", "a", "library", "to", "coexist", "in", "one", "runtime", "NUMBER", "Seems", "like", "a", "lot", "of", "opportunity", "for", "unexpect", "behavior", "though", "NUMBER", "Perhaps", "one", "of", "the", "maintainers", "will", "chime", "in", "NUMBER", "Make", "even", "inf", "NUMBER", "etc", "NUMBER", "raise", "an", "exception", "NUMBER", "Now", "with", "more", "who", "NUMBER", "Its", "terrific", "that", "Chez", "be", "now", "open", "source", "NUMBER", "I", "m", "psyched", "to", "play", "with", "it", "NUMBER", "I", "wanted", "to", "get", "an", "idea", "of", "how", "fast", "Chez", "be", "say", "compared", "to", "Go", "NUMBER", "I", "write", "up", "a", "little", "matrix", "multiplication", "study", "NUMBER", "The", "results", "be", "here", "LINK", "interpreter", "chezgo", "initial", "simple", "matrix", "mulitply", "benchmark", "where", "I", "see", "Chez", "run", "about", "NUMBER", "x", "slower", "than", "Golang", "NUMBER", "I", "wonder", "if", "there", "be", "anything", "else", "I", "could", "do", "to", "speed", "up", "the", "Chez", "run", "I", "do", "want", "to", "try", "and", "compare", "the", "same", "style", "of", "matrix", "multiply", "namely", "the", "vector", "of", "vectors", "implementation", "but", "be", "there", "other", "flags", "that", "might", "be", "helpful", "to", "the", "Chez", "run", "time", "or", "code", "change", "that", "keep", "the", "same", "similar", "data", "structure", "Perhaps", "there", "s", "a", "way", "to", "only", "use", "floats", "and", "not", "get", "generic", "multiplication", "Specifics", "Go", "code", "LINK", "interpreter", "chezgo", "blob", "master", "cmd", "matmul", "matmul", "NUMBER", "go", "Chez", "code", "LINK", "interpreter", "chezgo", "blob", "master", "matrix", "NUMBER", "ss", "based", "on", "LINK", "Thank", "you", "NUMBER", "Best", "regards", "Jason", "What", "be", "you", "benchmarking", "Multiplication", "of", "floating", "point", "matrix", "multiplication", "Or", "should", "the", "elements", "of", "the", "matrix", "be", "generic", "I", "don", "t", "know", "Go", "so", "I", "can", "t", "compare", "If", "so", "Use", "the", "floating", "point", "operation", "fl", "and", "friends", "instead", "of", "the", "generic", "multiplication", "operator", "NUMBER", "The", "vector", "of", "vector", "representation", "of", "matrices", "imply", "more", "allocations", "than", "a", "single", "vector", "would", "NUMBER", "Before", "run", "the", "timings", "force", "a", "garbage", "collection", "NUMBER", "The", "program", "should", "not", "be", "punished", "for", "any", "garbage", "left", "over", "by", "say", "the", "compilation", "process", "NUMBER", "Finally", "you", "be", "use", "matrix", "set", "in", "mul", "matrix", "set", "change", "the", "jth", "element", "of", "the", "ith", "row", "NUMBER", "define", "matrix", "set", "lambda", "m", "i", "j", "x", "vector", "set", "vector", "ref", "m", "i", "j", "x", "which", "means", "that", "vector", "ref", "m", "i", "be", "call", "multiple", "times", "for", "each", "row", "NUMBER", "Call", "vector", "ref", "m", "i", "once", "for", "each", "row", "in", "mul", "NUMBER", "Jens", "Axel", "S\u00f8gaard", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "GMT", "NUMBER", "NUMBER", "Jason", "E", "NUMBER", "Aten", "Ph", "NUMBER", "D", "NUMBER", "TAG", "I", "wanted", "to", "get", "an", "idea", "of", "how", "fast", "Chez", "be", "say", "compared", "to", "Go", "NUMBER", "I", "write", "up", "a", "little", "matrix", "multiplication", "study", "NUMBER", "The", "results", "be", "here", "LINK", "interpreter", "chezgo", "initial", "simple", "matrix", "mulitply", "benchmark", "where", "I", "see", "Chez", "run", "about", "NUMBER", "x", "slower", "than", "Golang", "NUMBER", "I", "wonder", "if", "there", "be", "anything", "else", "I", "could", "do", "to", "speed", "up", "the", "Chez", "run", "I", "do", "want", "to", "try", "and", "compare", "the", "same", "style", "of", "matrix", "multiply", "namely", "the", "vector", "of", "vectors", "implementation", "but", "be", "there", "other", "flags", "that", "might", "be", "helpful", "to", "the", "Chez", "run", "time", "Specifics", "Go", "code", "LINK", "interpreter", "chezgo", "blob", "master", "cmd", "matmul", "matmul", "NUMBER", "go", "Chez", "code", "LINK", "interpreter", "chezgo", "blob", "master", "matrix", "NUMBER", "ss", "based", "on", "LINK", "Thank", "you", "NUMBER", "Best", "regards", "Jason", "You", "be", "receiving", "this", "because", "you", "be", "subscribed", "to", "this", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "Jens", "Axel", "S\u00f8gaard", "Apropos", "Are", "there", "an", "equivalent", "to", "Racket", "floating", "point", "vectors", "flvector", "somewhere", "in", "Chez", "Jens", "Axel", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "GMT", "NUMBER", "NUMBER", "Jens", "Axel", "S\u00f8gaard", "TAG", "What", "be", "you", "benchmarking", "Multiplication", "of", "floating", "point", "matrix", "multiplication", "Or", "should", "the", "elements", "of", "the", "matrix", "be", "generic", "I", "don", "t", "know", "Go", "so", "I", "can", "t", "compare", "If", "so", "Use", "the", "floating", "point", "operation", "fl", "and", "friends", "instead", "of", "the", "generic", "multiplication", "operator", "NUMBER", "The", "vector", "of", "vector", "representation", "of", "matrices", "imply", "more", "allocations", "than", "a", "single", "vector", "would", "NUMBER", "Before", "run", "the", "timings", "force", "a", "garbage", "collection", "NUMBER", "The", "program", "should", "not", "be", "punished", "for", "any", "garbage", "left", "over", "by", "say", "the", "compilation", "process", "NUMBER", "Finally", "you", "be", "use", "matrix", "set", "in", "mul", "matrix", "set", "change", "the", "jth", "element", "of", "the", "ith", "row", "NUMBER", "define", "matrix", "set", "lambda", "m", "i", "j", "x", "vector", "set", "vector", "ref", "m", "i", "j", "x", "which", "means", "that", "vector", "ref", "m", "i", "be", "call", "multiple", "times", "for", "each", "row", "NUMBER", "Call", "vector", "ref", "m", "i", "once", "for", "each", "row", "in", "mul", "NUMBER", "Jens", "Axel", "S\u00f8gaard", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "GMT", "NUMBER", "NUMBER", "Jason", "E", "NUMBER", "Aten", "Ph", "NUMBER", "D", "NUMBER", "TAG", "I", "wanted", "to", "get", "an", "idea", "of", "how", "fast", "Chez", "be", "say", "compared", "to", "Go", "NUMBER", "I", "write", "up", "a", "little", "matrix", "multiplication", "study", "NUMBER", "The", "results", "be", "here", "LINK", "interpreter", "chezgo", "initial", "simple", "matrix", "mulitply", "benchmark", "where", "I", "see", "Chez", "run", "about", "NUMBER", "x", "slower", "than", "Golang", "NUMBER", "I", "wonder", "if", "there", "be", "anything", "else", "I", "could", "do", "to", "speed", "up", "the", "Chez", "run", "I", "do", "want", "to", "try", "and", "compare", "the", "same", "style", "of", "matrix", "multiply", "namely", "the", "vector", "of", "vectors", "implementation", "but", "be", "there", "other", "flags", "that", "might", "be", "helpful", "to", "the", "Chez", "run", "time", "Specifics", "Go", "code", "LINK", "interpreter", "chezgo", "blob", "master", "cmd", "matmul", "matmul", "NUMBER", "go", "Chez", "code", "LINK", "interpreter", "chezgo", "blob", "master", "matrix", "NUMBER", "ss", "based", "on", "LINK", "Thank", "you", "NUMBER", "Best", "regards", "Jason", "You", "be", "receiving", "this", "because", "you", "be", "subscribed", "to", "this", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "Jens", "Axel", "S\u00f8gaard", "Jens", "Axel", "S\u00f8gaard", "In", "order", "to", "give", "the", "Chez", "compiler", "opportunity", "to", "do", "some", "of", "the", "optimizations", "that", "it", "knows", "how", "to", "do", "you", "can", "t", "just", "define", "function", "at", "top", "level", "since", "this", "has", "to", "leave", "in", "indirections", "at", "the", "call", "sites", "just", "in", "case", "someone", "comes", "along", "and", "redefines", "some", "of", "them", "NUMBER", "There", "be", "several", "ways", "to", "keep", "this", "from", "happening", "the", "one", "with", "which", "I", "m", "most", "familiar", "be", "to", "put", "everything", "inside", "a", "library", "but", "I", "think", "putting", "everything", "inside", "a", "let", "NUMBER", "will", "do", "it", "NUMBER", "I", "want", "to", "say", "that", "not", "a", "lot", "of", "development", "effort", "has", "be", "spent", "on", "optimizing", "floating", "point", "math", "but", "I", "could", "be", "make", "that", "up", "NUMBER", "Thanks", "guys", "Jens", "soegaard", "These", "be", "super", "helpful", "suggestions", "Thank", "you", "NUMBER", "By", "re", "ordering", "the", "innermost", "two", "loops", "and", "shifting", "to", "vector", "ref", "instead", "of", "matrix", "ref", "I", "shaved", "NUMBER", "of", "the", "time", "off", "NUMBER", "Answering", "your", "question", "I", "m", "trying", "to", "see", "how", "fast", "Chez", "can", "do", "float", "NUMBER", "double", "matrix", "multiplies", "to", "get", "a", "general", "sense", "of", "system", "performance", "in", "the", "realm", "of", "data", "analysis", "statistics", "NUMBER", "Jamie", "jltaylor", "us", "Very", "good", "to", "know", "thank", "you", "Wrapping", "in", "a", "library", "seems", "to", "shave", "about", "NUMBER", "of", "the", "time", "off", "NUMBER", "Searching", "I", "wasn", "t", "able", "to", "find", "a", "specialized", "flvector", "or", "specialized", "floating", "point", "multiply", "NUMBER", "So", "if", "someone", "has", "specific", "pointers", "I", "would", "be", "grateful", "NUMBER", "Happy", "Holidays", "Ha", "I", "just", "realized", "that", "fl", "be", "the", "name", "of", "the", "floating", "point", "multiply", "operation", "heh", "NUMBER", "Thanks", "Jens", "NUMBER", "That", "shaved", "another", "NUMBER", "off", "the", "chez", "benchmark", "time", "NUMBER", "You", "can", "probably", "shave", "a", "bit", "more", "off", "by", "make", "your", "loop", "variables", "use", "fixnum", "operators", "i", "NUMBER", "e", "NUMBER", "fx", "fx", "etc", "and", "also", "use", "fl", "when", "you", "know", "you", "be", "add", "floats", "NUMBER", "I", "don", "t", "have", "any", "tips", "specific", "to", "optimizing", "matrix", "multiplication", "but", "you", "should", "look", "into", "some", "of", "chez", "s", "profiling", "tool", "NUMBER", "The", "most", "basic", "one", "be", "the", "time", "macro", "NUMBER", "It", "will", "display", "the", "cpu", "real", "time", "spent", "on", "the", "given", "block", "as", "well", "as", "some", "memory", "and", "gc", "info", "NUMBER", "For", "example", "in", "run", "bench", "I", "replaced", "let", "t", "NUMBER", "real", "time", "blah", "mul", "a", "b", "t", "NUMBER", "real", "time", "format", "t", "s", "x", "s", "matrix", "multiply", "in", "Chez", "took", "s", "msec", "sz", "sz", "t", "NUMBER", "t", "NUMBER", "newline", "with", "time", "mul", "a", "b", "Now", "I", "see", "the", "following", "information", "time", "mul", "a", "NUMBER", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "There", "be", "more", "in", "depth", "profiling", "tool", "as", "well", "LINK", "NUMBER", "system", "h", "NUMBER", "Using", "profile", "dump", "html", "I", "can", "see", "where", "code", "hotspots", "be", "NUMBER", "Check", "it", "out", "here", "LINK", "gwatt", "Graham", "Wow", "nice", "that", "html", "color", "profile", "be", "super", "slick", "NUMBER", "The", "inner", "loop", "of", "the", "matrix", "multiply", "be", "the", "expected", "hot", "spot", "and", "that", "s", "what", "we", "re", "seeing", "NUMBER", "Which", "leads", "me", "to", "think", "that", "unboxing", "really", "should", "be", "avoided", "to", "get", "any", "further", "improvement", "NUMBER", "So", "I", "looked", "harder", "for", "homogenous", "float", "NUMBER", "vectors", "NUMBER", "LINK", "NUMBER", "srfi", "NUMBER", "html", "talks", "about", "f", "NUMBER", "vector", "specialized", "vector", "type", "but", "I", "m", "not", "sure", "if", "Chez", "has", "it", "NUMBER", "LINK", "srfi", "doesn", "t", "list", "it", "and", "searching", "google", "and", "github", "don", "t", "turn", "up", "hits", "NUMBER", "Chez", "and", "V", "NUMBER", "node", "NUMBER", "js", "v", "NUMBER", "do", "the", "NUMBER", "x", "NUMBER", "multiply", "at", "about", "the", "same", "speed", "average", "chez", "NUMBER", "NUMBER", "msec", "depending", "on", "how", "much", "optimization", "applied", "vs", "NUMBER", "average", "node", "NUMBER", "js", "NUMBER", "msec", "NUMBER", "Since", "both", "be", "scheme", "underneath", "that", "kind", "of", "seems", "reasonable", "NUMBER", "Moreover", "Chez", "at", "full", "optimization", "be", "beating", "V", "NUMBER", "by", "NUMBER", "NUMBER", "V", "NUMBER", "has", "probably", "had", "much", "more", "money", "spent", "on", "it", "by", "Google", "so", "Chez", "s", "performance", "be", "actually", "kind", "of", "impressive", "there", "NUMBER", "Nice", "Andy", "NUMBER", "I", "consider", "myself", "schooled", "in", "the", "wayward", "use", "of", "set", "NUMBER", "That", "was", "just", "my", "hack", "and", "obviously", "a", "poor", "one", "NUMBER", "I", "should", "learn", "idiomatic", "scheme", "NUMBER", "it", "would", "be", "interesting", "to", "see", "how", "much", "further", "we", "could", "push", "this", "with", "some", "additional", "compiler", "support", "NUMBER", "Were", "you", "thinking", "of", "a", "single", "type", "vector", "e", "NUMBER", "g", "NUMBER", "a", "f", "NUMBER", "vector", "type", "or", "something", "to", "avoid", "all", "the", "boxing", "unboxing", "It", "s", "nice", "to", "see", "that", "Chez", "can", "be", "within", "NUMBER", "x", "of", "Go", "NUMBER", "And", "it", "be", "very", "responsive", "at", "the", "REPL", "NUMBER", "Of", "course", "Go", "be", "not", "really", "state", "of", "the", "art", "for", "this", "kind", "of", "thing", "either", "OpenBLAS", "and", "others", "yield", "such", "multiplications", "in", "NUMBER", "NUMBER", "msec", "NUMBER", "But", "that", "s", "binding", "to", "heavily", "optimized", "Fortran", "and", "not", "really", "in", "line", "with", "the", "aim", "of", "my", "experiment", "NUMBER", "My", "aim", "wasn", "t", "so", "much", "to", "do", "numerical", "linear", "algebra", "in", "Chez", "but", "just", "to", "get", "general", "sense", "of", "how", "fast", "the", "system", "can", "be", "as", "I", "was", "thinking", "that", "Chez", "s", "incremental", "native", "code", "compilation", "might", "make", "a", "nice", "backend", "for", "a", "Go", "interpreter", "NUMBER", "I", "suspect", "part", "of", "the", "problem", "with", "the", "byte", "vector", "version", "of", "the", "code", "be", "that", "it", "be", "immediately", "boxing", "the", "extracted", "value", "and", "an", "f", "NUMBER", "vector", "would", "effectively", "need", "to", "do", "the", "same", "Ah", "I", "don", "t", "quite", "follow", "why", "re", "boxing", "happens", "but", "it", "even", "so", "it", "seems", "like", "converting", "a", "byte", "vector", "into", "an", "unboxed", "vector", "of", "float", "or", "an", "unboxed", "vector", "of", "larger", "structures", "will", "require", "some", "kind", "of", "unsafe", "cast", "NUMBER", "Is", "there", "such", "a", "cast", "available", "Hi", "Jason", "I", "can", "see", "that", "your", "intent", "was", "to", "compare", "the", "vector", "of", "vectors", "but", "it", "would", "be", "interesting", "to", "compare", "the", "vector", "of", "vectors", "implementation", "with", "an", "implemenation", "use", "a", "single", "single", "vector", "to", "represent", "the", "matrix", "NUMBER", "Jens", "Axel", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "GMT", "NUMBER", "NUMBER", "Jason", "E", "NUMBER", "Aten", "Ph", "NUMBER", "D", "NUMBER", "TAG", "Ha", "I", "just", "realized", "that", "fl", "be", "the", "name", "of", "the", "floating", "point", "multiply", "operation", "heh", "NUMBER", "Thanks", "Jens", "NUMBER", "That", "shaved", "another", "NUMBER", "off", "the", "chez", "benchmark", "time", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "Jens", "Axel", "S\u00f8gaard", "However", "the", "garbage", "collector", "which", "be", "a", "copying", "collector", "would", "need", "to", "be", "in", "on", "the", "game", "because", "we", "would", "have", "pointers", "point", "into", "the", "middle", "of", "objects", "NUMBER", "These", "pointers", "would", "need", "to", "be", "update", "when", "the", "main", "object", "moved", "and", "it", "would", "also", "need", "to", "prevent", "the", "original", "object", "from", "be", "collected", "if", "there", "be", "no", "longer", "a", "live", "reference", "to", "that", "object", "NUMBER", "We", "don", "t", "currently", "have", "support", "for", "something", "like", "this", "in", "the", "collector", "NUMBER", "Very", "interesting", "NUMBER", "I", "thought", "about", "this", "some", "NUMBER", "I", "wonder", "if", "it", "would", "make", "sense", "to", "allocate", "big", "matrices", "in", "a", "separate", "region", "of", "memory", "away", "from", "the", "usual", "heap", "NUMBER", "Then", "the", "collector", "issue", "and", "boxing", "reboxing", "would", "disappear", "NUMBER", "Go", "do", "something", "like", "this", "NUMBER", "Back", "before", "the", "NUMBER", "microsecond", "pause", "collector", "get", "implement", "in", "Go", "I", "use", "to", "use", "offheap", "hashtables", "to", "avoid", "long", "pauses", "NUMBER", "On", "Thu", "Dec", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "Andy", "Keep", "TAG", "write", "Internally", "Chez", "Scheme", "represents", "everything", "as", "a", "tag", "pointer", "NUMBER", "There", "be", "a", "few", "categories", "of", "things", "fixnums", "characters", "constants", "like", "null", "t", "and", "f", "that", "do", "not", "require", "heap", "allocation", "because", "the", "tag", "indicates", "that", "the", "value", "be", "stored", "within", "the", "tag", "pointer", "NUMBER", "For", "everything", "else", "heap", "allocation", "be", "required", "NUMBER", "A", "byte", "vector", "of", "course", "allows", "you", "to", "store", "raw", "data", "but", "once", "you", "extract", "that", "data", "into", "a", "scheme", "tag", "pointer", "you", "need", "to", "allocate", "space", "on", "the", "heap", "for", "it", "NUMBER", "The", "value", "you", "get", "back", "from", "the", "reference", "be", "a", "tag", "pointer", "whose", "tag", "indicates", "it", "be", "a", "floating", "point", "number", "NUMBER", "By", "itself", "an", "f", "NUMBER", "vector", "type", "would", "have", "the", "same", "problem", "namely", "we", "d", "need", "to", "allocate", "space", "for", "that", "value", "to", "live", "as", "its", "own", "value", "NUMBER", "You", "might", "wonder", "why", "you", "cannot", "just", "have", "the", "tag", "pointer", "point", "to", "where", "the", "value", "already", "exists", "in", "memory", "since", "in", "both", "cases", "we", "know", "the", "value", "be", "already", "in", "the", "form", "we", "need", "it", "in", "NUMBER", "However", "the", "garbage", "collector", "which", "be", "a", "copying", "collector", "would", "need", "to", "be", "in", "on", "the", "game", "because", "we", "would", "have", "pointers", "point", "into", "the", "middle", "of", "objects", "NUMBER", "These", "pointers", "would", "need", "to", "be", "update", "when", "the", "main", "object", "moved", "and", "it", "would", "also", "need", "to", "prevent", "the", "original", "object", "from", "be", "collected", "if", "there", "be", "no", "longer", "a", "live", "reference", "to", "that", "object", "NUMBER", "We", "don", "t", "currently", "have", "support", "for", "something", "like", "this", "in", "the", "collector", "NUMBER", "Additionally", "in", "the", "case", "of", "both", "a", "byte", "vector", "and", "the", "f", "NUMBER", "vector", "both", "of", "which", "would", "need", "to", "be", "mutable", "for", "your", "purposes", "we", "d", "need", "to", "make", "it", "clear", "that", "the", "variable", "be", "held", "onto", "could", "potentially", "change", "value", "through", "another", "instruction", "setting", "the", "location", "NUMBER", "In", "general", "Chez", "Scheme", "s", "operators", "operate", "on", "the", "tag", "pointer", "representation", "and", "be", "expected", "to", "return", "tag", "pointer", "representations", "with", "a", "handful", "of", "exception", "NUMBER", "The", "ftype", "system", "which", "be", "a", "syntactic", "layer", "to", "make", "interacting", "with", "structured", "foreign", "data", "easier", "internally", "maintains", "a", "raw", "pointer", "type", "for", "computing", "memory", "offsets", "and", "the", "like", "and", "it", "be", "possible", "we", "could", "do", "something", "similar", "for", "floating", "point", "values", "NUMBER", "Another", "concern", "with", "raw", "values", "floating", "around", "be", "how", "they", "impact", "the", "garbage", "collector", "NUMBER", "We", "currently", "maintain", "a", "live", "pointer", "mask", "for", "each", "frame", "on", "the", "stack", "which", "form", "the", "root", "set", "for", "the", "collector", "NUMBER", "In", "general", "the", "live", "pointer", "mask", "indicates", "what", "must", "be", "maintained", "across", "non", "tail", "calls", "and", "any", "element", "on", "the", "frame", "not", "covered", "by", "the", "mask", "could", "be", "replaced", "with", "random", "garbage", "without", "cause", "problem", "NUMBER", "We", "would", "need", "to", "subtly", "change", "the", "meaning", "of", "the", "live", "pointer", "mask", "since", "we", "would", "potentially", "have", "valid", "raw", "data", "stored", "where", "the", "live", "pointer", "mask", "indicates", "they", "be", "not", "live", "pointers", "and", "we", "wouldn", "t", "want", "them", "to", "marked", "as", "live", "pointers", "since", "the", "raw", "data", "might", "be", "interpreted", "incorrectly", "by", "the", "garbage", "collector", "NUMBER", "In", "addition", "I", "would", "like", "to", "be", "able", "to", "take", "advantage", "of", "the", "floating", "point", "registers", "that", "exist", "on", "most", "modern", "processors", "to", "allow", "us", "to", "keep", "floating", "point", "values", "in", "registers", "for", "longer", "stretches", "when", "there", "be", "going", "to", "be", "multiple", "floating", "point", "operations", "in", "sequence", "on", "them", "rather", "than", "reading", "them", "from", "memory", "doing", "the", "operation", "then", "write", "them", "back", "to", "memory", "only", "to", "read", "them", "again", "at", "the", "start", "of", "the", "next", "operation", "NUMBER", "This", "might", "not", "make", "a", "big", "impact", "for", "your", "particular", "use", "case", "but", "I", "do", "think", "the", "kernel", "of", "your", "matrix", "multiple", "would", "have", "better", "code", "generate", "there", "if", "we", "could", "get", "something", "like", "this", "implement", "NUMBER", "If", "you", "be", "interested", "in", "seeing", "what", "Chez", "Scheme", "do", "now", "you", "can", "see", "the", "assembly", "code", "generate", "by", "setting", "the", "assembly", "output", "parameter", "to", "t", "or", "a", "textual", "output", "port", "NUMBER", "t", "indicates", "it", "should", "be", "output", "to", "standard", "out", "NUMBER", "You", "ll", "need", "to", "use", "the", "prefix", "to", "use", "this", "as", "it", "be", "a", "hidden", "primitive", "in", "Chez", "Scheme", "assembly", "output", "f", "assembly", "output", "t", "You", "be", "receiving", "this", "because", "you", "authored", "the", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "Thanks", "for", "the", "sage", "wisdom", "NUMBER", "In", "the", "test", "in", "WIndows", "I", "get", "this", "error", "in", "date", "NUMBER", "ms", "L", "NUMBER", "L", "NUMBER", "LINK", "L", "NUMBER", "L", "NUMBER", "let", "t", "current", "time", "time", "date", "time", "utc", "time", "utc", "date", "t", "NUMBER", "date", "time", "utc", "time", "utc", "date", "t", "NUMBER", "The", "error", "in", "the", "summary", "be", "something", "like", "o", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "conversions", "sleep", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "For", "reference", "when", "I", "run", "this", "variation", "manually", "I", "get", "this", "results", "let", "t", "current", "time", "list", "date", "time", "utc", "time", "utc", "date", "t", "NUMBER", "date", "time", "utc", "time", "utc", "date", "t", "TAG", "TAG", "In", "cygwin", "I", "get", "echo", "TZ", "America", "Buenos_Aires", "and", "use", "unset", "TZ", "doesn", "t", "fix", "the", "problem", "NUMBER", "In", "cmd", "NUMBER", "exe", "I", "don", "t", "have", "anything", "similar", "to", "a", "TZ", "variable", "but", "my", "timezone", "be", "set", "to", "UTC", "NUMBER", "NUMBER", "Ciudad", "de", "Buenos", "Aires", "NUMBER", "I", "get", "similar", "results", "TAG", "TAG", "run", "scheme", "in", "cmd", "NUMBER", "exe", "and", "in", "cygwin", "with", "and", "without", "TZ", "The", "first", "commit", "add", "a", "checks", "that", "first", "argument", "of", "map", "be", "a", "procedure", "in", "cp", "NUMBER", "expansion", "to", "raise", "the", "same", "error", "that", "the", "non", "expanded", "version", "This", "fix", "an", "error", "in", "the", "test", "in", "Windows", "of", "the", "mat", "NUMBER", "ms", "line", "NUMBER", "NUMBER", "LINK", "L", "NUMBER", "L", "NUMBER", "and", "line", "NUMBER", "L", "NUMBER", "LINK", "L", "NUMBER", "L", "NUMBER", "error", "nonprocedure", "map", "NUMBER", "a", "b", "c", "NUMBER", "error", "for", "each", "NUMBER", "a", "b", "c", "The", "summary", "be", "something", "like", "o", "NUMBER", "cp", "NUMBER", "t", "NUMBER", "NUMBER", "c", "NUMBER", "TAG", "NUMBER", "mo", "Expected", "error", "in", "mat", "map", "attempt", "to", "apply", "non", "procedure", "NUMBER", "NUMBER", "NUMBER", "c", "NUMBER", "TAG", "NUMBER", "mo", "Expected", "error", "in", "mat", "for", "each", "attempt", "to", "apply", "non", "procedure", "NUMBER", "NUMBER", "I", "really", "don", "t", "understand", "why", "the", "test", "in", "Linux", "don", "t", "detect", "this", "NUMBER", "Reading", "some", "error", "message", "I", "guess", "that", "it", "s", "a", "difference", "between", "scheme", "NUMBER", "boot", "and", "petite", "NUMBER", "boot", "but", "I", "m", "not", "sure", "if", "this", "even", "make", "sense", "NUMBER", "I", "m", "very", "confused", "NUMBER", "The", "second", "commit", "be", "a", "small", "improvement", "NUMBER", "It", "avoids", "build", "the", "result", "list", "in", "a", "map", "that", "be", "call", "for", "effect", "NUMBER", "There", "s", "a", "better", "reason", "to", "include", "the", "procedure", "check", "at", "optimize", "level", "NUMBER", "which", "be", "that", "NUMBER", "map", "e", "should", "raise", "an", "exception", "if", "x", "be", "not", "a", "procedure", "even", "when", "the", "code", "containing", "the", "call", "be", "run", "at", "optimize", "level", "NUMBER", "So", "this", "seems", "like", "a", "good", "change", "to", "me", "NUMBER", "Cosmetically", "I", "d", "prefer", "the", "then", "and", "else", "parts", "of", "the", "inserted", "if", "expression", "be", "indented", "under", "the", "test", "and", "the", "second", "and", "third", "make", "seq", "argument", "be", "indented", "two", "spaces", "rather", "than", "under", "the", "first", "argument", "NUMBER", "I", "m", "guessing", "the", "patch", "file", "need", "to", "be", "rebuilt", "to", "reflect", "the", "change", "in", "error", "message", "NUMBER", "I", "ll", "let", "Andy", "do", "a", "detailed", "check", "of", "the", "change", "if", "he", "wants", "and", "leave", "it", "to", "him", "to", "pull", "NUMBER", "I", "fix", "the", "indentation", "NUMBER", "I", "can", "rebase", "them", "if", "necessary", "NUMBER", "But", "I", "don", "t", "understand", "your", "comment", "NUMBER", "Is", "it", "posible", "to", "expand", "NUMBER", "map", "p", "list", "NUMBER", "with", "the", "current", "version", "and", "then", "run", "the", "expanded", "version", "in", "a", "way", "that", "it", "doesn", "t", "raise", "an", "error", "if", "p", "be", "not", "a", "procedure", "On", "the", "other", "hand", "NUMBER", "map", "NUMBER", "be", "still", "reduced", "to", "without", "any", "error", "NUMBER", "I", "didn", "t", "fix", "it", "NUMBER", "Is", "this", "an", "error", "The", "documentation", "be", "not", "NUMBER", "clear", "NUMBER", "This", "be", "cause", "by", "a", "special", "case", "that", "be", "checkd", "before", "calling", "inline", "lists", "NUMBER", "OK", "I", "see", "the", "problem", "NUMBER", "Should", "I", "change", "anything", "I", "m", "still", "worried", "about", "map", "NUMBER", "NUMBER", "In", "my", "current", "version", "with", "cptypes", "LINK", "the", "expansion", "can", "produce", "an", "error", "for", "example", "in", "define", "f", "p", "b", "unbox", "b", "map", "p", "if", "box", "b", "NUMBER", "NUMBER", "NUMBER", "list", "p", "procedure", "p", "f", "NUMBER", "box", "NUMBER", "NUMBER", "t", "The", "example", "be", "strange", "to", "make", "sure", "that", "the", "reductions", "of", "cp", "NUMBER", "and", "cptypes", "be", "applied", "in", "the", "right", "order", "to", "get", "the", "error", "NUMBER", "One", "solution", "be", "to", "fix", "the", "expansion", "of", "map", "in", "cp", "NUMBER", "and", "other", "solution", "be", "to", "change", "the", "signature", "of", "map", "NUMBER", "And", "other", "similar", "function", "NUMBER", "LINK", "L", "NUMBER", "In", "the", "case", "of", "unget", "u", "NUMBER", "char", "the", "value", "can", "be", "an", "also", "an", "eof", "so", "I", "have", "to", "change", "the", "type", "to", "ptr", "NUMBER", "Also", "it", "be", "strange", "that", "vector", "fill", "vector", "bytevector", "fill", "void", "string", "fill", "void", "fxvector", "fill", "void", "substring", "fill", "string", "I", "change", "the", "mat", "of", "substring", "fill", "because", "it", "use", "that", "the", "return", "value", "be", "the", "string", "NUMBER", "I", "remove", "the", "change", "of", "the", "signatures", "of", "vector", "fill", "and", "substring", "fill", "but", "I", "add", "a", "change", "to", "the", "signature", "of", "fxvector", "fill", "that", "I", "mysteriously", "miss", "NUMBER", "While", "I", "was", "write", "the", "fix", "I", "was", "also", "thinking", "that", "char", "eof", "may", "be", "a", "good", "idea", "NUMBER", "I", "m", "not", "sure", "about", "the", "name", "NUMBER", "NUMBER", "It", "s", "similar", "to", "maybe", "char", "NUMBER", "Procedure", "source", "locations", "be", "useful", "for", "error", "backtraces", "at", "a", "much", "lower", "cost", "while", "losing", "some", "precision", "compared", "to", "keep", "full", "inspector", "information", "NUMBER", "This", "patch", "add", "generate", "procedure", "source", "information", "which", "defaults", "to", "f", "and", "only", "applies", "when", "generate", "inspector", "information", "be", "f", "NUMBER", "If", "generate", "procedure", "source", "information", "be", "t", "then", "a", "source", "location", "be", "preserved", "with", "a", "code", "object", "even", "when", "generate", "inspector", "information", "be", "f", "NUMBER", "Rebased", "NUMBER", "For", "now", "Racket", "on", "Chez", "s", "default", "compilation", "mode", "still", "uses", "generate", "inspector", "information", "f", "and", "generate", "procedure", "source", "information", "t", "and", "that", "combination", "has", "worked", "as", "intended", "preserving", "the", "same", "kind", "of", "debugging", "information", "as", "traditional", "Racket", "with", "the", "same", "minimal", "cost", "NUMBER", "This", "be", "a", "fix", "of", "the", "bytevector", "u", "s", "NUMBER", "native", "set", "signature", "and", "also", "bytevector", "sint", "set", "NUMBER", "The", "signature", "of", "bytevector", "u", "s", "NUMBER", "native", "set", "be", "correct", "so", "it", "s", "not", "necessary", "to", "fix", "it", "NUMBER", "I", "made", "of", "socket", "fork", "thread", "recv", "and", "send", "data", "But", "i", "find", "that", "it", "may", "block", "in", "recv", "or", "send", "NUMBER", "Here", "be", "my", "code", "NUMBER", "import", "net", "socket", "ffi", "cffi", "cffi", "define", "socket", "fd", "NUMBER", "define", "n", "NUMBER", "define", "buff", "cffi", "alloc", "NUMBER", "cffi", "log", "t", "set", "socket", "fd", "socket", "AF_INET", "SOCK_STREAM", "NUMBER", "display", "format", "socket", "fd", "a", "n", "socket", "fd", "define", "server", "addr", "make", "sockaddr", "in", "AF_INET", "INADDR_ANY", "NUMBER", "define", "bind", "ret", "bind", "socket", "fd", "server", "addr", "NUMBER", "display", "format", "bind", "ret", "a", "n", "bind", "ret", "define", "listen", "ret", "listen", "socket", "fd", "NUMBER", "display", "format", "listen", "ret", "a", "n", "listen", "ret", "define", "make", "thread", "fd", "fork", "thread", "lambda", "let", "loop", "NUMBER", "buf", "cffi", "alloc", "NUMBER", "printf", "recv", "ret", "a", "n", "recv", "fd", "buf", "NUMBER", "NUMBER", "printf", "send", "ret", "a", "n", "send", "fd", "test\u4f60\u597d", "n", "NUMBER", "NUMBER", "printf", "get", "a", "a", "n", "fd", "cffi", "string", "buf", "sleep", "make", "time", "time", "duration", "NUMBER", "NUMBER", "loop", "NUMBER", "buf", "let", "loop", "printf", "loop", "thread", "a", "n", "get", "thread", "id", "let", "connect", "fd", "accept", "socket", "fd", "NUMBER", "NUMBER", "display", "format", "accept", "connect", "fd", "a", "n", "connect", "fd", "make", "thread", "connect", "fd", "printf", "fork", "thread", "end", "n", "loop", "close", "connect", "fd", "close", "socket", "fd", "It", "has", "two", "socket", "connects", "NUMBER", "I", "just", "write", "a", "server", "with", "c", "NUMBER", "It", "dosen", "t", "block", "NUMBER", "I", "think", "the", "fork", "thread", "may", "block", "in", "recv", "or", "send", "function", "with", "mutithread", "NUMBER", "Here", "be", "the", "code", "include", "TAG", "include", "TAG", "include", "TAG", "include", "TAG", "include", "TAG", "include", "TAG", "include", "TAG", "include", "TAG", "define", "MAXLINE", "NUMBER", "pthread_t", "main_tid", "void", "print_ids", "const", "char", "str", "pid_t", "pid", "pthread_t", "tid", "pid", "getpid", "tid", "pthread_self", "printf", "s", "pid", "u", "tid", "u", "NUMBER", "x", "x", "n", "str", "unsigned", "int", "pid", "unsigned", "int", "tid", "unsigned", "int", "tid", "void", "func", "void", "arg", "char", "buff", "NUMBER", "int", "n", "int", "connfd", "int", "arg", "print_ids", "new", "thread", "for", "n", "recv", "connfd", "buff", "MAXLINE", "NUMBER", "buff", "n", "NUMBER", "printf", "recv", "msg", "from", "client", "s", "n", "buff", "send", "connfd", "buff", "NUMBER", "NUMBER", "return", "void", "NUMBER", "int", "main", "int", "argc", "char", "argv", "int", "listenfd", "connfd", "struct", "sockaddr_in", "servaddr", "char", "buff", "NUMBER", "int", "n", "if", "listenfd", "socket", "AF_INET", "SOCK_STREAM", "NUMBER", "NUMBER", "printf", "create", "socket", "error", "s", "errno", "d", "n", "strerror", "errno", "errno", "exit", "NUMBER", "memset", "servaddr", "NUMBER", "sizeof", "servaddr", "servaddr", "NUMBER", "sin_family", "AF_INET", "servaddr", "NUMBER", "sin_addr", "NUMBER", "s_addr", "htonl", "INADDR_ANY", "servaddr", "NUMBER", "sin_port", "htons", "NUMBER", "if", "bind", "listenfd", "struct", "sockaddr", "servaddr", "sizeof", "servaddr", "NUMBER", "printf", "bind", "socket", "error", "s", "errno", "d", "n", "strerror", "errno", "errno", "exit", "NUMBER", "if", "listen", "listenfd", "NUMBER", "NUMBER", "printf", "listen", "socket", "error", "s", "errno", "d", "n", "strerror", "errno", "errno", "exit", "NUMBER", "printf", "waiting", "for", "client", "s", "request", "n", "while", "NUMBER", "if", "connfd", "accept", "listenfd", "struct", "sockaddr", "NULL", "NULL", "NUMBER", "printf", "accept", "socket", "error", "s", "errno", "d", "strerror", "errno", "errno", "continue", "int", "err", "err", "pthread_create", "main_tid", "NULL", "func", "connfd", "if", "err", "NUMBER", "printf", "create", "thread", "error", "s", "n", "strerror", "err", "return", "NUMBER", "close", "connfd", "close", "listenfd", "return", "EXIT_SUCCESS", "I", "finally", "find", "that", "Sactivate_thread", "and", "Sdeactivate_thread", "should", "be", "enclosed", "ffi", "function", "when", "call", "NUMBER", "akeep", "hmm", "NUMBER", "evilbinary", "Hi", "how", "did", "you", "fix", "your", "scheme", "code", "can", "you", "show", "it", "Saigut", "\u662f\u8fd9\u6837\u7684", "\u4f60\u628affi\u7684c\u51fd\u6570\u5305\u56f4\u4e00\u4e0b", "\u6bd4\u5982", "void", "test_read", "Sdeactivate_thread", "read\u51fd\u6570\u6b63\u5e38\u903b\u8f91", "Sactivate_thread", "\u7136\u540e\u53ef\u4ee5\u5728fork", "thread\u91cc\u9762\u7528\u4e86", "\u53ef\u4ee5\u52a0\u6211\u7fa4\u8ba8\u8bba", "Lisp\u5174\u8da3\u5c0f\u7ec4", "NUMBER", "\u8c22\u8c22", "Saigut", "you", "solve", "you", "problem", "right", "Solved", "NUMBER", "This", "issue", "ref", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "I", "think", "this", "change", "be", "mostly", "straightforward", "but", "be", "set", "make", "live", "info", "rax", "asm", "info", "asm", "locked", "cmpxchg", "NUMBER", "on", "line", "NUMBER", "of", "x", "NUMBER", "_", "NUMBER", "ss", "and", "similar", "for", "x", "NUMBER", "ss", "the", "best", "way", "to", "reflect", "that", "CMPXCHG", "may", "modify", "the", "RAX", "register", "I", "don", "t", "think", "it", "s", "necessary", "since", "the", "preceding", "instruction", "kills", "rax", "via", "urax", "so", "I", "would", "remove", "the", "assignment", "and", "leave", "the", "RHS", "NUMBER", "If", "it", "were", "necessary", "I", "think", "you", "d", "want", "it", "to", "set", "urax", "instead", "of", "rax", "since", "all", "assignments", "other", "than", "unspillable", "assignments", "need", "to", "be", "visible", "prior", "to", "live", "analysis", "NUMBER", "Updated", "NUMBER", "Rebased", "NUMBER", "burgerrg", "I", "use", "the", "usual", "cross", "compile", "steps", "set", "M", "TAG", "export", "M", "set", "ORIG", "TAG", "export", "ORIG", "cd", "M", "s", "make", "f", "Mf", "cross", "m", "M", "xm", "M", "base", "ORIG", "M", "make", "But", "I", "always", "feel", "like", "I", "must", "be", "miss", "some", "better", "and", "simpler", "way", "NUMBER", "I", "d", "like", "to", "roll", "my", "own", "release", "tarballs", "that", "only", "support", "the", "platforms", "I", "m", "interested", "for", "size", "reasons", "currently", "only", "x", "NUMBER", "NUMBER", "NUMBER", "Can", "anyone", "fill", "me", "in", "on", "how", "to", "do", "this", "Also", "I", "m", "curious", "if", "there", "d", "be", "interest", "in", "just", "use", "a", "regular", "configure", "make", "make", "install", "flow", "with", "normal", "automake", "autoconf", "tool", "rather", "than", "the", "homemade", "scripts", "currently", "in", "use", "IMHO", "make", "dist", "would", "be", "a", "nice", "way", "to", "do", "things", "NUMBER", "Awesome", "thank", "you", "for", "the", "help", "Looking", "to", "make", "Chez", "the", "basis", "for", "a", "new", "plotter", "I", "m", "work", "on", "very", "excited", "about", "the", "possibility", "NUMBER", "On", "my", "x", "NUMBER", "_", "NUMBER", "slackware", "linux", "gnu", "run", "a", "build", "from", "commit", "NUMBER", "dca", "NUMBER", "c", "NUMBER", "d", "NUMBER", "ff", "NUMBER", "b", "NUMBER", "f", "NUMBER", "I", "see", "the", "following", "boot", "file", "install", "ls", "l", "opt", "chez", "scheme", "NUMBER", "lib", "NUMBER", "csv", "NUMBER", "a", "NUMBER", "le", "total", "NUMBER", "M", "r", "r", "r", "NUMBER", "root", "root", "NUMBER", "K", "Oct", "NUMBER", "NUMBER", "NUMBER", "chez", "NUMBER", "boot", "r", "r", "r", "NUMBER", "root", "root", "NUMBER", "M", "Oct", "NUMBER", "NUMBER", "NUMBER", "petite", "NUMBER", "boot", "r", "r", "r", "NUMBER", "root", "root", "NUMBER", "M", "Oct", "NUMBER", "NUMBER", "NUMBER", "petite", "chez", "NUMBER", "boot", "r", "r", "r", "NUMBER", "root", "root", "NUMBER", "K", "Oct", "NUMBER", "NUMBER", "NUMBER", "scheme", "NUMBER", "boot", "r", "r", "r", "NUMBER", "root", "root", "NUMBER", "K", "Oct", "NUMBER", "NUMBER", "NUMBER", "scheme", "NUMBER", "h", "lrwxrwxrwx", "NUMBER", "root", "root", "NUMBER", "Oct", "NUMBER", "NUMBER", "NUMBER", "scheme", "script", "NUMBER", "boot", "opt", "chez", "scheme", "NUMBER", "lib", "NUMBER", "csv", "NUMBER", "a", "NUMBER", "le", "scheme", "NUMBER", "boot", "when", "use", "this", "build", "script", "export", "CHEZSCHEMELIBEXTS", "NUMBER", "chezscheme", "NUMBER", "sls", "NUMBER", "chezscheme", "NUMBER", "ss", "NUMBER", "sls", "NUMBER", "ss", "export", "CHEZSCHEMELIBDIRS", "unset", "CHEZSCHEMELIBDIRS", "unset", "SCHEMEHEAPDIRS", "VERSION", "VERSION", "NUMBER", "prefix", "opt", "chez", "scheme", "VERSION", "CHEZ_INSTALL_SUFFIX", "if", "test", "d", "lib", "NUMBER", "then", "libdir", "prefix", "lib", "NUMBER", "else", "libdir", "prefix", "lib", "fi", "make", "clean", "make", "distclean", "git", "clean", "xfd", "NUMBER", "configure", "installprefix", "prefix", "installlib", "libdir", "installowner", "root", "installgroup", "root", "installschemename", "chez", "installpetitename", "petite", "chez", "CFLAGS", "O", "NUMBER", "Wno", "maybe", "uninitialized", "CPPFLAGS", "I", "usr", "local", "include", "LDFLAGS", "L", "usr", "local", "lib", "NUMBER", "liconv", "make", "make", "docs", "umask", "NUMBER", "sudo", "install", "m", "NUMBER", "d", "prefix", "bin", "umask", "NUMBER", "sudo", "install", "m", "NUMBER", "d", "prefix", "share", "umask", "NUMBER", "sudo", "install", "m", "NUMBER", "d", "libdir", "umask", "NUMBER", "sudo", "make", "install", "you", "be", "seeing", "hard", "links", "which", "reflect", "the", "names", "you", "chose", "to", "call", "your", "Chez", "Scheme", "executables", "I", "see", "now", "NUMBER", "Internally", "though", "chez", "NUMBER", "boot", "will", "still", "be", "looking", "for", "a", "file", "call", "petite", "NUMBER", "boot", "so", "these", "be", "simply", "hard", "linked", "to", "avoid", "change", "the", "underlying", "generation", "of", "the", "boot", "file", "NUMBER", "That", "be", "confusing", "from", "the", "package", "maintainer", "point", "of", "view", "NUMBER", "An", "executable", "ciao", "chez", "will", "look", "for", "a", "boot", "file", "ciao", "chez", "NUMBER", "boot", "I", "understand", "this", "and", "I", "agree", "with", "this", "choice", "NUMBER", "But", "why", "be", "the", "original", "file", "pathnames", "still", "needed", "The", "pathname", "be", "just", "a", "Chez", "Scheme", "s", "compile", "time", "string", "NUMBER", "As", "far", "as", "I", "can", "tell", "there", "be", "no", "way", "to", "disable", "installation", "of", "Petite", "Chez", "and", "scheme", "script", "NUMBER", "I", "would", "appreciate", "it", "through", "a", "configure", "option", "NUMBER", "By", "the", "way", "do", "it", "still", "make", "sense", "to", "build", "and", "install", "Petite", "Chez", "and", "can", "be", "use", "a", "smaller", "run", "time", "for", "a", "precompiled", "scheme", "program", "NUMBER", "I", "was", "not", "aware", "of", "this", "NUMBER", "I", "will", "have", "to", "meditate", "more", "on", "this", "NUMBER", "The", "documentation", "currently", "shows", "format", "a", "Ouch", "ouch", "Chez", "NUMBER", "instead", "outputs", "OUCH", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "format", "a", "Ouch", "OUCH", "Chez", "NUMBER", "also", "yields", "this", "same", "behavior", "NUMBER", "The", "Common", "Lisp", "HyperSpec", "LINK", "_cha", "NUMBER", "htm", "indicates", "that", "be", "bogus", "NUMBER", "Shouldn", "t", "the", "example", "be", "format", "a", "ouch", "Ouch", "burgerrg", "be", "you", "suggesting", "adjusting", "the", "example", "in", "the", "docs", "rather", "than", "the", "output", "Yes", "I", "think", "the", "example", "should", "be", "update", "to", "be", "in", "sync", "with", "the", "format", "specification", "NUMBER", "Either", "use", "or", "the", "example", "I", "gave", "NUMBER", "Updated", "to", "burgerrg", "s", "suggested", "example", "NUMBER", "As", "akeep", "said", "colon", "and", "at", "sign", "can", "come", "in", "either", "order", "so", "and", "be", "equivalent", "NUMBER", "I", "believe", "this", "be", "true", "generally", "for", "Common", "Lisp", "format", "NUMBER", "If", "so", "I", "assume", "the", "referenced", "document", "just", "doesn", "t", "bother", "showing", "both", "orders", "and", "the", "original", "fix", "should", "be", "okay", "NUMBER", "For", "example", "fx", "carry", "quote", "NUMBER", "quote", "NUMBER", "quote", "NUMBER", "was", "reduced", "to", "values", "NUMBER", "NUMBER", "but", "to", "use", "the", "nanopass", "language", "correctly", "it", "should", "be", "reduced", "to", "values", "quote", "NUMBER", "quote", "NUMBER", "Hello", "NUMBER", "I", "pull", "an", "update", "today", "NUMBER", "The", "build", "fail", "to", "make", "NUMBER", "The", "error", "message", "be", "at", "the", "end", "of", "the", "output", "NUMBER", "Thank", "you", "for", "your", "time", "NUMBER", "make", "cd", "a", "NUMBER", "le", "make", "build", "cd", "c", "make", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "statics", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "segment", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "alloc", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "symbol", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "intern", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "gcwrapper", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "gc", "ocd", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "gc", "oce", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "number", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "schsig", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "io", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "new", "io", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "print", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "fasl", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "stats", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "foreign", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "prim", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "prim", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "flushcache", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "schlib", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "thread", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "expeditor", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "scheme", "NUMBER", "c", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "i", "NUMBER", "le", "NUMBER", "c", "ld", "melf_x", "NUMBER", "_", "NUMBER", "r", "X", "o", "NUMBER", "boot", "a", "NUMBER", "le", "kernel", "NUMBER", "o", "statics", "NUMBER", "o", "segment", "NUMBER", "o", "alloc", "NUMBER", "o", "symbol", "NUMBER", "o", "intern", "NUMBER", "o", "gcwrapper", "NUMBER", "o", "gc", "ocd", "NUMBER", "o", "gc", "oce", "NUMBER", "o", "number", "NUMBER", "o", "schsig", "NUMBER", "o", "io", "NUMBER", "o", "new", "io", "NUMBER", "o", "print", "NUMBER", "o", "fasl", "NUMBER", "o", "stats", "NUMBER", "o", "foreign", "NUMBER", "o", "prim", "NUMBER", "o", "prim", "NUMBER", "o", "flushcache", "NUMBER", "o", "schlib", "NUMBER", "o", "thread", "NUMBER", "o", "expeditor", "NUMBER", "o", "scheme", "NUMBER", "o", "i", "NUMBER", "le", "NUMBER", "o", "NUMBER", "zlib", "libz", "NUMBER", "a", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "c", "DX", "NUMBER", "_", "NUMBER", "I", "NUMBER", "boot", "a", "NUMBER", "le", "I", "NUMBER", "zlib", "main", "NUMBER", "c", "cp", "p", "main", "NUMBER", "o", "NUMBER", "boot", "a", "NUMBER", "le", "main", "NUMBER", "o", "cc", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "Werror", "Wno", "implicit", "fallthrough", "O", "NUMBER", "rdynamic", "o", "NUMBER", "bin", "a", "NUMBER", "le", "scheme", "NUMBER", "boot", "a", "NUMBER", "le", "kernel", "NUMBER", "o", "NUMBER", "boot", "a", "NUMBER", "le", "main", "NUMBER", "o", "lm", "ldl", "lncurses", "lrt", "cd", "s", "make", "bootstrap", "make", "allx", "rm", "f", "NUMBER", "a", "NUMBER", "le", "xpatch", "patch", "NUMBER", "patch", "NUMBER", "so", "NUMBER", "asm", "script", "NUMBER", "all", "header", "NUMBER", "tmp", "NUMBER", "html", "rm", "rf", "nanopass", "cp", "p", "f", "NUMBER", "boot", "a", "NUMBER", "le", "petite", "NUMBER", "boot", "NUMBER", "boot", "a", "NUMBER", "le", "sbb", "cp", "p", "f", "NUMBER", "boot", "a", "NUMBER", "le", "scheme", "NUMBER", "boot", "NUMBER", "boot", "a", "NUMBER", "le", "scb", "make", "all", "echo", "reset", "handler", "abort", "base", "exception", "handler", "lambda", "c", "fresh", "line", "display", "condition", "c", "newline", "reset", "keyboard", "interrupt", "handler", "lambda", "display", "interrupted", "aborting", "n", "reset", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "generate", "inspector", "information", "f", "subset", "mode", "quote", "system", "compile", "file", "cmacros", "NUMBER", "ss", "cmacros", "NUMBER", "so", "NUMBER", "bin", "a", "NUMBER", "le", "scheme", "q", "compile", "cmacros", "NUMBER", "ss", "with", "output", "to", "cmacros", "NUMBER", "so", "Exception", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "make", "NUMBER", "cmacros", "NUMBER", "so", "Error", "NUMBER", "make", "NUMBER", "allx", "Error", "NUMBER", "make", "NUMBER", "bootstrap", "Error", "NUMBER", "make", "NUMBER", "build", "Error", "NUMBER", "make", "build", "Error", "NUMBER", "Mm", "Thank", "you", "Andy", "Your", "suggestion", "works", "when", "input", "a", "wrong", "parameter", "a", "to", "x", "of", "function", "f", "the", "x", "can", "t", "be", "inspected", "in", "debugger", "r", "x", "NUMBER", "and", "in", "nested", "function", "call", "we", "also", "can", "t", "inspect", "function", "parameter", "in", "debugger", "NUMBER", "how", "to", "deal", "with", "it", "define", "f", "lambda", "x", "NUMBER", "x", "f", "a", "Exception", "in", "a", "be", "not", "a", "number", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "debug", "debug", "i", "system", "continuation", "in", "new", "cafe", "sf", "NUMBER", "system", "continuation", "in", "new", "cafe", "system", "continuation", "in", "new", "cafe", "s", "continuation", "null", "continuation", "frame", "and", "free", "variables", "NUMBER", "system", "continuation", "in", "dynamic", "wind", "akeep", "how", "to", "construct", "a", "helper", "function", "g", "x", "which", "non", "tail", "call", "f", "x", "for", "debugging", "purpose", "This", "patch", "be", "a", "first", "cut", "at", "add", "support", "struct", "argument", "and", "results", "when", "calling", "foreign", "procedure", "or", "generating", "a", "foreign", "callable", "wrapper", "for", "a", "Scheme", "procedure", "as", "in", "NUMBER", "NUMBER", "The", "initial", "implementation", "be", "only", "for", "x", "NUMBER", "and", "x", "NUMBER", "_", "NUMBER", "on", "Mac", "OS", "but", "if", "the", "approach", "makes", "sense", "then", "I", "can", "fill", "in", "more", "NUMBER", "Syntactically", "the", "patch", "add", "support", "for", "ftype", "as", "a", "foreign", "procedure", "argument", "or", "result", "NUMBER", "On", "the", "Scheme", "side", "the", "representation", "for", "ftype", "be", "the", "same", "as", "for", "ftype", "NUMBER", "On", "the", "foreign", "side", "the", "content", "of", "a", "pointer", "for", "ftype", "be", "pass", "as", "a", "value", "or", "received", "as", "a", "result", "instead", "of", "passing", "or", "receiving", "the", "pointer", "NUMBER", "For", "example", "typedef", "struct", "int", "x", "y", "pt", "pt", "get_pt", "pt", "p", "NUMBER", "NUMBER", "return", "p", "can", "be", "call", "with", "define", "ftype", "pt", "struct", "x", "int", "y", "int", "define", "get_pt", "foreign", "procedure", "foreign", "entry", "get_pt", "pt", "The", "ftype", "in", "ftype", "doesn", "t", "have", "to", "be", "a", "struct", "type", "NUMBER", "For", "example", "int", "could", "be", "use", "in", "place", "of", "an", "int", "argument", "or", "result", "in", "which", "case", "the", "Scheme", "side", "must", "supply", "or", "receive", "an", "fpointer", "to", "an", "integer", "NUMBER", "Unions", "packed", "structs", "etc", "NUMBER", "be", "all", "meant", "to", "work", "NUMBER", "On", "the", "Scheme", "side", "a", "result", "received", "as", "ftype", "or", "a", "callable", "s", "ftype", "argument", "be", "allocated", "with", "foreign", "alloc", "and", "must", "be", "explicitly", "freed", "NUMBER", "Similarly", "a", "callable", "must", "return", "a", "ftype", "result", "that", "be", "allocated", "and", "it", "will", "be", "freed", "on", "the", "foreign", "side", "after", "the", "value", "be", "copied", "out", "NUMBER", "An", "argument", "ftype", "be", "not", "freed", "by", "the", "call", "currently", "NUMBER", "I", "would", "be", "happier", "with", "a", "way", "to", "allocate", "memory", "as", "GCable", "and", "avoid", "the", "explicit", "frees", "but", "I", "don", "t", "think", "an", "fpointer", "can", "wrap", "GC", "allocated", "bytes", "NUMBER", "Some", "details", "I", "m", "unsure", "about", "the", "way", "that", "Scopy", "argument", "be", "call", "to", "copy", "the", "content", "of", "a", "ftype", "callable", "argument", "NUMBER", "Is", "it", "ok", "to", "pass", "an", "argument", "via", "ts", "Is", "the", "saved", "argument", "list", "correct", "For", "callables", "that", "return", "ftype", "the", "way", "that", "tail", "calling", "a", "S_call_", "NUMBER", "variant", "achieves", "the", "right", "result", "often", "involves", "some", "trickery", "The", "S_call_indirect_copy_three_chars", "variant", "be", "the", "biggest", "hack", "and", "I", "m", "not", "sure", "it", "s", "better", "than", "implement", "the", "ABI", "directly", "in", "each", "backend", "NUMBER", "But", "continuing", "with", "the", "S_call_", "NUMBER", "approach", "was", "the", "path", "of", "least", "resistance", "NUMBER", "mflatt", "You", "could", "put", "in", "a", "ftype", "guardian", "in", "the", "collector", "NUMBER", "It", "already", "close", "forgotten", "ports", "use", "a", "guardian", "LINK", "L", "NUMBER", "gwatt", "Thanks", "for", "the", "suggestion", "If", "I", "understand", "you", "mean", "registering", "the", "fptr", "that", "was", "created", "to", "wrap", "the", "address", "to", "free", "the", "malloc", "ed", "address", "NUMBER", "I", "worry", "about", "that", "indirection", "since", "the", "same", "address", "might", "be", "wrapped", "by", "a", "different", "fptr", "to", "cast", "it", "and", "then", "a", "programmer", "would", "have", "to", "take", "special", "care", "to", "keep", "the", "original", "fptr", "live", "as", "long", "as", "the", "new", "fptr", "be", "use", "NUMBER", "Also", "finalization", "doesn", "t", "currently", "compose", "well", "when", "a", "finalization", "action", "for", "some", "other", "object", "needs", "to", "use", "a", "finalized", "fptr", "although", "NUMBER", "be", "an", "effort", "to", "address", "that", "kind", "of", "problem", "NUMBER", "The", "latest", "patch", "include", "test", "and", "doc", "update", "NUMBER", "It", "support", "x", "NUMBER", "and", "x", "NUMBER", "_", "NUMBER", "on", "Linux", "Windows", "Mac", "OS", "and", "probably", "other", "Unix", "variants", "NUMBER", "The", "latest", "version", "be", "a", "good", "candidate", "for", "merge", "NUMBER", "Based", "on", "a", "suggestion", "from", "Kent", "the", "latest", "implementation", "treats", "a", "ftype", "result", "as", "an", "extra", "ftype", "initial", "argument", "which", "eliminates", "the", "implicit", "calls", "to", "malloc", "and", "free", "NUMBER", "When", "a", "program", "invokes", "a", "foreign", "procedure", "with", "a", "ftype", "the", "program", "allocates", "and", "provides", "a", "ftype", "argument", "before", "the", "normal", "argument", "and", "the", "result", "of", "the", "foreign", "procedure", "be", "unspecified", "NUMBER", "A", "callable", "with", "a", "ftype", "result", "should", "accept", "an", "extra", "ftype", "first", "argument", "to", "receive", "the", "result", "and", "the", "callable", "s", "direct", "result", "be", "ignored", "NUMBER", "A", "callable", "s", "ftype", "argument", "correspond", "to", "ftype", "argument", "that", "be", "valid", "only", "during", "the", "dynamic", "extent", "of", "the", "callable", "invocation", "because", "the", "associated", "address", "be", "on", "the", "stack", "or", "provide", "by", "the", "C", "caller", "NUMBER", "The", "key", "to", "avoiding", "implicit", "malloc", "and", "free", "with", "the", "new", "protocol", "was", "to", "get", "rid", "of", "the", "tail", "call", "S_call_", "NUMBER", "zoo", "replacing", "it", "with", "a", "non", "tail", "call", "to", "S_call_one_value", "or", "S_call_any_values", "plus", "a", "direct", "implementation", "of", "return", "values", "in", "each", "backend", "NUMBER", "All", "backends", "be", "implement", "x", "NUMBER", "x", "NUMBER", "_", "NUMBER", "ppc", "NUMBER", "and", "arm", "NUMBER", "Two", "bug", "On", "i", "NUMBER", "nt", "I", "must", "have", "overlooked", "__stdcall", "test", "failures", "NUMBER", "There", "s", "a", "NUMBER", "on", "line", "NUMBER", "of", "x", "NUMBER", "ss", "that", "should", "be", "init", "stack", "offset", "NUMBER", "On", "ppc", "NUMBER", "le", "the", "pointer", "to", "fill", "for", "a", "NUMBER", "result", "be", "stashed", "too", "deeply", "on", "the", "stack", "NUMBER", "The", "frame", "size", "on", "lines", "NUMBER", "NUMBER", "and", "NUMBER", "should", "be", "the", "original", "frame", "size", "from", "line", "NUMBER", "instead", "of", "the", "shadowing", "binding", "on", "line", "NUMBER", "These", "bug", "be", "fix", "in", "NUMBER", "I", "could", "move", "the", "repairs", "to", "here", "but", "it", "may", "make", "more", "sense", "to", "just", "consider", "the", "patches", "together", "NUMBER", "If", "I", "understand", "what", "you", "mean", "I", "think", "it", "would", "work", "to", "treat", "an", "ftype", "name", "for", "a", "struct", "or", "union", "differently", "from", "other", "ftype", "names", "NUMBER", "I", "don", "t", "think", "it", "would", "work", "to", "treat", "every", "ftype", "name", "as", "implicitly", "use", "the", "current", "NUMBER", "For", "example", "if", "I", "define", "define", "ftype", "NSUInteger", "unsigned", "long", "then", "when", "specify", "NSUInteger", "as", "a", "function", "argument", "type", "I", "would", "want", "to", "pass", "a", "number", "to", "the", "foreign", "procedure", "not", "a", "pointer", "to", "memory", "containing", "an", "integer", "NUMBER", "I", "see", "no", "problem", "with", "NSUInteger", "or", "base", "types", "if", "only", "struct", "union", "ftype", "names", "be", "treated", "as", "implying", "a", "NUMBER", "Racket", "s", "FFI", "do", "treat", "a", "struct", "union", "argument", "result", "type", "as", "implicitly", "having", "but", "it", "also", "manages", "storage", "differently", "for", "results", "or", "callable", "argument", "NUMBER", "Racket", "s", "FFI", "allocates", "GC", "managed", "memory", "for", "those", "structs", "unions", "so", "a", "function", "type", "that", "returns", "a", "struct", "union", "still", "corresponds", "to", "a", "function", "that", "returns", "one", "allocated", "result", "NUMBER", "I", "ve", "implement", "Racket", "s", "FFI", "on", "top", "of", "Chez", "Scheme", "s", "FFI", "use", "bytevectors", "but", "it", "requires", "copying", "and", "at", "least", "for", "now", "object", "locking", "and", "some", "worse", "trickery", "NUMBER", "With", "the", "memory", "management", "strategy", "in", "this", "patch", "seems", "more", "uniform", "and", "a", "better", "signal", "to", "readers", "in", "a", "foreign", "procedure", "specification", "NUMBER", "For", "example", "the", "in", "foreign", "procedure", "reel_one_in", "fish_t", "helps", "highlight", "that", "the", "resulting", "function", "takes", "one", "argument", "and", "returns", "no", "results", "NUMBER", "In", "contrast", "foreign", "procedure", "reel_one_in", "fish_t", "looks", "like", "a", "function", "that", "takes", "zero", "argument", "and", "returns", "one", "result", "but", "that", "wouldn", "t", "be", "true", "if", "fish_t", "be", "defined", "as", "a", "struct", "or", "union", "type", "that", "implies", "NUMBER", "Either", "way", "works", "for", "me", "but", "unless", "there", "s", "a", "better", "overall", "design", "point", "I", "recommend", "keep", "the", "explicit", "as", "a", "reminder", "of", "memory", "management", "obligations", "NUMBER", "This", "would", "be", "very", "helpful", "for", "me", "be", "there", "any", "way", "in", "which", "I", "can", "help", "with", "the", "work", "to", "get", "this", "into", "mainline", "chez", "I", "just", "cloned", "mflatt", "fp", "struct", "and", "run", "NUMBER", "configure", "make", "it", "stopped", "with", "the", "following", "error", "NUMBER", "if", "cmp", "s", "NUMBER", "boot", "a", "NUMBER", "le", "equates", "NUMBER", "h", "NUMBER", "boot", "a", "NUMBER", "le", "equates", "NUMBER", "h", "NUMBER", "bak", "then", "mv", "f", "NUMBER", "boot", "a", "NUMBER", "le", "equates", "NUMBER", "h", "NUMBER", "bak", "NUMBER", "boot", "a", "NUMBER", "le", "equates", "NUMBER", "h", "else", "rm", "f", "NUMBER", "boot", "a", "NUMBER", "le", "equates", "NUMBER", "h", "NUMBER", "bak", "fi", "Exception", "in", "fasl", "file", "equal", "gensym", "comparison", "fail", "while", "comparing", "NUMBER", "boot", "a", "NUMBER", "le", "sbb", "and", "NUMBER", "boot", "a", "NUMBER", "le", "petite", "NUMBER", "boot", "within", "fasl", "entry", "NUMBER", "make", "NUMBER", "Mf", "base", "NUMBER", "checkboot", "Error", "NUMBER", "make", "NUMBER", "Mf", "base", "NUMBER", "allx", "Error", "NUMBER", "make", "NUMBER", "Mf", "base", "NUMBER", "bootstrap", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "build", "Error", "NUMBER", "Am", "I", "build", "incorrectly", "I", "have", "a", "normal", "chez", "scheme", "install", "system", "wide", "be", "there", "some", "interference", "ecraven", "That", "check", "fail", "because", "the", "patch", "doesn", "t", "include", "update", "bootfiles", "NUMBER", "But", "you", "probably", "have", "a", "work", "build", "and", "run", "make", "again", "will", "normally", "succeed", "NUMBER", "Thanks", "that", "worked", "NUMBER", "I", "ll", "try", "wrapping", "some", "of", "CSFML", "to", "see", "how", "things", "work", "mflatt", "thanks", "for", "the", "hint", "works", "fine", "no", "problem", "with", "a", "few", "struct", "parameters", "and", "return", "values", "in", "CSFML", "so", "far", "NUMBER", "That", "makes", "sense", "NUMBER", "I", "had", "not", "worked", "out", "that", "it", "previously", "could", "make", "sense", "to", "pass", "a", "callable", "without", "locking", "it", "NUMBER", "Should", "the", "necessary", "locking", "be", "add", "to", "the", "callable", "s", "implementation", "instead", "of", "adjusting", "the", "requirements", "on", "program", "and", "the", "test", "case", "The", "new", "commit", "be", "intended", "to", "fix", "locking", "for", "the", "non", "tail", "call", "to", "the", "C", "helper", "NUMBER", "Repair", "applied", "thanks", "Rebased", "and", "squashed", "including", "repairs", "for", "the", "two", "bug", "noted", "on", "Jan", "NUMBER", "Is", "it", "possible", "to", "add", "support", "for", "translating", "a", "library", "name", "reference", "like", "srfi", "NUMBER", "to", "a", "safe", "pathname", "stem", "like", "srfi", "NUMBER", "a", "NUMBER", "like", "other", "implementations", "do", "It", "be", "a", "matter", "of", "use", "code", "like", "the", "following", "to", "translate", "symbols", "in", "the", "library", "name", "into", "directory", "pathname", "components", "scheme", "r", "NUMBER", "rs", "import", "rnrs", "NUMBER", "only", "chezscheme", "pretty", "print", "define", "compose", "stem", "id", "define", "display", "hex", "N", "port", "if", "fx", "TAG", "char", "fx", "char", "integer", "a", "fx", "N", "NUMBER", "port", "let", "values", "port", "extract", "open", "string", "output", "port", "let", "next", "component", "id", "car", "id", "id", "cdr", "id", "write", "char", "port", "for", "each", "lambda", "N", "Only", "characters", "in", "the", "ranges", "a", "z", "A", "Z", "NUMBER", "NUMBER", "plus", "be", "left", "untouched", "everything", "else", "be", "encoded", "in", "a", "percent", "sequence", "NUMBER", "if", "or", "fx", "TAG", "integer", "a", "N", "char", "integer", "z", "fx", "TAG", "integer", "A", "N", "char", "integer", "Z", "fx", "TAG", "integer", "NUMBER", "N", "char", "integer", "NUMBER", "fx", "N", "char", "integer", "write", "char", "integer", "char", "N", "port", "let", "values", "D", "M", "div", "and", "mod", "N", "NUMBER", "write", "char", "port", "display", "hex", "D", "port", "display", "hex", "M", "port", "bytevector", "u", "NUMBER", "list", "string", "utf", "NUMBER", "symbol", "string", "id", "if", "pair", "id", "next", "component", "car", "id", "cdr", "id", "extract", "pretty", "print", "compose", "stem", "srfi", "NUMBER", "lists", "current", "error", "port", "pretty", "print", "compose", "stem", "A", "NUMBER", "_", "Z", "TAG", "current", "error", "port", "The", "in", "file", "pathnames", "be", "also", "troublesome", "in", "Makefiles", "where", "it", "must", "be", "quoted", "with", "a", "backslash", "the", "same", "goes", "for", "command", "line", "completion", "in", "some", "Unix", "shells", "NUMBER", "I", "will", "try", "to", "port", "my", "SRFI", "collection", "to", "Chez", "use", "quoted", "in", "Makefiles", "and", "see", "how", "it", "feels", "NUMBER", "Writing", "build", "scripts", "with", "alphanumeric", "file", "pathnames", "only", "be", "for", "sure", "easier", "NUMBER", "Is", "this", "a", "matter", "of", "priority", "Do", "we", "favour", "build", "scripts", "comfortability", "or", "of", "file", "names", "expressiveness", "We", "need", "to", "remember", "that", "only", "developers", "not", "end", "users", "need", "to", "look", "at", "file", "names", "in", "NUMBER", "of", "cases", "NUMBER", "The", "file", "BUILDING", "has", "no", "instructions", "about", "how", "to", "build", "and", "install", "documentation", "NUMBER", "With", "a", "checkout", "up", "to", "commit", "b", "NUMBER", "e", "NUMBER", "ef", "NUMBER", "c", "NUMBER", "f", "NUMBER", "e", "NUMBER", "f", "NUMBER", "aede", "NUMBER", "a", "NUMBER", "d", "NUMBER", "c", "NUMBER", "f", "NUMBER", "if", "I", "do", "make", "docs", "I", "get", "this", "make", "docs", "cd", "a", "NUMBER", "le", "make", "build", "cd", "c", "make", "make", "NUMBER", "Nothing", "to", "be", "do", "for", "doit", "NUMBER", "cd", "s", "make", "bootstrap", "make", "NUMBER", "bootstrap", "be", "up", "to", "date", "NUMBER", "cd", "csug", "make", "m", "a", "NUMBER", "le", "NUMBER", "a", "NUMBER", "le", "bin", "a", "NUMBER", "le", "scheme", "b", "NUMBER", "a", "NUMBER", "le", "boot", "a", "NUMBER", "le", "petite", "NUMBER", "boot", "b", "NUMBER", "a", "NUMBER", "le", "boot", "a", "NUMBER", "le", "scheme", "NUMBER", "boot", "libdirs", "NUMBER", "stex", "src", "program", "NUMBER", "stex", "src", "scheme", "prep", "NUMBER", "ss", "tspl", "NUMBER", "prep", "csug", "Exception", "library", "dsm", "not", "find", "NUMBER", "stex", "Mf", "stex", "NUMBER", "recipe", "for", "target", "csug", "NUMBER", "tex", "fail", "make", "NUMBER", "csug", "NUMBER", "tex", "Error", "NUMBER", "Makefile", "NUMBER", "recipe", "for", "target", "docs", "fail", "make", "docs", "Error", "NUMBER", "I", "have", "not", "looked", "at", "the", "code", "yet", "would", "it", "be", "feasible", "to", "write", "a", "back", "end", "for", "the", "documentation", "system", "to", "produce", "a", "different", "output", "format", "Was", "the", "system", "write", "for", "this", "Yes", "we", "should", "probably", "add", "some", "instructions", "but", "in", "general", "make", "docs", "should", "just", "work", "NUMBER", "The", "library", "dsm", "NUMBER", "ss", "should", "be", "in", "the", "stex", "submodule", "that", "lands", "in", "the", "stex", "directory", "so", "the", "libdirs", "NUMBER", "stex", "src", "should", "be", "able", "to", "find", "it", "NUMBER", "Is", "it", "possible", "you", "have", "set", "CHEZSCHEMELIBEXTS", "to", "something", "that", "do", "not", "include", "ss", "before", "trying", "the", "build", "Yes", "this", "bites", "me", "again", "and", "again", "NUMBER", "But", "now", "I", "get", "this", "with", "the", "latest", "commit", "NUMBER", "use", "canned", "cisco", "logo", "large", "NUMBER", "png", "NUMBER", "usr", "local", "texlive", "NUMBER", "texmf", "var", "fonts", "ma", "p", "pdftex", "updmap", "pdftex", "NUMBER", "map", "TAG", "NUMBER", "copyright", "NUMBER", "tex", "usr", "local", "texlive", "NUMBER", "texmf", "dist", "tex", "latex", "base", "omscmr", "NUMBER", "fd", "Undefined", "control", "sequence", "NUMBER", "l", "NUMBER", "Revised", "INSERTREVISIONMONTHSPACEYEAR", "for", "Chez", "Scheme", "Version", "NUMBER", "use", "this", "build", "script", "bin", "bash", "Informal", "build", "script", "for", "Chez", "Scheme", "export", "CHEZSCHEMELIBEXTS", "NUMBER", "chezscheme", "NUMBER", "sls", "NUMBER", "chezscheme", "NUMBER", "ss", "NUMBER", "sls", "NUMBER", "ss", "export", "CHEZSCHEMELIBDIRS", "unset", "CHEZSCHEMELIBDIRS", "PREFIX", "opt", "chez", "scheme", "NUMBER", "CHEZ_INSTALL_SUFFIX", "make", "clean", "make", "distclean", "git", "clean", "xfd", "NUMBER", "configure", "installprefix", "PREFIX", "installowner", "root", "installgroup", "root", "installschemename", "chez", "installpetitename", "petite", "chez", "CFLAGS", "O", "NUMBER", "Wno", "maybe", "uninitialized", "CPPFLAGS", "I", "usr", "local", "include", "LDFLAGS", "L", "usr", "local", "lib", "NUMBER", "liconv", "make", "make", "docs", "end", "of", "file", "Still", "fail", "with", "commit", "c", "NUMBER", "c", "NUMBER", "cc", "NUMBER", "b", "NUMBER", "cc", "NUMBER", "d", "NUMBER", "cf", "NUMBER", "fbd", "NUMBER", "c", "NUMBER", "c", "NUMBER", "Do", "I", "need", "to", "install", "a", "git", "hook", "or", "something", "like", "that", "Yes", "Build", "succeeds", "with", "commit", "NUMBER", "febe", "NUMBER", "b", "NUMBER", "a", "NUMBER", "e", "NUMBER", "cde", "NUMBER", "b", "NUMBER", "be", "NUMBER", "bc", "NUMBER", "ee", "NUMBER", "b", "NUMBER", "afd", "NUMBER", "c", "NUMBER", "Now", "ahem", "be", "there", "no", "make", "install", "doc", "rule", "I", "notice", "that", "after", "run", "make", "docs", "if", "I", "do", "a", "git", "status", "I", "see", "a", "number", "of", "file", "not", "tracked", "by", "git", "but", "not", "ignored", "through", "NUMBER", "gitignore", "NUMBER", "A", "purist", "would", "say", "that", "this", "should", "not", "happen", "NUMBER", "On", "Unix", "like", "systems", "I", "suggest", "prefix", "share", "doc", "csv", "TAG", "that", "s", "where", "stuff", "goes", "on", "my", "Slackware", "installation", "and", "it", "be", "also", "the", "one", "selected", "by", "the", "GNU", "Autotools", "minus", "the", "version", "number", "NUMBER", "I", "cannot", "help", "for", "Windows", "NUMBER", "I", "correct", "myself", "the", "doc", "directory", "pathname", "should", "be", "prefix", "share", "doc", "csv", "TAG", "or", "the", "more", "explicit", "prefix", "share", "doc", "ChezScheme", "TAG", "with", "a", "dash", "between", "the", "package", "name", "and", "the", "version", "number", "NUMBER", "This", "be", "so", "for", "Slackware", "NUMBER", "Separate", "NUMBER", "and", "NUMBER", "bit", "MSIs", "Add", "wix", "bundle", "to", "combine", "MSIs", "into", "single", "installer", "Use", "basic", "wix", "UI", "Use", "merge", "modules", "to", "install", "vcredist", "package", "Add", "script", "to", "locate", "vcredist", "merge", "modules", "Fix", "installer", "status", "text", "by", "add", "WixUI_ErrorProgressText", "ref", "Merge", "modules", "seems", "to", "be", "the", "preferred", "method", "for", "installing", "the", "redistributable", "package", "which", "should", "decrease", "the", "package", "size", "and", "speed", "up", "installation", "NUMBER", "This", "commit", "also", "address", "a", "bug", "where", "the", "installer", "do", "not", "work", "when", "VC", "redistributable", "be", "not", "already", "install", "NUMBER", "The", "NUMBER", "and", "NUMBER", "bit", "components", "were", "split", "into", "separate", "MSIs", "because", "Windows", "Installer", "only", "officially", "support", "package", "containing", "a", "single", "architecture", "NUMBER", "A", "package", "bundle", "be", "then", "created", "containing", "both", "MSIs", "so", "only", "a", "single", "file", "needs", "to", "be", "distributed", "NUMBER", "There", "seem", "to", "be", "no", "trivial", "way", "to", "get", "the", "path", "to", "the", "vcredist", "merge", "modules", "bundled", "with", "visual", "studio", "so", "I", "add", "a", "script", "locate", "vcredist", "NUMBER", "bat", "that", "handles", "this", "NUMBER", "It", "will", "need", "to", "be", "update", "in", "the", "future", "for", "compatibility", "with", "newer", "VS", "platform", "toolsets", "NUMBER", "Some", "paths", "and", "name", "were", "change", "here", "s", "a", "summary", "NUMBER", "bit", "install", "path", "C", "Program", "Files", "x", "NUMBER", "Chez", "Scheme", "NUMBER", "NUMBER", "bit", "install", "path", "C", "Program", "Files", "Chez", "Scheme", "NUMBER", "installer", "file", "name", "ChezScheme", "NUMBER", "exe", "installer", "product", "name", "Chez", "Scheme", "NUMBER", "x", "NUMBER", "This", "ended", "up", "be", "much", "more", "complicated", "that", "what", "I", "originally", "set", "out", "to", "build", "NUMBER", "Let", "me", "know", "if", "anyone", "has", "any", "suggestions", "to", "trim", "it", "down", "NUMBER", "Dropping", "a", "registry", "key", "point", "to", "the", "install", "location", "would", "provide", "a", "robust", "way", "to", "find", "scheme", "NUMBER", "exe", "especially", "if", "multiple", "version", "be", "install", "NUMBER", "The", "NUMBER", "installer", "has", "a", "handy", "Add", "to", "path", "option", "be", "that", "something", "we", "still", "want", "Will", "anyone", "want", "multiple", "different", "version", "of", "Chez", "install", "at", "one", "time", "How", "should", "we", "handle", "this", "Currently", "only", "one", "NUMBER", "bit", "and", "one", "NUMBER", "bit", "installation", "be", "allow", "and", "installing", "a", "newer", "version", "be", "treated", "as", "an", "upgrade", "NUMBER", "I", "haven", "t", "test", "this", "Bash", "WSL", "since", "I", "don", "t", "have", "that", "environment", "set", "up", "NUMBER", "Does", "it", "work", "In", "order", "for", "ChezScheme", "to", "compile", "it", "needs", "comparatively", "large", "binary", "file", "to", "bootstrap", "the", "system", "first", "NUMBER", "Right", "now", "these", "file", "be", "include", "in", "the", "git", "repo", "itself", "and", "update", "frequently", "NUMBER", "Due", "to", "the", "way", "binary", "file", "be", "handle", "by", "git", "this", "effectively", "be", "cause", "massive", "size", "ballooning", "in", "the", "size", "of", "a", "full", "git", "repo", "at", "last", "count", "I", "saw", "the", "NUMBER", "git", "repo", "occupying", "almost", "a", "full", "gigabyte", "NUMBER", "As", "the", "repo", "be", "now", "hosted", "on", "github", "would", "it", "be", "feasible", "to", "move", "over", "to", "use", "github", "s", "binary", "release", "system", "LINK", "large", "binaries", "This", "would", "allow", "the", "git", "repo", "to", "remain", "binary", "file", "free", "while", "still", "make", "it", "feasible", "to", "compile", "the", "system", "from", "scratch", "NUMBER", "If", "something", "like", "this", "be", "not", "do", "then", "the", "git", "repo", "runs", "the", "risk", "of", "becoming", "unmanageable", "in", "size", "as", "it", "would", "effectively", "contain", "a", "full", "backup", "of", "every", "binary", "for", "every", "system", "ever", "release", "NUMBER", "This", "would", "indeed", "be", "useful", "NUMBER", "It", "s", "worth", "looking", "into", "because", "having", "boot", "file", "in", "the", "repo", "be", "definitely", "a", "problem", "and", "we", "haven", "t", "yet", "come", "up", "with", "a", "different", "solution", "NUMBER", "That", "would", "force", "us", "to", "create", "new", "release", "every", "time", "the", "uploaded", "boot", "file", "need", "to", "be", "rebuilt", "which", "be", "less", "often", "than", "we", "currently", "rebuild", "them", "NUMBER", "If", "this", "be", "pursued", "I", "would", "recommend", "update", "the", "build", "process", "to", "be", "able", "to", "compile", "use", "the", "system", "install", "ChezScheme", "file", "for", "people", "who", "have", "already", "build", "it", "once", "NUMBER", "Or", "at", "least", "make", "it", "default", "if", "this", "be", "already", "possible", "last", "time", "I", "recompiled", "I", "remember", "its", "still", "needing", "the", "boot", "file", "instead", "of", "use", "my", "already", "install", "version", "mine", "could", "ve", "be", "too", "out", "of", "date", "or", "something", "though", "NUMBER", "One", "caveat", "to", "this", "be", "that", "to", "my", "knowledge", "the", "release", "archives", "git", "creates", "do", "not", "include", "the", "git", "repo", "itself", "as", "in", "the", "NUMBER", "git", "directory", "NUMBER", "akeep", "and", "I", "have", "discussed", "several", "potential", "solutions", "for", "this", "issue", "none", "of", "them", "ideal", "and", "none", "of", "them", "fully", "test", "NUMBER", "Comments", "and", "corrections", "on", "these", "potential", "solutions", "and", "suggestions", "for", "others", "be", "welcome", "NUMBER", "NUMBER", "Leave", "the", "full", "set", "of", "boot", "file", "in", "the", "main", "repository", "NUMBER", "We", "want", "to", "store", "the", "full", "set", "of", "boot", "file", "somewhere", "and", "the", "main", "repository", "be", "the", "obvious", "place", "NUMBER", "Encourage", "people", "to", "clone", "with", "depth", "NUMBER", "if", "they", "don", "t", "need", "the", "full", "repository", "NUMBER", "PROS", "This", "be", "the", "simplest", "solution", "NUMBER", "With", "depth", "NUMBER", "the", "time", "to", "clone", "and", "the", "amount", "of", "space", "be", "both", "small", "NUMBER", "CONS", "The", "full", "repo", "be", "still", "large", "and", "a", "full", "clone", "be", "slow", "and", "requires", "a", "lot", "of", "disk", "space", "problem", "that", "will", "only", "get", "worse", "NUMBER", "NUMBER", "Prune", "older", "boot", "file", "from", "the", "repository", "and", "archive", "them", "elsewhere", "NUMBER", "We", "d", "probably", "keep", "older", "boot", "file", "for", "a", "specific", "machine", "type", "say", "a", "NUMBER", "le", "since", "a", "build", "for", "any", "machine", "type", "can", "be", "use", "to", "build", "boot", "file", "for", "the", "other", "machine", "types", "NUMBER", "PROS", "This", "would", "keep", "the", "repository", "size", "reasonably", "small", "and", "doesn", "t", "require", "people", "to", "use", "depth", "NUMBER", "to", "get", "a", "reasonably", "quick", "and", "small", "clone", "NUMBER", "CONS", "This", "solution", "be", "more", "work", "for", "the", "committers", "and", "requires", "them", "to", "modify", "older", "commit", "which", "seems", "unclean", "and", "dangerous", "NUMBER", "It", "complicates", "the", "build", "of", "older", "commit", "NUMBER", "We", "d", "have", "to", "find", "somewhere", "else", "to", "store", "older", "boot", "file", "NUMBER", "NUMBER", "Use", "github", "s", "large", "file", "support", "for", "boot", "file", "NUMBER", "PROS", "This", "reduces", "the", "size", "of", "a", "clone", "NUMBER", "CONS", "This", "doesn", "t", "reduce", "overall", "repository", "size", "NUMBER", "It", "requires", "the", "use", "of", "a", "different", "tool", "chain", "and", "a", "normal", "git", "clone", "will", "not", "produce", "a", "buildable", "clone", "NUMBER", "NUMBER", "Create", "a", "separate", "project", "for", "the", "boot", "file", "treat", "it", "as", "a", "submodule", "and", "have", "the", "configure", "script", "use", "depth", "NUMBER", "when", "it", "do", "the", "submodule", "init", "NUMBER", "Thanks", "to", "jamtaylo", "for", "this", "suggestion", "NUMBER", "PROS", "This", "reduces", "the", "size", "of", "the", "main", "repo", "to", "the", "space", "required", "just", "for", "the", "source", "code", "history", "and", "it", "reduces", "the", "size", "of", "a", "simple", "non", "recursive", "clone", "NUMBER", "CONS", "This", "be", "a", "bit", "more", "work", "for", "the", "committers", "NUMBER", "A", "recursive", "clone", "of", "the", "main", "repo", "without", "depth", "NUMBER", "will", "cause", "the", "entire", "boot", "file", "repo", "to", "be", "cloned", "NUMBER", "NUMBER", "As", "suggested", "by", "ultimatespirit", "in", "this", "issue", "LINK", "create", "a", "release", "each", "time", "the", "boot", "file", "change", "and", "upload", "boot", "file", "only", "as", "part", "of", "a", "release", "NUMBER", "Modify", "the", "build", "process", "either", "to", "require", "the", "appropriate", "release", "to", "be", "install", "or", "to", "download", "and", "build", "the", "appropriate", "release", "as", "part", "of", "build", "the", "current", "version", "NUMBER", "PROS", "This", "reduces", "the", "size", "of", "the", "main", "repo", "to", "the", "space", "required", "just", "for", "the", "source", "code", "history", "and", "it", "reduces", "the", "size", "of", "a", "clone", "NUMBER", "It", "reduces", "the", "chance", "that", "exist", "and", "possibly", "incompatible", "object", "file", "be", "use", "with", "a", "newer", "or", "older", "version", "NUMBER", "CONS", "This", "be", "more", "work", "for", "the", "committers", "and", "complicates", "the", "build", "scripts", "and", "process", "NUMBER", "It", "significantly", "increases", "the", "size", "of", "the", "repo", "as", "a", "whole", "since", "the", "release", "be", "required", "for", "build", "and", "be", "effectively", "part", "of", "the", "repo", "NUMBER", "Aside", "from", "these", "ideas", "we", "have", "come", "up", "with", "a", "couple", "of", "ways", "to", "reduce", "the", "number", "of", "boot", "file", "A", "Don", "t", "store", "boot", "file", "for", "the", "thread", "version", "since", "these", "can", "be", "created", "from", "the", "non", "thread", "version", "NUMBER", "This", "cuts", "the", "boot", "file", "storage", "requirements", "in", "half", "but", "complicates", "the", "build", "process", "NUMBER", "B", "Don", "t", "create", "new", "boot", "file", "as", "long", "as", "the", "exist", "set", "can", "still", "be", "use", "to", "compile", "the", "sources", "NUMBER", "At", "present", "we", "typically", "create", "new", "boot", "file", "after", "any", "change", "in", "the", "s", "directory", "NUMBER", "This", "requires", "some", "cleverness", "on", "the", "part", "of", "the", "committers", "to", "recognize", "when", "a", "change", "be", "not", "important", "NUMBER", "For", "example", "akeep", "chose", "not", "to", "create", "new", "boot", "file", "for", "the", "fx", "carry", "and", "company", "fix", "since", "these", "routines", "be", "not", "use", "in", "the", "compiler", "NUMBER", "This", "be", "error", "prone", "since", "fx", "carry", "might", "be", "use", "by", "the", "compiler", "in", "a", "subsequent", "commit", "NUMBER", "C", "Store", "only", "the", "boot", "file", "for", "one", "machine", "type", "say", "a", "NUMBER", "le", "NUMBER", "This", "would", "effectively", "eliminate", "the", "boot", "file", "storage", "problem", "but", "would", "require", "all", "cloners", "to", "have", "a", "Linux", "box", "or", "VM", "sitting", "around", "to", "build", "boot", "file", "NUMBER", "We", "did", "this", "before", "Chez", "Scheme", "was", "open", "sourced", "but", "only", "a", "handful", "of", "us", "were", "affected", "NUMBER", "Don", "t", "bother", "commenting", "on", "this", "option", "since", "it", "s", "not", "a", "serious", "suggestion", "just", "mention", "for", "completeness", "NUMBER", "B", "Don", "t", "create", "new", "boot", "file", "as", "long", "as", "the", "exist", "set", "can", "still", "be", "use", "to", "compile", "the", "sources", "NUMBER", "For", "what", "be", "worth", "I", "agree", "with", "this", "NUMBER", "This", "requires", "some", "cleverness", "on", "the", "part", "of", "the", "committers", "I", "have", "be", "bitten", "by", "this", "many", "times", "NUMBER", "But", "now", "you", "can", "use", "Travis", "CI", "to", "build", "a", "test", "boot", "file", "use", "a", "new", "boot", "file", "at", "every", "repository", "push", "it", "increases", "job", "execution", "time", "but", "life", "be", "hard", "NUMBER", "Is", "it", "possible", "to", "have", "non", "binary", "boot", "file", "xaengceilbiths", "Yes", "it", "be", "possible", "to", "have", "non", "binary", "boot", "file", "in", "fact", "there", "be", "a", "couple", "of", "different", "ways", "to", "do", "that", "NUMBER", "The", "simplest", "way", "to", "do", "this", "would", "be", "to", "take", "the", "exist", "binary", "file", "and", "encode", "them", "as", "text", "imagine", "use", "something", "like", "uuencoding", "LINK", "though", "we", "would", "likely", "want", "to", "define", "our", "own", "encoding", "NUMBER", "The", "hope", "here", "be", "that", "the", "binary", "file", "be", "relatively", "stable", "and", "the", "encoding", "of", "the", "binaries", "be", "also", "relatively", "stable", "so", "the", "change", "be", "minimized", "and", "the", "differences", "stored", "in", "the", "repository", "be", "hence", "minimized", "NUMBER", "dybvig", "and", "I", "experimented", "with", "this", "but", "find", "after", "trying", "a", "few", "encodings", "that", "this", "style", "text", "file", "was", "not", "helpful", "in", "reducing", "the", "size", "of", "the", "binary", "differences", "in", "fact", "if", "I", "recall", "correctly", "it", "pretty", "much", "made", "things", "worse", "which", "was", "a", "bit", "disappointing", "NUMBER", "Another", "way", "to", "do", "this", "would", "be", "to", "have", "an", "intermediate", "representation", "of", "the", "compiled", "code", "that", "be", "represented", "as", "text", "which", "Chez", "Scheme", "s", "run", "time", "can", "either", "interpret", "or", "finish", "the", "compilation", "of", "before", "run", "NUMBER", "This", "be", "a", "considerable", "amount", "of", "work", "and", "has", "some", "challenges", "NUMBER", "We", "would", "likely", "need", "to", "rework", "the", "machine", "type", "specific", "assemblers", "which", "be", "write", "in", "scheme", "so", "that", "the", "same", "type", "of", "work", "can", "be", "do", "without", "having", "the", "scheme", "binary", "around", "NUMBER", "If", "these", "file", "be", "machine", "independent", "we", "would", "also", "need", "to", "capture", "things", "like", "the", "machine", "specific", "foreign", "function", "interface", "code", "also", "write", "in", "scheme", "in", "the", "C", "run", "time", "NUMBER", "If", "these", "file", "be", "machine", "dependent", "then", "we", "would", "still", "need", "the", "same", "array", "of", "them", "and", "the", "text", "representation", "be", "going", "to", "be", "larger", "than", "the", "binary", "representation", "so", "the", "work", "checkout", "would", "be", "larger", "though", "hopefully", "the", "differences", "would", "be", "smaller", "NUMBER", "So", "I", "think", "a", "textual", "representation", "be", "a", "good", "idea", "but", "get", "there", "be", "a", "bit", "of", "a", "challenge", "NUMBER", "Here", "s", "another", "alternative", "NUMBER", "You", "can", "store", "each", "boot", "image", "along", "with", "a", "binary", "diff", "that", "will", "update", "it", "to", "the", "latest", "image", "NUMBER", "The", "bsdiff", "tool", "LINK", "be", "really", "good", "at", "creating", "such", "diffs", "NUMBER", "I", "did", "an", "experiment", "git", "show", "NUMBER", "d", "NUMBER", "boot", "a", "NUMBER", "le", "petite", "NUMBER", "boot", "petite", "current", "NUMBER", "boot", "NUMBER", "gz", "git", "show", "c", "NUMBER", "c", "NUMBER", "cc", "NUMBER", "boot", "a", "NUMBER", "le", "petite", "NUMBER", "boot", "petite", "previous", "NUMBER", "boot", "NUMBER", "gz", "gunzip", "petite", "NUMBER", "boot", "NUMBER", "gz", "bsdiff", "petite", "previous", "NUMBER", "boot", "petite", "current", "NUMBER", "boot", "petite", "NUMBER", "boot", "NUMBER", "bsdiff", "ls", "lh", "petite", "NUMBER", "boot", "NUMBER", "bsdiff", "rw", "r", "r", "NUMBER", "weinholt", "weinholt", "NUMBER", "K", "Nov", "NUMBER", "NUMBER", "NUMBER", "petite", "NUMBER", "boot", "NUMBER", "bsdiff", "The", "diff", "between", "the", "current", "and", "previous", "images", "be", "a", "mere", "NUMBER", "K", "which", "be", "easily", "stored", "in", "git", "NUMBER", "I", "m", "not", "sure", "if", "this", "be", "a", "representative", "result", "but", "it", "looks", "promising", "NUMBER", "The", "problem", "isn", "t", "storing", "binary", "file", "but", "rather", "that", "different", "version", "of", "binary", "file", "can", "be", "incredibly", "different", "with", "regards", "to", "diff", "tool", "from", "version", "to", "version", "NUMBER", "It", "seems", "bsdiff", "be", "designed", "to", "be", "hyper", "efficient", "at", "diffing", "binary", "file", "so", "the", "diff", "between", "two", "version", "would", "be", "small", "NUMBER", "However", "the", "question", "then", "becomes", "what", "be", "the", "diff", "between", "two", "diffs", "like", "That", "be", "given", "N", "boot", "images", "you", "would", "have", "to", "store", "N", "NUMBER", "diffs", "if", "each", "diff", "be", "significantly", "different", "from", "each", "other", "then", "you", "end", "up", "storing", "each", "diff", "individually", "in", "the", "repo", "instead", "of", "the", "deltas", "between", "them", "NUMBER", "Have", "you", "test", "the", "difference", "between", "multiple", "bsdiffs", "ultimatespirit", "Do", "you", "mean", "doing", "a", "bsdiff", "of", "two", "bsdiffs", "I", "m", "guessing", "it", "will", "not", "give", "good", "results", "since", "the", "bsdiffs", "be", "compressed", "NUMBER", "One", "would", "indeed", "have", "to", "store", "multiple", "diffs", "in", "some", "way", "perhaps", "with", "a", "reset", "of", "the", "base", "boot", "image", "every", "now", "and", "then", "NUMBER", "You", "d", "probably", "store", "bsdiff", "base", "base", "NUMBER", "NUMBER", "bsdiff", "base", "N", "NUMBER", "base", "N", "NUMBER", "With", "luck", "if", "the", "NUMBER", "K", "result", "be", "typical", "then", "with", "bsdiff", "you", "d", "be", "storing", "a", "diff", "which", "be", "in", "the", "same", "order", "of", "magnitude", "as", "the", "code", "change", "themselves", "although", "one", "per", "machine", "type", "NUMBER", "Why", "not", "create", "a", "scheme", "c", "translator", "for", "chez", "scheme", "just", "joking", "or", "not", "then", "there", "would", "not", "be", "need", "for", "boot", "file", "Another", "possibility", "albeit", "highly", "unlikely", "to", "be", "practical", "would", "be", "to", "convert", "the", "compiler", "code", "a", "micro", "compiler", "to", "LLVM", "IR", "and", "distribute", "that", "to", "be", "bootstrapped", "into", "the", "first", "scheme", "compiler", "to", "finish", "the", "rest", "of", "the", "compilation", "with", "NUMBER", "A", "big", "pro", "to", "this", "would", "be", "that", "LLVM", "IR", "be", "platform", "independent", "so", "we", "would", "not", "need", "to", "have", "multiple", "platform", "binary", "version", "so", "long", "as", "LLVM", "itself", "support", "the", "platform", "NUMBER", "Of", "course", "this", "would", "rely", "on", "a", "hope", "that", "the", "LLVM", "IR", "would", "change", "little", "between", "version", "or", "at", "least", "be", "significantly", "smaller", "than", "the", "compiled", "binaries", "otherwise", "it", "would", "only", "replace", "the", "problem", "with", "something", "else", "NUMBER", "Out", "of", "curiosity", "be", "it", "know", "what", "minimal", "feature", "set", "of", "chez", "scheme", "would", "be", "required", "to", "bootstrap", "the", "compiler", "If", "it", "isn", "t", "too", "large", "a", "c", "llvm", "microcompiler", "to", "begin", "bootstrapping", "from", "may", "not", "be", "too", "far", "fetched", "NUMBER", "If", "it", "s", "large", "perhaps", "boot", "strapping", "from", "older", "version", "up", "would", "work", "though", "not", "very", "practical", "I", "know", "NUMBER", "Unfortunately", "LLVM", "IR", "be", "not", "platform", "independent", "or", "portable", "NUMBER", "It", "looks", "like", "it", "be", "semi", "support", "NUMBER", "It", "be", "now", "enable", "by", "default", "on", "they", "Linux", "images", "but", "has", "to", "be", "install", "via", "homebrew", "on", "the", "Mac", "OS", "images", "so", "we", "ll", "need", "to", "update", "the", "travis", "ci", "config", "to", "set", "this", "up", "on", "the", "mac", "build", "before", "we", "build", "NUMBER", "There", "be", "some", "mention", "of", "authentication", "here", "but", "I", "m", "not", "sure", "what", "it", "refers", "to", "we", "might", "need", "to", "experiment", "with", "it", "a", "bit", "to", "get", "it", "work", "NUMBER", "I", "like", "the", "idea", "of", "a", "solution", "like", "this", "as", "long", "installing", "git", "lfs", "isn", "t", "deemed", "to", "be", "too", "big", "a", "bar", "to", "get", "over", "NUMBER", "Certainly", "I", "like", "the", "idea", "of", "this", "over", "build", "our", "own", "support", "for", "something", "like", "this", "NUMBER", "andy", "On", "August", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "NUMBER", "PM", "Bob", "Burger", "notifications", "github", "NUMBER", "com", "write", "I", "install", "Git", "Large", "File", "Storage", "TAG", "and", "it", "integrated", "seamlessly", "with", "git", "NUMBER", "I", "then", "run", "git", "lfs", "migrate", "import", "include", "NUMBER", "boot", "include", "ref", "refs", "heads", "master", "to", "rewrite", "the", "master", "branch", "use", "LFS", "NUMBER", "I", "push", "the", "result", "to", "LINK", "Running", "git", "clone", "on", "this", "repository", "downloaded", "a", "mere", "NUMBER", "MB", "and", "still", "allows", "me", "to", "go", "back", "in", "time", "and", "retrieve", "the", "boot", "file", "NUMBER", "akeep", "TAG", "do", "TravisCI", "work", "with", "GitHub", "s", "large", "file", "support", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "I", "ve", "be", "trying", "to", "build", "and", "run", "Chez", "in", "a", "container", "so", "support", "for", "Visual", "Studio", "BuildTools", "would", "be", "nice", "NUMBER", "I", "have", "not", "yet", "successfully", "use", "VS", "s", "BuildTools", "to", "produce", "a", "build", "that", "pass", "all", "the", "mats", "and", "I", "d", "be", "happy", "to", "sit", "on", "this", "PR", "until", "I", "can", "prove", "it", "all", "works", "NUMBER", "Current", "mat", "summary", "LINK", "Squashing", "on", "the", "pull", "request", "branch", "cause", "some", "confusion", "but", "should", "be", "good", "to", "go", "NUMBER", "Everything", "seems", "to", "work", "until", "you", "try", "to", "execute", "make", "workareas", "which", "ends", "up", "cause", "a", "file", "not", "find", "error", "NUMBER", "When", "I", "run", "things", "with", "Cygwin", "everything", "seem", "to", "work", "fine", "though", "I", "had", "to", "start", "over", "from", "scratch", "NUMBER", "cc", "mflatt", "This", "be", "still", "work", "in", "progress", "so", "the", "file", "still", "have", "some", "unnecessary", "comments", "and", "rough", "parts", "but", "it", "s", "already", "big", "and", "I", "think", "I", "need", "some", "feedback", "before", "continuing", "NUMBER", "In", "general", "this", "change", "be", "useful", "with", "optimization", "level", "NUMBER", "because", "most", "of", "the", "type", "checks", "be", "skipped", "in", "level", "NUMBER", "The", "idea", "was", "to", "reduce", "most", "common", "idioms", "for", "example", "lambda", "x", "vector", "set", "x", "NUMBER", "NUMBER", "vector", "x", "lambda", "x", "vector", "set", "x", "NUMBER", "NUMBER", "t", "lambda", "x", "when", "vector", "x", "vector", "x", "lambda", "x", "when", "vector", "x", "t", "lambda", "x", "when", "vector", "x", "box", "x", "lambda", "x", "when", "vector", "x", "f", "lambda", "x", "unless", "vector", "x", "error", "e", "vector", "x", "lambda", "x", "unless", "vector", "x", "error", "e", "t", "More", "examples", "of", "the", "reductions", "be", "in", "the", "first", "part", "of", "cptypes", "NUMBER", "ms", "The", "main", "part", "of", "the", "code", "be", "in", "cptypes", "NUMBER", "ss", "NUMBER", "It", "has", "an", "explanation", "of", "the", "parameters", "of", "the", "main", "function", "at", "the", "beginning", "of", "the", "file", "NUMBER", "Some", "auxiliary", "function", "be", "copied", "from", "cp", "NUMBER", "ss", "NUMBER", "There", "be", "also", "an", "hamt", "implementation", "in", "hamt", "NUMBER", "ss", "NUMBER", "It", "s", "necessary", "to", "get", "fast", "lookup", "of", "the", "discover", "types", "NUMBER", "The", "first", "commit", "be", "just", "to", "recalculate", "automatically", "the", "bootfiles", "in", "travis", "ci", "NUMBER", "It", "s", "handy", "for", "test", "while", "write", "the", "initial", "version", "but", "my", "idea", "be", "to", "remove", "revert", "it", "in", "the", "final", "version", "NUMBER", "The", "second", "commit", "add", "the", "signature", "information", "available", "in", "primdata", "NUMBER", "ss", "to", "the", "primref", "NUMBER", "so", "the", "other", "parts", "of", "the", "code", "can", "use", "it", "NUMBER", "This", "step", "be", "tricky", "so", "I", "left", "it", "in", "an", "isolated", "commit", "but", "my", "plan", "be", "to", "squash", "it", "in", "the", "final", "version", "NUMBER", "The", "third", "commit", "has", "the", "bootfiles", "NUMBER", "The", "last", "commit", "be", "the", "main", "part", "of", "the", "implementation", "NUMBER", "I", "read", "the", "preprint", "only", "twice", "so", "I", "hope", "I", "didn", "t", "misunderstand", "too", "much", "NUMBER", "There", "be", "a", "lot", "of", "small", "differences", "that", "can", "be", "ported", "in", "either", "way", "NUMBER", "For", "example", "his", "implementation", "reduces", "NUMBER", "car", "to", "NUMBER", "car", "when", "posible", "but", "I", "didn", "t", "add", "that", "NUMBER", "Also", "he", "be", "use", "a", "lattice", "of", "types", "with", "a", "very", "small", "height", "but", "I", "m", "use", "NUMBER", "or", "NUMBER", "steps", "in", "the", "numeric", "tower", "NUMBER", "The", "main", "difference", "be", "that", "he", "be", "use", "a", "graph", "to", "handle", "cycles", "like", "let", "loop", "n", "NUMBER", "NUMBER", "and", "I", "just", "give", "up", "and", "don", "t", "try", "anything", "smart", "with", "cycles", "so", "all", "the", "analysis", "can", "be", "do", "in", "one", "pass", "NUMBER", "The", "other", "difference", "be", "that", "I", "m", "always", "copying", "the", "info", "from", "each", "environment", "to", "the", "surrounding", "environment", "NUMBER", "This", "can", "lead", "to", "quadratic", "run", "time", "in", "cases", "like", "lamdba", "x", "NUMBER", "NUMBER", "xn", "let", "r", "NUMBER", "random", "NUMBER", "let", "r", "NUMBER", "random", "display", "list", "unbox", "x", "NUMBER", "NUMBER", "unbox", "xn", "display", "list", "box", "x", "NUMBER", "NUMBER", "box", "xn", "He", "be", "use", "an", "abstract", "analysis", "of", "the", "flow", "of", "the", "types", "an", "structure", "similar", "to", "a", "skiplist", "to", "avoiding", "to", "update", "the", "types", "in", "each", "step", "and", "the", "types", "just", "teletransport", "to", "the", "correct", "spot", "NUMBER", "So", "this", "be", "analyzed", "in", "O", "n", "log", "n", "instead", "of", "O", "n", "NUMBER", "NUMBER", "As", "an", "informal", "benchmark", "I", "m", "comparing", "the", "runtime", "between", "the", "master", "branch", "and", "my", "branch", "NUMBER", "With", "something", "like", "cd", "a", "NUMBER", "nt", "s", "time", "make", "allx", "o", "NUMBER", "my", "branch", "o", "NUMBER", "NUMBER", "sec", "master", "o", "NUMBER", "NUMBER", "sec", "with", "o", "NUMBER", "it", "runs", "twice", "so", "you", "must", "divide", "the", "time", "by", "NUMBER", "to", "compare", "my", "branch", "o", "NUMBER", "NUMBER", "sec", "NUMBER", "s", "sec", "master", "o", "NUMBER", "NUMBER", "sec", "NUMBER", "s", "sec", "I", "m", "cheating", "a", "little", "because", "most", "of", "the", "times", "I", "m", "not", "saving", "the", "type", "of", "a", "variable", "when", "it", "be", "a", "procedure", "NUMBER", "My", "code", "be", "correct", "I", "hope", "but", "it", "miss", "some", "optimization", "opportunities", "but", "not", "too", "much", "in", "usual", "code", "NUMBER", "If", "I", "add", "all", "the", "procedures", "the", "code", "has", "to", "track", "too", "many", "variables", "and", "the", "compilation", "gets", "NUMBER", "slower", "NUMBER", "He", "be", "saving", "all", "the", "info", "for", "all", "procedures", "with", "more", "details", "so", "this", "can", "have", "an", "important", "effect", "NUMBER", "Sorry", "for", "the", "long", "delay", "NUMBER", "I", "update", "the", "PR", "NUMBER", "This", "be", "a", "short", "description", "of", "the", "commit", "fix", "enumerate", "signature", "A", "small", "fix", "otherwise", "the", "PR", "doesn", "t", "compile", "NUMBER", "add", "signatures", "field", "to", "primref", "record", "Add", "cptypes", "pass", "to", "cp", "NUMBER", "to", "reduce", "expression", "use", "types", "These", "be", "the", "main", "parts", "of", "the", "old", "PR", "NUMBER", "See", "the", "description", "in", "the", "initial", "post", "NUMBER", "revert", "to", "version", "that", "can", "update", "primref", "record", "skip", "recalculate", "the", "bootfiles", "automatically", "in", "travis", "ci", "skip", "bootfiles", "signatures", "These", "be", "some", "commit", "to", "try", "to", "test", "the", "intermediate", "version", "in", "Travis", "without", "update", "the", "bootfiles", "with", "each", "change", "NUMBER", "These", "commit", "should", "be", "delete", "of", "the", "final", "version", "NUMBER", "Fix", "hashing", "of", "prelex", "fxmap", "version", "of", "cptypes", "change", "fxmap", "api", "to", "hide", "internal", "structure", "These", "commit", "change", "the", "hamt", "by", "an", "intmap", "fxmap", "made", "by", "NUMBER", "jaz", "NUMBER", "In", "particular", "the", "new", "structure", "can", "merge", "two", "similar", "intmap", "in", "O", "d", "log", "n", "where", "d", "be", "the", "number", "of", "differences", "and", "n", "be", "the", "total", "amount", "of", "variables", "NUMBER", "Also", "the", "prelex", "have", "a", "new", "field", "that", "be", "a", "counter", "that", "be", "use", "as", "the", "hash", "key", "for", "the", "map", "NUMBER", "remove", "some", "unnecessary", "pred", "env", "merge", "update", "comments", "and", "fix", "exact", "integer", "and", "result", "type", "of", "\u00ecf", "merge", "types", "after", "if", "rename", "merge", "union", "intersection", "refactor", "pref", "union", "intersect", "These", "be", "some", "assorted", "change", "mostly", "to", "avoid", "unnecessary", "merge", "in", "the", "pred", "env", "to", "try", "to", "avoid", "quadratic", "behavior", "in", "long", "chains", "of", "nested", "let", "s", "NUMBER", "They", "also", "provide", "more", "information", "about", "the", "return", "type", "of", "an", "if", "NUMBER", "They", "can", "probably", "be", "squashed", "in", "a", "single", "commit", "but", "some", "of", "them", "be", "mix", "with", "the", "previous", "commit", "and", "they", "be", "difficult", "to", "reorder", "NUMBER", "upper", "and", "lower", "bound", "for", "types", "cache", "for", "primref", "result", "argument", "predicate", "add", "safeongoodargs", "flag", "to", "primref", "Try", "to", "replace", "some", "applications", "of", "the", "primitives", "with", "the", "unsafe", "version", "when", "the", "types", "of", "all", "the", "argument", "be", "well", "enough", "NUMBER", "This", "change", "car", "TAG", "to", "NUMBER", "car", "TAG", "but", "it", "doesn", "t", "change", "vector", "ref", "TAG", "TAG", "to", "NUMBER", "vector", "ref", "TAG", "TAG", "because", "it", "s", "difficult", "to", "verify", "if", "TAG", "be", "in", "the", "correct", "interval", "NUMBER", "There", "be", "surprisingly", "many", "primitives", "where", "all", "the", "argument", "can", "be", "checked", "NUMBER", "About", "the", "thesis", "of", "Michael", "Adams", "The", "implementation", "be", "quite", "different", "but", "most", "of", "the", "results", "be", "equivalent", "NUMBER", "Something", "similar", "to", "a", "list", "of", "features", "be", "in", "mats", "cptypes", "NUMBER", "ss", "My", "PR", "uses", "nanopass", "instead", "of", "a", "custom", "graph", "NUMBER", "My", "version", "currently", "pass", "the", "checks", "in", "Travis", "NUMBER", "The", "runtime", "of", "the", "o", "NUMBER", "version", "increase", "only", "a", "little", "and", "the", "runtime", "of", "the", "o", "NUMBER", "version", "be", "smaller", "NUMBER", "It", "can", "be", "merge", "after", "checking", "a", "few", "points", "that", "I", "m", "not", "NUMBER", "sure", "that", "be", "correct", "and", "fix", "a", "few", "many", "style", "problem", "NUMBER", "IIUC", "the", "main", "features", "that", "be", "miss", "in", "my", "version", "be", "Types", "for", "loops", "I", "don", "t", "track", "the", "types", "in", "recursive", "function", "like", "let", "loop", "n", "NUMBER", "when", "TAG", "NUMBER", "car", "TAG", "fix", "vector", "ref", "TAG", "TAG", "NUMBER", "vector", "ref", "TAG", "TAG", "not", "fix", "bitwise", "copy", "bit", "TAG", "TAG", "TAG", "bitwise", "copy", "bit", "TAG", "TAG", "TAG", "not", "fix", "I", "add", "a", "reduction", "for", "the", "cases", "where", "it", "be", "possible", "to", "check", "all", "the", "argument", "and", "replace", "the", "application", "with", "the", "unsafe", "version", "NUMBER", "This", "be", "possible", "with", "car", "cdr", "and", "many", "NUMBER", "primitives", "but", "it", "s", "not", "possible", "with", "vector", "ref", "and", "most", "vector", "primitives", "NUMBER", "It", "s", "possible", "in", "the", "future", "to", "add", "some", "support", "for", "more", "general", "cases", "in", "particular", "the", "operations", "on", "vectors", "NUMBER", "A", "special", "case", "be", "the", "primitives", "like", "bitwise", "copy", "bit", "NUMBER", "They", "be", "marked", "as", "safeongoodarguments", "but", "the", "type", "system", "I", "currently", "use", "can", "t", "track", "the", "variables", "with", "enough", "precision", "so", "they", "be", "not", "change", "in", "the", "current", "version", "but", "it", "s", "possible", "to", "extend", "the", "type", "system", "in", "the", "future", "NUMBER", "Note", "that", "large", "uses", "of", "match", "at", "least", "in", "Racket", "can", "generate", "quite", "deeply", "nested", "if", "expressions", "NUMBER", "I", "m", "not", "sure", "if", "that", "s", "likely", "to", "be", "a", "problem", "with", "the", "issue", "you", "mention", "NUMBER", "I", "ll", "take", "a", "look", "at", "the", "expansion", "match", "in", "Racket", "but", "I", "expect", "them", "not", "to", "be", "so", "big", "to", "cause", "a", "problem", "NUMBER", "I", "think", "that", "it", "s", "easier", "to", "explain", "the", "problem", "with", "an", "example", "NUMBER", "In", "the", "current", "version", "of", "my", "PR", "this", "code", "lambda", "t", "unless", "symbol", "t", "error", "e", "msg", "let", "x", "NUMBER", "read", "x", "NUMBER", "read", "xn", "read", "if", "eq", "t", "v", "NUMBER", "display", "NUMBER", "x", "NUMBER", "x", "NUMBER", "xn", "if", "eq", "t", "v", "NUMBER", "display", "NUMBER", "x", "NUMBER", "x", "NUMBER", "xn", "if", "eq", "t", "vm", "display", "NUMBER", "x", "NUMBER", "x", "NUMBER", "xn", "display", "NUMBER", "x", "NUMBER", "x", "NUMBER", "xn", "list", "number", "x", "NUMBER", "number", "x", "NUMBER", "number", "xn", "The", "optimization", "step", "for", "this", "code", "be", "O", "n", "m", "log", "N", "where", "n", "be", "the", "number", "of", "auxiliary", "variables", "m", "be", "the", "number", "of", "conditions", "and", "N", "be", "the", "total", "amount", "of", "variables", "not", "shown", "in", "the", "example", "NUMBER", "But", "the", "length", "of", "the", "code", "be", "O", "n", "m", "because", "each", "variable", "must", "be", "use", "in", "almost", "each", "branch", "condition", "NUMBER", "If", "a", "variable", "be", "use", "only", "in", "one", "single", "branch", "in", "a", "long", "chain", "of", "if", "s", "after", "the", "first", "type", "merge", "it", "will", "dispersar", "and", "all", "the", "the", "other", "merge", "will", "not", "see", "the", "variable", "NUMBER", "So", "this", "simpler", "code", "code", "be", "optimized", "in", "a", "time", "essentially", "O", "n", "m", "ignoring", "something", "like", "log", "N", "if", "eq", "t", "v", "NUMBER", "NUMBER", "if", "eq", "t", "v", "NUMBER", "NUMBER", "if", "eq", "t", "vm", "NUMBER", "x", "NUMBER", "x", "NUMBER", "xn", "NUMBER", "x", "NUMBER", "x", "NUMBER", "xn", "I", "m", "slightly", "worried", "than", "in", "a", "future", "version", "I", "or", "someone", "will", "add", "some", "track", "of", "types", "inside", "function", "calls", "NUMBER", "Something", "like", "lambda", "t", "unless", "symbol", "t", "error", "e", "msg", "let", "x", "NUMBER", "read", "x", "NUMBER", "read", "xn", "read", "let", "sum", "lambda", "z", "dislay", "z", "x", "NUMBER", "x", "NUMBER", "xn", "let", "s", "assume", "it", "be", "not", "inined", "if", "eq", "t", "v", "NUMBER", "sum", "NUMBER", "if", "eq", "t", "v", "NUMBER", "sum", "NUMBER", "if", "eq", "t", "vm", "sum", "NUMBER", "sum", "NUMBER", "list", "number", "x", "NUMBER", "number", "x", "NUMBER", "number", "xn", "In", "this", "case", "if", "the", "optimizer", "be", "smart", "enough", "to", "realize", "that", "after", "calling", "sum", "all", "the", "captured", "variables", "x", "NUMBER", "x", "NUMBER", "xn", "be", "integers", "then", "the", "merge", "of", "the", "types", "will", "be", "O", "n", "m", "log", "N", "but", "the", "code", "will", "be", "of", "length", "O", "n", "m", "only", "because", "sum", "be", "not", "inlined", "NUMBER", "This", "be", "not", "a", "problem", "in", "my", "current", "version", "because", "it", "just", "ignore", "function", "calls", "NUMBER", "Only", "the", "primitives", "may", "mark", "the", "variables", "NUMBER", "The", "complexity", "of", "the", "merge", "algorithm", "be", "given", "in", "Okasaki", "and", "Gill", "as", "worst", "case", "O", "m", "n", "NUMBER", "Thanks", "for", "the", "minimized", "example", "NUMBER", "The", "problem", "with", "bytevector", "u", "s", "NUMBER", "native", "set", "was", "that", "it", "has", "a", "wrong", "signature", "NUMBER", "The", "NUMBER", "bits", "version", "be", "correct", "NUMBER", "So", "cptypes", "detects", "that", "the", "variable", "k", "be", "a", "fixnum", "and", "it", "uses", "the", "wrong", "signature", "to", "detect", "that", "k", "must", "be", "a", "symbol", "so", "it", "expect", "that", "the", "bytevector", "u", "NUMBER", "native", "set", "will", "generate", "an", "error", "so", "cptypes", "drops", "the", "rest", "of", "the", "expression", "NUMBER", "I", "submitted", "a", "fix", "in", "a", "different", "PR", "LINK", "because", "this", "looks", "isolated", "enough", "and", "simple", "enough", "to", "be", "merge", "soon", "NUMBER", "I", "ll", "reply", "to", "the", "rest", "of", "your", "comment", "later", "NUMBER", "I", "m", "work", "mostly", "in", "Windows", "but", "I", "never", "could", "fix", "the", "problem", "with", "iconv", "NUMBER", "dll", "so", "if", "I", "run", "all", "the", "test", "I", "get", "a", "lot", "of", "error", "NUMBER", "I", "m", "use", "a", "VM", "with", "Linux", "now", "so", "I", "can", "see", "the", "actual", "error", "NUMBER", "I", "find", "a", "few", "more", "NUMBER", "error", "with", "the", "signatures", "that", "were", "cause", "explicit", "error", "or", "invalid", "memory", "error", "NUMBER", "I", "ll", "submit", "the", "PR", "soon", "NUMBER", "I", "also", "find", "a", "a", "few", "places", "were", "I", "marked", "the", "primitive", "erroneously", "as", "safeongoodars", "NUMBER", "I", "also", "fix", "the", "checks", "of", "the", "expanded", "code", "NUMBER", "I", "ll", "update", "this", "PR", "in", "a", "week", "after", "I", "fix", "most", "of", "the", "problem", "NUMBER", "I", "still", "have", "to", "fix", "the", "error", "with", "records", "NUMBER", "mflatt", "find", "an", "error", "that", "be", "probably", "relate", "to", "records", "but", "he", "has", "no", "an", "small", "easy", "example", "NUMBER", "Some", "of", "the", "message", "of", "the", "error", "in", "the", "mats", "look", "similar", "so", "I", "hope", "that", "fix", "the", "mats", "will", "fix", "it", "NUMBER", "About", "Style", "box", "values", "OK", "I", "ll", "change", "it", "About", "asymptotic", "behavior", "I", "ll", "try", "to", "think", "the", "details", "later", "NUMBER", "I", "ll", "try", "to", "fix", "the", "other", "problem", "before", "NUMBER", "burgerrg", "I", "tried", "now", "to", "compile", "win", "iconv", "but", "I", "get", "an", "error", "Perhaps", "because", "I", "m", "use", "Cygwin", "instead", "of", "MinGW", "Anyway", "I", "downloaded", "the", "compiled", "version", "from", "LINK", "iconv", "windows", "NUMBER", "html", "and", "I", "copied", "the", "file", "libiconv", "NUMBER", "dll", "to", "ChezScheme", "a", "NUMBER", "nt", "bin", "a", "NUMBER", "nt", "and", "it", "works", "NUMBER", "I", "still", "get", "some", "error", "in", "the", "master", "branch", "in", "Windows", "NUMBER", "I", "ll", "try", "to", "classify", "them", "and", "send", "a", "pull", "request", "or", "a", "bug", "report", "if", "I", "can", "t", "fix", "it", "NUMBER", "akeep", "In", "my", "secret", "branch", "I", "fix", "all", "the", "error", "that", "the", "test", "in", "allx", "can", "detect", "NUMBER", "But", "I", "want", "to", "make", "a", "few", "more", "tweak", "before", "update", "the", "PR", "NUMBER", "I", "m", "optimistic", "about", "the", "problem", "with", "the", "quadratic", "time", "I", "think", "it", "s", "solvable", "with", "a", "few", "modifications", "to", "the", "current", "structures", "NUMBER", "I", "also", "tried", "to", "change", "the", "box", "to", "values", "but", "some", "parts", "be", "painful", "NUMBER", "For", "example", "to", "look", "at", "all", "the", "argument", "of", "a", "function", "with", "box", "call", "preinfo", "pr", "e", "NUMBER", "let", "r", "map", "lambda", "e", "box", "f", "e", "t", "map", "lambda", "e", "box", "unbox", "types", "e", "e", "map", "lambda", "e", "r", "t", "cptypes", "e", "value", "r", "t", "f", "f", "e", "r", "t", "set", "box", "types", "something", "with", "unbox", "types", "e", "r", "for", "each", "lambda", "t", "set", "box", "types", "pred", "env", "intersect", "unbox", "types", "unbox", "t", "t", "call", "preinfo", "pr", "e", "NUMBER", "and", "with", "box", "call", "preinfo", "pr", "e", "NUMBER", "let", "e", "r", "t", "map", "lambda", "e", "let", "values", "e", "r", "t", "t", "t", "f", "t", "cptypes", "e", "value", "types", "list", "e", "r", "t", "e", "e", "map", "car", "e", "r", "t", "r", "map", "cadr", "e", "r", "t", "t", "map", "caddr", "e", "r", "t", "let", "types", "something", "with", "types", "e", "r", "values", "call", "preinfo", "pr", "e", "NUMBER", "f", "fold", "left", "lambda", "types", "t", "pred", "env", "intersect", "types", "t", "types", "t", "f", "f", "After", "another", "long", "delay", "NUMBER", "Fixing", "the", "quadratic", "time", "was", "possible", "but", "it", "was", "harder", "than", "I", "expected", "NUMBER", "I", "squashed", "most", "of", "the", "commit", "and", "the", "fix", "in", "a", "few", "big", "commit", "NUMBER", "Short", "description", "add", "signatures", "field", "to", "primref", "record", "Version", "to", "upate", "primref", "record", "during", "rebase", "step", "NUMBER", "skip", "Version", "to", "upate", "primref", "record", "during", "rebase", "step", "NUMBER", "skip", "Version", "to", "upate", "primref", "record", "during", "rebase", "step", "NUMBER", "skip", "recalculate", "the", "bootfiles", "automatically", "in", "travis", "ci", "skip", "bootfiles", "signatures", "Add", "the", "signatures", "to", "the", "primref", "NUMBER", "This", "step", "be", "tricky", "so", "I", "left", "the", "intermediate", "steps", "to", "make", "a", "future", "rebase", "easier", "but", "most", "of", "these", "commit", "should", "be", "remove", "in", "the", "final", "version", "NUMBER", "Hashing", "of", "prelex", "for", "cptypes", "Add", "fxmap", "for", "cptypes", "Add", "more", "operations", "to", "fxmap", "test", "for", "fxmap", "remove", "reset", "base", "skip", "Implementation", "of", "an", "intmap", "that", "will", "hold", "the", "types", "recovered", "during", "the", "cptype", "pass", "NUMBER", "Remove", "special", "case", "for", "NUMBER", "map", "p", "in", "cp", "NUMBER", "fix", "in", "master", "Add", "cptypes", "pass", "to", "cp", "NUMBER", "to", "reduce", "expression", "use", "types", "This", "be", "the", "main", "part", "of", "the", "PR", "NUMBER", "This", "include", "the", "previous", "version", "some", "improvement", "and", "many", "fix", "NUMBER", "add", "safeongoodargs", "flag", "to", "primref", "Reductions", "to", "replace", "a", "primitive", "by", "the", "unsafe", "version", "NUMBER", "I", "left", "the", "safeongoodargs", "separated", "because", "it", "has", "a", "lot", "of", "instances", "to", "be", "review", "so", "perhaps", "it", "s", "better", "to", "merge", "it", "later", "NUMBER", "About", "the", "previous", "comments", "box", "values", "do", "fix", "test", "do", "records", "I", "change", "like", "the", "NUMBER", "of", "the", "implementation", "for", "records", "NUMBER", "I", "think", "that", "now", "it", "be", "correct", "NUMBER", "quadratic", "time", "The", "main", "idea", "be", "that", "the", "types", "be", "stored", "in", "a", "immutable", "intmap", "fxmap", "that", "remembers", "how", "much", "change", "were", "use", "to", "create", "it", "NUMBER", "So", "each", "time", "it", "be", "necessary", "to", "merge", "two", "intmaps", "it", "be", "possible", "to", "select", "the", "smaller", "one", "and", "add", "to", "the", "biggest", "one", "only", "the", "recent", "differences", "NUMBER", "The", "main", "advantage", "of", "this", "intmaps", "fxmaps", "be", "that", "the", "difference", "operation", "can", "be", "very", "efficient", "NUMBER", "Some", "construction", "like", "let", "use", "a", "special", "operation", "to", "forget", "the", "temporal", "variables", "NUMBER", "This", "operation", "not", "only", "remove", "the", "variable", "but", "it", "also", "try", "to", "reconstruct", "the", "inmap", "before", "the", "temporal", "variable", "was", "add", "NUMBER", "In", "particular", "with", "this", "reconstruction", "some", "trees", "that", "look", "equal", "be", "eq", "like", "in", "the", "additional", "test", "NUMBER", "Most", "of", "the", "times", "only", "a", "part", "of", "the", "tree", "be", "reconstructed", "NUMBER", "This", "helps", "the", "following", "parts", "of", "the", "code", "to", "compare", "two", "inmaps", "faster", "because", "the", "iterations", "can", "skip", "the", "common", "parts", "use", "eq", "without", "comparing", "the", "subtrees", "NUMBER", "The", "analysis", "of", "the", "if", "be", "more", "tricky", "because", "it", "s", "necessary", "to", "use", "a", "different", "strategy", "when", "the", "test", "part", "be", "longer", "than", "both", "branch", "NUMBER", "Also", "if", "one", "one", "of", "the", "branch", "be", "longer", "than", "the", "test", "it", "s", "important", "to", "use", "the", "intmap", "of", "the", "smaller", "branch", "for", "the", "iterations", "and", "compare", "use", "lookups", "in", "the", "intmap", "of", "the", "biggest", "branch", "NUMBER", "The", "length", "be", "actually", "calculated", "the", "number", "of", "change", "in", "the", "relevant", "intmap", "that", "be", "bounded", "by", "the", "actual", "length", "of", "the", "code", "NUMBER", "This", "pass", "runs", "in", "O", "N", "log", "N", "log", "N", "R", "where", "N", "be", "the", "total", "length", "of", "the", "code", "and", "R", "be", "the", "depth", "of", "the", "record", "hierarchy", "because", "to", "compare", "two", "records", "the", "program", "must", "walk", "from", "a", "rtd", "to", "the", "parents", "until", "it", "finds", "the", "other", "rtd", "or", "the", "base", "rtd", "NUMBER", "In", "practice", "R", "be", "small", "I", "test", "with", "the", "Chez", "Scheme", "compilation", "and", "I", "get", "R", "NUMBER", "and", "I", "expect", "that", "most", "program", "don", "t", "have", "rtd", "with", "parent", "with", "parent", "with", "parent", "with", "parent", "with", "parent", "NUMBER", "So", "the", "effective", "bound", "be", "O", "N", "log", "NUMBER", "N", "NUMBER", "It", "be", "possible", "to", "fix", "the", "problem", "of", "the", "records", "with", "too", "many", "ancestors", "but", "in", "that", "case", "I", "think", "it", "s", "better", "to", "change", "it", "in", "another", "time", "NUMBER", "This", "all", "sounds", "good", "NUMBER", "It", "will", "take", "me", "a", "few", "days", "to", "get", "some", "time", "to", "look", "through", "and", "test", "all", "these", "change", "but", "I", "m", "looking", "forward", "to", "going", "through", "it", "NUMBER", "Thanks", "for", "all", "the", "work", "I", "have", "no", "problem", "with", "use", "an", "auxiliary", "branch", "to", "get", "the", "fix", "NUMBER", "I", "was", "already", "doing", "something", "like", "that", "with", "NUMBER", "jaz", "and", "mflatt", "NUMBER", "About", "the", "change", "I", "have", "read", "the", "change", "and", "they", "look", "good", "but", "I", "need", "a", "few", "more", "days", "to", "read", "them", "more", "carefully", "NUMBER", "Also", "my", "notebook", "has", "a", "problem", "with", "the", "screen", "and", "I", "m", "use", "the", "old", "one", "for", "a", "few", "days", "NUMBER", "I", "agree", "with", "the", "change", "of", "types", "types", "NUMBER", "in", "the", "if", "clause", "of", "cptypes", "raw", "NUMBER", "It", "was", "a", "mistake", "NUMBER", "I", "was", "probably", "shadowing", "types", "and", "later", "decided", "to", "rename", "it", "as", "types", "NUMBER", "to", "get", "more", "consistent", "names", "and", "I", "forgot", "to", "update", "the", "name", "of", "the", "variable", "in", "these", "sites", "NUMBER", "About", "the", "ideas", "for", "change", "change", "empty", "x", "eq", "x", "TAG", "OK", "NUMBER", "I", "m", "only", "worry", "about", "the", "possibility", "in", "the", "future", "of", "reusing", "fxmap", "NUMBER", "ss", "in", "another", "pass", "like", "cp", "NUMBER", "and", "get", "a", "different", "singleton", "NUMBER", "This", "would", "be", "a", "problem", "be", "the", "fxmap", "s", "be", "somehow", "stored", "and", "shared", "NUMBER", "This", "problem", "be", "too", "hypothetical", "so", "it", "can", "be", "solve", "with", "a", "comment", "in", "the", "file", "with", "a", "warning", "for", "the", "future", "NUMBER", "Another", "small", "improvement", "would", "be", "write", "a", "version", "of", "fxmap", "merge", "that", "doesn", "t", "try", "to", "build", "a", "result", "fxmap", "NUMBER", "I", "m", "use", "it", "in", "fxmap", "for", "each", "diff", "trying", "to", "minimize", "the", "result", "and", "then", "discarding", "it", "at", "the", "end", "NUMBER", "make", "record", "rtd", "and", "record", "ref", "lists", "into", "records", "OK", "NUMBER", "remove", "temporal", "ir", "in", "the", "call", "clause", "of", "cptypes", "raw", "NUMBER", "OK", "NUMBER", "I", "think", "I", "write", "that", "for", "laziness", "to", "be", "able", "to", "return", "the", "default", "ir", "when", "necessary", "without", "thinking", "NUMBER", "Sometimes", "it", "s", "nice", "because", "it", "s", "clear", "that", "the", "reduction", "affects", "only", "the", "types", "and", "not", "the", "main", "expression", "NUMBER", "I", "use", "it", "only", "NUMBER", "times", "so", "it", "s", "easy", "to", "fix", "it", "with", "cut", "paste", "NUMBER", "use", "define", "inline", "like", "cp", "NUMBER", "I", "like", "the", "idea", "but", "I", "d", "prefer", "to", "wait", "NUMBER", "I", "like", "that", "define", "inline", "makes", "the", "code", "much", "easier", "to", "parse", "because", "it", "s", "clear", "where", "each", "primitive", "be", "handle", "NUMBER", "But", "I", "still", "not", "sure", "about", "the", "details", "of", "the", "interface", "NUMBER", "In", "particular", "the", "argument", "types", "can", "be", "a", "the", "original", "fxmap", "that", "be", "the", "argument", "of", "cptypes", "raw", "b", "the", "result", "after", "add", "the", "types", "recovered", "in", "the", "argument", "c", "the", "result", "of", "add", "also", "the", "types", "that", "be", "checked", "in", "the", "primitive", "definition", "signature", "Currently", "the", "effective", "value", "be", "c", "because", "it", "makes", "the", "implementation", "easier", "but", "in", "an", "isolated", "reduction", "b", "be", "more", "natural", "but", "it", "may", "be", "more", "error", "prone", "than", "a", "NUMBER", "The", "value", "of", "the", "argument", "be", "important", "because", "all", "the", "recovered", "types", "must", "be", "add", "first", "to", "the", "main", "fxmap", "in", "the", "result", "and", "later", "add", "the", "additional", "types", "to", "the", "results", "that", "will", "be", "use", "in", "the", "then", "and", "else", "branch", "NUMBER", "If", "you", "add", "them", "in", "other", "order", "you", "must", "use", "some", "of", "the", "unusual", "function", "of", "the", "fxmap", "s", "NUMBER", "Mmm", "NUMBER", "This", "description", "be", "probably", "not", "very", "clear", "but", "I", "hope", "it", "s", "clear", "that", "I", "don", "t", "have", "the", "details", "clear", "enough", "yet", "NUMBER", "So", "I", "d", "prefer", "to", "think", "about", "this", "and", "discuss", "the", "implementation", "details", "later", "before", "write", "them", "NUMBER", "About", "the", "quadratic", "time", "I", "m", "sure", "I", "fix", "all", "the", "corner", "cases", "but", "I", "have", "be", "wrong", "in", "the", "past", "NUMBER", "NUMBER", "The", "first", "important", "point", "be", "that", "the", "numeration", "of", "the", "prelex", "be", "consecutive", "or", "quasi", "consecutive", "so", "the", "fxmap", "s", "be", "almost", "balanced", "or", "to", "be", "more", "precise", "the", "height", "be", "bounded", "by", "log", "N", "k", "where", "N", "be", "the", "total", "number", "of", "variables", "in", "the", "program", "and", "k", "be", "a", "small", "number", "I", "guess", "NUMBER", "or", "NUMBER", "So", "there", "be", "not", "degenerated", "cases", "where", "a", "big", "fxmap", "be", "actually", "a", "long", "list", "NUMBER", "Also", "the", "fxmap", "with", "the", "types", "in", "the", "results", "be", "constructed", "in", "such", "a", "way", "that", "in", "an", "expression", "like", "e", "NUMBER", "e", "NUMBER", "the", "types", "NUMBER", "of", "e", "NUMBER", "and", "the", "types", "NUMBER", "of", "e", "NUMBER", "share", "as", "much", "as", "posible", "the", "structure", "with", "the", "original", "types", "NUMBER", "So", "the", "differences", "between", "typesX", "and", "types", "can", "be", "iterated", "in", "less", "than", "change", "typesX", "change", "types", "log", "N", "time", "NUMBER", "To", "ensure", "this", "property", "it", "be", "necessary", "be", "careful", "and", "in", "particular", "to", "use", "fxmap", "remove", "base", "to", "remove", "the", "temporal", "variables", "and", "rebuild", "the", "branch", "where", "they", "were", "stored", "NUMBER", "So", "it", "be", "possible", "to", "pick", "from", "types", "NUMBER", "and", "types", "NUMBER", "the", "one", "with", "fewer", "change", "and", "copy", "only", "those", "change", "to", "the", "other", "one", "NUMBER", "In", "particular", "if", "one", "of", "them", "has", "a", "few", "change", "from", "the", "original", "types", "and", "the", "other", "has", "a", "lot", "of", "change", "from", "the", "original", "types", "then", "the", "merge", "operation", "must", "copy", "only", "a", "few", "change", "and", "be", "fast", "NUMBER", "Selecting", "the", "one", "with", "fewer", "change", "be", "the", "main", "idea", "to", "ensure", "that", "the", "global", "runtime", "be", "O", "N", "log", "NUMBER", "N", "NUMBER", "Actually", "merge", "all", "the", "fxmap", "s", "in", "a", "if", "clause", "be", "trickier", "if", "you", "want", "to", "avoid", "quadratic", "time", "so", "I", "have", "to", "use", "some", "weird", "function", "with", "the", "fxmap", "s", "NUMBER", "There", "be", "three", "lines", "in", "cptypes", "NUMBER", "ss", "that", "have", "a", "CHECK", "reminder", "warning", "NUMBER", "These", "be", "parts", "that", "I", "think", "that", "be", "correct", "but", "I", "m", "not", "sure", "NUMBER", "For", "example", "the", "clause", "for", "immutable", "list", "in", "cptypes", "raw", "NUMBER", "I", "think", "that", "you", "already", "looked", "at", "the", "code", "and", "thought", "it", "was", "fine", "but", "can", "you", "take", "another", "look", "at", "them", "so", "I", "remove", "the", "reminder", "warning", "The", "predicate", "implies", "check", "be", "a", "good", "question", "NUMBER", "NUMBER", "I", "think", "it", "s", "better", "to", "use", "eqv", "because", "predicate", "implies", "be", "use", "in", "predicate", "implies", "not", "NUMBER", "So", "we", "get", "these", "reductions", "eq", "NUMBER", "NUMBER", "t", "unespecified", "eq", "NUMBER", "NUMBER", "f", "eqv", "NUMBER", "NUMBER", "t", "eqv", "NUMBER", "NUMBER", "f", "The", "first", "one", "be", "officialy", "unespecified", "but", "use", "eqv", "in", "predicate", "implies", "makes", "cptypes", "reduce", "it", "to", "t", "allways", "NUMBER", "Using", "eq", "would", "make", "the", "it", "sometimes", "be", "reduced", "to", "f", "because", "the", "result", "would", "depend", "on", "some", "of", "the", "internal", "details", "for", "example", "if", "both", "NUMBER", "be", "constant", "propagated", "from", "the", "same", "origin", "or", "if", "they", "be", "calculated", "independently", "or", "if", "there", "was", "a", "round", "trip", "to", "fasl", "NUMBER", "Something", "similar", "applies", "to", "the", "third", "one", "but", "the", "result", "of", "the", "third", "one", "must", "be", "t", "so", "comparing", "internaly", "with", "eq", "would", "be", "a", "problem", "NUMBER", "I", "also", "find", "another", "small", "optimization", "of", "the", "program", "in", "cptypes", "NUMBER", "I", "remove", "the", "wrapper", "around", "cptypes", "raw", "and", "now", "the", "recursion", "calls", "cptypes", "directly", "NUMBER", "The", "wrapper", "was", "there", "to", "replace", "t", "types", "and", "f", "types", "with", "the", "value", "of", "types", "when", "one", "of", "them", "was", "f", "that", "means", "the", "there", "be", "no", "additional", "predicates", "for", "the", "t", "or", "f", "branch", "NUMBER", "I", "now", "take", "care", "of", "that", "case", "inside", "the", "clause", "of", "if", "when", "it", "be", "necesary", "instead", "of", "in", "every", "recursive", "call", "NUMBER", "So", "it", "must", "save", "a", "few", "milliseconds", "here", "and", "there", "NUMBER", "I", "also", "had", "to", "make", "a", "trivial", "tiny", "modification", "in", "the", "clause", "of", "let", "let", "letrec", "but", "I", "have", "to", "debug", "the", "code", "for", "a", "while", "until", "I", "notice", "that", "I", "must", "fix", "it", "too", "NUMBER", "preview", "LINK", "massa", "ChezScheme", "commit", "c", "NUMBER", "e", "NUMBER", "c", "NUMBER", "da", "NUMBER", "abbb", "NUMBER", "e", "NUMBER", "c", "NUMBER", "a", "NUMBER", "fdeb", "I", "rebased", "the", "PR", "and", "in", "the", "last", "commit", "I", "add", "all", "the", "propose", "change", "exept", "define", "inline", "NUMBER", "I", "remove", "the", "auxiliary", "commit", "so", "this", "version", "doesn", "t", "have", "the", "correct", "bootfiles", "and", "it", "gets", "an", "error", "in", "travis", "NUMBER", "I", "have", "the", "outdate", "bootfiles", "and", "the", "trick", "to", "make", "travis", "recompile", "them", "in", "another", "branch", "gus", "massa", "NUMBER", "NUMBER", "Types", "Pass", "Extended", "LINK", "massa", "ChezScheme", "commit", "NUMBER", "NUMBER", "Types", "Pass", "Extended", "test", "LINK", "ci", "NUMBER", "org", "gus", "massa", "ChezScheme", "build", "NUMBER", "The", "main", "miss", "parts", "be", "the", "update", "to", "the", "LOG", "and", "CSUG", "NUMBER", "I", "still", "have", "problem", "with", "my", "main", "computer", "so", "I", "have", "to", "guess", "a", "little", "NUMBER", "One", "important", "part", "of", "pred", "env", "union", "from", "from", "base", "types", "new", "base", "be", "it", "must", "be", "possible", "to", "construct", "from", "starting", "with", "base", "and", "use", "a", "few", "add", "operations", "NUMBER", "Sometimes", "the", "process", "be", "more", "complicated", "but", "the", "operations", "like", "remove", "base", "ensure", "that", "there", "be", "an", "alternative", "path", "that", "uses", "only", "add", "operations", "NUMBER", "The", "error", "you", "find", "in", "the", "test", "be", "triggered", "because", "base", "has", "a", "binding", "that", "be", "not", "in", "from", "NUMBER", "This", "be", "impossible", "if", "you", "use", "only", "add", "operations", "add", "actually", "intersects", "the", "new", "type", "with", "the", "old", "value", "it", "s", "not", "a", "simple", "overwrite", "it", "never", "cleans", "a", "binding", "NUMBER", "I", "think", "the", "error", "procedure", "should", "be", "change", "to", "impoops", "because", "in", "a", "bug", "free", "universe", "it", "be", "impossible", "to", "reach", "this", "part", "of", "the", "program", "NUMBER", "I", "still", "don", "t", "understand", "where", "the", "problem", "be", "but", "something", "like", "the", "following", "example", "should", "cause", "a", "problem", "NUMBER", "Each", "variable", "has", "a", "friendly", "name", "and", "also", "a", "number", "that", "be", "the", "counter", "that", "be", "temporally", "assigned", "to", "the", "prelex", "operand", "field", "NUMBER", "The", "intmap", "uses", "only", "the", "counters", "not", "the", "name", "or", "the", "prelex", "itself", "NUMBER", "I", "assume", "that", "there", "be", "a", "rogue", "prelex", "that", "be", "shared", "between", "two", "threads", "and", "the", "different", "threads", "reuse", "the", "numbers", "NUMBER", "lambda", "t", "NUMBER", "x", "NUMBER", "y", "NUMBER", "when", "box", "shared", "NUMBER", "TAG", "e", "NUMBER", "or", "if", "TAG", "e", "NUMBER", "e", "NUMBER", "NUMBER", "Also", "IIRC", "the", "type", "lattice", "be", "not", "covered", "because", "I", "think", "it", "has", "no", "tricky", "parts", "most", "of", "the", "details", "of", "the", "conversions", "be", "in", "the", "big", "comment", "at", "the", "beginning", "of", "the", "file", "NUMBER", "I", "just", "push", "a", "small", "fix", "of", "the", "error", "message", "in", "particular", "it", "uses", "impoops", "instead", "of", "error", "because", "it", "should", "never", "happen", "NUMBER", "I", "d", "squash", "this", "commit", "too", "but", "as", "you", "have", "the", "fix", "the", "thread", "problem", "in", "a", "not", "public", "branch", "it", "may", "be", "easier", "to", "just", "copy", "these", "change", "there", "perhaps", "with", "a", "better", "text", "NUMBER", "I", "made", "a", "few", "small", "update", "NUMBER", "I", "squashed", "my", "two", "minor", "last", "commit", "with", "a", "few", "new", "change", "NUMBER", "If", "you", "have", "already", "made", "some", "change", "I", "can", "try", "to", "rearrange", "them", "with", "this", "change", "NUMBER", "Fix", "cptypes", "in", "multi", "thread", "version", "This", "be", "essentially", "the", "gist", "LINK", "made", "by", "akeep", "NUMBER", "I", "remove", "the", "error", "checks", "and", "the", "debug", "message", "NUMBER", "With", "this", "change", "many", "of", "the", "auxiliary", "function", "be", "defined", "inside", "the", "pass", "NUMBER", "I", "m", "not", "sure", "if", "this", "be", "a", "good", "idea", "because", "I", "m", "not", "sure", "if", "they", "will", "be", "slower", "than", "a", "version", "of", "the", "function", "that", "be", "defined", "outside", "the", "pass", "NUMBER", "Also", "IIUC", "the", "cache", "of", "the", "types", "of", "the", "signatures", "in", "L", "NUMBER", "LINK", "massa", "ChezScheme", "blob", "NUMBER", "f", "NUMBER", "cfc", "NUMBER", "f", "NUMBER", "fe", "NUMBER", "d", "NUMBER", "b", "NUMBER", "fd", "NUMBER", "cb", "NUMBER", "be", "NUMBER", "df", "NUMBER", "f", "s", "cptypes", "NUMBER", "ss", "L", "NUMBER", "and", "L", "NUMBER", "LINK", "massa", "ChezScheme", "blob", "NUMBER", "f", "NUMBER", "cfc", "NUMBER", "f", "NUMBER", "fe", "NUMBER", "d", "NUMBER", "b", "NUMBER", "fd", "NUMBER", "cb", "NUMBER", "be", "NUMBER", "df", "NUMBER", "f", "s", "cptypes", "NUMBER", "ss", "L", "NUMBER", "will", "get", "a", "different", "instance", "in", "each", "time", "the", "pass", "be", "use", "so", "it", "will", "be", "slower", "than", "having", "a", "common", "cache", "for", "all", "the", "instances", "that", "the", "pass", "be", "call", "NUMBER", "Are", "hash", "table", "thread", "safe", "Fix", "call", "case", "with", "rest", "argument", "in", "cptypes", "This", "has", "the", "two", "small", "fix", "and", "a", "special", "case", "to", "make", "cptypes", "detect", "that", "list", "x", "y", "z", "be", "a", "pair", "i", "NUMBER", "e", "NUMBER", "it", "be", "not", "null", "NUMBER", "This", "be", "useful", "because", "cp", "NUMBER", "may", "reduce", "lambda", "x", "NUMBER", "rest", "NUMBER", "a", "b", "c", "lambda", "x", "rest", "NUMBER", "a", "list", "b", "c", "and", "this", "make", "the", "type", "detection", "of", "rest", "slightly", "more", "consistent", "NUMBER", "I", "also", "add", "some", "test", "here", "NUMBER", "More", "on", "this", "in", "the", "next", "commit", "NUMBER", "more", "cptypes", "To", "make", "the", "test", "pass", "I", "had", "to", "add", "a", "call", "to", "cptypes", "in", "two", "file", "NUMBER", "First", "I", "made", "the", "calls", "look", "at", "the", "enable", "type", "recovery", "parameter", "so", "they", "can", "be", "disabled", "NUMBER", "Second", "I", "add", "a", "call", "to", "cptypes", "when", "cp", "NUMBER", "be", "not", "call", "to", "make", "it", "consistent", "with", "other", "compilation", "ways", "NUMBER", "The", "problem", "be", "that", "after", "use", "this", "in", "the", "test", "I", "don", "t", "like", "it", "NUMBER", "I", "made", "two", "version", "of", "the", "test", "NUMBER", "One", "disables", "cp", "NUMBER", "and", "use", "the", "fact", "that", "cptypes", "will", "be", "call", "anyway", "The", "other", "uses", "run", "cp", "NUMBER", "lambda", "cp", "NUMBER", "x", "NUMBER", "cptypes", "x", "I", "think", "that", "it", "s", "more", "intuitive", "that", "disabling", "cp", "NUMBER", "will", "disable", "all", "or", "most", "of", "the", "optimization", "including", "cptypes", "NUMBER", "It", "s", "not", "intuitive", "that", "cptypes", "be", "call", "anyway", "NUMBER", "My", "guess", "be", "that", "the", "normal", "users", "will", "not", "be", "interested", "in", "test", "the", "behavior", "of", "cptypes", "alone", "so", "in", "the", "rare", "case", "that", "any", "of", "them", "be", "interested", "they", "can", "use", "NUMBER", "cptype", "NUMBER", "So", "my", "proposal", "be", "to", "remove", "the", "second", "part", "of", "this", "commit", "and", "also", "remove", "all", "the", "cptypes", "from", "the", "cp", "NUMBER", "was", "not", "call", "branch", "in", "the", "compiler", "NUMBER", "I", "didn", "t", "write", "this", "yet", "NUMBER", "I", "like", "the", "flag", "enable", "type", "recovery", "it", "may", "be", "useful", "to", "isolate", "bug", "NUMBER", "An", "additional", "question", "The", "cp", "NUMBER", "was", "not", "call", "branch", "have", "a", "call", "to", "cpletrec", "NUMBER", "How", "bad", "be", "that", "someone", "redefines", "run", "cp", "NUMBER", "as", "run", "cp", "NUMBER", "lambda", "cp", "NUMBER", "x", "NUMBER", "cptypes", "cp", "NUMBER", "x", "Because", "it", "will", "set", "the", "flag", "that", "cp", "NUMBER", "was", "call", "and", "cpletrec", "will", "not", "be", "the", "last", "pass", "NUMBER", "IIUC", "the", "properties", "of", "the", "letrec", "s", "that", "cpletrec", "try", "to", "enforce", "be", "also", "enforced", "later", "in", "cpnanopass", "so", "this", "be", "not", "a", "problem", "NUMBER", "Test", "in", "version", "with", "bootfiles", "here", "LINK", "ci", "NUMBER", "org", "gus", "massa", "ChezScheme", "build", "NUMBER", "NUMBER", "I", "add", "a", "small", "commit", "change", "how", "enable", "type", "recovery", "work", "so", "run", "cp", "NUMBER", "lambda", "cp", "NUMBER", "x", "x", "will", "disable", "the", "traditional", "cp", "NUMBER", "pass", "and", "also", "the", "cptypes", "pass", "NUMBER", "I", "think", "it", "s", "more", "intuitive", "this", "way", "NUMBER", "More", "details", "in", "my", "previous", "comment", "NUMBER", "This", "be", "based", "in", "an", "old", "version", "so", "it", "needs", "some", "tricks", "to", "pass", "the", "test", "NUMBER", "See", "branch", "LINK", "massa", "ChezScheme", "tree", "NUMBER", "NUMBER", "Types", "Pass", "Z", "test", "LINK", "ci", "NUMBER", "org", "gus", "massa", "ChezScheme", "build", "NUMBER", "NUMBER", "I", "also", "made", "a", "rebased", "version", "in", "case", "it", "s", "useful", "NUMBER", "It", "needs", "new", "bootfiles", "but", "they", "don", "t", "have", "to", "be", "the", "very", "latest", "one", "NUMBER", "See", "branch", "LINK", "massa", "ChezScheme", "tree", "NUMBER", "NUMBER", "Types", "Pass", "ZR", "test", "LINK", "ci", "NUMBER", "org", "gus", "massa", "ChezScheme", "build", "NUMBER", "NUMBER", "Expanding", "to", "a", "definition", "means", "that", "it", "doesn", "t", "interrupt", "a", "definition", "sequence", "NUMBER", "Ordered", "finalization", "be", "intended", "to", "make", "certain", "finalization", "patterns", "more", "composable", "NUMBER", "A", "library", "might", "want", "to", "finalize", "internal", "parts", "of", "a", "data", "structure", "while", "allowing", "applications", "to", "finalize", "external", "pieces", "that", "refer", "to", "the", "internal", "parts", "NUMBER", "In", "that", "case", "the", "goal", "be", "to", "finalize", "the", "internal", "pieces", "only", "after", "the", "application", "be", "definitely", "do", "with", "the", "external", "parts", "including", "finalization", "on", "those", "external", "parts", "NUMBER", "Ordered", "finalization", "seems", "difficult", "to", "use", "correctly", "but", "it", "looks", "like", "a", "good", "option", "for", "handle", "foreign", "resources", "NUMBER", "This", "patch", "include", "two", "change", "to", "guardians", "it", "uses", "the", "seginfo", "trigger", "mechanism", "to", "avoid", "quadratic", "time", "handle", "of", "guardian", "chains", "which", "be", "granted", "unlikely", "in", "practice", "and", "it", "add", "an", "optional", "ordered", "argument", "to", "make", "guardian", "to", "provide", "a", "form", "of", "ordered", "finalization", "NUMBER", "I", "initially", "planned", "to", "stage", "those", "change", "as", "two", "commit", "but", "various", "representation", "choices", "interact", "so", "they", "re", "together", "here", "NUMBER", "The", "implementation", "add", "a", "field", "to", "a", "guardian", "entry", "and", "so", "there", "s", "a", "second", "field", "to", "preserve", "double", "word", "alignment", "which", "I", "think", "be", "necessary", "to", "declare", "and", "initialize", "to", "work", "right", "with", "the", "GC", "but", "correct", "me", "if", "that", "s", "not", "right", "NUMBER", "Since", "two", "words", "seem", "to", "be", "necessary", "for", "the", "one", "extra", "bit", "of", "information", "I", "need", "to", "distinguish", "ordered", "and", "unordered", "finalization", "I", "use", "the", "second", "word", "to", "make", "the", "handle", "of", "triggers", "more", "convenient", "NUMBER", "Another", "possible", "choice", "be", "to", "keep", "separate", "lists", "of", "ordered", "and", "unordered", "entries", "but", "that", "seems", "much", "less", "convenient", "in", "the", "GC", "implementation", "NUMBER", "Also", "the", "trigger", "lists", "in", "the", "seginfo", "record", "would", "have", "to", "be", "keep", "separate", "somehow", "and", "triggers", "for", "hold", "versus", "final", "lists", "would", "have", "to", "be", "keep", "separate", "NUMBER", "I", "can", "think", "of", "ways", "to", "encode", "two", "extra", "bits", "of", "information", "in", "the", "current", "record", "but", "the", "ways", "I", "see", "be", "too", "ugly", "unless", "this", "seems", "like", "a", "crucial", "issue", "NUMBER", "The", "documentation", "update", "be", "minimal", "NUMBER", "It", "s", "unlikely", "to", "be", "a", "good", "specification", "of", "ordered", "finalization", "and", "it", "certainly", "doesn", "t", "get", "across", "the", "pitfalls", "and", "intended", "use", "of", "ordered", "finalization", "NUMBER", "In", "the", "case", "of", "weak", "and", "ephemeron", "pairs", "I", "concluded", "that", "weak", "references", "shouldn", "t", "count", "against", "ordered", "finalization", "NUMBER", "I", "m", "not", "NUMBER", "certain", "of", "that", "choice", "or", "anything", "else", "about", "finalization", "and", "it", "makes", "some", "applications", "that", "I", "have", "in", "mind", "more", "difficult", "but", "it", "seems", "workable", "NUMBER", "Meanwhile", "having", "weak", "references", "prevent", "finalization", "doesn", "t", "seem", "like", "it", "would", "work", "in", "my", "application", "because", "ordered", "finalized", "objects", "will", "typically", "reside", "as", "keys", "in", "a", "weak", "hashtable", "NUMBER", "I", "didn", "t", "think", "of", "the", "problem", "with", "sweep", "and", "forwarding", "NUMBER", "A", "shortcut", "of", "not", "copying", "sweeping", "for", "objects", "that", "contain", "only", "non", "ptr", "values", "would", "likely", "cover", "most", "applications", "that", "I", "have", "in", "mind", "NUMBER", "It", "turns", "out", "that", "the", "fragile", "situation", "goes", "wrong", "if", "a", "pair", "s", "car", "refers", "back", "to", "the", "pair", "NUMBER", "The", "forwarding", "mark", "gets", "overwritten", "with", "the", "forwarded", "pointer", "for", "the", "car", "while", "the", "cdr", "has", "be", "modify", "to", "the", "forwarded", "pointer", "NUMBER", "In", "the", "end", "an", "extra", "pair", "be", "created", "and", "a", "weak", "reference", "can", "see", "the", "wrong", "copy", "NUMBER", "I", "think", "maybe", "a", "pair", "be", "the", "only", "object", "that", "can", "go", "wrong", "that", "way", "but", "the", "new", "commit", "try", "to", "resolve", "the", "fragility", "more", "generally", "NUMBER", "Instead", "of", "make", "a", "copy", "of", "the", "object", "sweep_in_old", "scans", "for", "immediate", "self", "references", "and", "it", "just", "copies", "the", "object", "normally", "if", "it", "finds", "any", "NUMBER", "Only", "if", "the", "object", "be", "free", "of", "immediate", "self", "references", "it", "continues", "on", "to", "sweep", "NUMBER", "The", "duplication", "of", "the", "sweep", "dispatch", "be", "a", "little", "awkward", "but", "seems", "ok", "to", "me", "NUMBER", "I", "m", "less", "happy", "with", "the", "duplication", "of", "seep_record", "but", "maybe", "it", "s", "ok", "NUMBER", "Handling", "threads", "seem", "like", "too", "much", "work", "and", "unlikely", "to", "be", "useful", "so", "sweep_in_old", "just", "treats", "every", "thread", "as", "referring", "to", "itself", "NUMBER", "Rebased", "NUMBER", "This", "implementation", "of", "ordered", "guardians", "has", "worked", "well", "for", "Racket", "on", "Chez", "NUMBER", "Racket", "s", "drawing", "and", "GUI", "libraries", "particularly", "rely", "on", "ordered", "finalization", "to", "ensure", "that", "resources", "be", "safely", "deallocated", "and", "ordered", "guardians", "have", "worked", "as", "expected", "over", "the", "past", "year", "NUMBER", "I", "m", "not", "sure", "about", "this", "and", "I", "m", "not", "sure", "if", "this", "be", "the", "correct", "fix", "NUMBER", "If", "I", "run", "expand", "optimize", "if", "zero", "random", "NUMBER", "pariah", "display", "green", "void", "I", "get", "if", "NUMBER", "zero", "NUMBER", "random", "NUMBER", "NUMBER", "display", "green", "NUMBER", "void", "but", "I", "expect", "something", "like", "if", "NUMBER", "zero", "NUMBER", "random", "NUMBER", "begin", "pariah", "void", "NUMBER", "display", "green", "NUMBER", "void", "The", "problem", "be", "that", "pariah", "be", "marked", "as", "simple", "and", "it", "s", "remove", "from", "the", "begin", "sequence", "NUMBER", "This", "change", "breaks", "the", "reduction", "of", "expand", "optimize", "if", "zero", "random", "NUMBER", "pariah", "void", "void", "Done", "NUMBER", "I", "add", "a", "test", "NUMBER", "This", "reduces", "NUMBER", "void", "x", "vector", "NUMBER", "NUMBER", "newline", "y", "begin", "newline", "void", "This", "can", "be", "useful", "to", "mark", "x", "and", "y", "as", "unuse", "and", "avoid", "allocating", "the", "vector", "NUMBER", "I", "was", "not", "sure", "if", "it", "s", "necessary", "to", "add", "test", "and", "in", "which", "file", "to", "put", "them", "NUMBER", "I", "enable", "it", "only", "for", "the", "optimization", "level", "NUMBER", "because", "otherwise", "it", "would", "reduce", "NUMBER", "void", "values", "NUMBER", "NUMBER", "void", "I", "was", "confused", "because", "Racket", "has", "an", "extend", "version", "of", "void", "that", "just", "ignores", "its", "argument", "NUMBER", "It", "s", "sometime", "handy", "in", "the", "RELP", "to", "ignore", "the", "result", "of", "an", "expression", "NUMBER", "void", "time", "NUMBER", "NUMBER", "NUMBER", "Anyway", "it", "s", "not", "very", "incredible", "useful", "so", "I", "think", "it", "s", "better", "to", "make", "no", "change", "NUMBER", "gcc", "NUMBER", "has", "a", "new", "warning", "Wimplicit", "fallthrough", "NUMBER", "When", "coupled", "with", "Wextra", "Werror", "this", "warning", "breaks", "the", "build", "NUMBER", "dybvig", "do", "NUMBER", "I", "drop", "the", "change", "to", "non", "linux", "makefiles", "NUMBER", "As", "this", "warning", "be", "only", "in", "gcc", "NUMBER", "and", "pre", "NUMBER", "gcc", "will", "also", "issue", "a", "warning", "for", "unknown", "flags", "I", "decided", "to", "not", "include", "it", "for", "all", "architectures", "that", "might", "possible", "use", "gcc", "NUMBER", "The", "code", "below", "sometimes", "raises", "an", "invalid", "memory", "reference", "when", "run", "on", "a", "NUMBER", "nt", "a", "NUMBER", "osx", "and", "a", "NUMBER", "le", "current", "eval", "interpret", "run", "cp", "NUMBER", "lambda", "cp", "NUMBER", "x", "x", "do", "n", "NUMBER", "n", "NUMBER", "ls", "iota", "NUMBER", "n", "NUMBER", "map", "lambda", "x", "let", "x", "exact", "sqrt", "NUMBER", "x", "ls", "I", "distilled", "this", "example", "from", "a", "mat", "that", "fail", "occasionally", "NUMBER", "It", "do", "not", "happen", "on", "i", "NUMBER", "nt", "so", "the", "bug", "may", "be", "relate", "to", "the", "x", "NUMBER", "_", "NUMBER", "code", "generator", "NUMBER", "dybvig", "I", "would", "like", "to", "pull", "the", "date", "dst", "request", "but", "there", "s", "no", "need", "to", "do", "the", "bootfiles", "twice", "NUMBER", "Can", "you", "rebase", "your", "fix", "onto", "the", "first", "commit", "of", "the", "date", "dst", "request", "then", "make", "the", "fix", "and", "rebuild", "the", "boot", "file", "The", "return", "value", "be", "marked", "as", "fixnum", "but", "it", "should", "be", "boolean", "NUMBER", "I", "m", "not", "sure", "if", "it", "be", "necesary", "to", "recalculate", "the", "bootfiles", "NUMBER", "This", "commit", "add", "a", "way", "to", "store", "line", "and", "column", "information", "explicitly", "instead", "of", "reconstructing", "it", "from", "a", "position", "by", "re", "reading", "the", "file", "NUMBER", "Specifically", "a", "file", "position", "object", "which", "combines", "a", "position", "line", "and", "column", "can", "be", "use", "in", "place", "of", "a", "position", "integer", "in", "function", "like", "make", "source", "object", "NUMBER", "The", "intent", "be", "to", "add", "line", "and", "column", "options", "without", "affecting", "exist", "code", "NUMBER", "It", "s", "not", "a", "completely", "backward", "compatible", "change", "because", "source", "object", "bfp", "and", "source", "object", "efp", "function", "can", "now", "return", "file", "position", "objects", "instead", "of", "integers", "but", "they", "won", "t", "show", "up", "unless", "some", "new", "function", "be", "use", "NUMBER", "When", "locate", "source", "receives", "a", "file", "position", "object", "in", "place", "of", "a", "position", "integer", "then", "it", "doesn", "t", "try", "to", "consult", "a", "file", "in", "the", "filesystem", "and", "just", "returns", "the", "file", "position", "object", "s", "line", "and", "column", "NUMBER", "The", "change", "include", "a", "new", "record", "source", "lines", "and", "columns", "that", "causes", "compile", "file", "and", "other", "tool", "to", "record", "line", "and", "column", "information", "instead", "of", "just", "positions", "NUMBER", "That", "works", "by", "collecting", "position", "to", "line", "information", "at", "the", "same", "time", "as", "computing", "the", "file", "checksum", "and", "the", "position", "to", "line", "table", "be", "keep", "as", "part", "of", "the", "source", "file", "descriptor", "NUMBER", "The", "make", "source", "object", "function", "maps", "a", "position", "to", "a", "file", "position", "object", "when", "the", "table", "be", "present", "NUMBER", "A", "source", "file", "descriptor", "lines", "do", "function", "drops", "the", "table", "and", "it", "s", "call", "automatically", "by", "read", "datum", "annotations", "NUMBER", "Maybe", "there", "s", "a", "better", "way", "to", "do", "all", "that", "NUMBER", "In", "fact", "for", "my", "purposes", "it", "s", "not", "so", "important", "to", "have", "something", "like", "record", "source", "lines", "and", "columns", "at", "all", "but", "I", "wanted", "to", "try", "to", "make", "the", "new", "functionality", "generally", "available", "and", "I", "do", "use", "it", "a", "little", "in", "my", "current", "Racket", "prototype", "NUMBER", "Finally", "inspectors", "for", "code", "and", "continuations", "support", "a", "new", "source", "object", "message", "to", "return", "the", "source", "object", "directly", "instead", "of", "sending", "it", "through", "locate", "source", "NUMBER", "Thanks", "a", "lot", "This", "be", "a", "feature", "I", "have", "be", "craving", "NUMBER", "I", "tried", "to", "build", "this", "but", "it", "seem", "to", "get", "into", "an", "infinite", "loop", "NUMBER", "rain", "NUMBER", "You", "ll", "need", "to", "use", "a", "regular", "Chez", "Scheme", "build", "to", "bootstrap", "this", "one", "NUMBER", "Here", "be", "some", "instructions", "based", "on", "instructs", "from", "Kent", "that", "I", "ve", "be", "meaning", "to", "turn", "into", "a", "PR", "as", "a", "patch", "BUILDING", "BOOSTRAPPING", "VIA", "CROSS", "COMPILATION", "To", "build", "a", "change", "that", "be", "not", "compatible", "with", "existng", "Chez", "Scheme", "build", "you", "will", "need", "to", "build", "in", "cross", "compilation", "mode", "NUMBER", "Start", "with", "a", "build", "from", "unadulterated", "sources", "in", "ORIG", "on", "machine", "type", "M", "NUMBER", "Then", "in", "the", "modify", "source", "tree", "NUMBER", "configure", "cd", "M", "s", "make", "f", "Mf", "cross", "m", "M", "xm", "M", "base", "ORIG", "M", "cd", "M", "c", "make", "cd", "M", "s", "make", "allx", "One", "reason", "I", "ve", "never", "gotten", "around", "to", "a", "PR", "be", "that", "it", "may", "be", "better", "to", "add", "a", "target", "to", "the", "main", "Makefile", "and", "I", "m", "undecided", "on", "that", "myself", "NUMBER", "Any", "of", "those", "choices", "work", "for", "me", "although", "I", "like", "least", "the", "choice", "of", "requiring", "both", "start", "and", "end", "to", "have", "lines", "and", "columns", "because", "an", "ending", "line", "and", "column", "doesn", "t", "seem", "useful", "to", "me", "NUMBER", "The", "Racket", "API", "be", "position", "line", "column", "span", "and", "an", "ending", "position", "works", "well", "enough", "in", "place", "of", "a", "span", "NUMBER", "If", "we", "don", "t", "have", "the", "requirement", "of", "keep", "old", "things", "the", "same", "size", "then", "I", "think", "add", "a", "starting", "line", "and", "column", "to", "the", "source", "record", "type", "be", "the", "way", "to", "go", "NUMBER", "The", "current", "implementation", "causes", "my", "example", "NUMBER", "so", "file", "to", "grow", "by", "about", "NUMBER", "when", "keep", "inspector", "information", "and", "I", "expect", "that", "add", "two", "field", "to", "source", "object", "would", "be", "more", "compact", "NUMBER", "Any", "of", "the", "choices", "be", "also", "an", "easy", "change", "if", "you", "re", "comfortable", "with", "the", "extra", "argument", "to", "make", "source", "file", "descriptor", "and", "the", "way", "source", "file", "descriptor", "lines", "do", "works", "NUMBER", "Here", "s", "another", "direction", "not", "yet", "carefully", "test", "for", "your", "consideration", "Keeps", "file", "location", "objects", "so", "space", "be", "the", "same", "as", "before", "without", "lines", "and", "columns", "NUMBER", "Gets", "rid", "of", "record", "source", "lines", "and", "columns", "source", "file", "descriptor", "lines", "do", "and", "the", "tasteless", "and", "problematic", "state", "in", "source", "file", "objects", "NUMBER", "Adds", "current", "locate", "source", "and", "current", "make", "syntax", "object", "which", "the", "system", "uses", "in", "place", "of", "calling", "locate", "source", "and", "make", "syntax", "object", "directly", "and", "whose", "initial", "values", "be", "locate", "source", "and", "make", "syntax", "object", "NUMBER", "This", "implementation", "do", "not", "add", "caching", "for", "locate", "source", "NUMBER", "I", "don", "t", "know", "how", "to", "do", "that", "and", "remain", "consistent", "with", "the", "idea", "that", "locate", "source", "tells", "you", "whether", "the", "source", "file", "has", "change", "NUMBER", "The", "current", "locate", "source", "parameter", "lets", "a", "program", "disable", "the", "system", "s", "on", "demand", "computation", "of", "lines", "and", "file", "NUMBER", "I", "find", "that", "control", "appealing", "because", "I", "worry", "about", "system", "operations", "trolling", "through", "the", "filesystem", "in", "a", "final", "application", "NUMBER", "Meanwhile", "current", "locate", "source", "could", "be", "set", "at", "compile", "time", "to", "cache", "file", "be", "compiled", "or", "current", "make", "syntax", "object", "could", "be", "set", "to", "compute", "line", "and", "column", "information", "eagerly", "while", "the", "reader", "constructs", "annotations", "NUMBER", "On", "locate", "source", "and", "caching", "I", "had", "imagined", "that", "the", "current", "setup", "was", "designed", "to", "handle", "the", "case", "that", "you", "you", "compile", "a", "file", "start", "debugging", "it", "without", "doing", "enough", "work", "to", "trigger", "a", "GC", "modify", "the", "file", "and", "then", "use", "the", "inspector", "to", "view", "source", "information", "NUMBER", "If", "you", "re", "ok", "with", "the", "inspector", "report", "a", "bad", "line", "and", "column", "in", "that", "case", "then", "it", "s", "fine", "with", "me", "NUMBER", "On", "the", "filesystem", "and", "final", "applications", "Maybe", "the", "issue", "here", "be", "final", "application", "NUMBER", "I", "had", "in", "mind", "one", "that", "could", "use", "eval", "which", "could", "trigger", "the", "compilation", "of", "a", "define", "values", "form", "which", "could", "trigger", "the", "use", "of", "locate", "source", "on", "a", "source", "that", "was", "recorded", "during", "the", "compilation", "of", "the", "application", "and", "through", "syntax", "datum", "applied", "to", "the", "evaluated", "form", "NUMBER", "I", "could", "arrange", "for", "Racket", "to", "never", "include", "define", "values", "in", "its", "output", "but", "I", "worry", "that", "some", "other", "form", "that", "Racket", "uses", "may", "change", "to", "use", "locate", "source", "in", "the", "future", "NUMBER", "Racket", "could", "also", "avoid", "source", "objects", "that", "have", "only", "positions", "but", "since", "Racket", "allows", "source", "locations", "at", "its", "own", "layer", "to", "just", "have", "positions", "it", "s", "clumsy", "at", "best", "to", "encode", "that", "in", "a", "file", "position", "object", "NUMBER", "Our", "users", "have", "had", "trouble", "with", "the", "interaction", "of", "slow", "filesystems", "and", "unexpect", "filesystem", "operations", "and", "we", "get", "bug", "report", "when", "the", "distribution", "contains", "or", "accesses", "paths", "that", "it", "shouldn", "t", "NUMBER", "A", "parameter", "to", "disable", "filesystem", "access", "in", "locate", "source", "would", "avoid", "complicated", "question", "in", "a", "simple", "and", "reliable", "way", "NUMBER", "The", "new", "commit", "add", "caching", "in", "locate", "source", "NUMBER", "I", "m", "not", "sure", "the", "way", "I", "connected", "cache", "clearing", "to", "a", "maximum", "generation", "GC", "be", "the", "way", "you", "had", "in", "mind", "NUMBER", "Here", "s", "a", "program", "I", "tried", "for", "checking", "the", "performance", "effect", "of", "current", "make", "source", "object", "on", "the", "reader", "LINK", "NUMBER", "On", "my", "machine", "that", "program", "runs", "in", "about", "NUMBER", "seconds", "with", "the", "current", "Chez", "Scheme", "and", "about", "NUMBER", "seconds", "with", "this", "PR", "so", "a", "slowdown", "on", "the", "order", "of", "NUMBER", "NUMBER", "Uncommenting", "out", "the", "parameter", "adjustment", "which", "means", "that", "every", "source", "object", "constructor", "goes", "through", "an", "indirection", "with", "argument", "validation", "makes", "it", "run", "in", "about", "NUMBER", "seconds", "but", "that", "kind", "of", "penalty", "happens", "only", "when", "current", "make", "source", "object", "be", "adjusted", "NUMBER", "I", "m", "hoping", "that", "read", "datum", "be", "generally", "use", "to", "read", "program", "where", "expansion", "and", "compilation", "time", "will", "be", "much", "more", "than", "reader", "time", "so", "that", "NUMBER", "will", "be", "ok", "NUMBER", "Still", "it", "s", "the", "least", "important", "part", "of", "the", "PR", "for", "my", "purposes", "NUMBER", "Well", "there", "be", "test", "failures", "in", "NUMBER", "ms", "NUMBER", "I", "think", "the", "two", "test", "fail", "because", "the", "new", "cache", "records", "a", "relative", "path", "for", "an", "sfd", "based", "on", "one", "search", "and", "then", "the", "same", "relative", "path", "be", "use", "after", "the", "directory", "change", "NUMBER", "so", "more", "work", "there", "but", "only", "if", "this", "be", "an", "acceptable", "direction", "overall", "NUMBER", "The", "new", "commit", "makes", "the", "cache", "record", "state", "use", "to", "find", "a", "file", "and", "it", "discards", "the", "cache", "entry", "if", "the", "state", "doesn", "t", "match", "NUMBER", "With", "that", "repair", "the", "test", "pass", "NUMBER", "If", "I", "understand", "the", "source", "file", "locator", "suggestion", "then", "I", "don", "t", "think", "it", "works", "NUMBER", "Annotations", "contain", "source", "objects", "that", "become", "argument", "to", "locate", "source", "NUMBER", "A", "source", "object", "shouldn", "t", "contain", "a", "source", "file", "locator", "because", "that", "would", "just", "take", "us", "back", "to", "the", "problem", "of", "having", "a", "line", "table", "in", "an", "annotation", "NUMBER", "My", "reasoning", "on", "the", "potential", "cost", "of", "current", "directory", "was", "that", "it", "s", "cheaper", "than", "reading", "a", "file", "and", "would", "at", "least", "resolve", "the", "current", "potential", "quadratic", "behavior", "NUMBER", "And", "there", "s", "the", "current", "locate", "source", "parameter", "if", "an", "application", "needs", "something", "different", "NUMBER", "Another", "thought", "on", "the", "cost", "of", "current", "make", "source", "object", "Is", "it", "worth", "reserving", "a", "tc", "slot", "for", "the", "parameter", "which", "I", "imagine", "would", "make", "lookup", "even", "faster", "Or", "be", "the", "cost", "more", "likely", "in", "the", "indirection", "through", "make", "source", "object", "I", "m", "still", "miss", "something", "NUMBER", "The", "particular", "case", "I", "have", "in", "mind", "be", "the", "call", "to", "locate", "source", "in", "the", "expansion", "of", "let", "values", "NUMBER", "I", "can", "see", "how", "let", "values", "expansion", "could", "reasonably", "pass", "a", "true", "value", "of", "ok", "to", "cache", "but", "I", "don", "t", "see", "where", "a", "locator", "object", "would", "live", "for", "let", "values", "to", "use", "NUMBER", "The", "new", "commit", "add", "a", "use", "cache", "argument", "to", "locate", "source", "NUMBER", "Good", "point", "I", "ll", "adjust", "the", "table", "representation", "NUMBER", "I", "squashed", "the", "commit", "to", "make", "the", "overall", "diff", "easier", "to", "see", "and", "I", "can", "revert", "if", "squashing", "be", "unhelpful", "but", "there", "s", "still", "a", "patch", "NUMBER", "ss", "change", "to", "revert", "NUMBER", "Here", "s", "another", "try", "at", "the", "API", "edit", "as", "suggested", "in", "the", "original", "feedback", "NUMBER", "Instead", "of", "add", "file", "position", "objects", "this", "version", "add", "optional", "beginning", "file", "line", "and", "beginning", "file", "column", "components", "to", "a", "source", "object", "NUMBER", "This", "approach", "be", "more", "compatible", "with", "exist", "code", "avoids", "a", "new", "file", "position", "object", "concept", "and", "simplifies", "source", "object", "construction", "use", "a", "line", "and", "column", "NUMBER", "It", "doesn", "t", "support", "an", "ending", "line", "and", "column", "NUMBER", "Internally", "the", "variant", "with", "line", "and", "column", "components", "be", "a", "subtype", "of", "the", "one", "without", "NUMBER", "New", "source", "object", "bfl", "and", "source", "object", "bfl", "accessors", "each", "get", "a", "value", "of", "a", "new", "component", "returning", "f", "if", "the", "value", "be", "not", "present", "NUMBER", "Possible", "issue", "copying", "adjusting", "a", "source", "object", "would", "be", "a", "little", "tedious", "since", "make", "source", "object", "doesn", "t", "accept", "f", "as", "a", "line", "or", "column", "NUMBER", "To", "help", "the", "compiler", "etc", "NUMBER", "use", "the", "new", "optional", "components", "the", "function", "bound", "to", "current", "locate", "source", "do", "not", "accept", "the", "same", "argument", "as", "locate", "source", "NUMBER", "Possible", "issue", "maybe", "current", "locate", "source", "should", "have", "a", "different", "name", "NUMBER", "Instead", "the", "parameter", "s", "function", "accepts", "a", "source", "object", "not", "an", "sfd", "a", "boolean", "for", "start", "to", "indicate", "whether", "a", "start", "or", "end", "position", "be", "wanted", "and", "a", "boolean", "for", "cache", "NUMBER", "If", "start", "be", "true", "and", "the", "source", "object", "has", "sfl", "and", "sfc", "components", "the", "default", "function", "for", "current", "locate", "source", "returns", "those", "components", "with", "the", "sfd", "path", "without", "searching", "otherwise", "locate", "source", "be", "use", "NUMBER", "This", "worked", "out", "because", "all", "exist", "calls", "to", "current", "locate", "source", "have", "a", "source", "object", "on", "hand", "NUMBER", "This", "commit", "also", "implement", "current", "mso", "as", "suggested", "NUMBER", "The", "current", "commit", "be", "set", "up", "to", "simplify", "cross", "compilation", "NUMBER", "There", "be", "several", "UNPATCHME", "s", "to", "clean", "up", "after", "bootstrapping", "NUMBER", "I", "add", "locate", "source", "object", "source", "and", "renamed", "the", "parameter", "to", "current", "locate", "source", "object", "source", "although", "those", "names", "seem", "long", "NUMBER", "Having", "the", "parameter", "s", "procedure", "take", "a", "source", "object", "be", "intended", "to", "allow", "control", "over", "the", "way", "that", "recorded", "information", "and", "the", "filesystem", "be", "use", "since", "there", "be", "many", "reasonable", "choices", "that", "depend", "on", "the", "application", "NUMBER", "For", "example", "an", "application", "might", "want", "to", "use", "a", "recorded", "line", "and", "column", "but", "still", "perform", "a", "search", "for", "the", "file", "path", "NUMBER", "Leaving", "out", "the", "use", "cache", "argument", "would", "mean", "that", "the", "inspector", "uses", "the", "cache", "too", "which", "would", "be", "a", "change", "some", "test", "in", "NUMBER", "ms", "around", "line", "NUMBER", "would", "fail", "I", "think", "NUMBER", "In", "that", "case", "the", "test", "would", "have", "to", "change", "or", "the", "inspector", "would", "have", "to", "avoid", "current", "locate", "source", "object", "source", "NUMBER", "I", "recommend", "keep", "use", "cache", "but", "the", "behavior", "of", "that", "corner", "doesn", "t", "matter", "to", "me", "so", "I", "ll", "go", "with", "whatever", "you", "prefer", "NUMBER", "I", "don", "t", "have", "strong", "opinions", "on", "the", "name", "for", "current", "locate", "source", "object", "source", "NUMBER", "FWIW", "current", "source", "object", "location", "seems", "misleading", "as", "a", "replacement", "for", "current", "locate", "source", "object", "source", "since", "it", "sounds", "like", "a", "parameter", "that", "holds", "a", "source", "location", "instead", "of", "a", "function", "to", "find", "a", "location", "and", "I", "like", "keep", "locate", "in", "the", "name", "to", "connect", "it", "to", "locate", "source", "NUMBER", "But", "I", "d", "be", "happy", "to", "change", "to", "whatever", "name", "seems", "best", "to", "you", "NUMBER", "Thanks", "for", "the", "repairs", "and", "other", "improvement", "I", "think", "the", "latest", "commit", "gets", "them", "all", "NUMBER", "For", "NUMBER", "I", "opted", "for", "an", "additional", "argument", "even", "though", "the", "new", "argument", "and", "prefix", "be", "correlated", "NUMBER", "If", "it", "s", "otherwise", "ok", "let", "me", "know", "if", "you", "d", "like", "the", "commit", "squashed", "and", "or", "bootfiles", "add", "with", "UNPATCHME", "s", "remove", "NUMBER", "I", "have", "just", "one", "fix", "to", "the", "fix", "the", "semicolon", "after", "relocate", "CURRENTMSO", "tc", "be", "unnecessary", "if", "harmless", "NUMBER", "Otherwise", "this", "looks", "good", "so", "please", "go", "ahead", "and", "squash", "create", "bootfiles", "and", "remove", "the", "patches", "NUMBER", "Done", "Not", "a", "high", "priority", "but", "would", "be", "nice", "to", "have", "if", "it", "seems", "like", "a", "good", "idea", "Expose", "zlib", "s", "compress", "and", "uncompress", "API", "as", "bytevector", "compress", "and", "bytevector", "decompress", "NUMBER", "This", "be", "useful", "to", "Racket", "because", "compiled", "code", "be", "write", "via", "compile", "to", "port", "to", "a", "bytevector", "NUMBER", "With", "this", "commit", "the", "resulting", "bytevector", "can", "be", "compressed", "and", "decompressed", "without", "going", "through", "a", "file", "NUMBER", "I", "think", "add", "a", "size", "to", "the", "start", "of", "the", "result", "of", "bytevector", "compress", "be", "a", "good", "idea", "NUMBER", "I", "was", "originally", "trying", "to", "more", "directly", "reflect", "the", "underlying", "function", "but", "having", "the", "size", "build", "in", "would", "certainly", "work", "better", "in", "my", "one", "use", "case", "so", "far", "NUMBER", "The", "compressBound", "function", "looks", "handy", "and", "I", "ll", "switch", "to", "that", "NUMBER", "Oddly", "the", "documentation", "that", "I", "find", "for", "compress", "gives", "the", "formula", "in", "the", "code", "instead", "of", "point", "to", "compressBound", "which", "be", "in", "the", "same", "set", "of", "docs", "NUMBER", "Updated", "as", "suggested", "NUMBER", "Ok", "do", "Does", "not", "prevent", "binary", "creation", "the", "program", "seems", "to", "work", "as", "intended", "but", "this", "do", "not", "look", "good", "NUMBER", "make", "j", "NUMBER", "make", "NUMBER", "warning", "jobserver", "unavailable", "use", "j", "NUMBER", "Add", "to", "parent", "make", "rule", "NUMBER", "Exception", "in", "fasl", "file", "equal", "code", "comparison", "fail", "while", "comparing", "NUMBER", "boot", "ta", "NUMBER", "le", "sbb", "and", "NUMBER", "boot", "ta", "NUMBER", "le", "petite", "NUMBER", "boot", "within", "fasl", "entry", "NUMBER", "make", "NUMBER", "checkboot", "Error", "NUMBER", "If", "that", "be", "the", "case", "boot", "file", "provide", "by", "the", "stable", "release", "source", "package", "v", "NUMBER", "since", "initial", "commit", "apparently", "be", "outdate", "NUMBER", "The", "error", "do", "not", "seem", "to", "appear", "after", "compile", "it", "once", "having", "bootfile", "comparison", "succeeded", "at", "the", "end", "of", "the", "build", "to", "which", "I", "assume", "that", "be", "because", "new", "bootfiles", "be", "compiled", "NUMBER", "The", "only", "way", "to", "reproduce", "that", "was", "through", "make", "distclean", "NUMBER", "configure", "threads", "make", "NUMBER", "If", "that", "behaviour", "be", "expected", "new", "bootfiles", "compiled", "for", "the", "binaries", "this", "issue", "should", "be", "close", "and", "apologies", "for", "wasting", "your", "time", "NUMBER", "Build", "logs", "attached", "number", "at", "the", "beginning", "indicates", "the", "order", "NUMBER", "OS", "CentOS", "NUMBER", "x", "NUMBER", "_", "NUMBER", "Kernel", "NUMBER", "NUMBER", "el", "NUMBER", "x", "NUMBER", "_", "NUMBER", "gcc", "v", "Using", "build", "in", "specs", "NUMBER", "COLLECT_GCC", "gcc", "COLLECT_LTO_WRAPPER", "usr", "libexec", "gcc", "x", "NUMBER", "_", "NUMBER", "redhat", "linux", "NUMBER", "lto", "wrapper", "Target", "x", "NUMBER", "_", "NUMBER", "redhat", "linux", "Configured", "with", "NUMBER", "configure", "prefix", "usr", "mandir", "usr", "share", "man", "infodir", "usr", "share", "info", "with", "bugurl", "LINK", "enable", "bootstrap", "enable", "shared", "enable", "threads", "posix", "enable", "checking", "release", "with", "system", "zlib", "enable", "__cxa_atexit", "disable", "libunwind", "exception", "enable", "gnu", "unique", "object", "enable", "linker", "build", "id", "with", "linker", "hash", "style", "gnu", "enable", "languages", "c", "c", "objc", "obj", "c", "java", "fortran", "ada", "go", "lto", "enable", "plugin", "enable", "initfini", "array", "disable", "libgcj", "with", "isl", "builddir", "build", "BUILD", "gcc", "NUMBER", "NUMBER", "obj", "x", "NUMBER", "_", "NUMBER", "redhat", "linux", "isl", "install", "with", "cloog", "builddir", "build", "BUILD", "gcc", "NUMBER", "NUMBER", "obj", "x", "NUMBER", "_", "NUMBER", "redhat", "linux", "cloog", "install", "enable", "gnu", "indirect", "function", "with", "tune", "generic", "with", "arch_", "NUMBER", "x", "NUMBER", "NUMBER", "build", "x", "NUMBER", "_", "NUMBER", "redhat", "linux", "Thread", "model", "posix", "gcc", "version", "NUMBER", "NUMBER", "Red", "Hat", "NUMBER", "NUMBER", "GCC", "NUMBER", "fresh", "compilation", "NUMBER", "txt", "LINK", "NUMBER", "fresh", "NUMBER", "compilation", "NUMBER", "txt", "NUMBER", "make", "distclean", "NUMBER", "txt", "LINK", "NUMBER", "make", "NUMBER", "distclean", "NUMBER", "txt", "NUMBER", "make", "clean", "NUMBER", "txt", "LINK", "NUMBER", "make", "NUMBER", "clean", "NUMBER", "txt", "I", "finally", "understand", "this", "issue", "after", "looking", "through", "your", "make", "distclean", "NUMBER", "txt", "attachment", "NUMBER", "Yes", "this", "be", "expected", "behavior", "NUMBER", "The", "bootstrap", "process", "generally", "requires", "two", "runs", "to", "produce", "equivalent", "boot", "file", "NUMBER", "The", "first", "run", "uses", "the", "pre", "compiled", "compiler", "and", "run", "time", "system", "in", "the", "distribution", "boot", "file", "to", "compile", "the", "compiler", "and", "run", "time", "system", "sources", "into", "the", "first", "set", "of", "new", "boot", "file", "and", "the", "second", "run", "uses", "the", "freshly", "compiled", "compiler", "and", "run", "time", "system", "in", "the", "first", "set", "of", "new", "boot", "file", "to", "compile", "the", "sources", "into", "the", "second", "set", "of", "new", "boot", "file", "NUMBER", "The", "first", "set", "of", "new", "boot", "file", "be", "generally", "not", "equivalent", "to", "the", "boot", "file", "in", "the", "distribution", "hence", "the", "ignored", "boot", "file", "comparison", "exception", "you", "notice", "midway", "through", "the", "build", "NUMBER", "On", "the", "other", "hand", "the", "second", "set", "of", "new", "boot", "file", "be", "usually", "equivalent", "to", "the", "first", "set", "of", "new", "boot", "file", "hence", "the", "overall", "success", "of", "the", "build", "NUMBER", "The", "boot", "file", "in", "the", "distribution", "be", "produced", "via", "a", "cross", "compiler", "NUMBER", "The", "cross", "compiler", "be", "compiled", "with", "different", "compiler", "options", "that", "can", "result", "in", "evaluation", "order", "differences", "within", "the", "compiler", "that", "in", "turn", "result", "in", "harmless", "differences", "in", "code", "layout", "within", "the", "boot", "file", "NUMBER", "When", "the", "host", "and", "target", "machines", "differ", "the", "cross", "compiler", "also", "produces", "larger", "and", "less", "efficient", "code", "due", "to", "the", "disabling", "of", "some", "machine", "dependent", "optimizations", "NUMBER", "This", "be", "why", "the", "first", "set", "of", "new", "boot", "file", "be", "generally", "not", "equivalent", "to", "the", "boot", "file", "in", "the", "distribution", "NUMBER", "Extend", "the", "reductions", "for", "map", "and", "for", "each", "when", "the", "argument", "be", "explicit", "lists", "like", "list", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "or", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "cp", "NUMBER", "ss", "NUMBER", "ms", "This", "has", "many", "tweak", "here", "and", "there", "but", "they", "be", "too", "much", "interrelated", "to", "split", "this", "naturaly", "in", "a", "few", "smaller", "commit", "NUMBER", "The", "idea", "be", "to", "extend", "the", "reduction", "for", "expressions", "like", "map", "list", "NUMBER", "NUMBER", "list", "NUMBER", "NUMBER", "to", "expressions", "like", "map", "list", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "I", "have", "to", "change", "the", "order", "of", "some", "optimizations", "NUMBER", "In", "expressions", "like", "the", "former", "cp", "NUMBER", "first", "try", "to", "inline", "the", "lists", "and", "if", "that", "failt", "then", "it", "try", "to", "inline", "the", "implementation", "of", "map", "for", "short", "list", "with", "up", "to", "NUMBER", "items", "NUMBER", "Also", "when", "map", "try", "to", "detect", "a", "short", "list", "the", "optimization", "will", "be", "able", "to", "calculate", "the", "lenght", "of", "list", "like", "list", "NUMBER", "NUMBER", "NUMBER", "instead", "of", "only", "list", "like", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "This", "extend", "the", "reductions", "for", "expressions", "like", "map", "begin", "something", "NUMBER", "NUMBER", "NUMBER", "another", "list", "to", "expressions", "like", "map", "begin", "something", "list", "NUMBER", "NUMBER", "NUMBER", "another", "list", "I", "made", "similar", "change", "to", "for", "each", "NUMBER", "In", "particular", "for", "each", "had", "a", "reduction", "for", "quoted", "short", "lists", "that", "be", "extend", "to", "list", "defined", "with", "list", "NUMBER", "And", "I", "add", "a", "reduction", "for", "expressions", "like", "for", "each", "something", "list", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "I", "just", "use", "the", "internal", "function", "inline", "lists", "with", "a", "flag", "to", "signal", "if", "it", "be", "use", "in", "a", "map", "or", "a", "for", "each", "NUMBER", "In", "a", "for", "each", "it", "be", "not", "necesary", "to", "calculate", "all", "the", "cdr", "initially", "but", "use", "the", "implementation", "that", "be", "use", "for", "map", "avoids", "creating", "the", "list", "and", "in", "many", "times", "the", "values", "can", "be", "propagated", "NUMBER", "NUMBER", "indentation", "Fixed", "NUMBER", "safe", "assert", "list", "I", "add", "the", "code", "in", "null", "rec", "NUMBER", "I", "hope", "the", "comment", "be", "fine", "NUMBER", "NUMBER", "more", "test", "I", "add", "a", "few", "combinations", "with", "map", "applied", "to", "expressions", "with", "side", "effect", "with", "list", "and", "NUMBER", "I", "also", "add", "similar", "mats", "with", "for", "each", "NUMBER", "I", "use", "a", "lambda", "with", "a", "side", "effect", "to", "ensure", "that", "the", "side", "effect", "of", "the", "argument", "be", "run", "before", "the", "side", "effect", "of", "the", "lambda", "and", "to", "avoid", "too", "smart", "optimizations", "that", "remove", "the", "whole", "application", "NUMBER", "I", "m", "not", "test", "the", "result", "of", "the", "for", "each", "NUMBER", "But", "I", "m", "not", "sure", "if", "the", "application", "order", "in", "a", "for", "each", "be", "guaranteed", "in", "Chez", "Scheme", "NUMBER", "For", "example", "be", "this", "possible", "for", "each", "display", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "One", "possible", "fix", "be", "to", "add", "in", "each", "mat", "all", "the", "possible", "results", "so", "they", "will", "pass", "in", "possible", "any", "application", "order", "of", "the", "lambda", "NUMBER", "Another", "possibility", "be", "to", "remove", "the", "side", "effect", "NUMBER", "And", "a", "third", "possibility", "be", "to", "test", "both", "behaviors", "NUMBER", "NUMBER", "check", "long", "quoted", "lists", "I", "add", "a", "check", "to", "avoid", "the", "expansion", "when", "all", "list", "be", "quoted", "and", "they", "have", "more", "than", "NUMBER", "elements", "NUMBER", "I", "don", "t", "like", "the", "idea", "of", "the", "NUMBER", "element", "threshold", "too", "much", "because", "this", "transformation", "may", "enable", "more", "reductions", "than", "the", "other", "cases", "NUMBER", "In", "the", "other", "cases", "the", "code", "must", "still", "build", "the", "list", "so", "it", "s", "not", "possible", "to", "propagate", "the", "values", "at", "compile", "time", "NUMBER", "Anyway", "there", "be", "a", "few", "bad", "examples", "without", "the", "threshold", "like", "let", "l", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "for", "each", "display", "l", "for", "each", "display", "l", "for", "each", "display", "l", "for", "each", "display", "l", "display", "l", "Do", "you", "think", "I", "have", "to", "fix", "something", "or", "you", "be", "planning", "to", "merge", "this", "as", "be", "The", "test", "already", "check", "the", "official", "behavior", "NUMBER", "I", "was", "sure", "that", "the", "optimization", "didn", "t", "change", "the", "order", "of", "the", "applications", "NUMBER", "Anyway", "I", "have", "read", "it", "again", "and", "double", "checked", "just", "in", "case", "NUMBER", "It", "be", "ok", "NUMBER", "The", "test", "assumed", "no", "reorder", "of", "the", "application", "too", "NUMBER", "I", "asked", "because", "I", "was", "unsure", "if", "the", "test", "were", "too", "strict", "NUMBER", "They", "be", "ok", "too", "NUMBER", "I", "looked", "at", "the", "fix", "and", "now", "I", "understand", "the", "error", "NUMBER", "I", "made", "an", "easy", "example", "to", "see", "it", "NUMBER", "for", "each", "lambda", "x", "y", "display", "list", "display", "a", "display", "A", "list", "display", "b", "display", "B", "Bad", "output", "Bba", "A", "Correct", "output", "aAbB", "AabB", "BbAa", "NUMBER", "posibilities", "Here", "s", "a", "first", "cut", "no", "documentation", "or", "test", "to", "add", "ephemerons", "make", "ephemeron", "key", "value", "makes", "an", "ephemeron", "that", "holds", "value", "only", "as", "long", "as", "key", "be", "reachable", "where", "value", "doesn", "t", "count", "as", "reachable", "from", "the", "ephemeron", "until", "key", "be", "otherwise", "determined", "to", "be", "reachable", "ephemeron", "value", "eph", "returns", "either", "the", "value", "or", "bwp", "where", "a", "value", "goes", "to", "bwp", "when", "the", "key", "be", "unreachable", "even", "if", "the", "value", "be", "otherwise", "still", "reachable", "ephemeron", "key", "eph", "returns", "either", "the", "key", "or", "bwp", "the", "key", "and", "value", "go", "to", "bwp", "at", "the", "same", "time", "ephemeron", "v", "report", "whether", "v", "be", "an", "ephemeron", "Racket", "do", "not", "provide", "an", "ephemeron", "key", "operation", "and", "I", "doubt", "that", "it", "s", "useful", "but", "it", "seems", "harmless", "NUMBER", "The", "other", "function", "match", "Racket", "which", "explains", "the", "make", "on", "the", "front", "of", "make", "ephemeron", "except", "that", "Racket", "uses", "f", "in", "place", "of", "bwp", "NUMBER", "The", "implementation", "include", "a", "new", "type", "tag", "for", "ephemerons", "and", "a", "new", "space", "since", "the", "sweep", "action", "be", "special", "NUMBER", "The", "GC", "change", "avoids", "quadratic", "time", "ephemeron", "processing", "by", "registering", "each", "discover", "ephemeron", "with", "the", "segment", "that", "contains", "its", "key", "if", "the", "key", "has", "not", "be", "determined", "to", "be", "reachable", "already", "NUMBER", "The", "second", "part", "of", "LINK", "sets", "up", "an", "example", "that", "would", "exhibit", "quadratic", "time", "behavior", "otherwise", "NUMBER", "Triggering", "ephemerons", "requires", "that", "copy", "check", "the", "old", "space", "segment", "for", "each", "object", "NUMBER", "This", "extra", "check", "on", "every", "copy", "be", "not", "measurable", "in", "my", "test", "so", "far", "NUMBER", "Where", "copy", "use", "to", "take", "a", "space", "kind", "argument", "it", "now", "takes", "a", "space", "info", "argument", "which", "was", "always", "computed", "to", "get", "the", "space", "kind", "argument", "so", "I", "think", "that", "part", "of", "the", "change", "has", "no", "effect", "by", "itself", "NUMBER", "An", "ephemeron", "be", "allocated", "with", "room", "for", "two", "extra", "pointers", "that", "be", "use", "at", "GC", "time", "one", "for", "a", "list", "of", "a", "all", "discover", "ephemerons", "and", "one", "for", "a", "segment", "specific", "list", "to", "trigger", "NUMBER", "Having", "the", "extra", "pointer", "space", "in", "the", "object", "be", "convenient", "but", "I", "wonder", "whether", "it", "s", "better", "to", "allocate", "those", "administrative", "lists", "separately", "during", "collection", "NUMBER", "Thanks", "for", "work", "on", "this", "NUMBER", "If", "successful", "it", "might", "be", "a", "useful", "substitute", "for", "weak", "pairs", "in", "weak", "eq", "hashables", "which", "probably", "should", "probably", "have", "ephemeron", "like", "behavior", "NUMBER", "To", "that", "end", "do", "you", "think", "it", "would", "be", "possible", "to", "make", "ephemerons", "a", "kind", "of", "pair", "like", "weak", "pairs", "Extra", "field", "should", "be", "okay", "if", "needed", "NUMBER", "gc", "support", "for", "mutable", "ephemerons", "could", "be", "tricky", "NUMBER", "Incidentally", "I", "just", "glanced", "at", "the", "first", "couple", "of", "diffs", "and", "I", "notice", "that", "faslin", "uses", "INITCAR", "and", "INITCDR", "to", "initialize", "field", "of", "an", "ephemeron", "NUMBER", "I", "don", "t", "think", "that", "will", "work", "unless", "ephemerons", "become", "pairs", "so", "I", "m", "guessing", "it", "hasn", "t", "be", "test", "NUMBER", "I", "ll", "look", "closer", "at", "the", "code", "when", "I", "get", "a", "chance", "NUMBER", "I", "initially", "considered", "make", "ephemerons", "like", "weak", "pairs", "with", "the", "key", "and", "value", "as", "be", "car", "and", "cdr", "respectively", "NUMBER", "That", "didn", "t", "seem", "useful", "in", "the", "same", "way", "as", "weak", "pairs", "though", "since", "you", "generally", "wouldn", "t", "want", "to", "put", "a", "chain", "in", "the", "value", "part", "of", "an", "ephemeron", "NUMBER", "Maybe", "you", "have", "a", "different", "arrangement", "in", "mind", "with", "the", "value", "in", "the", "car", "part", "something", "strongly", "held", "in", "the", "cdr", "part", "and", "the", "key", "in", "an", "additional", "field", "I", "also", "had", "in", "mind", "that", "Racket", "distinguishes", "ephemerons", "from", "other", "datatypes", "and", "so", "having", "a", "Chez", "level", "empheron", "respond", "t", "to", "pair", "be", "inconvenient", "NUMBER", "That", "s", "a", "Racket", "specific", "issue", "though", "NUMBER", "You", "re", "right", "of", "course", "that", "I", "didn", "t", "test", "the", "fasl", "part", "yet", "NUMBER", "Hashtables", "in", "Chez", "Scheme", "store", "the", "key", "and", "value", "in", "the", "car", "and", "cdr", "of", "a", "pair", "NUMBER", "In", "this", "case", "the", "cdr", "be", "not", "use", "to", "chain", "list", "elements", "NUMBER", "For", "weak", "eq", "hashtables", "the", "pair", "be", "a", "weak", "pair", "NUMBER", "We", "could", "instead", "have", "the", "pair", "be", "an", "ephemeron", "at", "least", "optionally", "if", "ephemerons", "be", "pairs", "needed", "for", "hashtable", "cell", "NUMBER", "Weak", "pairs", "be", "pairs", "but", "they", "can", "be", "distinguished", "via", "the", "weak", "pair", "predicate", "NUMBER", "We", "could", "do", "the", "same", "for", "ephemerons", "NUMBER", "weak", "pair", "a", "slow", "predicate", "however", "since", "it", "has", "to", "index", "into", "the", "segment", "table", "NUMBER", "It", "also", "involves", "a", "foreign", "procedure", "call", "though", "we", "could", "fix", "that", "NUMBER", "I", "forgot", "that", "Chez", "Scheme", "hashables", "expose", "the", "implementation", "s", "use", "of", "pairs", "though", "hashtable", "cell", "so", "now", "I", "understand", "the", "motivation", "for", "make", "ephemerons", "a", "subtype", "of", "pairs", "NUMBER", "I", "ll", "revise", "the", "PR", "to", "make", "the", "additions", "just", "ephemeron", "cons", "and", "ephemeron", "pair", "NUMBER", "I", "don", "t", "immediately", "see", "an", "obstacle", "to", "make", "ephemerons", "mutable", "except", "that", "a", "kind", "of", "race", "condition", "with", "the", "GC", "can", "leave", "you", "with", "a", "half", "bwp", "ed", "pair", "NUMBER", "Did", "you", "have", "different", "problem", "in", "mind", "To", "distinguish", "Racket", "level", "ephemerons", "from", "pairs", "I", "guess", "Racket", "will", "just", "introduce", "an", "extra", "record", "wrapper", "the", "same", "as", "for", "weak", "boxes", "implement", "with", "weak", "pairs", "NUMBER", "Okay", "after", "thinking", "about", "the", "ephemeron", "gc", "problem", "a", "bit", "I", "expected", "to", "see", "something", "like", "this", "in", "the", "code", "A", "NUMBER", "When", "sweeping", "an", "ephemeron", "in", "sweep", "or", "sweep_space", "two", "cases", "NUMBER", "If", "the", "key", "be", "not", "oldspace", "or", "be", "oldspace", "and", "has", "be", "forwarded", "relocate", "both", "the", "key", "and", "the", "value", "NUMBER", "NUMBER", "Otherwise", "associate", "the", "ephemeron", "with", "the", "key", "in", "a", "key", "ephemeron", "table", "implement", "say", "as", "a", "hashtable", "B", "NUMBER", "After", "copying", "any", "non", "flonum", "object", "in", "copy", "relocate", "the", "keys", "and", "values", "of", "all", "ephemerons", "associated", "with", "the", "object", "in", "the", "key", "ephemeron", "table", "and", "remove", "the", "associations", "from", "the", "table", "NUMBER", "C", "NUMBER", "At", "the", "end", "of", "collection", "bwp", "the", "key", "and", "value", "of", "any", "empheron", "present", "in", "the", "key", "ephemeron", "table", "NUMBER", "I", "m", "probably", "miss", "something", "I", "might", "spot", "if", "I", "actually", "tried", "to", "implement", "it", "but", "I", "think", "I", "see", "this", "basic", "structure", "in", "your", "code", "NUMBER", "It", "looks", "like", "your", "code", "treats", "the", "segment", "info", "structure", "as", "a", "coarse", "form", "of", "hashtable", "key", "in", "effect", "and", "that", "perhaps", "because", "of", "this", "it", "handles", "emphemerons", "in", "batches", "at", "the", "end", "of", "each", "sweep_space", "loop", "NUMBER", "It", "also", "seems", "like", "the", "table", "might", "contain", "emphemerons", "for", "which", "the", "key", "has", "already", "be", "forwarded", "and", "for", "this", "you", "need", "the", "trigger", "next", "t", "flag", "NUMBER", "Is", "that", "about", "right", "Using", "the", "segment", "info", "structure", "in", "this", "way", "be", "clever", "but", "I", "wonder", "if", "it", "be", "sufficient", "to", "eliminate", "all", "pathological", "behavior", "NUMBER", "The", "copy", "check", "for", "the", "presence", "of", "a", "list", "in", "si", "be", "less", "overhead", "than", "a", "hashtable", "lookup", "but", "we", "might", "be", "able", "to", "make", "a", "hashtable", "lookup", "reasonably", "inexpensive", "in", "the", "common", "cases", "once", "we", "figure", "out", "what", "those", "be", "NUMBER", "Nobody", "should", "be", "mutating", "a", "pair", "during", "collection", "unless", "it", "s", "locked", "and", "be", "mutated", "from", "C", "code", "in", "which", "case", "I", "m", "not", "too", "excited", "about", "it", "NUMBER", "The", "real", "problem", "be", "dealing", "with", "wrong", "way", "pointers", "in", "sweep_dirty", "and", "an", "analogue", "of", "resweep_dirty_weak_pairs", "though", "we", "might", "get", "away", "without", "the", "latter", "NUMBER", "The", "revised", "commit", "change", "the", "API", "to", "ephemeron", "cons", "and", "ephemeron", "NUMBER", "The", "GC", "implementation", "be", "essentially", "as", "before", "NUMBER", "You", "re", "right", "that", "the", "segment", "info", "structure", "be", "acting", "as", "a", "coarse", "hash", "table", "and", "so", "on", "NUMBER", "I", "believe", "the", "worst", "case", "complexity", "here", "be", "proportional", "to", "the", "square", "of", "the", "number", "of", "objects", "M", "in", "a", "segment", "but", "I", "also", "expect", "that", "worst", "case", "time", "to", "be", "both", "unlikely", "and", "less", "than", "the", "total", "number", "of", "objects", "and", "use", "a", "per", "segment", "trigger", "list", "minimizes", "the", "constant", "factor", "on", "the", "number", "of", "copied", "objects", "NUMBER", "In", "any", "case", "I", "m", "happy", "to", "defer", "to", "your", "judgment", "on", "the", "GC", "time", "data", "structures", "and", "performance", "NUMBER", "I", "don", "t", "see", "the", "need", "for", "something", "like", "resweep_dirty_weak_pairs", "since", "the", "pending", "list", "plays", "a", "similar", "role", "and", "ephemeron", "handle", "in", "sweep_dirty", "seems", "straightforward", "but", "maybe", "it", "s", "beyond", "the", "frontier", "of", "what", "I", "ve", "understood", "NUMBER", "The", "code", "at", "LINK", "be", "a", "step", "closer", "to", "a", "test", "suite", "including", "a", "small", "initial", "test", "for", "fasl", "write", "and", "reading", "NUMBER", "With", "this", "third", "commit", "to", "add", "test", "and", "docs", "the", "pull", "request", "be", "meant", "to", "be", "complete", "NUMBER", "Great", "NUMBER", "weak", "cons", "not", "weaj", "cons", "On", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Matthew", "Flatt", "write", "mflatt", "commented", "on", "this", "pull", "request", "NUMBER", "In", "csug", "smgmt", "NUMBER", "ex", "TAG", "however", "the", "results", "of", "the", "last", "two", "expressions", "will", "always", "be", "scheme", "a", "NUMBER", "b", "because", "the", "cdr", "of", "a", "weak", "pair", "holds", "a", "non", "weak", "reference", "and", "that", "non", "weak", "reference", "prevents", "the", "car", "field", "from", "becoming", "scheme", "bwp", "NUMBER", "entryheader", "formdef", "ephemeron", "pair", "categoryprocedure", "ephemeron", "pair", "var", "obj", "returns", "scheme", "t", "if", "obj", "be", "a", "ephemeron", "pair", "scheme", "f", "otherwise", "listlibraries", "endentryheader", "schemedisplay", "ephemeron", "pair", "ephemeron", "cons", "a", "b", "t", "ephemeron", "pair", "cons", "a", "b", "f", "ephemeron", "pair", "weaj", "cons", "a", "b", "f", "Thanks", "You", "be", "receiving", "this", "because", "you", "be", "subscribed", "to", "this", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "I", "made", "the", "first", "two", "change", "the", "easy", "ones", "rebased", "and", "include", "a", "commit", "for", "bootfiles", "NUMBER", "I", "can", "squash", "the", "commit", "especially", "the", "non", "bootfile", "ones", "if", "you", "d", "prefer", "NUMBER", "I", "didn", "t", "make", "the", "third", "change", "NUMBER", "I", "think", "the", "indirection", "through", "pending_ephemerons", "makes", "the", "GC", "perform", "less", "work", "in", "the", "common", "case", "but", "probably", "not", "enough", "to", "matter", "NUMBER", "As", "one", "example", "when", "run", "the", "Racket", "expander", "to", "load", "racket", "base", "ephemerons", "be", "use", "for", "weak", "hashtables", "as", "now", "build", "in", "ephemerons", "find", "NUMBER", "NUMBER", "dirty", "ephemerons", "find", "NUMBER", "NUMBER", "ephemeron", "checks", "NUMBER", "NUMBER", "i", "NUMBER", "e", "NUMBER", "how", "many", "times", "a", "key", "be", "checked", "triggers", "install", "NUMBER", "NUMBER", "triggered", "lists", "NUMBER", "triggered", "ephemerons", "NUMBER", "NUMBER", "i", "NUMBER", "e", "NUMBER", "ephemerons", "in", "those", "lists", "If", "I", "remove", "the", "indirection", "through", "pending_ephemerons", "ephemerons", "find", "NUMBER", "NUMBER", "dirty", "ephemerons", "find", "NUMBER", "NUMBER", "ephemeron", "checks", "NUMBER", "NUMBER", "triggers", "install", "NUMBER", "NUMBER", "triggered", "lists", "NUMBER", "NUMBER", "triggered", "ephemerons", "NUMBER", "NUMBER", "So", "an", "ephemeron", "can", "be", "handle", "immediately", "about", "NUMBER", "NUMBER", "of", "the", "time", "and", "it", "s", "rare", "for", "a", "key", "to", "become", "accessible", "only", "after", "following", "ephemeron", "values", "NUMBER", "As", "a", "result", "the", "indirection", "avoids", "almost", "all", "trigger", "work", "NUMBER", "If", "add", "an", "emphemeron", "to", "pending_ephemerons", "requires", "allocation", "then", "maybe", "it", "s", "worth", "a", "check", "for", "the", "half", "that", "can", "be", "handle", "right", "away", "but", "keep", "the", "indirection", "for", "the", "rest", "NUMBER", "Then", "again", "these", "be", "all", "tiny", "numbers", "relative", "to", "the", "overall", "run", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "The", "gist", "stress", "test", "intentionally", "creates", "chains", "through", "ephemerons", "and", "then", "pending_ephemerons", "has", "no", "effect", "as", "expected", "NUMBER", "Forgot", "to", "revert", "patch", "NUMBER", "ss", "now", "do", "in", "the", "bootfiles", "commit", "NUMBER", "My", "limited", "understanding", "of", "the", "context", "for", "check_dirty_ephemeron", "was", "that", "it", "needs", "to", "decide", "on", "a", "youngest", "result", "immediately", "NUMBER", "The", "more", "eager", "check", "lets", "it", "sometimes", "pick", "a", "more", "precise", "youngest", "NUMBER", "Oh", "if", "the", "eager", "check", "fail", "the", "ephemeron", "could", "be", "put", "in", "the", "pending", "list", "instead", "of", "add", "as", "a", "trigger", "NUMBER", "So", "yes", "I", "think", "I", "made", "check_dirty_ephemeron", "too", "much", "like", "check_ephemeron", "NUMBER", "The", "fxarithmetic", "shift", "left", "procedure", "do", "not", "detect", "overflow", "under", "some", "conditions", "NUMBER", "Here", "be", "some", "comparisons", "showing", "that", "the", "upper", "bits", "of", "the", "result", "be", "discarded", "Scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "fixnum", "width", "NUMBER", "number", "string", "fxarithmetic", "shift", "left", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "number", "string", "bitwise", "arithmetic", "shift", "left", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "number", "string", "fxarithmetic", "shift", "left", "xB", "NUMBER", "NUMBER", "NUMBER", "C", "NUMBER", "number", "string", "bitwise", "arithmetic", "shift", "left", "xB", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "C", "NUMBER", "number", "string", "fxarithmetic", "shift", "left", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "number", "string", "bitwise", "arithmetic", "shift", "left", "x", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Tested", "with", "master", "v", "NUMBER", "NUMBER", "g", "NUMBER", "fbe", "NUMBER", "b", "NUMBER", "on", "a", "Debian", "GNU", "Linux", "NUMBER", "amd", "NUMBER", "system", "NUMBER", "If", "you", "change", "the", "shift", "count", "restriction", "for", "either", "fxsll", "and", "fxsrl", "should", "behave", "like", "fxarithmetic", "shift", "left", "and", "fxarithmetic", "shift", "right", "NUMBER", "The", "latter", "be", "constrained", "not", "to", "allow", "fixnum", "width", "shifts", "by", "R", "NUMBER", "RS", "NUMBER", "fxsll", "and", "fxsrl", "historically", "allow", "fixnum", "width", "shifts", "and", "we", "didn", "t", "change", "that", "when", "add", "the", "R", "NUMBER", "RS", "procedures", "NUMBER", "The", "requirement", "to", "produce", "implementation", "restriction", "on", "fixnum", "overflow", "be", "mention", "in", "the", "introduction", "of", "TSPL", "Section", "NUMBER", "and", "also", "in", "the", "introduction", "of", "the", "R", "NUMBER", "RS", "library", "document", "Section", "NUMBER", "Thanks", "I", "didn", "t", "change", "the", "limits", "for", "the", "shift", "operators", "but", "fix", "the", "overflow", "detection", "NUMBER", "Fixed", "in", "commit", "f", "NUMBER", "b", "NUMBER", "f", "NUMBER", "ab", "NUMBER", "d", "NUMBER", "f", "NUMBER", "d", "NUMBER", "c", "NUMBER", "ceba", "When", "I", "was", "trying", "to", "send", "a", "fixnum", "to", "a", "procedure", "created", "by", "enum", "set", "indexer", "I", "get", "an", "exception", "invalid", "memory", "reference", "NUMBER", "Some", "debugging", "context", "lost", "NUMBER", "I", "know", "send", "a", "number", "to", "this", "procedure", "be", "incorrect", "but", "exception", "won", "t", "happen", "when", "I", "send", "bignum", "symbols", "strings", "or", "other", "objects", "to", "this", "procedure", "so", "it", "may", "be", "a", "bug", "The", "version", "of", "Chez", "Scheme", "be", "NUMBER", "run", "on", "macOS", "NUMBER", "scheme", "define", "e", "make", "enumeration", "a", "b", "c", "d", "enum", "set", "indexer", "e", "NUMBER", "f", "enum", "set", "indexer", "e", "NUMBER", "error", "Fixed", "in", "NUMBER", "df", "NUMBER", "d", "NUMBER", "eb", "NUMBER", "a", "NUMBER", "cb", "NUMBER", "e", "NUMBER", "f", "NUMBER", "f", "NUMBER", "ed", "NUMBER", "I", "be", "trying", "to", "cross", "compile", "Chez", "Scheme", "on", "my", "Lenovo", "tablet", "run", "termux", "a", "unix", "like", "environment", "with", "help", "on", "Google", "Groups", "from", "Atticus", "and", "Andy", "Keep", "NUMBER", "I", "performed", "the", "following", "steps", "Step", "NUMBER", "On", "the", "host", "machine", "an", "i", "NUMBER", "desktop", "run", "Linux", "Mint", "cd", "home", "phil", "git", "clone", "LINK", "cd", "ChezScheme", "master", "NUMBER", "configure", "sudo", "make", "install", "mkdir", "boot", "arm", "NUMBER", "le", "cd", "a", "NUMBER", "le", "make", "f", "Mf", "boot", "arm", "NUMBER", "le", "NUMBER", "boot", "cd", "NUMBER", "NUMBER", "configure", "m", "arm", "NUMBER", "le", "NUMBER", "configure", "workarea", "arm", "NUMBER", "le", "cd", "arm", "NUMBER", "le", "s", "make", "f", "Mf", "cross", "m", "a", "NUMBER", "le", "xm", "arm", "NUMBER", "le", "base", "NUMBER", "NUMBER", "a", "NUMBER", "le", "cd", "NUMBER", "NUMBER", "NUMBER", "Step", "NUMBER", "On", "the", "target", "machine", "a", "Lenovo", "ARM", "tablet", "run", "Android", "NUMBER", "cd", "data", "data", "com", "NUMBER", "termux", "file", "home", "scp", "r", "phil", "haydn", "home", "phil", "ChezScheme", "master", "NUMBER", "edit", "file", "ChezScheme", "master", "configure", "change", "bin", "sh", "to", "data", "data", "com", "NUMBER", "termux", "file", "usr", "bin", "sh", "edit", "file", "ChezScheme", "master", "zlib", "configure", "change", "bin", "sh", "to", "data", "data", "com", "NUMBER", "termux", "file", "usr", "bin", "sh", "cd", "ChezScheme", "master", "arm", "NUMBER", "le", "c", "make", "While", "performing", "this", "step", "make", "encountered", "three", "error", "all", "in", "file", "segment", "NUMBER", "c", "at", "line", "NUMBER", "character", "NUMBER", "symbol", "build_ptr", "at", "line", "NUMBER", "character", "NUMBER", "symbol", "SYMVAL", "at", "line", "NUMBER", "character", "NUMBER", "symbol", "Sflonum_value", "The", "first", "two", "error", "were", "the", "same", "cast", "to", "ptr", "aka", "void", "from", "smaller", "integer", "type", "unsigned", "int", "The", "third", "error", "was", "a", "different", "message", "cast", "to", "double", "from", "smaller", "integer", "type", "unsigned", "int", "The", "C", "compiler", "be", "gcc", "clang", "version", "NUMBER", "target", "aarch", "NUMBER", "linux", "android", "thread", "model", "posix", "NUMBER", "Please", "help", "me", "compile", "Chez", "Scheme", "NUMBER", "It", "sounds", "like", "you", "re", "build", "the", "boot", "and", "header", "file", "for", "NUMBER", "bit", "arm", "NUMBER", "le", "and", "the", "c", "directory", "for", "NUMBER", "bit", "NUMBER", "If", "you", "mean", "to", "build", "the", "NUMBER", "bit", "version", "you", "might", "need", "to", "supply", "the", "m", "NUMBER", "option", "to", "the", "C", "compiler", "NUMBER", "Success", "build", "chez", "on", "android", "arm", "works", "for", "me", "NUMBER", "LOCAL_ARM_MODE", "arm", "LOCAL_CFLAGS", "g", "Wall", "DANDROID", "DINLINES", "DGC_MACROS", "DARMV", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "DLIBICONV_PLUG", "fPIC", "pie", "fPIE", "scheme", "release", "NUMBER", "apk", "LINK", "lib", "master", "data", "apk", "scheme", "release", "NUMBER", "apk", "I", "add", "a", "line", "CFLAGS", "m", "NUMBER", "near", "the", "top", "of", "ChezScheme", "master", "arm", "NUMBER", "le", "c", "Makefile", "above", "the", "line", "that", "defines", "C", "and", "received", "the", "same", "three", "error", "NUMBER", "What", "do", "your", "C", "compiler", "report", "as", "it", "s", "target", "now", "that", "CFLAGS", "be", "set", "to", "target", "a", "NUMBER", "bit", "machine", "In", "your", "original", "email", "you", "indicated", "it", "was", "targeting", "aarch", "NUMBER", "linux", "android", "which", "be", "definitely", "a", "NUMBER", "bit", "architecture", "NUMBER", "andy", "On", "April", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "NUMBER", "PM", "pbewig", "notifications", "github", "NUMBER", "com", "write", "I", "add", "a", "line", "CFLAGS", "m", "NUMBER", "near", "the", "top", "of", "ChezScheme", "master", "arm", "NUMBER", "le", "c", "Makefile", "above", "the", "line", "that", "defines", "C", "and", "received", "the", "same", "three", "error", "NUMBER", "You", "be", "receiving", "this", "because", "you", "be", "subscribed", "to", "this", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "When", "I", "perform", "make", "with", "the", "provide", "Makefile", "as", "I", "did", "before", "my", "first", "message", "I", "get", "the", "following", "error", "gcc", "Wpointer", "arith", "Wextra", "Werror", "O", "NUMBER", "c", "DARMV", "NUMBER", "I", "NUMBER", "boot", "arm", "NUMBER", "le", "I", "NUMBER", "zlib", "segment", "NUMBER", "c", "segment", "NUMBER", "c", "NUMBER", "NUMBER", "error", "cast", "to", "ptr", "aka", "void", "from", "smaller", "integer", "type", "unsigned", "int", "Werror", "Wint", "to", "void", "pointer", "cast", "if", "build_ptr", "base", "NUMBER", "addr", "base", "nact", "uptr", "NUMBER", "TAG", "__int", "NUMBER", "_t", "be", "emulated", "and", "its", "only", "available", "on", "NUMBER", "bit", "platforms", "NUMBER", "Its", "not", "available", "on", "Android", "which", "be", "a", "NUMBER", "bit", "platform", "NUMBER", "Is", "there", "anything", "I", "can", "do", "Just", "define", "__int", "NUMBER", "_t", "to", "int", "pbewig", "Android", "be", "one", "of", "most", "important", "platforms", "now", "any", "plan", "to", "support", "ARMv", "NUMBER", "ARM", "NUMBER", "dybvig", "Chez", "Scheme", "be", "a", "great", "fit", "small", "and", "effective", "of", "script", "programming", "on", "embeded", "devices", "NUMBER", "I", "get", "Chez", "Scheme", "to", "compile", "on", "Android", "within", "the", "GnuRoot", "environment", "NUMBER", "See", "LINK", "chez", "scheme", "on", "android", "arm", "NUMBER", "On", "Mon", "Jan", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "Andy", "Keep", "TAG", "write", "I", "don", "t", "know", "that", "we", "have", "any", "particular", "plan", "to", "work", "on", "this", "right", "now", "but", "we", "would", "certainly", "welcome", "the", "effort", "if", "someone", "wanted", "to", "take", "the", "lead", "on", "the", "porting", "work", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "evilbinary", "On", "my", "android", "arm", "tablet", "when", "I", "say", "sqrt", "NUMBER", "Chez", "responds", "NUMBER", "exactly", "the", "same", "as", "my", "desktop", "computer", "NUMBER", "On", "Tue", "Jan", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "evilbinary", "TAG", "write", "pbewig", "TAG", "android", "arm", "do", "not", "suport", "floating", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "pbewig", "really", "did", "you", "see", "this", "LINK", "evilbinary", "Don", "t", "ever", "doubt", "me", "NUMBER", "image", "Inline", "image", "NUMBER", "On", "Wed", "Jan", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "evilbinary", "TAG", "write", "pbewig", "TAG", "really", "did", "you", "see", "this", "NUMBER", "TAG", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "LINK", "It", "looks", "like", "start_thread", "fail", "to", "process", "the", "guardian", "entries", "when", "calling", "destroy_thread", "NUMBER", "It", "appears", "as", "though", "guardians", "store", "entries", "in", "the", "current", "thread", "context", "NUMBER", "If", "an", "object", "be", "registered", "with", "a", "guardian", "on", "a", "thread", "that", "then", "exits", "calling", "the", "guardian", "never", "results", "in", "the", "objects", "NUMBER", "with", "interrupts", "disabled", "let", "g", "make", "guardian", "fork", "thread", "lambda", "disable", "interrupts", "g", "list", "a", "b", "sleep", "make", "time", "time", "duration", "NUMBER", "NUMBER", "collect", "NUMBER", "NUMBER", "g", "This", "should", "return", "a", "b", "but", "returns", "f", "NUMBER", "You", "re", "right", "NUMBER", "I", "will", "implement", "a", "fix", "unless", "someone", "beats", "me", "to", "it", "NUMBER", "Looks", "good", "Bob", "though", "it", "s", "probably", "not", "necessary", "to", "set", "GUARDIANENTRIES", "tc", "to", "Snil", "before", "freeing", "it", "NUMBER", "Incidentally", "it", "seems", "like", "there", "be", "a", "miss", "break", "after", "status", "NUMBER", "which", "you", "might", "also", "want", "to", "fix", "NUMBER", "run", "chez", "flag", "NUMBER", "should", "according", "to", "the", "man", "page", "pass", "flag", "NUMBER", "through", "as", "command", "line", "or", "command", "line", "argument", "NUMBER", "but", "run", "that", "at", "the", "shell", "raises", "chez", "flag", "NUMBER", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "Exception", "in", "load", "fail", "for", "flag", "no", "such", "file", "or", "directory", "I", "pull", "everything", "from", "master", "today", "and", "compiled", "with", "threads", "installschemename", "chez", "Thanks", "for", "the", "info", "NUMBER", "However", "this", "be", "not", "very", "clear", "in", "the", "man", "page", "and", "should", "maybe", "be", "clarified", "NUMBER", "Agreed", "NUMBER", "I", "have", "attempted", "such", "a", "clarification", "with", "this", "commit", "LINK", "NUMBER", "dybvig", "That", "be", "indeed", "more", "clear", "but", "the", "explanation", "for", "still", "says", "pass", "all", "remaining", "command", "line", "argument", "through", "to", "scheme", "which", "was", "what", "confused", "me", "in", "the", "first", "place", "NUMBER", "I", "was", "write", "a", "getopt", "long", "clone", "and", "needed", "to", "play", "with", "the", "command", "line", "interactively", "NUMBER", "In", "the", "perfect", "world", "everyone", "would", "read", "the", "whole", "man", "page", "but", "as", "it", "be", "now", "it", "be", "often", "just", "a", "quick", "fix", "to", "look", "up", "things", "on", "the", "command", "line", "NUMBER", "Maybe", "When", "program", "or", "script", "be", "present", "pass", "all", "remaining", "argument", "through", "to", "scheme", "NUMBER", "The", "change", "look", "solid", "to", "me", "with", "one", "concern", "NUMBER", "If", "a", "program", "registers", "a", "mutex", "or", "condition", "object", "with", "a", "guardian", "and", "attempts", "to", "use", "the", "mutex", "or", "condition", "object", "after", "retrieving", "it", "from", "the", "guardian", "what", "happens", "We", "have", "a", "similar", "issue", "with", "file", "ports", "for", "which", "we", "use", "a", "similar", "mechanism", "NUMBER", "The", "port", "will", "be", "close", "by", "the", "time", "it", "s", "retrieved", "and", "an", "attempt", "to", "read", "from", "or", "write", "to", "it", "will", "cause", "an", "exception", "to", "be", "raise", "NUMBER", "That", "bothers", "me", "a", "bit", "but", "not", "as", "much", "as", "say", "an", "invalid", "memory", "reference", "or", "memory", "corruption", "NUMBER", "Yes", "I", "think", "so", "NUMBER", "I", "downloaded", "zip", "from", "LINK", "get", "Extracted", "it", "NUMBER", "Following", "LINK", "for", "windows", "I", "install", "Wix", "toolset", "and", "extension", "for", "Visual", "Studio", "NUMBER", "that", "I", "have", "NUMBER", "cygwin", "be", "also", "install", "and", "in", "Path", "NUMBER", "I", "renamed", "configure", "to", "configure", "NUMBER", "exe", "and", "run", "it", "NUMBER", "Nothing", "seems", "to", "happen", "NUMBER", "command", "shell", "doesn", "t", "do", "anything", "NUMBER", "cygwin", "be", "also", "install", "and", "in", "Path", "NUMBER", "I", "renamed", "configure", "to", "configure", "NUMBER", "exe", "and", "run", "it", "NUMBER", "You", "don", "t", "have", "to", "do", "so", "NUMBER", "Steps", "should", "be", "UPDATE", "It", "turned", "out", "following", "steps", "be", "not", "required", "on", "Git", "HEAD", "see", "below", "NUMBER", "NUMBER", "Open", "VS", "NUMBER", "x", "NUMBER", "Native", "Tools", "Command", "Prompt", "NUMBER", "Start", "Cygwin", "on", "the", "VS", "NUMBER", "x", "NUMBER", "Native", "Tools", "Command", "Prompt", "opened", "with", "c", "cygwin", "NUMBER", "Cygwin", "NUMBER", "bat", "NUMBER", "At", "this", "point", "it", "would", "be", "nice", "to", "check", "cl", "NUMBER", "exe", "on", "the", "path", "which", "cl", "Native", "Tools", "should", "configure", "PATH", "value", "for", "you", "so", "you", "don", "t", "have", "to", "change", "PATH", "by", "yourself", "NUMBER", "checkout", "Git", "repository", "extract", "NUMBER", "zip", "somewhere", "and", "cd", "into", "it", "NUMBER", "run", "NUMBER", "configure", "NUMBER", "run", "make", "In", "a", "nutshell", "you", "will", "have", "to", "build", "ChezScheme", "on", "Cygwin", "shell", "it", "do", "not", "provide", "Visual", "Studio", "project", "file", "NUMBER", "Don", "t", "forget", "installing", "make", "git", "and", "other", "friends", "on", "your", "Cygwin", "install", "NUMBER", "Step", "NUMBER", "should", "look", "like", "this", "NUMBER", "snapcrab_noname_", "NUMBER", "NUMBER", "NUMBER", "_", "NUMBER", "NUMBER", "NUMBER", "_no", "NUMBER", "LINK", "NUMBER", "cf", "NUMBER", "e", "NUMBER", "NUMBER", "d", "NUMBER", "d", "cacc", "NUMBER", "f", "NUMBER", "dcd", "NUMBER", "png", "Hi", "First", "of", "all", "I", "have", "NUMBER", "bit", "system", "NUMBER", "So", "I", "install", "Native", "tool", "prompt", "accordingly", "NUMBER", "which", "cl", "and", "which", "make", "didn", "t", "show", "after", "Native", "tool", "and", "so", "I", "add", "the", "bin", "carrying", "those", "to", "PATH", "varaible", "NUMBER", "Even", "after", "add", "which", "cl", "and", "which", "make", "did", "t", "show", "but", "I", "went", "ahead", "NUMBER", "The", "output", "of", "the", "remaining", "steps", "be", "as", "follows", "nwe", "nwe", "PC", "cygdrive", "d", "swbuilds", "ChezScheme", "NUMBER", "NUMBER", "configure", "no", "suitable", "machine", "type", "find", "try", "rerunning", "as", "NUMBER", "configure", "m", "TAG", "available", "machine", "types", "a", "NUMBER", "le", "a", "NUMBER", "nt", "a", "NUMBER", "osx", "i", "NUMBER", "le", "i", "NUMBER", "nt", "i", "NUMBER", "osx", "ta", "NUMBER", "le", "ta", "NUMBER", "nt", "ta", "NUMBER", "osx", "ti", "NUMBER", "le", "ti", "NUMBER", "nt", "and", "ti", "NUMBER", "osx", "nwe", "nwe", "PC", "cygdrive", "d", "swbuilds", "ChezScheme", "NUMBER", "NUMBER", "configure", "m", "i", "NUMBER", "nt", "Total", "Received", "Xferd", "Average", "Speed", "Time", "Time", "Time", "Current", "Dload", "Upload", "Total", "Spent", "Left", "Speed", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "k", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Total", "Received", "Xferd", "Average", "Speed", "Time", "Time", "Time", "Current", "Dload", "Upload", "Total", "Spent", "Left", "Speed", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "k", "NUMBER", "NUMBER", "k", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Total", "Received", "Xferd", "Average", "Speed", "Time", "Time", "Time", "Current", "Dload", "Upload", "Total", "Spent", "Left", "Speed", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "k", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "nwe", "nwe", "PC", "cygdrive", "d", "swbuilds", "ChezScheme", "NUMBER", "I", "tried", "to", "run", "scheme", "NUMBER", "exe", "and", "petite", "NUMBER", "exe", "from", "within", "git", "repository", "NUMBER", "They", "say", "Access", "be", "denied", "NUMBER", "I", "guess", "it", "isn", "t", "build", "properly", "NUMBER", "Rupinder", "NUMBER", "zip", "distribution", "fail", "to", "me", "too", "NUMBER", "Perhaps", "it", "would", "be", "better", "to", "use", "git", "source", "since", "it", "worked", "for", "me", "both", "i", "NUMBER", "nt", "and", "ti", "NUMBER", "nt", "NUMBER", "You", "don", "t", "have", "to", "install", "Chez", "prior", "build", "git", "sources", "NUMBER", "which", "cl", "and", "which", "make", "didn", "t", "show", "after", "Native", "tool", "and", "so", "I", "add", "the", "bin", "carrying", "those", "to", "PATH", "varaible", "NUMBER", "You", "don", "t", "have", "to", "fiddle", "with", "PATH", "variable", "NUMBER", "The", "script", "should", "find", "correct", "tool", "based", "on", "environment", "variables", "NUMBER", "VS", "NUMBER", "installer", "should", "set", "VS", "NUMBER", "COMNTOOLS", "variable", "and", "the", "script", "LINK", "i", "NUMBER", "nt", "uses", "it", "NUMBER", "NUMBER", "actually", "I", "haven", "t", "aware", "they", "ve", "fix", "the", "script", "in", "the", "last", "year", "LINK", "NUMBER", "Now", "my", "steps", "above", "be", "just", "redundant", "NUMBER", "NUMBER", "Open", "Cygwin", "Adding", "Cygwin", "tool", "to", "PATH", "do", "not", "work", "here", "NUMBER", "Always", "use", "Cygwin", "NUMBER", "bat", "or", "mintty", "short", "cut", "which", "Cygwin", "install", "to", "invoke", "bash", "prompt", "and", "issue", "every", "command", "there", "NUMBER", "NUMBER", "NUMBER", "configure", "m", "i", "NUMBER", "nt", "NUMBER", "make", "that", "s", "it", "NUMBER", "I", "tried", "to", "run", "scheme", "NUMBER", "exe", "and", "petite", "NUMBER", "exe", "from", "within", "git", "repository", "NUMBER", "They", "say", "Access", "be", "denied", "NUMBER", "I", "guess", "it", "isn", "t", "build", "properly", "NUMBER", "Perhaps", "it", "be", "just", "a", "symlink", "to", "somewhere", "NUMBER", "It", "won", "t", "work", "outside", "of", "Cygwin", "NUMBER", "I", "put", "my", "build", "at", "LINK", "NUMBER", "Scheme", "NUMBER", "msi", "I", "believe", "it", "be", "the", "expected", "output", "build", "with", "VS", "NUMBER", "pro", "NUMBER", "Hi", "NUMBER", "The", "installer", "works", "of", "course", "NUMBER", "However", "I", "get", "the", "following", "output", "on", "build", "from", "source", "NUMBER", "I", "cleaned", "the", "installation", "directory", "once", "and", "re", "cloned", "NUMBER", "It", "persists", "NUMBER", "nwe", "nwe", "PC", "cygdrive", "d", "swbuilds", "ChezScheme", "NUMBER", "configure", "m", "i", "NUMBER", "nt", "NUMBER", "configure", "line", "NUMBER", "r", "command", "not", "find", "NUMBER", "configure", "line", "NUMBER", "r", "command", "not", "find", "NUMBER", "configure", "line", "NUMBER", "r", "command", "not", "find", "NUMBER", "configure", "line", "NUMBER", "syntax", "error", "near", "unexpect", "token", "do", "r", "configure", "line", "NUMBER", "for", "fn", "in", "boot", "scheme", "NUMBER", "boot", "do", "I", "get", "the", "same", "output", "with", "m", "ti", "NUMBER", "nt", "Rupinder", "Thanks", "okuoku", "and", "Bob", "Despite", "okuoku", "s", "reminder", "I", "forgot", "to", "install", "git", "and", "make", "on", "Cygwin", "which", "I", "did", "now", "and", "build", "seems", "ok", "NUMBER", "Again", "I", "forgot", "to", "give", "argument", "m", "i", "NUMBER", "nt", "but", "make", "seems", "to", "have", "detected", "it", "NUMBER", "To", "be", "safe", "re", "run", "with", "m", "i", "NUMBER", "nt", "NUMBER", "Both", "scheme", "NUMBER", "exe", "and", "petite", "NUMBER", "exe", "be", "available", "and", "run", "ok", "NUMBER", "I", "be", "attaching", "the", "complete", "ouput", "for", "record", "NUMBER", "ouput", "NUMBER", "txt", "LINK", "Rupinder", "I", "be", "closing", "this", "issue", "by", "summarizing", "Okuoku", "s", "and", "Bob", "s", "suggestions", "for", "use", "by", "the", "other", "prospective", "beginners", "NUMBER", "NUMBER", "Ensure", "that", "Cygwin", "be", "install", "on", "your", "Windows", "with", "git", "and", "make", "package", "NUMBER", "NUMBER", "Open", "Cygwin", "by", "Cygwin", "shortcut", "minty", "or", "Cygwin", "NUMBER", "bat", "NUMBER", "cd", "to", "some", "directory", "you", "want", "to", "install", "in", "NUMBER", "NUMBER", "Clone", "current", "ChezScheme", "source", "from", "LINK", "to", "that", "directory", "use", "git", "clone", "LINK", "a", "git", "repository", "will", "be", "created", "named", "ChezScheme", "NUMBER", "NUMBER", "cd", "to", "ChezScheme", "directory", "cloned", "as", "above", "NUMBER", "NUMBER", "NUMBER", "configure", "m", "i", "NUMBER", "nt", "NUMBER", "make", "NUMBER", "scheme", "NUMBER", "exe", "and", "petite", "NUMBER", "exe", "should", "be", "available", "in", "newly", "created", "folders", "i", "NUMBER", "nt", "NUMBER", "NUMBER", "Repeat", "steps", "NUMBER", "and", "NUMBER", "with", "m", "ti", "NUMBER", "nt", "if", "you", "want", "threaded", "version", "too", "NUMBER", "I", "m", "trying", "to", "add", "a", "field", "to", "the", "record", "primref", "in", "s", "primref", "NUMBER", "ss", "LINK", "but", "I", "get", "an", "error", "while", "compile", "NUMBER", "I", "made", "a", "minimized", "version", "of", "my", "change", "LINK", "massa", "ChezScheme", "commit", "NUMBER", "fbc", "NUMBER", "fc", "NUMBER", "ca", "NUMBER", "f", "NUMBER", "b", "NUMBER", "e", "NUMBER", "bb", "NUMBER", "a", "Tests", "in", "Travis", "LINK", "ci", "NUMBER", "org", "gus", "massa", "ChezScheme", "jobs", "NUMBER", "L", "NUMBER", "NUMBER", "Am", "I", "miss", "something", "obvious", "like", "update", "the", "definition", "elsewhere", "or", "do", "I", "have", "to", "recompile", "the", "intermediate", "file", "with", "an", "especial", "command", "Thanks", "I", "have", "to", "retry", "a", "few", "steps", "because", "I", "made", "a", "mistake", "but", "finaly", "this", "worked", "NUMBER", "LINK", "massa", "ChezScheme", "commit", "NUMBER", "ba", "NUMBER", "c", "NUMBER", "cae", "NUMBER", "f", "NUMBER", "ea", "NUMBER", "d", "NUMBER", "ac", "NUMBER", "bf", "NUMBER", "d", "NUMBER", "Tests", "LINK", "ci", "NUMBER", "org", "gus", "massa", "ChezScheme", "build", "NUMBER", "Some", "minor", "details", "remarks", "I", "had", "to", "change", "a", "NUMBER", "osx", "to", "a", "NUMBER", "nt", "everywhere", "and", "add", "NUMBER", "in", "front", "of", "configure", "and", "workarea", "NUMBER", "checkin", "offers", "to", "copy", "too", "many", "file", "NUMBER", "I", "selected", "only", "the", "s", "primref", "NUMBER", "ss", "s", "primvars", "NUMBER", "ss", "boot", "a", "NUMBER", "nt", "petite", "NUMBER", "boot", "and", "boot", "a", "NUMBER", "nt", "scheme", "NUMBER", "boot", "After", "this", "I", "also", "run", "make", "bootfiles", "to", "update", "the", "other", "boot", "file", "NUMBER", "This", "partial", "patch", "no", "test", "or", "docs", "yet", "add", "support", "for", "immutable", "vectors", "strings", "and", "bytestrings", "where", "vector", "set", "and", "similar", "operations", "check", "for", "mutability", "NUMBER", "New", "vector", "set", "immutable", "string", "set", "immutable", "bytevector", "set", "immutable", "operations", "change", "a", "value", "from", "mutable", "to", "immutable", "as", "a", "one", "way", "street", "and", "vector", "immutable", "etc", "NUMBER", "report", "whether", "a", "value", "be", "immutable", "NUMBER", "For", "vectors", "the", "high", "bit", "of", "the", "type", "length", "field", "be", "use", "for", "an", "immutable", "flag", "NUMBER", "For", "strings", "and", "bytevectors", "the", "length", "part", "of", "the", "field", "be", "shifted", "up", "by", "one", "to", "make", "room", "for", "the", "immutable", "bit", "NUMBER", "So", "the", "runtime", "implications", "be", "halving", "of", "the", "maximum", "size", "of", "a", "vector", "string", "or", "bytevector", "which", "could", "matter", "on", "a", "NUMBER", "bit", "platform", "add", "a", "bit", "test", "in", "vector", "set", "string", "set", "etc", "NUMBER", "and", "add", "a", "bitwise", "and", "to", "vector", "length", "and", "the", "range", "check", "for", "vector", "ref", "but", "no", "new", "steps", "for", "string", "length", "or", "string", "ref", "since", "a", "shift", "was", "needed", "already", "add", "a", "range", "check", "in", "make", "vector", "etc", "NUMBER", "since", "the", "maximum", "size", "of", "a", "vector", "no", "longer", "matches", "the", "maximum", "fixnum", "NUMBER", "The", "main", "question", "be", "whether", "those", "implications", "be", "acceptable", "enough", "to", "continue", "NUMBER", "I", "could", "also", "use", "help", "make", "sure", "that", "the", "generate", "code", "be", "a", "good", "as", "possible", "NUMBER", "In", "case", "we", "get", "past", "those", "concerns", "I", "didn", "t", "add", "an", "immutability", "bit", "to", "fxvectors", "just", "because", "Racket", "doesn", "t", "have", "immutable", "fxvectors", "but", "I", "could", "add", "it", "for", "consistency", "NUMBER", "Just", "to", "sync", "I", "ve", "update", "the", "demo", "commit", "to", "include", "immutable", "fxvectors", "and", "fold", "the", "mutability", "test", "into", "the", "type", "test", "for", "strings", "bytevectors", "and", "fxvectors", "NUMBER", "I", "bet", "there", "s", "a", "better", "way", "to", "handle", "the", "vector", "test", "but", "I", "didn", "t", "find", "it", "NUMBER", "So", "this", "commit", "still", "halves", "the", "maximum", "size", "of", "a", "string", "bytevector", "or", "fxvector", "add", "a", "bitwise", "and", "to", "vector", "length", "and", "the", "range", "check", "for", "vector", "ref", "and", "add", "a", "range", "check", "in", "make", "string", "make", "bytevector", "and", "make", "fxvector", "NUMBER", "Just", "to", "clarify", "to", "anyone", "else", "reading", "this", "on", "why", "I", "haven", "t", "tried", "to", "do", "anything", "with", "pairs", "Racket", "s", "mutable", "pair", "be", "a", "separate", "datatype", "from", "its", "immutable", "pair", "so", "Racket", "can", "just", "not", "expose", "set", "car", "and", "set", "cdr", "NUMBER", "The", "problem", "with", "Racket", "vectors", "etc", "NUMBER", "be", "that", "operations", "like", "vector", "ref", "be", "supposed", "to", "work", "on", "mutable", "and", "immutable", "vectors", "alike", "and", "we", "d", "like", "to", "have", "vector", "ref", "string", "ref", "bytevector", "u", "NUMBER", "ref", "bytevectoru", "NUMBER", "set", "etc", "NUMBER", "run", "as", "fast", "as", "possible", "NUMBER", "Immutable", "boxes", "be", "also", "a", "problem", "but", "also", "not", "much", "use", "so", "I", "m", "happy", "to", "do", "something", "slow", "with", "them", "NUMBER", "Sync", "ed", "to", "NUMBER", "d", "NUMBER", "bbae", "NUMBER", "b", "NUMBER", "cef", "NUMBER", "d", "NUMBER", "a", "NUMBER", "a", "NUMBER", "a", "NUMBER", "ee", "NUMBER", "and", "change", "the", "public", "interface", "to", "vector", "immutable", "vector", "etc", "NUMBER", "instead", "of", "vector", "set", "immutable", "NUMBER", "Issues", "and", "question", "Since", "make", "vector", "NUMBER", "always", "returns", "the", "same", "vector", "vector", "immutable", "vector", "doesn", "t", "yet", "work", "on", "the", "empty", "vector", "NUMBER", "Is", "there", "a", "better", "approach", "than", "add", "a", "new", "hand", "code", "primitive", "to", "allocate", "a", "fresh", "NUMBER", "sized", "vector", "To", "support", "immutable", "boxes", "be", "the", "right", "idea", "to", "add", "a", "type", "tag", "b", "NUMBER", "to", "go", "along", "with", "b", "NUMBER", "and", "use", "a", "suitable", "mask", "for", "test", "for", "boxes", "The", "new", "commit", "add", "support", "for", "immutable", "values", "to", "fasl", "but", "write", "be", "disabled", "because", "bootstrapping", "will", "need", "an", "extra", "step", "NUMBER", "I", "think", "I", "know", "how", "to", "do", "that", "and", "end", "up", "with", "suitable", "bootfiles", "but", "be", "the", "disabled", "approach", "the", "right", "idea", "Good", "point", "about", "constructing", "cyclic", "structures", "NUMBER", "Racket", "provides", "make", "reader", "graph", "as", "a", "primitive", "so", "that", "the", "runtime", "system", "can", "construct", "cyclic", "immutable", "data", "NUMBER", "Is", "it", "better", "to", "keep", "the", "more", "restrictive", "interface", "for", "future", "implementation", "flexibility", "and", "add", "something", "like", "make", "reader", "graph", "to", "Chez", "or", "be", "it", "better", "to", "keep", "the", "imperative", "interface", "after", "all", "On", "marking", "the", "empty", "string", "etc", "NUMBER", "as", "immutable", "Although", "the", "empty", "values", "be", "inherently", "immutable", "make", "NUMBER", "immutable", "return", "true", "for", "them", "complicates", "the", "contract", "for", "function", "like", "make", "string", "where", "the", "result", "should", "be", "mutable", "or", "string", "copy", "I", "forgot", "to", "add", "a", "check", "there", "so", "far", "where", "the", "destination", "string", "should", "be", "mutable", "and", "it", "makes", "sense", "to", "pass", "an", "empty", "string", "with", "a", "range", "of", "NUMBER", "characters", "to", "copy", "NUMBER", "On", "the", "whole", "it", "worked", "better", "in", "Racket", "to", "keep", "the", "mutable", "empty", "values", "separate", "from", "the", "immutable", "ones", "NUMBER", "Bootstrapping", "when", "I", "uncomment", "the", "uses", "of", "vector", "immutable", "etc", "NUMBER", "in", "fasl", "NUMBER", "ss", "then", "I", "get", "unbound", "variable", "error", "NUMBER", "I", "thought", "it", "was", "a", "bootstrapping", "issue", "but", "maybe", "I", "m", "doing", "something", "else", "wrong", "NUMBER", "Thanks", "for", "the", "comments", "NUMBER", "I", "ll", "look", "into", "those", "NUMBER", "Meanwhile", "new", "issue", "with", "the", "latest", "commit", "I", "add", "the", "immutable", "empty", "vector", "to", "S_G", "and", "made", "it", "accessible", "to", "vector", "immutable", "vector", "via", "a", "cs", "null_immutable_vector", "foreign", "procedure", "while", "fasl", "NUMBER", "c", "accesses", "S_G", "NUMBER", "null_immutable_vector", "directly", "NUMBER", "Is", "there", "a", "better", "or", "more", "canonical", "way", "To", "make", "bytevector", "treat", "immutable", "and", "mutable", "bytevectors", "as", "equal", "I", "had", "to", "introduce", "a", "new", "len", "NUMBER", "temporary", "NUMBER", "I", "don", "t", "know", "how", "much", "that", "matters", "I", "think", "I", "couldn", "t", "inline", "the", "expression", "for", "len", "NUMBER", "in", "the", "if", "test", "because", "that", "position", "has", "a", "more", "restricted", "grammar", "than", "the", "right", "hand", "side", "of", "set", "but", "I", "m", "not", "certain", "NUMBER", "What", "would", "be", "the", "process", "of", "add", "a", "set", "box", "library", "entry", "I", "get", "a", "miss", "no", "headroom", "libspec", "if", "I", "just", "comment", "the", "set", "box", "definition", "in", "library", "NUMBER", "ss", "NUMBER", "This", "doesn", "t", "matter", "for", "the", "commit", "but", "I", "m", "curious", "about", "the", "concept", "that", "I", "m", "miss", "NUMBER", "To", "be", "clear", "when", "I", "referred", "to", "contracts", "before", "I", "didn", "t", "mean", "the", "implementation", "of", "a", "contract", "system", "like", "racket", "contract", "but", "instead", "the", "way", "that", "programmers", "reason", "about", "contracts", "NUMBER", "For", "example", "if", "a", "programmer", "decides", "to", "implement", "string", "reverse", "should", "it", "accept", "the", "empty", "string", "If", "so", "and", "if", "the", "implementer", "include", "defensive", "checks", "the", "implementer", "must", "be", "careful", "to", "check", "for", "the", "empty", "string", "in", "addition", "to", "whether", "the", "string", "be", "immutable", "NUMBER", "If", "not", "clients", "must", "be", "careful", "to", "never", "pass", "an", "empty", "string", "NUMBER", "The", "contracts", "be", "easier", "to", "reason", "about", "when", "mutability", "be", "independent", "of", "length", "whether", "or", "not", "the", "contracts", "be", "enforced", "or", "not", "at", "a", "given", "time", "through", "a", "contract", "system", "NUMBER", "dybvig", "The", "latest", "commit", "follows", "your", "suggestions", "including", "change", "the", "error", "message", "NUMBER", "I", "add", "both", "mutable", "vector", "and", "immutable", "vector", "etc", "NUMBER", "to", "replace", "vector", "immutable", "etc", "NUMBER", "Ok", "that", "change", "be", "do", "NUMBER", "Unless", "I", "m", "miss", "something", "I", "don", "t", "have", "any", "pending", "issue", "at", "this", "point", "NUMBER", "Making", "mutable", "vector", "and", "immutable", "vector", "both", "return", "true", "for", "the", "empty", "vector", "could", "make", "sense", "NUMBER", "I", "didn", "t", "pursue", "that", "though", "because", "it", "doesn", "t", "fit", "with", "Racket", "s", "exist", "API", "where", "not", "immutable", "mutable", "NUMBER", "This", "patch", "add", "record", "equal", "hash", "for", "get", "or", "setting", "a", "customization", "for", "equal", "and", "equal", "hash", "on", "an", "RTD", "to", "apply", "to", "its", "instances", "NUMBER", "Potential", "issue", "The", "API", "explicitly", "uses", "a", "pair", "of", "function", "and", "the", "identity", "of", "the", "pair", "be", "relevant", "for", "determining", "when", "the", "pair", "s", "car", "be", "use", "for", "equal", "NUMBER", "Any", "suggestions", "for", "a", "more", "tasteful", "data", "structure", "or", "API", "Relatedly", "although", "there", "s", "a", "check", "when", "a", "pair", "be", "provide", "that", "its", "car", "and", "cdr", "have", "procedures", "the", "pair", "could", "be", "mutated", "at", "any", "time", "NUMBER", "The", "effect", "of", "mutation", "be", "not", "particularly", "specified", "NUMBER", "When", "use", "record", "equal", "hash", "to", "get", "an", "RTD", "s", "current", "mapping", "there", "s", "no", "way", "to", "distinguish", "an", "explicit", "mapping", "versus", "inheriting", "and", "ancestor", "s", "mapping", "NUMBER", "The", "difference", "can", "matter", "if", "the", "ancestor", "s", "mapping", "be", "change", "in", "which", "case", "the", "change", "be", "inherited", "NUMBER", "The", "mapping", "be", "implement", "by", "a", "property", "on", "the", "RTD", "s", "UID", "NUMBER", "Is", "there", "a", "convention", "for", "property", "keys", "to", "avoid", "conflict", "The", "code", "s", "indentation", "doesn", "t", "quite", "match", "the", "rest", "of", "the", "Chez", "Scheme", "code", "NUMBER", "If", "that", "s", "important", "what", "Emacs", "configuration", "would", "do", "the", "right", "thing", "dybvig", "Thanks", "for", "the", "review", "and", "corrections", "As", "long", "as", "the", "thread", "safety", "issue", "be", "also", "address", "I", "think", "path", "compression", "should", "always", "work", "with", "the", "exist", "implementation", "due", "to", "an", "empty", "record", "that", "be", "install", "when", "an", "RTD", "has", "no", "setting", "and", "no", "parent", "NUMBER", "Is", "use", "with", "tc", "mutex", "around", "the", "property", "manipulations", "be", "sure", "to", "check", "for", "an", "exist", "system", "property", "value", "within", "the", "mutex", "for", "an", "empty", "record", "enough", "to", "avoid", "the", "thread", "safety", "issue", "that", "you", "see", "Of", "course", "that", "wouldn", "t", "be", "enough", "to", "make", "equality", "installing", "operations", "on", "RTD", "allow", "concurrent", "to", "use", "equal", "on", "instances", "of", "the", "RTD", "or", "other", "installations", "on", "the", "RTD", "or", "its", "children", "but", "that", "unsafety", "seems", "ok", "and", "consistent", "with", "other", "choices", "NUMBER", "Thanks", "for", "the", "suggestions", "on", "excising", "pairs", "from", "the", "API", "NUMBER", "Relying", "on", "the", "identity", "of", "the", "customized", "RTD", "be", "closer", "to", "where", "I", "start", "and", "I", "lost", "my", "way", "during", "some", "other", "bad", "turns", "NUMBER", "I", "have", "in", "mind", "make", "record", "equal", "hash", "return", "an", "RTD", "as", "well", "as", "the", "equality", "and", "hashing", "procedures", "which", "generally", "address", "the", "issue", "of", "distinguishing", "inherited", "versus", "direct", "results", "NUMBER", "Only", "sputprop", "and", "not", "sgetprop", "Is", "there", "something", "like", "a", "TSO", "guarantee", "so", "that", "getprop", "doesn", "t", "need", "to", "be", "wrapped", "I", "tried", "to", "wrap", "all", "the", "sputprop", "s", "that", "could", "affect", "uids", "but", "maybe", "that", "s", "not", "right", "if", "any", "symbol", "can", "be", "a", "uid", "NUMBER", "If", "so", "would", "it", "be", "better", "to", "put", "the", "with", "tc", "mutex", "in", "putprop", "On", "closer", "inspection", "I", "see", "that", "with", "tc", "mutex", "was", "generally", "in", "place", "around", "sputprop", "s", "and", "sremprop", "s", "except", "in", "initialization", "places", "where", "no", "threads", "can", "be", "run", "NUMBER", "I", "ended", "up", "keep", "only", "NUMBER", "additions", "in", "exist", "code", "in", "record", "NUMBER", "ss", "NUMBER", "Just", "in", "case", "the", "patch", "be", "ready", "to", "merge", "I", "ve", "squashed", "and", "add", "a", "bootfiles", "commit", "NUMBER", "This", "patch", "now", "has", "Kent", "s", "split", "into", "separate", "function", "for", "setting", "equality", "and", "hashing", "function", "and", "separate", "function", "for", "get", "the", "procedures", "to", "be", "use", "for", "a", "given", "set", "of", "equality", "or", "hashing", "argument", "NUMBER", "dybvig", "I", "notice", "a", "few", "typo", "in", "the", "docs", "and", "I", "add", "a", "small", "clarification", "on", "the", "default", "hashing", "function", "NUMBER", "Otherwise", "this", "all", "works", "great", "for", "me", "NUMBER", "The", "update", "foreign", "NUMBER", "ms", "mats", "expose", "a", "bug", "in", "the", "handle", "of", "floating", "point", "varargs", "in", "NUMBER", "bit", "Windows", "NUMBER", "According", "to", "Microsoft", "floating", "point", "varargs", "values", "should", "be", "loaded", "into", "the", "XMM", "register", "as", "well", "as", "the", "integer", "register", "for", "the", "first", "four", "argument", "LINK", "us", "library", "dd", "NUMBER", "wa", "NUMBER", "c", "NUMBER", "aspx", "load", "shared", "object", "msvcrt", "NUMBER", "dll", "define", "f", "foreign", "procedure", "printf", "string", "double", "int", "f", "g", "NUMBER", "NUMBER", "exit", "NUMBER", "e", "NUMBER", "I", "have", "a", "fix", "on", "the", "rgburger", "varargs", "branch", "NUMBER", "I", "wanted", "to", "set", "the", "integer", "register", "to", "be", "the", "floating", "point", "register", "but", "it", "looks", "as", "though", "the", "x", "NUMBER", "_", "NUMBER", "code", "generator", "do", "not", "distinguish", "between", "integer", "and", "XMM", "registers", "in", "the", "reg", "record", "NUMBER", "So", "I", "add", "a", "new", "primitive", "move", "double", "that", "do", "the", "sse", "NUMBER", "movd", "instruction", "NUMBER", "If", "there", "s", "a", "better", "way", "to", "do", "this", "please", "comment", "Thanks", "I", "update", "rgburger", "varargs", "with", "this", "change", "NUMBER", "I", "also", "find", "that", "Windows", "do", "not", "support", "single", "precision", "floating", "point", "argument", "to", "varargs", "procedures", "so", "I", "remove", "that", "change", "NUMBER", "If", "this", "looks", "good", "I", "ll", "update", "the", "suite", "of", "boot", "file", "NUMBER", "Thanks", "I", "ve", "test", "the", "change", "on", "Windows", "Linux", "and", "Mac", "OS", "X", "NUMBER", "They", "re", "now", "merge", "to", "master", "NUMBER", "Accesses", "exist", "but", "hidden", "DST", "information", "in", "date", "records", "NUMBER", "This", "PR", "do", "not", "provide", "a", "way", "to", "explicitly", "construct", "date", "objects", "where", "date", "dst", "produces", "t", "since", "that", "would", "require", "a", "change", "to", "the", "make", "date", "signature", "NUMBER", "Instead", "only", "dates", "constructed", "with", "current", "date", "or", "time", "utc", "date", "or", "where", "the", "OS", "determines", "that", "the", "date", "provide", "to", "make", "date", "be", "in", "DST", "will", "have", "date", "dst", "as", "t", "NUMBER", "Todo", "x", "rename", "to", "date", "dst", "x", "fix", "test", "failures", "test", "on", "Windows", "x", "figure", "out", "whether", "make", "date", "ever", "sets", "isdst", "to", "t", "NUMBER", "I", "ll", "go", "with", "date", "dst", "which", "be", "the", "name", "we", "use", "in", "Racket", "as", "well", "NUMBER", "I", "have", "not", "test", "on", "Windows", "I", "ll", "see", "about", "doing", "that", "although", "that", "ifdef", "block", "do", "not", "seem", "to", "change", "the", "tm_isdst", "value", "NUMBER", "Reading", "this", "man", "page", "for", "mktime", "LINK", "suggests", "that", "it", "will", "only", "guess", "if", "the", "input", "be", "NUMBER", "for", "tm_isdst", "whereas", "we", "re", "setting", "it", "to", "NUMBER", "in", "S_mktime", "in", "stats", "NUMBER", "c", "NUMBER", "Should", "that", "be", "change", "to", "NUMBER", "A", "note", "for", "the", "docs", "While", "Daylight", "Savings", "Time", "be", "certainly", "in", "widespread", "use", "the", "official", "name", "be", "Daylight", "Saving", "Time", "NUMBER", "You", "can", "go", "learn", "all", "kinds", "of", "fascinating", "stuff", "by", "poking", "around", "on", "Wikipedia", "but", "here", "s", "a", "link", "to", "the", "last", "US", "legislation", "that", "update", "DST", "wherein", "you", "can", "find", "its", "reference", "to", "adjusting", "the", "Daylight", "Saving", "Time", "LINK", "NUMBER", "publ", "NUMBER", "html", "PLAW", "NUMBER", "publ", "NUMBER", "htm", "I", "think", "that", "setting", "tm_isdst", "to", "NUMBER", "before", "calling", "mktime", "will", "eliminate", "the", "need", "for", "the", "WIN", "NUMBER", "code", "NUMBER", "See", "LINK", "us", "cpp", "c", "runtime", "library", "reference", "mktime", "mktime", "NUMBER", "mktime", "NUMBER", "One", "question", "while", "I", "work", "on", "test", "these", "change", "how", "do", "I", "run", "a", "subset", "of", "the", "test", "say", "just", "date", "NUMBER", "ms", "I", "think", "this", "be", "now", "do", "except", "for", "test", "on", "Windows", "NUMBER", "Why", "don", "t", "we", "add", "a", "tri", "state", "dst", "argument", "to", "make", "date", "Then", "make", "date", "would", "have", "all", "the", "options", "NUMBER", "I", "ve", "write", "production", "code", "that", "uses", "make", "date", "with", "UTC", "dates", "where", "I", "do", "not", "want", "the", "DST", "offset", "applied", "NUMBER", "I", "don", "t", "understand", "what", "the", "WIN", "NUMBER", "code", "be", "doing", "NUMBER", "Why", "do", "it", "apply", "the", "time", "zone", "and", "DST", "offset", "of", "the", "_current", "time_", "to", "the", "date", "time", "specified", "GetTimeZoneInformation", "doesn", "t", "look", "at", "the", "date", "specified", "NUMBER", "Unfortunately", "the", "else", "part", "doesn", "t", "compile", "under", "Windows", "NUMBER", "I", "don", "t", "understand", "what", "s", "going", "on", "with", "the", "tz", "offsets", "in", "this", "code", "so", "I", "don", "t", "know", "what", "to", "recommend", "NUMBER", "Racket", "has", "very", "similar", "code", "for", "Windows", "see", "here", "LINK", "L", "NUMBER", "L", "NUMBER", "which", "it", "also", "uses", "to", "compute", "whether", "the", "date", "be", "in", "DST", "NUMBER", "The", "Racket", "code", "for", "Windows", "looks", "good", "NUMBER", "Can", "the", "S_mktime", "code", "set", "the", "tmx", "NUMBER", "tm_gmtoff", "before", "calling", "mktime", "and", "avoid", "the", "difftime", "Unfortunately", "Windows", "doesn", "t", "have", "the", "tm_gmtoff", "member", "NUMBER", "I", "think", "the", "right", "repair", "for", "Windows", "be", "TIME_ZONE_INFORMATION", "tz", "long", "tzoff", "The", "NUMBER", "ForYear", "function", "be", "available", "on", "Windows", "Vista", "and", "later", "GetTimeZoneInformationForYear", "tmx", "NUMBER", "tm_year", "NULL", "tz", "if", "tmx", "NUMBER", "tm_isdst", "tzoff", "tz", "NUMBER", "Bias", "tz", "NUMBER", "DaylightBias", "NUMBER", "else", "tzoff", "tz", "NUMBER", "Bias", "tz", "NUMBER", "StandardBias", "NUMBER", "if", "tzoff", "orig_tzoff", "tx", "time_t", "difftime", "tx", "time_t", "orig_tzoff", "tzoff", "Note", "that", "it", "uses", "a", "function", "that", "s", "only", "available", "in", "Vista", "and", "later", "NUMBER", "Racket", "checks", "dynamically", "for", "the", "function", "and", "uses", "an", "older", "one", "on", "XP", "and", "earlier", "but", "I", "don", "t", "know", "if", "XP", "an", "earlier", "be", "an", "issue", "anymore", "NUMBER", "A", "possible", "locale", "independent", "test", "to", "demonstrate", "the", "problem", "with", "the", "old", "code", "Get", "the", "difference", "between", "June", "NUMBER", "and", "January", "NUMBER", "in", "seconds", "and", "check", "whether", "that", "difference", "be", "consistent", "with", "the", "DST", "results", "for", "each", "NUMBER", "There", "be", "NUMBER", "possible", "cases", "no", "DST", "or", "more", "generally", "same", "DST", "for", "January", "and", "June", "shorter", "by", "an", "hour", "in", "the", "northern", "hemisphere", "with", "DST", "i", "NUMBER", "e", "NUMBER", "January", "be", "not", "DST", "and", "June", "be", "or", "longer", "by", "an", "hour", "in", "the", "southern", "hemisphere", "with", "DST", "assuming", "that", "DST", "be", "always", "a", "NUMBER", "hour", "shift", "NUMBER", "The", "date", "dst", "test", "in", "the", "current", "commit", "seems", "locale", "specific", "since", "June", "NUMBER", "NUMBER", "was", "not", "in", "DST", "everywhere", "NUMBER", "The", "only", "idea", "I", "have", "for", "a", "test", "involves", "add", "a", "way", "to", "lookup", "the", "time", "zone", "abbreviation", "which", "would", "be", "handy", "for", "Racket", "on", "Chez", "Scheme", "and", "then", "a", "test", "could", "work", "in", "a", "handful", "of", "recognized", "time", "zones", "NUMBER", "I", "ve", "push", "a", "variant", "of", "Sam", "s", "patch", "to", "mflatt", "ChezScheme", "b", "NUMBER", "ae", "NUMBER", "fc", "NUMBER", "f", "NUMBER", "f", "NUMBER", "e", "NUMBER", "a", "NUMBER", "ca", "NUMBER", "c", "NUMBER", "b", "NUMBER", "a", "NUMBER", "rebased", "to", "master", "NUMBER", "It", "ended", "up", "be", "more", "of", "a", "change", "than", "I", "planned", "NUMBER", "While", "looking", "into", "time", "zone", "names", "I", "saw", "that", "there", "was", "no", "way", "to", "create", "a", "date", "with", "an", "arbitrary", "day", "such", "that", "the", "zone", "offset", "be", "set", "to", "be", "consistent", "with", "Daylight", "Saving", "for", "that", "day", "NUMBER", "Instead", "the", "zone", "offset", "would", "stay", "as", "provide", "to", "make", "date", "NUMBER", "Also", "if", "you", "provide", "a", "time", "zone", "offset", "to", "make", "date", "then", "the", "result", "of", "date", "dst", "doesn", "t", "match", "up", "with", "that", "offset", "NUMBER", "So", "I", "made", "the", "zone", "offset", "optional", "for", "make", "date", "NUMBER", "When", "not", "provide", "the", "offset", "be", "determined", "by", "the", "system", "time", "zone", "setting", "as", "appropriate", "for", "the", "target", "day", "date", "dst", "be", "set", "appropriately", "and", "date", "zone", "name", "be", "now", "set", "NUMBER", "When", "a", "zone", "offset", "be", "provide", "then", "date", "dst", "and", "date", "zone", "name", "of", "the", "date", "both", "return", "f", "NUMBER", "Date", "constructions", "without", "an", "explicit", "zone", "offset", "now", "allocate", "an", "extra", "string", "each", "time", "but", "I", "expect", "that", "s", "ok", "NUMBER", "Similarly", "there", "s", "a", "copy", "vector", "in", "date", "time", "utc", "to", "avoid", "mutating", "the", "given", "date", "s", "time", "zone", "information", "NUMBER", "samth", "If", "the", "variant", "looks", "ok", "then", "I", "suggest", "moving", "it", "to", "your", "branch", "for", "this", "pull", "request", "NUMBER", "Note", "I", "remove", "the", "true", "flag", "from", "the", "primdata", "NUMBER", "ss", "spec", "for", "date", "dst", "since", "the", "selector", "doesn", "t", "always", "return", "a", "true", "value", "NUMBER", "I", "ve", "adopted", "mflatt", "s", "change", "fix", "an", "error", "on", "Linux", "discover", "by", "spall", "and", "push", "here", "NUMBER", "Building", "bootfiles", "run", "test", "now", "may", "need", "some", "line", "number", "fix", "in", "the", "test", "NUMBER", "Bootfiles", "build", "still", "some", "line", "number", "error", "to", "repair", "I", "think", "NUMBER", "dybvig", "any", "suggestion", "for", "how", "to", "maintain", "the", "mats", "file", "other", "than", "manually", "The", "change", "for", "Windows", "look", "good", "NUMBER", "The", "mat", "patch", "file", "change", "be", "incorrect", "NUMBER", "They", "cause", "lots", "of", "false", "report", "for", "o", "NUMBER", "spi", "t", "p", "t", "on", "a", "NUMBER", "nt", "NUMBER", "This", "be", "now", "do", "and", "successfully", "pass", "make", "test", "NUMBER", "samth", "all", "of", "the", "patch", "file", "need", "to", "be", "update", "NUMBER", "In", "particular", "patch", "compile", "NUMBER", "t", "f", "f", "patch", "interpret", "NUMBER", "f", "f", "f", "and", "patch", "interpret", "NUMBER", "f", "t", "f", "need", "to", "be", "update", "for", "make", "allx", "to", "succeed", "in", "the", "mats", "directory", "NUMBER", "burgerrg", "I", "tried", "run", "make", "patches", "in", "ta", "NUMBER", "le", "mats", "but", "I", "get", "error", "like", "this", "rm", "f", "patch", "compile", "NUMBER", "t", "f", "f", "diff", "context", "error", "compile", "NUMBER", "f", "f", "f", "error", "compile", "NUMBER", "t", "f", "f", "patch", "compile", "NUMBER", "t", "f", "f", "Mf", "base", "NUMBER", "recipe", "for", "target", "xpatch", "compile", "NUMBER", "t", "f", "f", "fail", "make", "NUMBER", "xpatch", "compile", "NUMBER", "t", "f", "f", "Error", "NUMBER", "ignored", "I", "haven", "t", "do", "this", "before", "either", "but", "I", "m", "guessing", "that", "we", "need", "to", "run", "all", "the", "combinations", "first", "NUMBER", "for", "EVAL", "in", "compile", "interpret", "do", "for", "O", "in", "NUMBER", "NUMBER", "NUMBER", "do", "for", "SPI", "in", "f", "t", "do", "for", "CP", "NUMBER", "in", "f", "t", "do", "for", "CIS", "in", "f", "t", "do", "make", "report", "eval", "EVAL", "o", "O", "spi", "SPI", "cp", "NUMBER", "CP", "NUMBER", "cis", "CIS", "do", "do", "do", "do", "do", "and", "then", "run", "make", "patches", "NUMBER", "I", "m", "trying", "this", "on", "a", "NUMBER", "le", "now", "NUMBER", "Ok", "trying", "that", "NUMBER", "That", "took", "quite", "a", "while", "but", "didn", "t", "fix", "the", "error", "in", "make", "patches", "NUMBER", "I", "don", "t", "think", "the", "ignored", "failures", "be", "relevant", "NUMBER", "Doing", "this", "procedure", "should", "have", "fix", "several", "of", "the", "patch", "file", "and", "introduce", "a", "couple", "new", "ones", "NUMBER", "Be", "sure", "to", "cp", "patch", "NUMBER", "NUMBER", "mats", "so", "that", "git", "observes", "the", "change", "NUMBER", "When", "I", "run", "this", "on", "both", "a", "NUMBER", "nt", "and", "a", "NUMBER", "le", "I", "had", "several", "fix", "to", "the", "patch", "file", "and", "a", "couple", "new", "ones", "NUMBER", "dybvig", "should", "we", "add", "an", "all", "report", "target", "to", "mats", "Mf", "base", "that", "do", "MAKE", "report", "on", "every", "combination", "Do", "we", "need", "every", "combination", "I", "don", "t", "completely", "understand", "the", "patch", "system", "for", "mats", "NUMBER", "samth", "your", "update", "patches", "worked", "for", "Windows", "NUMBER", "Please", "squash", "that", "commit", "with", "the", "original", "commit", "rebase", "onto", "master", "and", "then", "update", "the", "boot", "file", "NUMBER", "Thanks", "burgerrg", "Done", "NUMBER", "Thanks", "Sam", "I", "m", "going", "to", "see", "if", "we", "can", "skip", "the", "bootfiles", "commit", "and", "combine", "with", "a", "fix", "for", "issue", "NUMBER", "Hii", "ChezScheme", "team", "I", "find", "this", "project", "to", "be", "an", "amazing", "asset", "for", "learning", "I", "ve", "gone", "through", "the", "WIki", "not", "much", "here", "Docs", "and", "the", "Book", "as", "well", "but", "I", "didn", "t", "see", "any", "reference", "to", "the", "byte", "code", "or", "the", "VM", "having", "seen", "the", "garbage", "collection", "be", "documented", "so", "thoroughly", "I", "imagined", "ChezScheme", "has", "a", "VM", "or", "something", "NUMBER", "Could", "you", "please", "point", "me", "to", "the", "right", "resources", "I", "m", "not", "as", "proficient", "in", "reading", "the", "source", "code", "as", "of", "yet", "Thank", "you", "dybvig", "for", "the", "wonderful", "response", "NUMBER", "I", "was", "wondering", "about", "what", "makes", "Chez", "different", "from", "Racket", "or", "Guile", "NUMBER", "Also", "could", "you", "please", "tell", "me", "more", "about", "the", "design", "decisions", "that", "the", "ChezScheme", "team", "has", "made", "regard", "targeting", "LLVM", "if", "at", "all", "P", "NUMBER", "S", "NUMBER", "I", "love", "reading", "Source", "code", "and", "understanding", "the", "organization", "of", "project", "and", "I", "must", "say", "Chez", "has", "one", "of", "the", "cleanest", "code", "bases", "NUMBER", "Mm", "hmm", "so", "I", "ll", "close", "the", "issue", "NUMBER", "I", "do", "hope", "to", "see", "a", "better", "documentation", "of", "the", "internals", "though", "soon", "dybvig", "I", "ve", "be", "use", "Chez", "a", "lot", "and", "I", "can", "honestly", "say", "I", "look", "forward", "to", "use", "it", "more", "and", "more", "NUMBER", "However", "I", "d", "like", "to", "ask", "you", "whether", "it", "s", "possible", "to", "replace", "the", "C", "code", "with", "say", "Rust", "or", "Go", "and", "make", "Chez", "a", "more", "native", "companion", "to", "that", "language", "How", "much", "of", "the", "C", "relate", "code", "in", "interspersed", "in", "the", "s", "or", "other", "directory", "apart", "from", "c", "of", "course", "NUMBER", "It", "s", "mention", "in", "the", "csug", "that", "the", "c", "portion", "relies", "upon", "the", "header", "file", "generate", "by", "the", "s", "file", "NUMBER", "Does", "it", "mean", "more", "effort", "would", "be", "required", "in", "untangling", "Chez", "from", "C", "NUMBER", "for", "the", "internal", "documentation", "NUMBER", "Look", "forward", "to", "learning", "Chez", "s", "architecture", "from", "it", "NUMBER", "BTW", "do", "anyone", "know", "which", "file", "be", "relate", "to", "macro", "expander", "in", "Chez", "repository", "following", "this", "commit", "LINK", "I", "get", "boot", "file", "for", "openbsd", "a", "NUMBER", "ob", "from", "a", "linux", "NUMBER", "I", "copied", "boot", "a", "NUMBER", "ob", "directory", "to", "openbsd", "NUMBER", "and", "run", "NUMBER", "configure", "gmake", "Build", "fail", "at", "this", "step", "with", "below", "error", "gmake", "all", "echo", "reset", "handler", "abort", "base", "exception", "handler", "lambda", "c", "fresh", "line", "display", "condition", "c", "newline", "reset", "keyboard", "interrupt", "handler", "lambda", "display", "interrupted", "aborting", "n", "reset", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "generate", "inspector", "information", "f", "subset", "mode", "quote", "system", "compile", "file", "cmacros", "NUMBER", "ss", "cmacros", "NUMBER", "so", "NUMBER", "bin", "a", "NUMBER", "ob", "scheme", "q", "sizeof", "time_t", "NUMBER", "NUMBER", "time_t_bits", "NUMBER", "gmake", "NUMBER", "Mf", "base", "NUMBER", "cmacros", "NUMBER", "so", "Error", "NUMBER", "gmake", "NUMBER", "Mf", "base", "NUMBER", "allx", "Error", "NUMBER", "gmake", "NUMBER", "Mf", "base", "NUMBER", "bootstrap", "Error", "NUMBER", "gmake", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "gmake", "Makefile", "NUMBER", "build", "Error", "NUMBER", "build", "logs", "NUMBER", "LINK", "I", "replaced", "make", "gmake", "in", "c", "Mf", "a", "NUMBER", "ob", "run", "gmake", "again", "and", "get", "below", "error", "NUMBER", "LINK", "uname", "a", "OpenBSD", "ab", "NUMBER", "my", "NUMBER", "domain", "NUMBER", "GENERIC", "NUMBER", "MP", "NUMBER", "amd", "NUMBER", "change", "define", "time_t_bits", "NUMBER", "x", "NUMBER", "define", "time_t_bits", "NUMBER", "x", "NUMBER", "in", "boot", "a", "NUMBER", "ob", "equates", "NUMBER", "h", "gives", "segfault", "It", "looks", "like", "the", "netbsd", "NUMBER", "def", "also", "needs", "this", "change", "NUMBER", "thanks", "akeep", "and", "gwatt", "for", "your", "replies", "NUMBER", "I", "tried", "your", "change", "but", "no", "luck", "NUMBER", "If", "I", "change", "boot", "a", "NUMBER", "ob", "equates", "NUMBER", "h", "define", "time_t_bits", "NUMBER", "x", "NUMBER", "define", "time_t_bits", "NUMBER", "x", "NUMBER", "This", "change", "error", "in", "compilation", "NUMBER", "now", "it", "be", "segfault", "NUMBER", "see", "below", "gist", "NUMBER", "LINK", "Any", "idea", "on", "how", "to", "debug", "btw", "I", "also", "change", "ChezScheme", "s", "a", "NUMBER", "ob", "NUMBER", "def", "I", "copied", "boot", "a", "NUMBER", "ob", "from", "a", "linux", "x", "NUMBER", "_", "NUMBER", "machine", "use", "make", "bootfiles", "NUMBER", "my", "target", "openbsd", "machine", "be", "OpenBSD", "NUMBER", "amd", "NUMBER", "here", "be", "the", "output", "from", "gdb", "LINK", "you", "can", "see", "scheme", "was", "run", "with", "no", "argument", "when", "it", "crashes", "NUMBER", "when", "I", "pass", "version", "or", "help", "it", "has", "below", "output", "LINK", "passing", "script", "or", "during", "make", "it", "fail", "NUMBER", "I", "would", "appreciate", "if", "someone", "could", "provide", "any", "hints", "the", "call", "be", "fail", "in", "mmap", "see", "gdb", "output", "segment", "NUMBER", "c", "NUMBER", "if", "addr", "mmap", "NULL", "p_bytes", "PROT_EXEC", "PROT_WRITE", "PROT_READ", "MAP_PRIVATE", "MAP_ANONYMOUS", "NUMBER", "NUMBER", "void", "NUMBER", "openbsd", "NUMBER", "has", "wx", "enable", "NUMBER", "so", "PROT_EXEC", "PROT_WRITE", "PROT_READ", "might", "be", "a", "start", "when", "debugging", "this", "issue", "NUMBER", "I", "will", "try", "to", "find", "more", "information", "later", "NUMBER", "But", "I", "need", "someone", "from", "chezscheme", "team", "to", "fix", "this", "issue", "NUMBER", "NUMBER", "and", "I", "have", "this", "on", "dmesg", "scheme", "NUMBER", "mmap", "W", "X", "violation", "scheme", "NUMBER", "mmap", "W", "X", "violation", "scheme", "NUMBER", "mmap", "W", "X", "violation", "scheme", "NUMBER", "mmap", "W", "X", "violation", "scheme", "NUMBER", "mmap", "W", "X", "violation", "scheme", "NUMBER", "mmap", "W", "X", "violation", "add", "Wl", "z", "wxneeded", "to", "LDFLAGS", "fix", "the", "segfault", "issue", "NUMBER", "but", "still", "I", "cannot", "run", "this", "NUMBER", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "b", "NUMBER", "a", "NUMBER", "ob", "boot", "a", "NUMBER", "ob", "petite", "NUMBER", "boot", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "ELF", "not", "find", "Weird", "I", "was", "able", "to", "run", "scheme", "in", "an", "OpenBSD", "NUMBER", "VM", "NUMBER", "how", "NUMBER", "I", "tried", "to", "latest", "git", "master", "branch", "and", "last", "release", "archive", "NUMBER", "can", "you", "tell", "how", "you", "generate", "bootfiles", "on", "what", "machine", "and", "steps", "etc", "NUMBER", "I", "build", "the", "bootfiles", "on", "a", "linux", "amd", "NUMBER", "machine", "and", "uploaded", "them", "LINK", "bootfiles", "Then", "I", "cloned", "the", "repository", "to", "my", "VM", "NUMBER", "To", "actually", "build", "chez", "I", "had", "to", "delete", "some", "of", "the", "locale", "stuff", "in", "c", "expeditor", "NUMBER", "c", "NUMBER", "After", "that", "it", "worked", "fine", "NUMBER", "I", "should", "probably", "try", "on", "bare", "metal", "and", "not", "a", "vm", "but", "I", "don", "t", "expect", "that", "to", "matter", "NUMBER", "the", "issue", "has", "to", "be", "with", "bootfiles", "I", "guess", "NUMBER", "I", "be", "still", "not", "able", "to", "make", "things", "work", "on", "my", "openbsd", "NUMBER", "can", "you", "give", "output", "of", "ldd", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "uname", "a", "openbsd", "OpenBSD", "my", "NUMBER", "domain", "NUMBER", "GENERIC", "NUMBER", "MP", "NUMBER", "amd", "NUMBER", "uname", "a", "linux", "Linux", "NUMBER", "NUMBER", "generic", "NUMBER", "Ubuntu", "SMP", "Wed", "Jan", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "UTC", "NUMBER", "x", "NUMBER", "_", "NUMBER", "x", "NUMBER", "_", "NUMBER", "x", "NUMBER", "_", "NUMBER", "GNU", "Linux", "OpenBSD", "openbsd", "NUMBER", "GENERIC", "NUMBER", "amd", "NUMBER", "hmm", "NUMBER", "that", "be", "same", "NUMBER", "error", "keep", "change", "NUMBER", "see", "here", "gmake", "all", "echo", "reset", "handler", "abort", "base", "exception", "handler", "lambda", "c", "fresh", "line", "display", "condition", "c", "newline", "reset", "keyboard", "interrupt", "handler", "lambda", "display", "interrupted", "aborting", "n", "reset", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "generate", "inspector", "information", "f", "subset", "mode", "quote", "system", "compile", "file", "cmacros", "NUMBER", "ss", "cmacros", "NUMBER", "so", "NUMBER", "bin", "a", "NUMBER", "ob", "scheme", "q", "NUMBER", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "syntax", "error", "unexpect", "I", "don", "t", "have", "an", "all", "target", "for", "gmake", "at", "the", "root", "directory", "NUMBER", "Where", "be", "you", "run", "gmake", "i", "be", "run", "from", "root", "directory", "of", "repo", "NUMBER", "where", "should", "I", "run", "gmake", "I", "clone", "your", "repository", "checkout", "out", "new", "bootfiles", "branch", "NUMBER", "and", "NUMBER", "configure", "gmake", "has", "to", "change", "c", "expeditor", "NUMBER", "c", "for", "locale", "change", "as", "you", "said", "gmake", "cd", "c", "gmake", "gmake", "NUMBER", "Nothing", "to", "be", "do", "for", "doit", "NUMBER", "cd", "s", "gmake", "bootstrap", "gmake", "allx", "rm", "f", "NUMBER", "a", "NUMBER", "ob", "xpatch", "patch", "NUMBER", "patch", "NUMBER", "so", "NUMBER", "asm", "script", "NUMBER", "all", "header", "NUMBER", "tmp", "NUMBER", "html", "rm", "rf", "nanopass", "cp", "p", "f", "NUMBER", "boot", "a", "NUMBER", "ob", "petite", "NUMBER", "boot", "NUMBER", "boot", "a", "NUMBER", "ob", "sbb", "cp", "p", "f", "NUMBER", "boot", "a", "NUMBER", "ob", "scheme", "NUMBER", "boot", "NUMBER", "boot", "a", "NUMBER", "ob", "scb", "gmake", "all", "echo", "reset", "handler", "abort", "base", "exception", "handler", "lambda", "c", "fresh", "line", "display", "condition", "c", "newline", "reset", "keyboard", "interrupt", "handler", "lambda", "display", "interrupted", "aborting", "n", "reset", "optimize", "level", "NUMBER", "debug", "level", "NUMBER", "generate", "inspector", "information", "f", "subset", "mode", "quote", "system", "compile", "file", "cmacros", "NUMBER", "ss", "cmacros", "NUMBER", "so", "NUMBER", "bin", "a", "NUMBER", "ob", "scheme", "q", "NUMBER", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "syntax", "error", "unexpect", "gmake", "NUMBER", "Mf", "base", "NUMBER", "cmacros", "NUMBER", "so", "Error", "NUMBER", "gmake", "NUMBER", "Mf", "base", "NUMBER", "allx", "Error", "NUMBER", "gmake", "NUMBER", "Mf", "base", "NUMBER", "bootstrap", "Error", "NUMBER", "gmake", "Makefile", "NUMBER", "build", "Error", "NUMBER", "That", "s", "where", "I", "m", "run", "it", "but", "if", "I", "try", "gmake", "all", "it", "tells", "me", "gmake", "No", "rule", "to", "make", "target", "all", "NUMBER", "Stop", "NUMBER", "Edit", "After", "a", "second", "look", "I", "think", "that", "s", "a", "recursive", "invocation", "of", "gmake", "in", "some", "subdirectory", "so", "my", "line", "of", "pursuit", "here", "be", "not", "useful", "NUMBER", "okay", "NUMBER", "syntax", "error", "unexpect", "could", "be", "signalling", "a", "difference", "target", "vs", "host", "arch", "That", "looks", "like", "a", "shell", "error", "to", "me", "NUMBER", "Edit", "NUMBER", "ls", "ksh", "syntax", "error", "unexpect", "No", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "syntax", "error", "unexpect", "file", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "ELF", "NUMBER", "bit", "LSB", "shared", "object", "x", "NUMBER", "NUMBER", "version", "NUMBER", "Edit", "run", "from", "bash", "gives", "this", "error", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "bash", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "cannot", "execute", "binary", "file", "Exec", "format", "error", "file", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "ELF", "NUMBER", "bit", "LSB", "shared", "object", "x", "NUMBER", "NUMBER", "version", "NUMBER", "can", "you", "push", "your", "change", "to", "expeditor", "NUMBER", "c", "in", "case", "change", "weren", "t", "same", "on", "my", "side", "NUMBER", "just", "to", "be", "sure", "NUMBER", "Done", "NUMBER", "thanks", "NUMBER", "I", "checkout", "out", "the", "code", "and", "still", "not", "work", "NUMBER", "I", "still", "believe", "there", "be", "something", "wroing", "with", "generate", "bootfiles", "and", "later", "use", "it", "to", "creating", "scheme", "binaries", "NUMBER", "some", "more", "question", "be", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "be", "supposed", "to", "scripts", "or", "executable", "file", "because", "you", "see", "the", "output", "of", "file", "command", "on", "my", "system", "NUMBER", "and", "if", "that", "be", "a", "shell", "script", "then", "ldd", "gives", "some", "information", "depending", "on", "if", "there", "be", "any", "shared", "libraries", "NUMBER", "ldd", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "do", "nm", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "gives", "you", "any", "undefined", "symbols", "thanks", "again", "for", "your", "patience", "and", "good", "effort", "in", "helping", "ldd", "on", "ta", "NUMBER", "ob", "bin", "scheme", "yields", "fairly", "normal", "output", "libiconv", "libm", "libncurses", "libpthread", "libc", "nm", "also", "looks", "normal", "NUMBER", "There", "be", "undefined", "symbols", "but", "they", "re", "all", "provide", "by", "the", "shared", "libraries", "NUMBER", "ah", "NUMBER", "in", "my", "case", "ldd", "gives", "error", "ldd", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "Exec", "format", "error", "NUMBER", "a", "NUMBER", "ob", "bin", "a", "NUMBER", "ob", "scheme", "exit", "status", "NUMBER", "finally", "it", "be", "work", "NUMBER", "the", "fix", "was", "silly", "NUMBER", "clone", "and", "build", "your", "repo", "on", "usr", "local", "NUMBER", "why", "only", "this", "parttion", "be", "mounted", "with", "wxneeded", "and", "add", "LDFLAGS", "won", "t", "help", "un", "run", "scheme", "binaries", "NUMBER", "ufff", "Ha", "That", "explains", "why", "I", "didn", "t", "have", "problem", "NUMBER", "My", "vm", "be", "small", "and", "I", "just", "let", "the", "installer", "auto", "partition", "the", "drive", "NUMBER", "home", "was", "too", "small", "for", "the", "chez", "repo", "so", "I", "moved", "it", "into", "usr", "before", "build", "NUMBER", "NUMBER", "ta", "NUMBER", "ob", "bin", "scheme", "b", "NUMBER", "boot", "ta", "NUMBER", "ob", "petite", "NUMBER", "boot", "Petite", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "printf", "hello", "world", "hello", "world", "exit", "Thanks", "a", "lot", "for", "your", "immense", "patience", "and", "support", "in", "helping", "me", "NUMBER", "You", "might", "merge", "change", "to", "upstream", "NUMBER", "maybe", "add", "a", "ifdef", "openbsd", "for", "locale", "stuff", "I", "could", "NUMBER", "I", "d", "want", "to", "know", "upstream", "s", "interest", "in", "having", "and", "maintaining", "OpenBSD", "as", "a", "first", "class", "citizen", "before", "I", "do", "that", "NUMBER", "Sure", "NUMBER", "you", "have", "my", "NUMBER", "and", "hope", "they", "include", "in", "upstream", "NUMBER", "Would", "be", "great", "to", "have", "BSD", "support", "in", "Chez", "Scheme", "NUMBER", "NUMBER", "Hey", "All", "Just", "a", "quick", "follow", "up", "on", "this", "NUMBER", "I", "d", "love", "to", "get", "better", "support", "for", "the", "BSDs", "in", "as", "well", "NUMBER", "Currently", "the", "boot", "file", "be", "one", "of", "the", "limiting", "factors", "here", "NUMBER", "Unfortunately", "they", "be", "binary", "and", "already", "compressed", "and", "each", "platform", "add", "about", "NUMBER", "MB", "for", "each", "revision", "that", "requires", "a", "new", "boot", "file", "be", "build", "which", "be", "essentially", "every", "time", "we", "make", "source", "code", "change", "to", "the", "Scheme", "compiler", "or", "libraries", "NUMBER", "So", "we", "need", "to", "find", "a", "way", "to", "pair", "down", "our", "exist", "boot", "file", "potentially", "going", "back", "to", "just", "having", "a", "single", "machine", "type", "checked", "in", "and", "then", "provide", "the", "other", "binaries", "for", "download", "after", "each", "check", "in", "NUMBER", "I", "don", "t", "have", "a", "solution", "for", "this", "yet", "but", "it", "be", "something", "we", "re", "thinking", "about", "so", "that", "we", "can", "provide", "a", "larger", "set", "of", "boot", "file", "including", "boot", "file", "for", "the", "BSDs", "NUMBER", "I", "do", "have", "a", "question", "for", "those", "of", "you", "use", "BSDs", "though", "be", "you", "aware", "of", "any", "continuous", "integration", "resources", "for", "build", "on", "BSDs", "as", "commit", "come", "in", "I", "ve", "be", "considering", "automating", "the", "Linux", "and", "macOS", "build", "and", "I", "d", "really", "like", "to", "get", "all", "support", "platforms", "on", "this", "but", "I", "m", "not", "sure", "where", "to", "look", "for", "BSD", "automation", "resources", "NUMBER", "akeep", "Is", "there", "a", "way", "to", "provide", "a", "single", "boot", "file", "per", "architecture", "regardless", "of", "operate", "system", "If", "that", "s", "not", "possible", "what", "about", "smaller", "OS", "dependent", "boot", "file", "and", "a", "large", "boot", "file", "containing", "portable", "code", "Another", "issue", "be", "build", "the", "C", "parts", "on", "the", "BSDs", "NUMBER", "Obviously", "OpenBSD", "requires", "source", "change", "NUMBER", "I", "have", "build", "Chez", "on", "FreeBSD", "but", "don", "t", "have", "that", "system", "install", "anymore", "NUMBER", "I", "remember", "there", "were", "some", "issue", "with", "iconv", "but", "cannot", "remember", "specifics", "NUMBER", "I", "also", "don", "t", "know", "if", "this", "was", "before", "LINK", "which", "causes", "build", "failures", "on", "OpenBSD", "NUMBER", "I", "have", "never", "tried", "build", "Chez", "on", "NetBSD", "NUMBER", "Hey", "gwatt", "No", "it", "be", "not", "possible", "to", "have", "one", "boot", "file", "per", "architecture", "NUMBER", "The", "boot", "file", "has", "compiled", "in", "calls", "to", "the", "C", "runtime", "routines", "so", "it", "needs", "to", "have", "the", "calling", "conventions", "for", "the", "OS", "for", "that", "machine", "type", "NUMBER", "Even", "the", "threaded", "vs", "NUMBER", "non", "threaded", "version", "need", "to", "be", "independent", "because", "the", "handle", "of", "Scheme", "s", "context", "be", "different", "between", "the", "two", "and", "produces", "different", "boot", "file", "NUMBER", "The", "C", "parts", "already", "make", "heavy", "use", "of", "ifdef", "s", "to", "control", "how", "code", "be", "build", "on", "different", "platforms", "and", "I", "think", "this", "should", "be", "perfectly", "sufficient", "for", "keep", "the", "BSD", "code", "compile", "especially", "since", "we", "also", "build", "for", "Windows", "from", "this", "source", "tree", "NUMBER", "Unfortunately", "not", "having", "regular", "test", "on", "the", "BSDs", "has", "lead", "to", "some", "code", "be", "add", "that", "has", "never", "be", "test", "on", "a", "BSD", "like", "the", "newlocale", "code", "for", "allowing", "the", "expression", "editor", "to", "accept", "unicode", "input", "NUMBER", "The", "system", "NUMBER", "h", "file", "contains", "the", "selectors", "for", "features", "that", "be", "only", "available", "on", "some", "platforms", "NUMBER", "I", "ve", "build", "Chez", "since", "the", "open", "source", "release", "on", "FreeBSD", "OpenBSD", "NetBSD", "and", "DragonFlyBSD", "but", "it", "be", "has", "probably", "be", "NUMBER", "months", "at", "least", "and", "I", "ve", "not", "gone", "through", "all", "the", "test", "on", "these", "platforms", "NUMBER", "This", "be", "part", "of", "the", "reason", "I", "d", "like", "to", "get", "all", "of", "this", "stuff", "on", "regular", "continuous", "integration", "NUMBER", "It", "be", "easy", "for", "me", "to", "drop", "the", "ball", "on", "this", "when", "I", "get", "busy", "with", "my", "day", "job", "when", "the", "continuous", "integration", "isn", "t", "keep", "my", "feet", "to", "the", "fire", "NUMBER", "akeep", "I", "feared", "that", "was", "the", "case", "for", "the", "bootfiles", "NUMBER", "Oh", "well", "NUMBER", "akeep", "If", "you", "can", "have", "OpenBSD", "VM", "always", "last", "stable", "release", "be", "that", "enough", "to", "setup", "a", "daily", "CI", "build", "I", "have", "use", "ctest", "for", "continuous", "integration", "under", "obsd", "NUMBER", "Let", "me", "know", "what", "be", "required", "and", "I", "can", "try", "to", "setup", "this", "on", "my", "part", "rkanavath", "part", "of", "what", "I", "m", "looking", "for", "be", "a", "service", "like", "Travis", "CI", "that", "can", "be", "connected", "with", "GitHub", "to", "initiate", "these", "build", "in", "an", "autonomous", "fashion", "NUMBER", "Short", "of", "that", "I", "can", "probably", "try", "to", "get", "a", "machine", "setup", "to", "do", "these", "build", "but", "I", "suspect", "a", "service", "will", "be", "a", "bit", "more", "reliable", "NUMBER", "akeep", "I", "be", "not", "aware", "of", "any", "service", "like", "travis", "CI", "that", "support", "BSD", "systems", "NUMBER", "other", "than", "a", "VM", "to", "do", "continuous", "build", "i", "don", "t", "see", "any", "other", "option", "NUMBER", "about", "openbsd", "boot", "file", "be", "it", "possible", "to", "include", "all", "boot", "file", "in", "git", "repo", "and", "use", "git", "submodule", "akeep", "I", "be", "not", "aware", "of", "any", "service", "like", "travis", "CI", "that", "support", "BSD", "systems", "NUMBER", "other", "than", "a", "VM", "to", "do", "continuous", "build", "i", "don", "t", "see", "any", "other", "option", "NUMBER", "about", "openbsd", "boot", "file", "be", "it", "possible", "to", "include", "all", "boot", "file", "in", "git", "repo", "and", "use", "git", "submodule", "add", "cmake", "file", "test", "under", "x", "NUMBER", "windows", "NUMBER", "dybvig", "I", "try", "to", "build", "under", "Windows", "but", "current", "build", "system", "not", "work", "well", "NUMBER", "I", "think", "cmake", "be", "a", "more", "convinient", "and", "universal", "solution", "though", "I", "aware", "that", "the", "conversion", "cost", "from", "make", "to", "cmake", "be", "too", "much", "to", "be", "impossible", "and", "everyone", "has", "his", "own", "preferred", "build", "system", "NUMBER", "I", "just", "have", "find", "that", "make", "configure", "be", "unfriendly", "for", "windows", "user", "and", "I", "have", "do", "some", "basic", "work", "NUMBER", "Perhaps", "someone", "needs", "it", "NUMBER", "Just", "a", "typo", "fix", "I", "think", "this", "looks", "like", "a", "good", "change", "but", "there", "be", "a", "unit", "test", "in", "the", "file", "format", "NUMBER", "ms", "that", "checks", "for", "the", "format", "of", "numbers", "which", "also", "needs", "to", "be", "update", "with", "this", "change", "NUMBER", "Check", "line", "NUMBER", "of", "format", "NUMBER", "ms", "NUMBER", "Please", "update", "the", "unit", "test", "and", "also", "add", "a", "comment", "to", "the", "LOG", "file", "NUMBER", "You", "can", "run", "the", "unit", "test", "by", "run", "make", "test", "at", "the", "top", "level", "directory", "if", "you", "ve", "made", "your", "change", "in", "the", "same", "directory", "created", "by", "make", "NUMBER", "You", "can", "also", "go", "directly", "into", "the", "machine", "type", "directory", "s", "mats", "directory", "e", "NUMBER", "g", "NUMBER", "a", "NUMBER", "osx", "mats", "for", "NUMBER", "bit", "Mac", "OS", "X", "or", "a", "NUMBER", "le", "mats", "for", "NUMBER", "bit", "Linux", "and", "run", "make", "all", "which", "runs", "one", "set", "of", "test", "and", "check", "the", "report", "file", "or", "make", "allx", "which", "runs", "several", "variations", "of", "the", "all", "test", "and", "check", "the", "summary", "file", "NUMBER", "Thanks", "I", "be", "trying", "to", "define", "a", "foreign", "procedure", "that", "directly", "returns", "a", "struct", "NUMBER", "As", "an", "example", "from", "the", "C", "version", "of", "SFML", "typedef", "struct", "sfInt", "NUMBER", "microseconds", "sfTime", "sfTime", "sfSeconds", "float", "amount", "I", "have", "tried", "the", "following", "but", "get", "the", "error", "shown", "define", "ftype", "sfTime", "struct", "microseconds", "integer", "NUMBER", "define", "sf", "seconds", "foreign", "procedure", "sfSeconds", "float", "sfTime", "Exception", "invalid", "non", "base", "foreign", "procedure", "result", "ftype", "sfTime", "I", "hope", "I", "haven", "t", "miss", "how", "to", "do", "this", "while", "reading", "the", "csug", "NUMBER", "Is", "there", "any", "way", "to", "achieve", "this", "short", "of", "write", "a", "custom", "C", "function", "that", "wraps", "the", "struct", "value", "in", "a", "pointer", "Meet", "the", "same", "question", "for", "passing", "directly", "struct", "to", "a", "function", "NUMBER", "Passing", "and", "returning", "structs", "rather", "than", "pointers", "to", "structs", "be", "not", "presently", "support", "NUMBER", "To", "call", "a", "function", "that", "requires", "struct", "argument", "or", "returns", "struct", "values", "you", "d", "need", "to", "create", "an", "appropriate", "C", "wrapper", "NUMBER", "Or", "you", "d", "need", "to", "extend", "foreign", "procedure", "and", "foreign", "callable", "to", "handle", "struct", "argument", "and", "return", "values", "NUMBER", "How", "to", "extend", "foreign", "procedure", "and", "foreign", "callable", "I", "need", "passing", "struct", "and", "return", "the", "struct", "value", "NUMBER", "Could", "you", "show", "detail", "dybvig", "Oh", "that", "maybe", "cost", "a", "lot", "of", "time", "quickly", "I", "made", "of", "this", "LINK", "lib", "blob", "master", "package", "cffi", "cffi", "NUMBER", "ss", "LINK", "lib", "blob", "master", "package", "cffi", "cffi", "NUMBER", "ss", "NUMBER", "It", "can", "use", "struct", "parameter", "to", "call", "directly", "NUMBER", "ecraven", "Hi", "If", "I", "compile", "ChezScheme", "with", "CHEZSCHEMELIBDIRS", "environment", "variable", "set", "then", "the", "compilation", "fail", "NUMBER", "Is", "this", "expected", "If", "I", "unset", "it", "then", "the", "compilation", "succeeds", "NUMBER", "NUMBER", "NUMBER", "bin", "ta", "NUMBER", "le", "scheme", "q", "cmacros", "NUMBER", "so", "priminfo", "NUMBER", "so", "primvars", "NUMBER", "so", "env", "NUMBER", "so", "setup", "NUMBER", "so", "script", "script", "NUMBER", "all", "compile", "library", "NUMBER", "ss", "with", "output", "to", "library", "NUMBER", "ta", "NUMBER", "le", "compile", "prims", "NUMBER", "ss", "with", "output", "to", "prims", "NUMBER", "ta", "NUMBER", "le", "compile", "mathprims", "NUMBER", "ss", "with", "output", "to", "mathprims", "NUMBER", "ta", "NUMBER", "le", "compile", "record", "NUMBER", "ss", "with", "output", "to", "record", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "_", "NUMBER", "ss", "with", "output", "to", "NUMBER", "_", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "_", "NUMBER", "ss", "with", "output", "to", "NUMBER", "_", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "_", "NUMBER", "ss", "with", "output", "to", "NUMBER", "_", "NUMBER", "ta", "NUMBER", "le", "compile", "strnum", "NUMBER", "ss", "with", "output", "to", "strnum", "NUMBER", "ta", "NUMBER", "le", "compile", "bytevector", "NUMBER", "ss", "with", "output", "to", "bytevector", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "_", "NUMBER", "ss", "with", "output", "to", "NUMBER", "_", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "_", "NUMBER", "ss", "with", "output", "to", "NUMBER", "_", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "_", "NUMBER", "ss", "with", "output", "to", "NUMBER", "_", "NUMBER", "ta", "NUMBER", "le", "compile", "event", "NUMBER", "ss", "with", "output", "to", "event", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "ss", "with", "output", "to", "NUMBER", "ta", "NUMBER", "le", "compile", "front", "NUMBER", "ss", "with", "output", "to", "front", "NUMBER", "ta", "NUMBER", "le", "compile", "foreign", "NUMBER", "ss", "with", "output", "to", "foreign", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "ss", "with", "output", "to", "NUMBER", "ta", "NUMBER", "le", "compile", "print", "NUMBER", "ss", "with", "output", "to", "print", "NUMBER", "ta", "NUMBER", "le", "compile", "newhash", "NUMBER", "ss", "with", "output", "to", "newhash", "NUMBER", "ta", "NUMBER", "le", "compile", "format", "NUMBER", "ss", "with", "output", "to", "format", "NUMBER", "ta", "NUMBER", "le", "compile", "date", "NUMBER", "ss", "with", "output", "to", "date", "NUMBER", "ta", "NUMBER", "le", "compile", "NUMBER", "ss", "with", "output", "to", "NUMBER", "ta", "NUMBER", "le", "Exception", "library", "nanopass", "not", "find", "make", "NUMBER", "Mf", "base", "NUMBER", "bootall", "Error", "NUMBER", "make", "NUMBER", "Mf", "base", "NUMBER", "allx", "Error", "NUMBER", "make", "NUMBER", "Mf", "base", "NUMBER", "bootstrap", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "build", "Error", "NUMBER", "If", "you", "set", "CHEZSCHEMELIBDIRS", "to", "xxx", "you", "lib", "path", "Then", "xxx", "you", "lib", "path", "be", "the", "only", "path", "Chez", "Scheme", "to", "search", "NUMBER", "But", "if", "you", "plus", "a", "colon", "at", "the", "end", "of", "that", "variable", "xxx", "you", "lib", "path", "Then", "xxx", "you", "lib", "path", "will", "be", "add", "in", "exist", "libraries", "path", "NUMBER", "Chez", "Scheme", "will", "first", "search", "in", "xxx", "you", "lib", "path", "and", "then", "the", "paths", "previously", "set", "NUMBER", "This", "will", "also", "fix", "LINK", "This", "should", "be", "fix", "by", "this", "commit", "LINK", "NUMBER", "Hello", "NUMBER", "years", "ago", "I", "bought", "Chez", "Scheme", "NUMBER", "for", "Solaris", "NUMBER", "OS", "x", "NUMBER", "_", "NUMBER", "ta", "NUMBER", "s", "NUMBER", "and", "as", "bonus", "Chez", "Scheme", "NUMBER", "for", "Solaris", "SPARC", "tsp", "NUMBER", "NUMBER", "Worked", "nice", "for", "me", "and", "my", "learners", "on", "Intel", "and", "SPARC", "Thank", "You", "Now", "I", "find", "open", "source", "Chez", "Scheme", "NUMBER", "but", "without", "support", "Solaris", "OS", "NUMBER", "Despite", "the", "fact", "that", "the", "source", "file", "have", "Solaris", "specifics", "NUMBER", "I", "tried", "to", "create", "into", "the", "directory", "boot", "subdirectory", "ta", "NUMBER", "s", "NUMBER", "and", "copy", "petite", "NUMBER", "boot", "scheme", "NUMBER", "boot", "and", "scheme", "NUMBER", "h", "file", "from", "NUMBER", "release", "into", "it", "NUMBER", "Poorly", "I", "created", "edit", "equated", "NUMBER", "h", "from", "linux", "distr", "poorly", "Now", "the", "question", "Why", "don", "t", "you", "make", "Solaris", "distribution", "Solaris", "isn", "t", "popular", "or", "what", "If", "you", "need", "help", "to", "do", "this", "then", "I", "be", "willing", "to", "participate", "NUMBER", "I", "can", "even", "give", "one", "of", "my", "native", "not", "virtual", "Solaris", "NUMBER", "server", "for", "this", "NUMBER", "Via", "ssh", "NUMBER", "With", "developerstudio", "NUMBER", "c", "c", "sun", "oracle", "compilers", "or", "gcc", "NUMBER", "Let", "s", "try", "to", "do", "it", "NUMBER", "Now", "SPARC", "not", "important", "to", "me", "because", "I", "have", "very", "old", "Sun", "SPARC", "servers", "SunFire", "V", "NUMBER", "without", "support", "Solaris", "NUMBER", "Now", "I", "be", "only", "interested", "x", "NUMBER", "_", "NUMBER", "arch", "NUMBER", "When", "I", "buy", "a", "Oracle", "SPARC", "T", "or", "M", "based", "servers", "then", "go", "back", "to", "the", "tsp", "NUMBER", "release", "Thank", "You", "NUMBER", "sorry", "for", "bad", "english", "Issue", "resolve", "NUMBER", "Now", "Chez", "Scheme", "can", "run", "on", "Oracle", "Solaris", "NUMBER", "OS", "x", "NUMBER", "_", "NUMBER", "NUMBER", "And", "on", "SPARC", "too", "I", "think", "NUMBER", "Sun", "Meddle", "uname", "a", "SunOS", "Meddle", "NUMBER", "NUMBER", "i", "NUMBER", "pc", "i", "NUMBER", "i", "NUMBER", "pc", "Sun", "Meddle", "isainfo", "v", "NUMBER", "bit", "amd", "NUMBER", "applications", "avx", "xsave", "pclmulqdq", "aes", "movbe", "sse", "NUMBER", "sse", "NUMBER", "ssse", "NUMBER", "amd_lzcnt", "popcnt", "tscp", "ahf", "cx", "NUMBER", "sse", "NUMBER", "sse", "NUMBER", "sse", "fxsr", "mmx", "cmov", "amd_sysc", "cx", "NUMBER", "tsc", "fpu", "efs", "rtm", "hle", "bmi", "NUMBER", "avx", "NUMBER", "bmi", "NUMBER", "f", "NUMBER", "c", "fma", "rdrand", "Sun", "Meddle", "chez", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Thanks", "to", "all", "Thanks", "in", "the", "standard", "libc", "function", "strcpy", "we", "can", "t", "get", "destination", "from", "source", "char", "strcpy", "char", "destination", "const", "char", "source", "and", "doing", "some", "test", "shows", "fail", "to", "transfer", "value", "out", "through", "function", "param", "in", "Foreign", "Interface", "foreign", "procedure", "entry", "exp", "param", "type", "NUMBER", "res", "type", "the", "following", "be", "the", "execution", "commands", "scheme", "load", "shared", "object", "libc", "NUMBER", "so", "NUMBER", "define", "strcpy", "foreign", "procedure", "strcpy", "string", "string", "string", "define", "from", "some", "random", "texts", "define", "to", "make", "string", "NUMBER", "strcpy", "to", "from", "some", "random", "texts", "to", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "x", "NUMBER", "From", "LINK", "NUMBER", "foreign", "h", "NUMBER", "documentation", "on", "conversion", "of", "parameters", "do", "by", "the", "function", "returned", "by", "foreign", "procedure", "string", "This", "type", "be", "an", "alias", "for", "utf", "NUMBER", "NUMBER", "utf", "NUMBER", "The", "argument", "must", "be", "a", "Scheme", "string", "or", "f", "NUMBER", "For", "f", "the", "null", "pointer", "NUMBER", "be", "pass", "to", "the", "foreign", "procedure", "NUMBER", "A", "string", "be", "converted", "into", "a", "bytevector", "as", "if", "via", "string", "utf", "NUMBER", "with", "an", "add", "null", "byte", "and", "the", "address", "of", "the", "first", "byte", "of", "the", "bytevector", "be", "pass", "to", "C", "NUMBER", "So", "the", "pointer", "pass", "to", "the", "first", "argument", "of", "the", "C", "strcpy", "function", "be", "not", "the", "same", "as", "the", "pointer", "to", "the", "scheme", "string", "to", "NUMBER", "which", "be", "good", "because", "scheme", "strings", "and", "C", "strings", "be", "not", "the", "same", "thing", "and", "things", "would", "go", "horribly", "awry", "if", "C", "write", "all", "over", "the", "memory", "that", "was", "supposed", "to", "be", "a", "scheme", "string", "NUMBER", "Then", "how", "to", "define", "strcpy", "in", "scheme", "foreign", "interface", "to", "make", "it", "work", "In", "the", "example", "code", "of", "foreign", "interface", "LINK", "NUMBER", "foreign", "h", "NUMBER", "The", "c_read", "also", "don", "t", "work", "as", "expected", "int", "c_read", "int", "fd", "char", "buf", "unsigned", "n", "scheme", "define", "c", "read", "foreign", "procedure", "c_read", "integer", "NUMBER", "string", "integer", "NUMBER", "integer", "NUMBER", "define", "get", "procedure", "to", "read", "data", "from", "client", "let", "buff", "make", "string", "NUMBER", "lambda", "let", "n", "c", "read", "client", "socket", "buff", "string", "length", "buff", "printf", "client", "a", "server", "substring", "buff", "NUMBER", "n", "The", "param", "value", "of", "buf", "can", "t", "pass", "out", "The", "examples", "in", "the", "documentation", "be", "out", "of", "date", "but", "the", "two", "file", "referenced", "examples", "csocket", "NUMBER", "c", "and", "examples", "socket", "NUMBER", "ss", "be", "up", "to", "date", "in", "the", "repository", "NUMBER", "after", "modify", "strcpy", "declaration", "as", "following", "it", "works", "NUMBER", "scheme", "define", "strcpy", "foreign", "procedure", "strcpy", "u", "NUMBER", "string", "string", "define", "from", "some", "random", "texts", "define", "to", "make", "bytevector", "string", "length", "from", "strcpy", "to", "from", "utf", "NUMBER", "string", "to", "but", "it", "still", "doesn", "t", "work", "that", "reading", "out", "from", "a", "file", "through", "the", "foreign", "interface", "u", "NUMBER", "cpp", "native", "NUMBER", "c", "include", "TAG", "int", "myRead", "char", "filename", "char", "buf", "int", "len", "int", "fd", "open", "filename", "O_RDONLY", "if", "fd", "NUMBER", "return", "read", "fd", "buf", "len", "close", "fd", "return", "NUMBER", "scheme", "native", "NUMBER", "ss", "load", "shared", "object", "NUMBER", "libnative", "NUMBER", "so", "define", "myRead", "foreign", "procedure", "myRead", "string", "u", "NUMBER", "int", "int", "define", "buf", "make", "bytevector", "NUMBER", "define", "len", "myRead", "NUMBER", "some", "log", "buf", "bytevector", "length", "buf", "printf", "len", "a", "n", "len", "define", "outBuf", "make", "bytevector", "len", "bytevector", "copy", "outBuf", "NUMBER", "buf", "NUMBER", "len", "printf", "the", "res", "be", "a", "n", "utf", "NUMBER", "string", "outBuf", "bash", "scheme", "script", "native", "NUMBER", "ss", "len", "NUMBER", "the", "res", "be", "akeep", "you", "re", "right", "the", "problem", "has", "be", "fix", "thanks", "Hello", "I", "find", "something", "strange", "when", "work", "on", "an", "extensible", "pattern", "matcher", "in", "Chez", "NUMBER", "Here", "s", "a", "minimal", "test", "case", "library", "a", "export", "a", "import", "scheme", "define", "a", "box", "f", "library", "b", "export", "foo", "a", "import", "scheme", "a", "define", "foo", "display", "hello", "world", "set", "box", "a", "t", "import", "b", "a", "f", "foo", "hello", "world", "a", "t", "Is", "this", "the", "correct", "behavior", "Check", "both", "the", "beginning", "file", "pointer", "bfp", "and", "end", "file", "pointer", "efp", "of", "the", "source", "location", "associated", "with", "a", "profile", "counter", "when", "update", "its", "count", "NUMBER", "Assuming", "that", "each", "expression", "has", "a", "unique", "bfp", "with", "respect", "to", "profiling", "seems", "to", "give", "accurate", "execution", "counts", "for", "s", "expression", "based", "source", "locations", "as", "in", "Scheme", "but", "causes", "problem", "when", "targeting", "other", "kinds", "of", "syntax", "NUMBER", "For", "instance", "a", "C", "style", "function", "call", "referencing", "the", "call", "function", "by", "name", "such", "as", "fn", "arg", "can", "logically", "have", "profile", "counters", "associated", "with", "NUMBER", "the", "function", "name", "reference", "fn", "and", "NUMBER", "the", "entire", "function", "call", "expression", "fn", "arg", "both", "of", "which", "begin", "at", "the", "same", "source", "location", "NUMBER", "Only", "the", "bfp", "be", "checked", "when", "update", "profile", "counters", "so", "the", "two", "source", "locations", "be", "conflated", "and", "only", "one", "counter", "be", "incremented", "which", "gives", "inaccurate", "execution", "counts", "for", "both", "locations", "approximately", "twice", "as", "many", "for", "one", "and", "zero", "for", "the", "other", "NUMBER", "The", "change", "in", "the", "pull", "request", "probably", "wouldn", "t", "be", "necessary", "if", "not", "for", "the", "profile", "source", "object", "form", "documented", "here", "LINK", "NUMBER", "system", "s", "NUMBER", "which", "be", "intended", "for", "use", "cases", "in", "which", "Chez", "Scheme", "be", "the", "target", "language", "of", "another", "compiler", "or", "interpreter", "NUMBER", "I", "had", "write", "a", "longer", "explanation", "recapitulating", "the", "text", "of", "the", "original", "comment", "before", "I", "realized", "that", "the", "pull", "request", "never", "mention", "be", "able", "to", "leverage", "Chez", "Scheme", "s", "profiling", "from", "when", "compile", "from", "other", "source", "languages", "NUMBER", "I", "believe", "your", "assertion", "that", "each", "expression", "s", "bfp", "be", "unique", "be", "correct", "in", "Scheme", "and", "similar", "s", "expression", "based", "languages", "NUMBER", "However", "if", "the", "source", "language", "has", "a", "C", "style", "function", "argument", "argument", "syntax", "there", "can", "logically", "be", "a", "profiling", "counter", "for", "function", "and", "one", "for", "function", "argument", "argument", "both", "of", "which", "have", "a", "source", "object", "with", "the", "same", "bfp", "NUMBER", "As", "implement", "without", "the", "change", "in", "the", "pull", "request", "the", "profiling", "output", "code", "will", "increment", "whichever", "counter", "it", "finds", "first", "for", "both", "the", "reference", "to", "function", "as", "well", "as", "for", "the", "entire", "function", "call", "expression", "NUMBER", "This", "gives", "incorrect", "execution", "counts", "for", "both", "expressions", "NUMBER", "Apparently", "Github", "detects", "NUMBER", "ms", "file", "as", "MAXscript", "make", "the", "mats", "file", "look", "like", "they", "re", "not", "Scheme", "NUMBER", "It", "also", "thinks", "the", "NUMBER", "h", "file", "be", "C", "as", "oppose", "to", "C", "NUMBER", "This", "pull", "request", "simply", "add", "a", "NUMBER", "gitattributes", "file", "to", "hint", "the", "correct", "languages", "to", "Github", "NUMBER", "Originally", "it", "was", "a", "very", "tiny", "patch", "NUMBER", "But", "these", "commit", "also", "contain", "bootstrap", "images", "as", "well", "as", "some", "auto", "generate", "file", "NUMBER", "Not", "sure", "you", "want", "all", "of", "them", "NUMBER", "If", "not", "I", "can", "strip", "it", "down", "to", "a", "few", "lines", "patch", "so", "that", "the", "DragonFly", "build", "will", "still", "be", "possible", "but", "only", "with", "help", "of", "a", "Linux", "machine", "NUMBER", "Btw", "it", "was", "extremely", "easy", "to", "port", "NUMBER", "Thanks", "Thanks", "for", "your", "answer", "NUMBER", "I", "will", "try", "to", "do", "what", "you", "ve", "asked", "in", "the", "next", "few", "days", "NUMBER", "As", "for", "the", "NUMBER", "bit", "version", "of", "DragonFly", "they", "discontinued", "support", "for", "it", "since", "release", "NUMBER", "see", "LINK", "NUMBER", "Neither", "do", "they", "support", "NUMBER", "bit", "tool", "chain", "on", "NUMBER", "bit", "version", "as", "far", "as", "I", "know", "but", "I", "will", "double", "check", "this", "NUMBER", "I", "submitted", "Mf", "a", "NUMBER", "df", "in", "mats", "and", "run", "the", "test", "NUMBER", "Some", "fail", "NUMBER", "During", "the", "investigation", "I", "find", "a", "bug", "in", "DragonFly", "s", "version", "of", "clock_gettime", "NUMBER", "I", "file", "a", "bug", "report", "LINK", "but", "there", "be", "definitely", "a", "workaround", "instead", "of", "clock_gettime", "getrusage", "can", "be", "use", "NUMBER", "If", "the", "bug", "be", "not", "fix", "quickly", "in", "DragonFly", "I", "ll", "submit", "my", "workaround", "NUMBER", "I", "find", "in", "the", "original", "loop", "NUMBER", "in", "lookup", "let", "loop", "NUMBER", "i", "NUMBER", "if", "fx", "i", "n", "loop", "NUMBER", "env", "next", "env", "if", "eq", "vector", "ref", "old", "rib", "i", "id", "vector", "ref", "new", "rib", "i", "let", "i", "fx", "i", "NUMBER", "if", "fx", "i", "n", "loop", "NUMBER", "env", "next", "env", "if", "eq", "vector", "ref", "old", "rib", "i", "id", "vector", "ref", "new", "rib", "i", "loop", "NUMBER", "fx", "i", "NUMBER", "the", "last", "let", "statement", "let", "i", "fx", "i", "NUMBER", "NUMBER", "be", "the", "duplicate", "one", "of", "the", "loop", "NUMBER", "and", "can", "be", "replaced", "with", "just", "the", "recursive", "call", "of", "loop", "NUMBER", "NUMBER", "It", "seems", "like", "a", "manual", "loop", "unrolling", "but", "according", "to", "the", "third", "guidance", "mention", "in", "the", "_CONTRIBUTING", "NUMBER", "md_", "All", "other", "things", "equal", "shorter", "code", "be", "preferable", "to", "longer", "code", "NUMBER", "I", "decide", "to", "open", "this", "pull", "request", "NUMBER", "This", "commit", "fix", "calls", "to", "syntax", "error", "in", "case", "and", "exclusive", "cond", "s", "syntax", "NUMBER", "ss", "which", "had", "their", "argument", "reversed", "cause", "exception", "like", "Exception", "in", "syntax", "error", "TAG", "be", "not", "a", "string", "Instead", "of", "Exception", "invalid", "case", "clause", "NUMBER", "In", "cases", "such", "as", "case", "NUMBER", "NUMBER", "All", "test", "pass", "on", "my", "machine", "and", "there", "weren", "t", "any", "other", "obvious", "ie", "static", "strings", "cases", "of", "this", "NUMBER", "I", "m", "build", "an", "REPL", "myself", "NUMBER", "Here", "be", "some", "code", "ptr", "scheme_eval", "const", "char", "expr_string", "auto", "open_input_string", "Stop_level_value", "Sstring_to_symbol", "open", "input", "string", "auto", "stream", "Scall", "NUMBER", "open_input_string", "Sstring", "expr_string", "auto", "read", "Stop_level_value", "Sstring_to_symbol", "read", "auto", "expr", "Scall", "NUMBER", "read", "stream", "auto", "eval", "Stop_level_value", "Sstring_to_symbol", "eval", "return", "Scall", "NUMBER", "eval", "expr", "But", "when", "I", "call", "scheme_eval", "error", "a", "b", "It", "will", "exit", "directly", "NUMBER", "So", "I", "add", "an", "exception", "handler", "scheme_eval", "base", "exception", "handler", "lambda", "x", "display", "condition", "x", "debug", "But", "in", "debug", "console", "I", "can", "t", "input", "e", "or", "q", "It", "will", "raise", "another", "exception", "Exception", "occur", "with", "condition", "components", "NUMBER", "non", "continuable", "How", "do", "I", "return", "to", "the", "context", "which", "calls", "the", "scheme_eval", "please", "Thanks", "very", "much", "NUMBER", "Now", "I", "use", "call", "cc", "and", "with", "exception", "handler", "to", "capture", "exception", "when", "eval", "it", "works", "well", "NUMBER", "make", "libchezscheme", "NUMBER", "a", "from", "kernel", "NUMBER", "o", "install", "Mf", "embed", "and", "libchezscheme", "NUMBER", "a", "to", "os", "NUMBER", "Commit", "log", "have", "be", "amended", "as", "follows", "Added", "libchezscheme", "NUMBER", "a", "and", "Mf", "embed", "Make", "libchezscheme", "NUMBER", "a", "from", "kernel", "NUMBER", "o", "which", "can", "be", "use", "for", "compile", "program", "with", "ChezScheme", "embeded", "NUMBER", "Add", "Mf", "embed", "which", "will", "help", "setup", "CFLAGS", "LDFLAGS", "and", "LDLIBS", "for", "compile", "ChezScheme", "embeded", "program", "Install", "Mf", "embed", "and", "libchezscheme", "NUMBER", "a", "to", "OS", "path", "be", "the", "same", "as", "scheme", "NUMBER", "boot", "file", "so", "it", "will", "have", "seperate", "paths", "for", "NUMBER", "bit", "and", "NUMBER", "bit", "installation", "examples", "crepl", "NUMBER", "c", "has", "change", "comments", "An", "example", "of", "use", "libchezscheme", "NUMBER", "a", "and", "Mf", "embed", "in", "examples", "dir", "of", "chez", "source", "run", "make", "f", "usr", "local", "lib", "csv", "NUMBER", "a", "NUMBER", "le", "Mf", "embed", "CFLAGS", "ChezCFLAGS", "LDFLAGS", "ChezLDFLAGS", "LDLIBS", "ChezLDLIBS", "crepl", "and", "then", "bash", "c", "exec", "a", "scheme", "NUMBER", "crepl", "commit", "da", "NUMBER", "d", "NUMBER", "bad", "NUMBER", "a", "NUMBER", "f", "NUMBER", "aa", "NUMBER", "b", "NUMBER", "f", "NUMBER", "afabc", "NUMBER", "I", "ve", "be", "use", "this", "PR", "recently", "to", "great", "effect", "I", "wanted", "to", "write", "a", "custom", "Scheme", "kernel", "for", "extra", "diagnostics", "debugging", "etc", "and", "this", "worked", "great", "NUMBER", "Thanks", "for", "write", "it", "NUMBER", "I", "left", "some", "review", "comments", "NUMBER", "Also", "The", "change", "to", "LOG", "don", "t", "actually", "seem", "to", "be", "in", "this", "PR", "Regarding", "the", "stuff", "about", "Mf", "embed", "I", "would", "do", "this", "let", "the", "user", "supply", "the", "final", "link", "flags", "but", "the", "Mf", "embed", "makefile", "provides", "the", "libraries", "itself", "NUMBER", "The", "way", "I", "work", "around", "it", "be", "like", "this", "inside", "my", "Makefile", "make", "LDLIBS", "be", "the", "libraries", "we", "need", "to", "pass", "to", "CC", "in", "order", "to", "link", "the", "executable", "shell", "LDLIBS", "chezscheme", "m", "dl", "ncurses", "rt", "pthread", "some", "rule", "NUMBER", "gcc", "CFLAGS", "fPIC", "o", "TAG", "NUMBER", "NUMBER", "whatever", "in", "numeric", "tower", "NUMBER", "I", "be", "not", "sure", "but", "I", "think", "so", "hence", "NUMBER", "inf", "NUMBER", "NUMBER", "mathematically", "it", "be", "correct", "NUMBER", "Yes", "ChaosEternal", "be", "correct", "the", "R", "NUMBER", "RS", "standard", "allows", "NUMBER", "inf", "NUMBER", "to", "return", "either", "NUMBER", "or", "nan", "NUMBER", "NUMBER", "The", "description", "for", "in", "section", "NUMBER", "It", "include", "the", "explicit", "examples", "NUMBER", "inf", "NUMBER", "NUMBER", "or", "nan", "NUMBER", "NUMBER", "nan", "NUMBER", "NUMBER", "or", "nan", "NUMBER", "Thanks", "for", "your", "answer", "and", "the", "reference", "to", "the", "R", "NUMBER", "RS", "standard", "with", "an", "example", "NUMBER", "Still", "_mathematically_", "NUMBER", "Infinity", "be", "not", "defined", "Infinity", "be", "not", "a", "number", "NUMBER", "Consider", "the", "example", "define", "f", "x", "x", "and", "g", "x", "NUMBER", "x", "NUMBER", "Then", "you", "have", "lim", "x", "Infinity", "f", "x", "Infinity", "lim", "x", "Infinity", "g", "x", "NUMBER", "From", "this", "if", "you", "assume", "that", "NUMBER", "_Infinity", "be", "NUMBER", "you", "would", "conclude", "that", "lim", "x", "Infinity", "f", "x", "_g", "x", "NUMBER", "but", "this", "be", "clearly", "wrong", "as", "lim", "x", "Infinity", "f", "x", "g", "x", "lim", "x", "Infinity", "x", "x", "NUMBER", "I", "can", "imagine", "that", "the", "allowance", "for", "NUMBER", "inf", "NUMBER", "in", "the", "standard", "comes", "from", "a", "remove", "past", "where", "nan", "NUMBER", "didn", "t", "exist", "and", "people", "doing", "numerical", "computations", "wanted", "to", "avoid", "their", "procedures", "blowing", "up", "NUMBER", "But", "now", "with", "nan", "NUMBER", "we", "can", "do", "better", "and", "avoid", "in", "some", "situations", "get", "wrong", "results", "NUMBER", "On", "Fri", "Aug", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "AM", "Andy", "Keep", "notifications", "github", "NUMBER", "com", "write", "Yes", "ChaosEternal", "LINK", "be", "correct", "the", "R", "NUMBER", "RS", "standard", "allows", "NUMBER", "inf", "NUMBER", "to", "return", "either", "NUMBER", "or", "nan", "NUMBER", "The", "description", "for", "in", "section", "NUMBER", "It", "include", "the", "explicit", "examples", "NUMBER", "inf", "NUMBER", "NUMBER", "or", "nan", "NUMBER", "NUMBER", "nan", "NUMBER", "NUMBER", "or", "nan", "NUMBER", "You", "be", "receiving", "this", "because", "you", "authored", "the", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AHUKsk", "NUMBER", "aHzYUPtVAVRhlzh", "NUMBER", "Q", "NUMBER", "tRBAFVzks", "NUMBER", "qhRhwgaJpZM", "NUMBER", "Jn", "NUMBER", "qO", "NUMBER", "The", "thing", "be", "that", "inf", "NUMBER", "do", "not", "represent", "infinity", "NUMBER", "It", "represents", "a", "number", "which", "happen", "to", "be", "so", "large", "that", "it", "can", "t", "be", "represented", "in", "floating", "point", "NUMBER", "So", "NUMBER", "inf", "NUMBER", "just", "means", "exact", "zero", "times", "a", "very", "large", "number", "and", "then", "it", "makes", "sense", "to", "make", "the", "result", "exact", "zero", "NUMBER", "Well", "Section", "NUMBER", "of", "R", "NUMBER", "RS", "appears", "to", "say", "otherwise", "NUMBER", "The", "literals", "inf", "NUMBER", "and", "inf", "NUMBER", "represent", "positive", "and", "negative", "infinity", "respectively", "NUMBER", "NUMBER", "Later", "Section", "NUMBER", "it", "says", "that", "you", "_may_", "use", "it", "for", "the", "purpose", "that", "you", "describe", "NUMBER", "I", "see", "your", "point", "of", "view", "NUMBER", "However", "in", "my", "opinion", "it", "be", "dangerous", "to", "give", "as", "result", "of", "a", "computation", "a", "definitive", "answer", "which", "may", "or", "may", "not", "be", "correct", "NUMBER", "By", "returning", "nan", "NUMBER", "instead", "of", "NUMBER", "one", "would", "warn", "the", "user", "that", "something", "may", "be", "wrong", "NUMBER", "If", "somebody", "be", "trying", "to", "use", "finite", "numbers", "that", "can", "t", "be", "represented", "by", "the", "computer", "system", "from", "my", "point", "of", "view", "something", "be", "definitely", "wrong", "NUMBER", "By", "the", "way", "out", "of", "curiosity", "I", "ve", "checked", "MATLAB", "Numpy", "and", "Octave", "which", "be", "the", "most", "widely", "use", "systems", "for", "numerical", "computations", "and", "they", "all", "return", "NaN", "NUMBER", "On", "Fri", "Aug", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "R", "NUMBER", "Kent", "Dybvig", "notifications", "github", "NUMBER", "com", "write", "For", "the", "most", "part", "R", "NUMBER", "RS", "try", "to", "remain", "representation", "agnostic", "to", "allow", "a", "wide", "variety", "of", "implementation", "choices", "for", "inexact", "arithmetic", "NUMBER", "One", "choice", "be", "to", "use", "arbitrary", "precision", "inexact", "arithmetic", "in", "which", "all", "finite", "numbers", "be", "representable", "albeit", "imprecisely", "and", "in", "which", "inf", "NUMBER", "and", "inf", "NUMBER", "represent", "only", "non", "finite", "numbers", "NUMBER", "An", "implementation", "may", "however", "choose", "to", "treat", "finite", "numbers", "as", "inf", "NUMBER", "and", "inf", "NUMBER", "if", "they", "be", "out", "of", "that", "implementation", "s", "representable", "range", "NUMBER", "The", "exact", "zero", "value", "of", "NUMBER", "inf", "NUMBER", "derives", "from", "that", "choice", "in", "such", "an", "implementation", "inf", "NUMBER", "and", "inf", "NUMBER", "most", "often", "represent", "out", "of", "range", "finite", "numbers", "and", "multiplying", "such", "numbers", "by", "exact", "NUMBER", "should", "produce", "exact", "NUMBER", "A", "program", "needing", "infinities", "that", "never", "represent", "mere", "out", "of", "range", "finite", "numbers", "isn", "t", "well", "served", "by", "this", "NUMBER", "My", "guess", "be", "such", "program", "aren", "t", "common", "aren", "t", "well", "served", "anyway", "by", "a", "single", "pair", "of", "infinities", "representing", "all", "cardinalities", "and", "might", "even", "require", "some", "form", "of", "symbolic", "arithmetic", "NUMBER", "You", "be", "receiving", "this", "because", "you", "authored", "the", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AHUKspeFl", "NUMBER", "U", "NUMBER", "MlPgyUIoXwNJi", "NUMBER", "aO", "bvzks", "NUMBER", "qhaiCgaJpZM", "NUMBER", "Jn", "NUMBER", "qO", "NUMBER", "fedeinthemix", "as", "long", "as", "you", "use", "inexact", "floating", "point", "numbers", "it", "behaves", "as", "you", "d", "expect", "namely", "NUMBER", "inf", "NUMBER", "nan", "NUMBER", "In", "my", "experience", "the", "most", "common", "scenario", "be", "code", "that", "multiples", "two", "variables", "each", "of", "which", "be", "bound", "to", "an", "inexact", "number", "NUMBER", "Mathematically", "NUMBER", "limit", "x", "NUMBER", "NUMBER", "x", "NUMBER", "rather", "than", "undefined", "NUMBER", "and", "infinite", "small", "infinite", "large", "Undefined", "Of", "course", "there", "be", "_examples_", "where", "a", "careful", "mathematical", "analysis", "gives", "a", "result", "which", "looks", "like", "NUMBER", "infinity", "NUMBER", "However", "when", "you", "only", "see", "NUMBER", "_infinity", "you", "do", "not", "have", "enough", "information", "to", "tell", "if", "this", "be", "one", "of", "those", "examples", "or", "not", "NUMBER", "In", "particular", "given", "the", "applicative", "order", "evaluation", "of", "Scheme", "_", "NUMBER", "inf", "NUMBER", "can", "be", "a", "partial", "evaluation", "of", "some", "arbitrary", "expression", "NUMBER", "Here", "an", "example", "define", "f", "x", "x", "define", "g", "x", "NUMBER", "x", "f", "NUMBER", "g", "NUMBER", "NUMBER", "wrong", "On", "Sat", "Aug", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "AM", "ChaosEternal", "notifications", "github", "NUMBER", "com", "write", "Mathematically", "NUMBER", "limit", "x", "NUMBER", "NUMBER", "x", "NUMBER", "rather", "than", "undefined", "NUMBER", "and", "infinite", "small", "infinite", "large", "Undefined", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AHUKsmY", "NUMBER", "J", "NUMBER", "IPRGNSjPeu", "_", "NUMBER", "MJiZUW", "saks", "NUMBER", "qhpBrgaJpZM", "NUMBER", "Jn", "NUMBER", "qO", "NUMBER", "From", "my", "point", "of", "view", "as", "somebody", "who", "was", "not", "involved", "in", "write", "R", "NUMBER", "RS", "but", "who", "reads", "its", "outcome", "section", "NUMBER", "and", "the", "requirement", "that", "NUMBER", "NUMBER", "should", "evaluate", "to", "inf", "NUMBER", "implies", "that", "the", "latter", "means", "infinity", "and", "not", "arbitrarily", "large", "but", "not", "infinity", "NUMBER", "The", "matter", "of", "sign", "comes", "down", "to", "convention", "this", "must", "be", "for", "every", "function", "with", "discontinuities", "NUMBER", "Making", "a", "distinction", "between", "infinity", "and", "a", "symbol", "which", "stands", "for", "arbitrarily", "large", "but", "not", "infinity", "and", "zero", "and", "arbitrarily", "small", "but", "not", "exact", "zero", "leads", "to", "more", "problematic", "cases", "NUMBER", "For", "example", "why", "do", "NUMBER", "NUMBER", "evaluates", "to", "t", "if", "NUMBER", "inf", "NUMBER", "gives", "a", "result", "different", "from", "NUMBER", "inf", "NUMBER", "Should", "this", "TAG", "NUMBER", "be", "exactly", "zero", "not", "arbitrarily", "close", "to", "it", "and", "inf", "NUMBER", "as", "infinity", "then", "NUMBER", "NUMBER", "be", "naturally", "t", "TAG", "What", "s", "wrong", "here", "be", "that", "NUMBER", "NUMBER", "evaluates", "to", "inf", "NUMBER", "It", "should", "be", "an", "error", "or", "at", "least", "nan", "NUMBER", "since", "a", "it", "be", "division", "by", "exact", "zero", "not", "something", "arbitrarily", "close", "to", "zero", "and", "b", "the", "sign", "be", "indeterminate", "since", "exact", "NUMBER", "be", "neither", "positive", "nor", "negative", "NUMBER", "R", "NUMBER", "RS", "however", "requires", "NUMBER", "NUMBER", "to", "return", "inf", "NUMBER", "under", "the", "assumption", "that", "NUMBER", "be", "first", "converted", "to", "NUMBER", "inf", "NUMBER", "and", "inf", "NUMBER", "shouldn", "t", "be", "use", "when", "something", "went", "wrong", "as", "in", "this", "example", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AHUKst", "NUMBER", "f", "NUMBER", "FEBYkjILJqrUI", "NUMBER", "q", "NUMBER", "_", "NUMBER", "CvipDks", "NUMBER", "qhwUDgaJpZM", "NUMBER", "Jn", "NUMBER", "qO", "NUMBER", "Yes", "like", "it", "be", "common", "in", "mathematics", "NUMBER", "should", "mean", "NUMBER", "reached", "from", "the", "positive", "side", "lim", "x", "NUMBER", "f", "x", "and", "NUMBER", "should", "mean", "NUMBER", "reached", "from", "the", "negative", "side", "lim", "x", "NUMBER", "f", "x", "NUMBER", "This", "add", "a", "piece", "of", "information", "to", "help", "with", "the", "evaluation", "of", "function", "with", "discontinuities", "and", "in", "particular", "with", "singularities", "NUMBER", "On", "Sun", "Aug", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "AM", "R", "NUMBER", "Kent", "Dybvig", "notifications", "github", "NUMBER", "com", "write", "Should", "NUMBER", "also", "be", "treated", "as", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AHUKsvWoprfQx", "NUMBER", "YU", "NUMBER", "gjxC", "NUMBER", "wPUEaG", "NUMBER", "Vjks", "NUMBER", "qh", "NUMBER", "pPgaJpZM", "NUMBER", "Jn", "NUMBER", "qO", "NUMBER", "The", "value", "of", "NUMBER", "NUMBER", "should", "be", "inf", "NUMBER", "as", "currently", "given", "and", "in", "accordance", "with", "lim", "x", "NUMBER", "NUMBER", "x", "NUMBER", "On", "Sun", "Aug", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "R", "NUMBER", "Kent", "Dybvig", "notifications", "github", "NUMBER", "com", "write", "And", "what", "be", "the", "value", "of", "NUMBER", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AHUKstvGj", "NUMBER", "O", "NUMBER", "MGcma", "NUMBER", "eYwPuTV", "NUMBER", "AcgM", "NUMBER", "ks", "NUMBER", "qiFosgaJpZM", "NUMBER", "Jn", "NUMBER", "qO", "NUMBER", "On", "Mon", "Aug", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "AM", "R", "NUMBER", "Kent", "Dybvig", "notifications", "github", "NUMBER", "com", "write", "Your", "third", "note", "back", "claims", "it", "s", "problematic", "for", "NUMBER", "inf", "NUMBER", "to", "give", "a", "different", "result", "from", "NUMBER", "inf", "NUMBER", "when", "NUMBER", "NUMBER", "evaluates", "to", "t", "NUMBER", "By", "the", "same", "logic", "it", "s", "equally", "problematic", "for", "NUMBER", "NUMBER", "to", "give", "a", "different", "result", "from", "NUMBER", "NUMBER", "when", "NUMBER", "NUMBER", "evaluates", "to", "t", "yet", "that", "s", "what", "your", "second", "and", "first", "note", "back", "require", "NUMBER", "Not", "exactly", "I", "said", "that", "NUMBER", "NUMBER", "and", "NUMBER", "NUMBER", "should", "mean", "lim", "x", "NUMBER", "NUMBER", "x", "while", "NUMBER", "NUMBER", "should", "mean", "lim", "x", "NUMBER", "NUMBER", "x", "NUMBER", "The", "numbers", "NUMBER", "NUMBER", "and", "NUMBER", "should", "all", "be", "the", "same", "exact", "number", "but", "they", "carry", "an", "extra", "piece", "of", "information", "to", "tell", "from", "which", "side", "you", "reached", "it", "NUMBER", "That", "s", "just", "borrowing", "notation", "from", "mathematics", "NUMBER", "So", "your", "interpretation", "be", "problematic", "or", "your", "logic", "be", "flawed", "NUMBER", "In", "this", "issue", "your", "logic", "be", "flawed", "numeric", "equality", "be", "inherently", "imprecise", "when", "inexact", "numbers", "be", "involved", "and", "do", "not", "imply", "identical", "behavior", "NUMBER", "There", "be", "many", "cases", "where", "the", "behavior", "of", "numerically", "equal", "numbers", "can", "differ", "NUMBER", "For", "example", "NUMBER", "NUMBER", "t", "but", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "f", "NUMBER", "That", "s", "very", "revealing", "It", "seems", "that", "mixing", "exact", "and", "inexact", "numbers", "always", "leads", "to", "surprises", "NUMBER", "Your", "interpretation", "has", "a", "flaw", "as", "well", "because", "R", "NUMBER", "RS", "calculations", "treat", "NUMBER", "differently", "from", "NUMBER", "in", "more", "than", "the", "one", "case", "you", "brought", "up", "originally", "precisely", "because", "NUMBER", "be", "exactly", "NUMBER", "and", "NUMBER", "be", "not", "NUMBER", "A", "trivial", "example", "be", "that", "NUMBER", "NUMBER", "while", "NUMBER", "NUMBER", "A", "particularly", "relevant", "example", "be", "that", "NUMBER", "NUMBER", "raises", "an", "exception", "while", "NUMBER", "NUMBER", "do", "not", "NUMBER", "Also", "as", "has", "be", "observed", "recently", "LINK", "an", "inexact", "zero", "imaginary", "part", "makes", "a", "complex", "number", "non", "real", "while", "an", "exact", "zero", "imaginary", "part", "do", "not", "NUMBER", "This", "difference", "shows", "up", "in", "calculations", "too", "e", "NUMBER", "g", "NUMBER", "cos", "NUMBER", "NUMBER", "i", "cos", "NUMBER", "NUMBER", "while", "cos", "NUMBER", "NUMBER", "i", "NUMBER", "NUMBER", "Thanks", "for", "the", "examples", "NUMBER", "The", "possibility", "of", "other", "interpretations", "aside", "I", "remain", "comfortable", "with", "the", "interpretation", "that", "NUMBER", "and", "NUMBER", "be", "close", "to", "but", "not", "quite", "zero", "and", "inf", "NUMBER", "and", "inf", "NUMBER", "be", "large", "but", "not", "quite", "infinity", "NUMBER", "My", "preference", "for", "this", "interpretation", "reflects", "a", "the", "fact", "that", "inf", "NUMBER", "and", "inf", "NUMBER", "can", "arise", "through", "overflow", "or", "through", "underflow", "followed", "by", "division", "and", "b", "my", "suspicion", "that", "they", "arise", "this", "way", "much", "more", "often", "than", "through", "the", "intentional", "introduction", "of", "a", "true", "infinity", "NUMBER", "So", "I", "remain", "convinced", "that", "in", "Chez", "Scheme", "NUMBER", "TAG", "should", "continue", "to", "evaluate", "to", "NUMBER", "which", "R", "NUMBER", "RS", "allows", "and", "TAG", "NUMBER", "should", "raise", "an", "exception", "which", "R", "NUMBER", "RS", "do", "not", "allow", "though", "I", "m", "tempted", "to", "arrange", "for", "the", "version", "of", "export", "from", "the", "chezscheme", "library", "to", "do", "so", "NUMBER", "I", "decided", "to", "open", "an", "issue", "by", "seeing", "the", "result", "of", "f", "NUMBER", "g", "NUMBER", "with", "f", "and", "g", "as", "given", "on", "a", "previous", "note", "which", "be", "definitely", "a", "wrong", "result", "NUMBER", "I", "thought", "that", "change", "NUMBER", "inf", "NUMBER", "from", "NUMBER", "to", "nan", "NUMBER", "was", "a", "simple", "solution", "but", "I", "see", "that", "peoples", "disagree", "NUMBER", "To", "me", "what", "matters", "be", "to", "minimize", "the", "number", "of", "times", "that", "a", "computation", "can", "lead", "to", "a", "wrong", "result", "NUMBER", "Rising", "an", "exception", "as", "you", "suggest", "be", "one", "such", "method", "and", "be", "fine", "with", "me", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AHUKstDLkszJTV", "NUMBER", "rLQOaJt", "NUMBER", "TNo", "NUMBER", "p", "NUMBER", "V_jks", "NUMBER", "qiRsPgaJpZM", "NUMBER", "Jn", "NUMBER", "qO", "NUMBER", "I", "m", "closing", "this", "discussion", "but", "welcome", "a", "pull", "request", "that", "causes", "TAG", "NUMBER", "to", "raise", "an", "exception", "when", "be", "imported", "from", "chezscheme", "rather", "than", "rnrs", "NUMBER", "A", "change", "in", "NUMBER", "broken", "build", "on", "NUMBER", "bit", "glibc", "NUMBER", "The", "function", "s_ee_write_char", "has", "s_ee_write_char", "INT", "prototype", "NUMBER", "Despite", "it", "fix", "build", "on", "NUMBER", "bit", "Linux", "perhaps", "the", "correct", "fix", "be", "doing", "opposite", "define", "some", "type", "for", "character", "in", "expeditor", "and", "change", "s_ee_write_char", "prototype", "NUMBER", "Sorry", "but", "i", "m", "too", "lazy", "to", "explore", "on", "this", "NUMBER", "cc", "eraserhd", "R", "NUMBER", "RS", "and", "SRFI", "NUMBER", "say", "that", "if", "there", "be", "no", "matching", "handler", "clause", "in", "the", "guard", "form", "for", "a", "particular", "exception", "the", "exception", "condition", "be", "re", "raise", "as", "if", "by", "raise", "NUMBER", "Kent", "Dybvig", "s", "TSPL", "says", "that", "it", "be", "re", "raise", "as", "if", "by", "raise", "continuable", "which", "be", "wrong", "if", "intended", "to", "follow", "R", "NUMBER", "RS", "NUMBER", "R", "NUMBER", "RS", "initially", "said", "it", "was", "re", "raise", "as", "if", "by", "raise", "continuable", "but", "this", "was", "correct", "in", "an", "erratum", "so", "as", "to", "be", "the", "same", "as", "R", "NUMBER", "RS", "and", "SRFI", "NUMBER", "erratum", "NUMBER", "NUMBER", "It", "be", "rare", "for", "a", "situation", "to", "arise", "where", "this", "be", "relevant", "as", "on", "re", "raising", "an", "exception", "condition", "that", "would", "usually", "be", "handle", "in", "another", "guard", "form", "further", "up", "the", "stack", "or", "if", "there", "be", "none", "terminate", "the", "program", "NUMBER", "But", "there", "be", "situations", "where", "the", "outcome", "raise", "versus", "raise", "continuable", "makes", "a", "difference", "such", "as", "in", "the", "code", "below", "NUMBER", "The", "code", "below", "shows", "that", "in", "fact", "chez", "scheme", "do", "neither", "what", "R", "NUMBER", "RS", "says", "re", "raise", "with", "raise", "nor", "what", "TCPL", "says", "re", "raise", "with", "raise", "continuable", "NUMBER", "It", "ends", "up", "re", "raising", "a", "non", "continuable", "exception", "with", "raise", "and", "re", "raises", "a", "continuable", "exception", "with", "raise", "continuable", "NUMBER", "Although", "when", "a", "non", "continuable", "exception", "be", "throw", "by", "the", "code", "below", "within", "a", "guard", "form", "the", "program", "exits", "with", "a", "non", "continuable", "exception", "error", "when", "the", "with", "exception", "handler", "handler", "lambda", "finally", "exits", "it", "be", "in", "fact", "a", "little", "more", "complicated", "than", "that", "NUMBER", "If", "extra", "instrumentation", "be", "add", "it", "seems", "that", "the", "with", "exception", "handler", "handler", "lambda", "be", "entered", "as", "many", "times", "as", "there", "be", "nested", "guard", "form", "further", "down", "the", "stack", "twice", "in", "the", "code", "below", "with", "what", "appear", "to", "be", "continuable", "exception", "and", "then", "after", "the", "exception", "handlers", "established", "by", "the", "guard", "form", "have", "be", "exhausted", "by", "a", "non", "continuable", "exception", "NUMBER", "define", "raise", "proc", "NUMBER", "raise", "continuable", "test", "display", "Returning", "from", "raise", "proc", "NUMBER", "n", "define", "raise", "proc", "NUMBER", "raise", "test", "we", "will", "never", "reach", "here", "display", "Returning", "from", "raise", "proc", "NUMBER", "n", "define", "guard", "proc", "inner", "f", "guard", "c", "f", "f", "f", "display", "Returning", "from", "inner", "re", "raise", "continuable", "exception", "n", "define", "guard", "proc", "outer", "f", "guard", "c", "f", "f", "guard", "proc", "inner", "f", "display", "Returning", "from", "outer", "re", "raise", "continuable", "exception", "n", "with", "exception", "handler", "lambda", "k", "f", "lambda", "guard", "proc", "outer", "raise", "proc", "NUMBER", "display", "Normal", "exit", "n", "n", "with", "exception", "handler", "lambda", "k", "f", "lambda", "guard", "proc", "outer", "raise", "proc", "NUMBER", "never", "executed", "display", "Normal", "exit", "n", "n", "Hey", "ChrisVine", "Thanks", "for", "the", "bug", "report", "NUMBER", "This", "be", "actually", "something", "that", "was", "change", "in", "the", "Errata", "for", "R", "NUMBER", "RS", "see", "the", "errata", "for", "section", "NUMBER", "LINK", "errata", "NUMBER", "html", "It", "actually", "do", "specify", "that", "raise", "continuable", "should", "be", "use", "The", "sentence", "If", "every", "TAG", "s", "TAG", "evaluates", "to", "f", "and", "there", "be", "no", "else", "clause", "then", "raise", "be", "re", "invoked", "on", "the", "raise", "object", "NUMBER", "should", "be", "replaced", "by", "If", "every", "TAG", "s", "TAG", "evaluates", "to", "f", "and", "there", "be", "no", "else", "clause", "then", "raise", "continuable", "be", "invoked", "on", "the", "raise", "object", "NUMBER", "Chez", "Scheme", "be", "consistent", "with", "the", "Errata", "NUMBER", "What", "a", "mess", "NUMBER", "R", "NUMBER", "RS", "and", "R", "NUMBER", "RS", "issue", "errata", "in", "opposite", "directions", "NUMBER", "However", "the", "test", "case", "posted", "appears", "to", "show", "that", "with", "non", "continuable", "exception", "raise", "be", "in", "the", "end", "re", "invoked", "on", "the", "raise", "object", "NUMBER", "Is", "that", "consistent", "with", "the", "Errata", "The", "interesting", "thing", "be", "that", "the", "R", "NUMBER", "RS", "errata", "seems", "to", "indicate", "it", "was", "change", "to", "be", "compatible", "with", "R", "NUMBER", "RS", "so", "I", "think", "there", "was", "some", "miscommunication", "on", "that", "part", "of", "the", "standard", "and", "the", "errata", "NUMBER", "So", "I", "believe", "the", "test", "shows", "the", "correct", "behavior", "NUMBER", "Adding", "a", "print", "statement", "to", "your", "handlers", "might", "make", "it", "a", "little", "bit", "more", "clear", "what", "be", "going", "on", "NUMBER", "Here", "be", "my", "understanding", "after", "reading", "the", "R", "NUMBER", "RS", "documentation", "on", "guard", "raise", "raise", "continuable", "and", "with", "exception", "handler", "NUMBER", "So", "imagine", "a", "simpler", "situation", "with", "exception", "handler", "lambda", "x", "printf", "first", "handler", "invoked", "with", "s", "n", "x", "f", "lambda", "guard", "c", "f", "f", "raise", "continuable", "a", "printf", "returned", "from", "continuable", "exception", "n", "with", "exception", "handler", "lambda", "x", "printf", "second", "handler", "invoked", "with", "s", "n", "x", "f", "lambda", "guard", "c", "f", "f", "raise", "b", "printf", "I", "should", "never", "be", "printed", "n", "This", "prints", "first", "handler", "invoked", "with", "a", "returned", "from", "continuable", "exception", "second", "handler", "invoked", "with", "b", "second", "handler", "invoked", "with", "TAG", "Exception", "occur", "with", "condition", "components", "NUMBER", "non", "continuable", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "As", "I", "read", "the", "standard", "this", "be", "what", "I", "expect", "NUMBER", "The", "first", "expression", "invokes", "raise", "continuable", "with", "a", "which", "causes", "the", "exception", "handler", "created", "by", "guard", "to", "be", "invoked", "NUMBER", "Because", "the", "guard", "expression", "do", "not", "handle", "the", "exception", "it", "re", "raises", "a", "with", "raise", "continuable", "cause", "the", "handler", "established", "by", "the", "first", "with", "exception", "handler", "to", "be", "invoked", "with", "a", "NUMBER", "This", "prints", "first", "handler", "invoked", "with", "a", "Since", "the", "inner", "most", "call", "was", "a", "raise", "continuable", "we", "re", "do", "and", "we", "print", "our", "next", "line", "out", "returned", "from", "continuable", "exception", "Now", "we", "head", "into", "the", "second", "exception", "handler", "which", "has", "a", "raise", "at", "the", "core", "NUMBER", "So", "the", "raise", "be", "call", "with", "b", "invoking", "the", "handler", "established", "by", "the", "guard", "expression", "NUMBER", "Since", "the", "guard", "again", "doesn", "t", "know", "how", "to", "handle", "the", "exception", "it", "calls", "raise", "continuable", "on", "b", "invoking", "the", "handler", "established", "by", "the", "second", "with", "exception", "handler", "and", "we", "get", "second", "handler", "invoked", "with", "b", "Now", "we", "re", "do", "with", "that", "handler", "but", "the", "inner", "most", "raise", "be", "not", "do", "it", "still", "needs", "to", "call", "raise", "on", "a", "non", "continuable", "condition", "on", "the", "handler", "one", "level", "up", "from", "the", "handler", "we", "established", "with", "guard", "NUMBER", "This", "recursive", "call", "to", "raise", "immediately", "invokes", "the", "handler", "established", "in", "the", "second", "with", "exception", "handler", "and", "we", "get", "second", "handler", "invoked", "with", "TAG", "Since", "raise", "call", "itself", "recursively", "and", "there", "be", "still", "more", "handlers", "on", "the", "handler", "stack", "in", "this", "case", "Chez", "Scheme", "s", "outer", "most", "handler", "NUMBER", "The", "recursive", "call", "to", "raise", "with", "the", "non", "continuable", "condition", "recurs", "to", "raise", "again", "on", "the", "next", "handler", "in", "the", "handler", "stack", "the", "outer", "most", "handler", "and", "we", "get", "Exception", "occur", "with", "condition", "components", "NUMBER", "non", "continuable", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "The", "Type", "debug", "line", "be", "there", "because", "I", "run", "this", "within", "the", "REPL", "and", "it", "establishes", "a", "handler", "that", "prints", "this", "message", "and", "returns", "to", "the", "REPL", "prompt", "NUMBER", "I", "think", "the", "core", "idea", "here", "be", "that", "even", "though", "guard", "calls", "raise", "continuable", "and", "you", "can", "see", "that", "for", "yourself", "in", "s", "exception", "NUMBER", "ss", "in", "the", "guard", "procedure", "this", "cannot", "make", "a", "non", "continuable", "raise", "continuable", "NUMBER", "With", "all", "of", "this", "said", "this", "doesn", "t", "prevent", "us", "from", "catching", "a", "non", "continuable", "exception", "determining", "what", "we", "want", "to", "do", "with", "it", "and", "carrying", "on", "execution", "NUMBER", "We", "just", "cannot", "continue", "from", "the", "point", "at", "which", "the", "raise", "was", "invoked", "NUMBER", "OK", "I", "be", "grateful", "for", "your", "analysis", "NUMBER", "I", "assumed", "the", "explanation", "for", "chez", "scheme", "s", "behaviour", "was", "something", "like", "that", "NUMBER", "However", "the", "idea", "that", "NUMBER", "the", "inner", "most", "raise", "be", "not", "do", "it", "still", "needs", "to", "call", "raise", "on", "a", "non", "continuable", "condition", "on", "the", "handler", "one", "level", "up", "from", "the", "handler", "we", "established", "with", "guard", "do", "not", "seem", "to", "me", "to", "be", "the", "more", "obvious", "reading", "of", "R", "NUMBER", "RS", "with", "the", "erratum", "applied", "to", "it", "NUMBER", "On", "an", "ordinary", "reading", "of", "the", "R", "NUMBER", "RS", "text", "with", "erratum", "NUMBER", "If", "every", "TAG", "s", "TAG", "evaluates", "to", "f", "and", "there", "be", "no", "else", "clause", "then", "raise", "continuable", "be", "invoked", "on", "the", "raise", "object", "within", "the", "dynamic", "environment", "of", "the", "original", "call", "to", "raise", "except", "that", "the", "current", "exception", "handler", "be", "that", "of", "the", "guard", "expression", "it", "seems", "to", "me", "that", "the", "re", "invocation", "be", "intended", "to", "be", "substitutional", "that", "be", "how", "it", "behaves", "where", "the", "original", "exception", "was", "raise", "with", "raise", "continuable", "a", "continuable", "exception", "be", "not", "handle", "twice", "in", "your", "example", "or", "three", "times", "in", "mine", "nor", "be", "it", "intended", "that", "there", "would", "be", "multiple", "exception", "in", "my", "example", "of", "two", "nested", "guard", "form", "if", "the", "inner", "form", "do", "not", "handle", "a", "non", "continuable", "exception", "so", "generating", "a", "continuable", "exception", "but", "the", "outer", "form", "do", "handle", "the", "exception", "NUMBER", "Anyway", "test", "guile", "and", "kawa", "the", "only", "other", "schemes", "to", "which", "I", "have", "access", "which", "purport", "to", "have", "some", "measure", "of", "R", "NUMBER", "RS", "support", "they", "in", "fact", "re", "raise", "with", "raise", "rather", "than", "raise", "continuable", "NUMBER", "In", "addition", "they", "re", "raise", "without", "when", "doing", "so", "restoring", "the", "dynamic", "environment", "to", "that", "of", "the", "original", "call", "to", "raise", "the", "failure", "to", "do", "so", "be", "both", "sensible", "and", "more", "efficient", "if", "the", "exception", "be", "re", "raise", "with", "raise", "NUMBER", "Thus", "the", "following", "code", "scheme", "guard", "c", "t", "f", "guard", "c", "f", "f", "dynamic", "wind", "lambda", "display", "in", "lambda", "raise", "test", "lambda", "display", "out", "correctly", "prints", "in", "out", "in", "out", "with", "chez", "scheme", "by", "virtue", "of", "re", "entry", "into", "the", "dynamic", "wind", "block", "when", "the", "inner", "guard", "form", "fail", "to", "handle", "the", "exception", "but", "only", "in", "out", "with", "guile", "or", "kawa", "the", "kawa", "documentation", "quotes", "R", "NUMBER", "RS", "with", "erratum", "applied", "but", "do", "not", "in", "fact", "comply", "with", "it", "NUMBER", "From", "its", "documentation", "racket", "also", "appears", "to", "behave", "like", "guile", "and", "kawa", "when", "in", "R", "NUMBER", "RS", "mode", "although", "I", "have", "not", "test", "that", "NUMBER", "As", "a", "side", "issue", "raise", "continuable", "be", "in", "my", "opinion", "more", "or", "less", "useless", "NUMBER", "The", "idea", "that", "code", "further", "up", "the", "stack", "will", "have", "a", "better", "idea", "about", "how", "to", "handle", "an", "exception", "_before", "continuing", "back", "down", "the", "stack", "again_", "than", "the", "code", "which", "_is_", "down", "the", "stack", "be", "contrary", "to", "all", "practical", "experience", "NUMBER", "It", "seems", "to", "be", "inspired", "by", "common", "lisp", "restarts", "the", "only", "practical", "use", "of", "which", "I", "have", "seen", "be", "in", "REPLs", "and", "debuggers", "NUMBER", "From", "that", "point", "of", "view", "apart", "from", "efficiency", "the", "issue", "disappears", "NUMBER", "Decent", "code", "employing", "with", "exception", "handler", "will", "either", "carry", "out", "clean", "up", "and", "logging", "before", "terminating", "the", "program", "if", "it", "cannot", "handle", "the", "exception", "or", "handle", "the", "exception", "and", "then", "continue", "by", "invoking", "an", "explicit", "continuation", "object", "NUMBER", "For", "such", "code", "it", "doesn", "t", "matter", "whether", "the", "exception", "be", "continuable", "or", "not", "NUMBER", "dybig", "Thanks", "I", "can", "see", "the", "sense", "in", "that", "so", "long", "as", "it", "be", "thought", "that", "continuable", "exception", "may", "actually", "be", "use", "NUMBER", "Anyway", "the", "implementation", "in", "section", "NUMBER", "of", "R", "NUMBER", "RS", "in", "the", "absence", "of", "the", "possibly", "incorrect", "R", "NUMBER", "RS", "erratum", "behaves", "in", "the", "way", "chez", "scheme", "do", "so", "I", "think", "it", "must", "be", "taken", "to", "be", "what", "R", "NUMBER", "RS", "with", "the", "erratum", "to", "which", "akeep", "has", "referred", "intends", "to", "occur", "NUMBER", "It", "be", "the", "only", "scheme", "which", "as", "far", "as", "I", "can", "see", "actually", "do", "so", "NUMBER", "I", "ll", "therefore", "close", "this", "NUMBER", "I", "m", "work", "on", "make", "ChezScheme", "availible", "in", "macports", "NUMBER", "Unfortunately", "this", "requires", "link", "against", "macports", "zlib", "not", "the", "vendored", "one", "NUMBER", "Is", "there", "a", "configuration", "option", "for", "this", "be", "there", "a", "reason", "it", "be", "vendored", "Also", "it", "seems", "the", "CC", "environmental", "variable", "be", "not", "honored", "and", "we", "d", "like", "it", "to", "be", "NUMBER", "There", "was", "also", "a", "problem", "with", "build", "and", "configure", "downloading", "things", "but", "that", "seems", "to", "be", "a", "more", "a", "nice", "to", "avoid", "NUMBER", "We", "have", "our", "own", "mirroring", "system", "NUMBER", "The", "ticket", "in", "Macports", "be", "LINK", "I", "will", "try", "to", "modify", "the", "Makefile", "NUMBER", "in", "appropriately", "to", "honor", "CC", "NUMBER", "I", "see", "your", "point", "about", "zlib", "and", "will", "add", "X", "as", "a", "dependency", "NUMBER", "I", "think", "that", "will", "be", "enough", "but", "will", "check", "with", "the", "committers", "to", "Macports", "NUMBER", "MacPorts", "contains", "all", "of", "Xquartz", "in", "separate", "ports", "for", "each", "X", "library", "so", "it", "s", "no", "problem", "for", "the", "ChezScheme", "port", "wbl", "be", "developing", "to", "declare", "dependencies", "on", "whatever", "X", "libraries", "it", "needs", "NUMBER", "MacPorts", "and", "macOS", "in", "general", "prefers", "dynamic", "link", "over", "static", "link", "NUMBER", "ChezScheme", "should", "dynamically", "link", "to", "MacPorts", "zlib", "not", "download", "and", "build", "its", "own", "copy", "NUMBER", "Generally", "all", "fetching", "of", "data", "from", "the", "Internet", "should", "be", "do", "by", "MacPorts", "during", "the", "fetch", "phase", "not", "by", "the", "build", "system", "during", "later", "phases", "NUMBER", "Looks", "like", "I", "won", "t", "get", "to", "the", "CC", "issue", "anytime", "soon", "so", "you", "might", "be", "able", "to", "solve", "them", "faster", "NUMBER", "Okay", "I", "have", "some", "more", "time", "now", "to", "work", "on", "this", "NUMBER", "Are", "all", "of", "ryandesign", "s", "things", "still", "issue", "I", "ve", "get", "the", "X", "dependence", "declared", "but", "be", "unsure", "how", "to", "fix", "the", "fetch", "issue", "NUMBER", "With", "LINK", "ports", "commit", "d", "NUMBER", "ef", "NUMBER", "b", "NUMBER", "f", "NUMBER", "b", "NUMBER", "d", "NUMBER", "f", "NUMBER", "c", "NUMBER", "dc", "NUMBER", "ec", "NUMBER", "d", "NUMBER", "efd", "NUMBER", "b", "I", "think", "this", "issue", "be", "fix", "NUMBER", "cc", "wbl", "ryandesign", "dybvig", "Chez", "Scheme", "doesn", "t", "recognize", "umlauts", "read", "by", "command", "line", "and", "command", "line", "argument", "NUMBER", "Tested", "with", "version", "NUMBER", "and", "NUMBER", "commit", "a", "NUMBER", "Link", "to", "mailing", "list", "discussion", "LINK", "_escaped_fragment_", "topic", "chez", "scheme", "hwg", "NUMBER", "KLYHH", "NUMBER", "topic", "chez", "scheme", "hwg", "NUMBER", "KLYHH", "NUMBER", "NUMBER", "I", "ve", "test", "this", "out", "on", "my", "Mac", "use", "the", "standard", "terminal", "and", "it", "also", "fail", "here", "if", "the", "expression", "editor", "be", "enable", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "define", "TAG", "u", "which", "should", "produce", "\u00fc", "produces", "nothing", "NUMBER", "However", "when", "I", "turn", "the", "expeditor", "off", "it", "seems", "to", "work", "fine", "akeep", "hawkeye", "scheme", "eedisable", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "define", "\u00fc", "NUMBER", "\u00fc", "NUMBER", "Additionally", "echoing", "the", "instructions", "in", "from", "the", "terminal", "worked", "in", "both", "cases", "echo", "define", "\u00fc", "NUMBER", "\u00fc", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "NUMBER", "and", "with", "eedisable", "echo", "define", "\u00fc", "NUMBER", "\u00fc", "scheme", "eedisable", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "NUMBER", "However", "command", "line", "argument", "which", "allow", "us", "to", "name", "file", "to", "load", "also", "fail", "NUMBER", "So", "for", "instance", "if", "we", "have", "two", "file", "u", "NUMBER", "ss", "and", "\u00fc", "NUMBER", "ss", "with", "the", "contents", "u", "NUMBER", "ss", "define", "u", "NUMBER", "pretty", "print", "u", "and", "\u00fc", "NUMBER", "ss", "define", "\u00fc", "NUMBER", "pretty", "print", "\u00fc", "Then", "Chez", "can", "load", "u", "NUMBER", "ss", "scheme", "u", "NUMBER", "ss", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "NUMBER", "But", "not", "\u00fc", "NUMBER", "ss", "scheme", "\u00fc", "NUMBER", "ss", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "Exception", "in", "load", "fail", "for", "NUMBER", "ss", "no", "such", "file", "or", "directory", "However", "Chez", "can", "load", "the", "\u00fc", "NUMBER", "ss", "and", "execute", "it", "correctly", "if", "we", "disable", "the", "expression", "editor", "NUMBER", "scheme", "eedisable", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "load", "\u00fc", "NUMBER", "ss", "NUMBER", "So", "anyway", "it", "seems", "like", "there", "be", "two", "problem", "here", "NUMBER", "The", "expression", "editor", "isn", "t", "able", "to", "take", "in", "unicode", "characters", "NUMBER", "NUMBER", "The", "command", "line", "argument", "aren", "t", "be", "processed", "in", "a", "way", "that", "accepts", "unicode", "characters", "NUMBER", "I", "think", "in", "both", "cases", "OS", "X", "be", "probably", "provide", "the", "characters", "in", "UTF", "NUMBER", "but", "I", "was", "a", "little", "surprised", "by", "the", "number", "of", "characters", "in", "the", "load", "error", "report", "NUMBER", "So", "there", "be", "some", "work", "arounds", "though", "not", "be", "able", "to", "use", "the", "expression", "editor", "be", "a", "pretty", "big", "bummer", "NUMBER", "Worth", "noting", "though", "be", "that", "file", "and", "console", "IO", "seem", "to", "do", "the", "right", "thing", "when", "the", "expression", "editor", "isn", "t", "involved", "NUMBER", "I", "ll", "also", "try", "to", "take", "a", "look", "into", "this", "and", "see", "what", "I", "can", "figure", "out", "NUMBER", "The", "inability", "to", "enter", "non", "latin", "characters", "in", "the", "expression", "editor", "be", "NUMBER", "This", "issue", "would", "be", "more", "accurately", "titled", "Command", "line", "argument", "always", "treated", "as", "bytes", "NUMBER", "The", "C", "spec", "at", "least", "as", "of", "C", "NUMBER", "says", "that", "argv", "contains", "strings", "which", "by", "definition", "be", "made", "up", "of", "characters", "not", "wide", "characters", "NUMBER", "It", "be", "silent", "on", "whether", "those", "strings", "can", "be", "multi", "byte", "strings", "which", "of", "course", "it", "would", "be", "since", "they", "re", "the", "same", "pointer", "type", "NUMBER", "It", "appears", "that", "it", "s", "up", "to", "the", "OS", "or", "maybe", "even", "the", "particular", "shell", "to", "fill", "in", "argv", "however", "it", "sees", "fit", "and", "it", "s", "not", "always", "consistent", "NUMBER", "See", "e", "NUMBER", "g", "NUMBER", "LINK", "be", "the", "encoding", "of", "argv", "In", "any", "case", "if", "you", "want", "to", "take", "a", "stab", "at", "make", "things", "better", "looks", "like", "scheme", "NUMBER", "c", "NUMBER", "be", "the", "place", "to", "start", "NUMBER", "possibly", "use", "the", "mbstowcs", "c", "library", "function", "and", "a", "new", "function", "like", "Sstring", "that", "takes", "wide", "character", "strings", "instead", "NUMBER", "Yes", "I", "was", "just", "looking", "at", "that", "file", "and", "the", "that", "stack", "overflow", "article", "NUMBER", "The", "pertinent", "code", "for", "the", "expression", "editor", "be", "in", "expeditor", "NUMBER", "c", "at", "lines", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "and", "NUMBER", "where", "we", "use", "read", "through", "the", "READ", "macro", "to", "read", "a", "single", "byte", "lines", "NUMBER", "NUMBER", "NUMBER", "and", "NUMBER", "and", "then", "convert", "it", "into", "a", "character", "with", "Schar", "line", "NUMBER", "NUMBER", "The", "mbstowcs", "and", "mbrtowc", "seem", "like", "they", "may", "help", "for", "this", "and", "NUMBER", "akeep", "You", "will", "probably", "also", "have", "to", "use", "newlocale", "and", "uselocale", "in", "a", "way", "similar", "to", "PR", "NUMBER", "The", "command", "line", "argument", "be", "converted", "to", "Scheme", "strings", "use", "Sstring", "NUMBER", "Sstring", "do", "not", "process", "UTF", "NUMBER", "which", "explains", "the", "behavior", "you", "re", "experience", "NUMBER", "The", "command", "line", "argument", "handle", "should", "account", "for", "the", "encoding", "use", "by", "the", "operate", "system", "NUMBER", "For", "unix", "like", "systems", "it", "be", "UTF", "NUMBER", "For", "Windows", "it", "s", "UTF", "NUMBER", "LE", "when", "the", "argument", "be", "obtained", "from", "CommandLineToArgvW", "NUMBER", "It", "would", "be", "helpful", "to", "add", "Sstring_utf", "NUMBER", "and", "Sstring_utf", "NUMBER", "le", "to", "scheme", "NUMBER", "h", "NUMBER", "Thank", "you", "for", "fix", "this", "issue", "NUMBER", "Closed", "NUMBER", "Hello", "I", "m", "trying", "to", "learn", "how", "to", "debug", "program", "with", "chezscheme", "NUMBER", "In", "this", "case", "I", "have", "an", "exception", "while", "loading", "some", "code", "NUMBER", "But", "I", "cannot", "easily", "find", "from", "where", "the", "error", "be", "come", "NUMBER", "There", "be", "some", "way", "to", "show", "a", "backtrace", "to", "see", "the", "context", "from", "where", "the", "variable", "be", "referenced", "Follows", "my", "attempt", "to", "inspect", "the", "code", "load", "sdl", "NUMBER", "sls", "Exception", "variable", "sdl", "pixeltype", "be", "not", "bound", "Type", "debug", "to", "enter", "the", "debugger", "NUMBER", "debug", "debug", "i", "TAG", "s", "continuation", "TAG", "call", "code", "sdl", "pixeltype", "TAG", "TAG", "c", "source", "code", "not", "available", "TAG", "sl", "continuation", "TAG", "call", "code", "sdl", "pixeltype", "TAG", "sf", "NUMBER", "TAG", "NUMBER", "TAG", "NUMBER", "TAG", "NUMBER", "TAG", "NUMBER", "TAG", "NUMBER", "TAG", "NUMBER", "TAG", "TAG", "cp", "this", "frame", "has", "no", "closure", "sdl", "pixeltype", "ref", "r", "NUMBER", "inspect", "value", "field", "n", "of", "symbol", "value", "v", "NUMBER", "inspect", "top", "level", "value", "of", "symbol", "name", "n", "NUMBER", "inspect", "name", "of", "symbol", "property", "list", "pl", "NUMBER", "inspect", "property", "list", "of", "symbol", "show", "s", "NUMBER", "show", "field", "of", "symbol", "NUMBER", "display", "more", "options", "sdl", "pixeltype", "s", "NUMBER", "top", "level", "value", "TAG", "NUMBER", "name", "sdl", "pixeltype", "NUMBER", "properties", "On", "Windows", "there", "do", "not", "appear", "to", "be", "a", "way", "to", "limit", "a", "process", "s", "memory", "usage", "NUMBER", "In", "NUMBER", "bit", "mode", "if", "I", "write", "bad", "code", "which", "allocates", "a", "lot", "of", "memory", "Windows", "will", "cause", "the", "rest", "of", "the", "system", "to", "become", "unresponsive", "make", "it", "difficult", "to", "terminate", "the", "current", "Scheme", "process", "NUMBER", "Would", "it", "be", "useful", "to", "have", "a", "maximum", "heap", "size", "parameter", "that", "be", "checked", "and", "allows", "Chez", "to", "display", "out", "of", "memory", "and", "call", "S_abnormal_exit", "If", "a", "parameter", "were", "to", "exist", "would", "the", "checks", "be", "limited", "to", "where", "membytes", "be", "incremented", "in", "segment", "NUMBER", "c", "Are", "there", "other", "allocations", "that", "need", "to", "be", "considered", "Does", "this", "have", "any", "unintentional", "impact", "on", "threaded", "mode", "Could", "this", "be", "useful", "in", "low", "memory", "environments", "too", "That", "s", "fair", "NUMBER", "I", "have", "run", "into", "a", "similar", "issue", "with", "a", "foreign", "library", "that", "liked", "to", "do", "large", "allocations", "NUMBER", "You", "re", "right", "I", "would", "need", "that", "mechanism", "for", "that", "foreign", "code", "as", "well", "NUMBER", "Inside", "c", "thread", "NUMBER", "c", "the", "malloc", "of", "the", "tc", "structure", "be", "not", "checked", "NUMBER", "I", "believe", "forking", "a", "large", "amount", "of", "threads", "in", "NUMBER", "bit", "mode", "should", "cause", "the", "malloc", "to", "fail", "then", "the", "memcpy", "that", "follows", "to", "crash", "the", "system", "NUMBER", "Based", "on", "the", "note", "above", "S_create_thread_object", "it", "be", "not", "clear", "that", "the", "normal", "error", "handle", "procedures", "work", "here", "as", "they", "may", "allocate", "memory", "along", "the", "way", "NUMBER", "The", "tc_mutex", "be", "also", "currently", "allocated", "and", "would", "likely", "not", "be", "release", "without", "special", "effort", "NUMBER", "Can", "the", "call", "sites", "adequately", "handle", "a", "malloc", "failure", "properly", "Perhaps", "the", "caller", "should", "allocate", "the", "memory", "and", "pass", "the", "resulting", "pointer", "into", "S_create_thread_object", "NUMBER", "If", "it", "s", "NULL", "then", "there", "s", "no", "need", "to", "copy", "NUMBER", "I", "haven", "t", "chased", "the", "details", "of", "vector_in", "or", "cons_in", "but", "be", "it", "possible", "they", "can", "also", "return", "invalid", "values", "for", "thread", "creation", "Reviewing", "more", "code", "there", "be", "another", "unguarded", "malloc", "in", "io", "NUMBER", "c", "at", "the", "bottom", "of", "S_malloc_pathname", "again", "followed", "by", "memcpy", "NUMBER", "And", "one", "in", "schlib", "NUMBER", "c", "S_call_help", "the", "usage", "of", "CREATEJMPBUF", "which", "appears", "to", "be", "defined", "as", "malloc", "NUMBER", "I", "ll", "take", "this", "one", "NUMBER", "I", "ve", "get", "the", "change", "to", "the", "three", "file", "underway", "right", "now", "NUMBER", "I", "need", "to", "run", "test", "and", "make", "sure", "I", "ve", "not", "broken", "anything", "with", "this", "change", "but", "I", "d", "be", "surprised", "if", "this", "small", "change", "creates", "problem", "NUMBER", "The", "most", "recent", "commit", "fix", "these", "three", "unchecked", "malloc", "locations", "thanks", "for", "report", "the", "problem", "The", "chezscheme", "library", "be", "large", "and", "monolithic", "NUMBER", "It", "would", "be", "helpful", "to", "split", "it", "up", "into", "Implementations", "of", "SRFIs", "in", "their", "respective", "libraries", "NUMBER", "Chez", "specific", "code", "that", "do", "not", "depend", "on", "Chez", "specific", "primitives", "and", "thus", "could", "be", "use", "elsewhere", "which", "might", "belong", "in", "an", "external", "library", "NUMBER", "One", "such", "library", "that", "has", "already", "be", "factored", "out", "be", "the", "nanopass", "framework", "NUMBER", "Libraries", "tightly", "integrated", "with", "Chez", "Scheme", "that", "cannot", "be", "reasonably", "provide", "elsewhere", "NUMBER", "These", "should", "stay", "under", "chezscheme", "or", "perhaps", "split", "into", "smaller", "libraries", "under", "chezscheme", "NUMBER", "The", "libraries", "that", "be", "split", "out", "of", "chezscheme", "should", "probably", "be", "reexported", "from", "chezscheme", "for", "backwards", "compatibility", "NUMBER", "Is", "there", "a", "way", "to", "obtain", "the", "arity", "of", "procedures", "I", "ve", "tried", "with", "e", "NUMBER", "g", "inspect", "object", "proc", "code", "source", "but", "it", "returns", "f", "for", "build", "in", "procedures", "such", "as", "car", "NUMBER", "I", "ve", "tried", "change", "the", "line", "i", "f", "to", "i", "t", "in", "Mf", "base", "before", "compile", "Chez", "but", "it", "doesn", "t", "seem", "to", "have", "any", "effect", "on", "this", "NUMBER", "For", "example", "be", "it", "possible", "to", "have", "a", "new", "foreign", "procedure", "which", "could", "automatically", "deactivate", "and", "reactivate", "threads", "and", "a", "new", "foreign", "callable", "which", "could", "automatically", "activate", "and", "deactivate", "threads", "LINK", "fix", "this", "fix", "NUMBER", "A", "NUMBER", "ss", "library", "A", "export", "A", "import", "scheme", "define", "A", "NUMBER", "scheme", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "compile", "file", "A", "compile", "A", "NUMBER", "ss", "with", "output", "to", "A", "NUMBER", "so", "make", "boot", "file", "A", "NUMBER", "boot", "scheme", "A", "NUMBER", "so", "exit", "scheme", "b", "NUMBER", "A", "NUMBER", "boot", "Exception", "in", "compiler", "internal", "install", "library", "rt", "code", "unable", "to", "install", "invoke", "code", "for", "non", "existant", "library", "A", "eldnidvc", "NUMBER", "vkegxvd", "NUMBER", "huz", "NUMBER", "gj", "NUMBER", "This", "worked", "in", "Chez", "Scheme", "NUMBER", "Also", "_non", "existent_", "be", "misspelled", "NUMBER", "Perhaps", "the", "load", "procedure", "in", "c", "scheme", "NUMBER", "c", "do", "not", "handle", "the", "library", "rt", "info", "and", "library", "ct", "info", "records", "that", "run", "inner", "of", "do", "load", "binary", "in", "s", "NUMBER", "ss", "do", "The", "first", "commit", "on", "this", "branch", "LINK", "boot", "poc", "be", "a", "quick", "stab", "at", "this", "NUMBER", "I", "restricted", "it", "to", "the", "non", "procedure", "case", "of", "non", "base", "boot", "file", "to", "limit", "overhead", "in", "the", "common", "case", "NUMBER", "Thanks", "pull", "request", "LINK", "fix", "this", "NUMBER", "The", "load", "LINK", "L", "NUMBER", "and", "handle_visit_revisit", "LINK", "L", "NUMBER", "code", "in", "scheme", "NUMBER", "c", "silently", "ignore", "unexpect", "values", "but", "my", "change", "has", "us", "now", "going", "through", "run", "inner", "LINK", "L", "NUMBER", "which", "be", "not", "so", "forgiving", "NUMBER", "Should", "make", "load", "binary", "take", "a", "for", "boot", "flag", "that", "makes", "run", "inner", "tolerate", "unexpect", "values", "LINK", "NUMBER", "system", "s", "NUMBER", "The", "times", "be", "no", "longer", "milliseconds", "but", "time", "records", "NUMBER", "Thanks", "I", "update", "the", "web", "pages", "and", "PDF", "NUMBER", "hi", "there", "when", "data", "be", "read", "write", "through", "normal", "binary", "port", "they", "should", "be", "able", "to", "pack", "unpack", "use", "the", "same", "function", "that", "ftype", "has", "NUMBER", "naturally", "if", "ftype", "ref", "ftype", "set", "family", "can", "have", "bytevectors", "as", "argument", "will", "be", "make", "life", "easier", "NUMBER", "Partially", "agree", "but", "defining", "a", "struct", "for", "bytevectors", "and", "foreign", "pointer", "shares", "something", "in", "common", "name", "size", "type", "sign", "position", "and", "padding", "align", "NUMBER", "current", "syntax", "ftype", "ref", "can", "give", "position", "information", "use", "form", "ftype", "ref", "type", "NUMBER", "but", "others", "be", "not", "very", "handy", "to", "achieve", "NUMBER", "the", "library", "code", "linux", "abc", "NUMBER", "ss", "library", "linux", "abc", "export", "getenv", "NUMBER", "import", "chezscheme", "rnrs", "bytevectors", "define", "getenv", "NUMBER", "foreign", "procedure", "getenv", "string", "string", "begin", "load", "shared", "object", "libc", "NUMBER", "so", "NUMBER", "seems", "putting", "load", "shared", "object", "here", "has", "no", "effect", "the", "test", "code", "the", "test", "code", "import", "linux", "abc", "display", "getenv", "NUMBER", "HOME", "the", "error", "message", "Exception", "in", "foreign", "procedure", "no", "entry", "for", "getenv", "The", "behavior", "of", "Chez", "be", "maybe", "different", "to", "r", "NUMBER", "rs", "LINK", "Z", "H", "NUMBER", "html", "node_sec_", "NUMBER", "The", "TAG", "be", "the", "library", "body", "consisting", "of", "a", "sequence", "of", "definitions", "followed", "by", "a", "sequence", "of", "expressions", "NUMBER", "The", "definitions", "may", "be", "both", "for", "local", "unexported", "and", "export", "bindings", "and", "the", "expressions", "be", "initialization", "expressions", "to", "be", "evaluated", "for", "their", "effect", "NUMBER", "You", "ll", "need", "to", "move", "the", "load", "shared", "object", "call", "above", "any", "foreign", "procedure", "definitions", "NUMBER", "I", "realize", "that", "r", "NUMBER", "rs", "requires", "library", "definitions", "to", "appear", "above", "arbitrary", "code", "but", "thankfully", "you", "can", "do", "still", "do", "this", "library", "linux", "abc", "export", "getenv", "NUMBER", "import", "chezscheme", "rnrs", "bytevectors", "define", "init", "begin", "load", "shared", "object", "libc", "NUMBER", "so", "NUMBER", "anything", "else", "you", "may", "need", "define", "getenv", "NUMBER", "foreign", "procedure", "getenv", "string", "string", "The", "relevant", "section", "be", "NUMBER", "LINK", "NUMBER", "foreign", "h", "NUMBER", "Two", "steps", "be", "necessary", "before", "foreign", "procedures", "can", "be", "invoked", "from", "Scheme", "NUMBER", "First", "the", "foreign", "procedure", "must", "be", "compiled", "and", "loaded", "either", "statically", "or", "dynamically", "as", "describe", "in", "Section", "NUMBER", "LINK", "g", "NUMBER", "NUMBER", "Then", "access", "to", "the", "foreign", "procedure", "must", "be", "established", "in", "Scheme", "as", "describe", "in", "this", "section", "NUMBER", "Once", "access", "to", "a", "foreign", "procedure", "has", "be", "established", "it", "may", "be", "call", "as", "an", "ordinary", "Scheme", "procedure", "NUMBER", "Your", "original", "approach", "understandably", "reversed", "the", "two", "steps", "NUMBER", "actually", "i", "misunderstood", "r", "NUMBER", "rs", "thanks", "Here", "s", "another", "method", "I", "ve", "ever", "use", "NUMBER", "You", "may", "define", "multiple", "libraries", "in", "a", "file", "so", "you", "do", "this", "scheme", "library", "init", "import", "export", "load", "shared", "object", "xxx", "NUMBER", "so", "do", "other", "relate", "init", "work", "library", "your", "module", "import", "init", "chezscheme", "rnrs", "export", "NUMBER", "put", "your", "definitions", "here", "This", "method", "be", "useful", "especially", "if", "you", "have", "record", "type", "to", "be", "defined", "first", "NUMBER", "The", "makefile", "doesn", "t", "have", "an", "uninstall", "target", "NUMBER", "I", "ve", "just", "run", "sudo", "rm", "rf", "usr", "bin", "scheme", "usr", "bin", "petite", "usr", "bin", "scheme", "script", "usr", "lib", "csv", "NUMBER", "usr", "share", "man", "man", "NUMBER", "scheme", "NUMBER", "gz", "usr", "share", "man", "man", "NUMBER", "petite", "NUMBER", "gz", "Hopefully", "I", "haven", "t", "messed", "anything", "up", "NUMBER", "burgerrg", "could", "you", "take", "a", "look", "at", "this", "NUMBER", "if", "the", "process", "above", "sufficient", "for", "totally", "remove", "NUMBER", "whether", "we", "introduce", "a", "uninstall", "target", "or", "mention", "somewhere", "like", "BUILDING", "burgerrg", "nice", "job", "then", "could", "we", "just", "close", "this", "thread", "I", "have", "find", "a", "piece", "of", "code", "in", "configure", "file", "about", "FreeBSD", "if", "uname", "a", "egrep", "i", "NUMBER", "i", "NUMBER", "amd", "NUMBER", "athlon", "x", "NUMBER", "_", "NUMBER", "dev", "null", "NUMBER", "NUMBER", "then", "m", "NUMBER", "i", "NUMBER", "fb", "m", "NUMBER", "a", "NUMBER", "fb", "tm", "NUMBER", "ti", "NUMBER", "fb", "tm", "NUMBER", "ta", "NUMBER", "fb", "fi", "installprefix", "usr", "local", "nstallmansuffix", "man", "but", "when", "I", "run", "the", "NUMBER", "configure", "command", "it", "tell", "me", "available", "machine", "types", "a", "NUMBER", "le", "a", "NUMBER", "nt", "a", "NUMBER", "osx", "i", "NUMBER", "le", "i", "NUMBER", "nt", "i", "NUMBER", "osx", "ta", "NUMBER", "le", "ta", "NUMBER", "nt", "ta", "NUMBER", "osx", "ti", "NUMBER", "le", "ti", "NUMBER", "nt", "and", "ti", "NUMBER", "osx", "and", "my", "question", "be", "what", "be", "the", "right", "machine", "type", "for", "FreeBSD", "amd", "NUMBER", "And", "what", "be", "i", "NUMBER", "fb", "a", "NUMBER", "fb", "ti", "NUMBER", "fb", "ta", "NUMBER", "fb", "that", "mention", "in", "that", "piece", "of", "code", "Detailed", "note", "about", "the", "change", "be", "in", "the", "commit", "LINK", "NUMBER", "Some", "other", "note", "These", "change", "be", "meant", "to", "be", "conservative", "NUMBER", "Two", "other", "improvement", "could", "be", "do", "NUMBER", "Any", "interest", "Use", "CSS", "classes", "rather", "than", "inline", "styles", "Use", "CSS", "classes", "rather", "than", "tables", "You", "may", "want", "to", "consider", "a", "lighter", "color", "scheme", "just", "change", "the", "first", "palette", "entry", "pair", "to", "EEEEEE", "black", "NUMBER", "profilehtml", "white", "LINK", "NUMBER", "c", "NUMBER", "NUMBER", "e", "NUMBER", "NUMBER", "c", "NUMBER", "NUMBER", "f", "NUMBER", "ab", "NUMBER", "fd", "NUMBER", "png", "fatfibhtml", "white", "LINK", "NUMBER", "c", "NUMBER", "NUMBER", "e", "NUMBER", "NUMBER", "NUMBER", "a", "NUMBER", "a", "NUMBER", "ac", "NUMBER", "a", "NUMBER", "png", "PS", "If", "you", "create", "new", "screenshots", "note", "that", "the", "timestamp", "be", "an", "Easter", "egg", "NUMBER", "Hmmm", "I", "just", "notice", "that", "the", "old", "screenshots", "have", "a", "tmp", "fatfib", "prefix", "in", "the", "file", "paths", "NUMBER", "Let", "me", "know", "if", "you", "d", "like", "new", "ones", "that", "match", "NUMBER", "I", "add", "the", "paths", "to", "the", "screenshots", "NUMBER", "Sorry", "about", "the", "noise", "I", "might", "recommend", "avoiding", "whitespace", "only", "change", "such", "as", "the", "removal", "of", "trail", "spaces", "which", "make", "it", "harder", "to", "find", "the", "more", "interesting", "differences", "for", "review", "NUMBER", "There", "were", "many", "of", "these", "for", "example", "in", "system", "NUMBER", "ex", "NUMBER", "Yes", "I", "ve", "be", "wondering", "about", "that", "NUMBER", "Btw", "in", "case", "you", "weren", "t", "aware", "you", "can", "ask", "GitHub", "to", "ignore", "whitespace", "in", "its", "diffs", "by", "add", "w", "NUMBER", "like", "this", "LINK", "NUMBER", "Whitespace", "change", "be", "fine", "with", "me", "if", "they", "help", "keep", "the", "code", "clean", "or", "eliminate", "tabs", "from", "source", "file", "as", "I", "ve", "just", "do", "NUMBER", "It", "can", "be", "helpful", "to", "put", "the", "whitespace", "only", "change", "in", "a", "different", "commit", "particularly", "if", "there", "be", "a", "lot", "of", "them", "or", "a", "lot", "of", "other", "change", "NUMBER", "Should", "I", "close", "this", "NUMBER", "Right", "NUMBER", "The", "colors", "I", "chose", "were", "from", "the", "Material", "Design", "palette", "LINK", "color", "color", "palette", "NUMBER", "There", "s", "nothing", "magical", "about", "Material", "it", "just", "has", "the", "benefit", "of", "be", "well", "specified", "NUMBER", "For", "example", "there", "be", "tints", "and", "shades", "of", "each", "hue", "of", "blue", "NUMBER", "Convenient", "Changing", "the", "palette", "will", "mean", "re", "doing", "the", "screenshots", "NUMBER", "I", "can", "do", "that", "or", "you", "can", "but", "if", "you", "do", "it", "I", "made", "the", "two", "screenshots", "exactly", "the", "same", "size", "in", "order", "to", "make", "them", "feel", "more", "like", "screenshots", "and", "less", "like", "rectangles", "copied", "from", "a", "screenshot", "NUMBER", "Btw", "I", "asked", "if", "there", "was", "interest", "in", "two", "other", "possible", "change", "NUMBER", "The", "first", "would", "be", "to", "switch", "from", "inline", "styles", "to", "CSS", "classes", "the", "second", "would", "be", "to", "use", "CSS", "for", "layout", "rather", "than", "tables", "NUMBER", "On", "the", "first", "point", "I", "was", "going", "to", "use", "an", "Atomic", "CSS", "approach", "along", "the", "lines", "of", "Basscss", "LINK", "NUMBER", "Atomic", "CSS", "be", "highly", "modular", "and", "composable", "NUMBER", "The", "result", "would", "look", "and", "feel", "somewhat", "like", "the", "current", "inline", "styles", "but", "be", "more", "DRY", "NUMBER", "Those", "change", "may", "well", "be", "past", "the", "point", "of", "diminishing", "returns", "but", "I", "thought", "the", "idea", "of", "use", "HTML", "for", "visualization", "was", "interesting", "and", "I", "was", "thinking", "that", "we", "could", "slowly", "make", "all", "of", "this", "a", "better", "foundation", "for", "other", "visualizations", "NUMBER", "I", "ve", "add", "a", "LOG", "entry", "NUMBER", "I", "ll", "consider", "creating", "a", "separate", "pull", "request", "for", "the", "other", "color", "scheme", "at", "some", "point", "but", "it", "may", "be", "enough", "to", "simply", "say", "somewhere", "that", "you", "can", "switch", "color", "schemes", "by", "change", "the", "first", "palette", "pair", "to", "EEEEEE", "black", "NUMBER", "thanks", "to", "rain", "NUMBER", "and", "hyln", "NUMBER", "on", "chez", "although", "this", "makes", "some", "of", "the", "output", "better", "but", "there", "still", "problem", "about", "pretty", "print", "NUMBER", "scheme", "pretty", "print", "match", "a", "NUMBER", "NUMBER", "a", "b", "c", "let", "a", "NUMBER", "a", "b", "c", "a", "a", "b", "c", "b", "a", "b", "c", "c", "a", "b", "c", "I", "expect", "to", "get", "scheme", "match", "a", "NUMBER", "NUMBER", "a", "b", "c", "let", "a", "NUMBER", "a", "b", "c", "a", "a", "b", "c", "b", "a", "b", "c", "c", "a", "b", "c", "but", "I", "actually", "get", "scheme", "match", "quote", "a", "NUMBER", "NUMBER", "a", "b", "c", "let", "a", "NUMBER", "a", "b", "c", "a", "a", "b", "c", "b", "a", "b", "c", "c", "a", "b", "c", "the", "use", "of", "be", "not", "specified", "by", "r", "NUMBER", "rs", "NUMBER", "while", "chez", "be", "use", "it", "as", "normal", "symbol", "for", "example", "be", "viewed", "as", "a", "list", "of", "two", "symbols", "and", "this", "makes", "it", "possible", "for", "a", "user", "to", "define", "his", "her", "own", "macros", "to", "use", "in", "anyway", "he", "she", "wishs", "NUMBER", "it", "will", "be", "great", "to", "see", "this", "fact", "documented", "in", "the", "documents", "of", "chez", "NUMBER", "also", "it", "be", "really", "necessary", "for", "those", "printer", "function", "such", "as", "pretty", "print", "to", "handle", "in", "a", "proper", "way", "NUMBER", "This", "change", "would", "introduce", "an", "incompatibility", "with", "R", "NUMBER", "RS", "so", "I", "would", "want", "it", "enable", "only", "when", "a", "parameter", "say", "print", "extend", "identifier", "syntax", "be", "t", "NUMBER", "If", "we", "had", "such", "a", "parameter", "I", "would", "want", "write", "to", "handle", "other", "Chez", "Scheme", "extensions", "to", "the", "syntax", "of", "identifiers", "as", "well", "such", "as", "the", "identifier", "NUMBER", "NUMBER", "This", "would", "require", "wrsymbol", "to", "make", "two", "pass", "over", "the", "symbol", "s", "name", "one", "to", "determine", "whether", "the", "symbol", "falls", "into", "the", "extend", "category", "and", "another", "to", "do", "the", "printing", "NUMBER", "These", "extensions", "be", "available", "outside", "libraries", "and", "top", "level", "program", "except", "when", "prefixed", "by", "r", "NUMBER", "rs", "and", "inside", "libraries", "and", "top", "level", "program", "only", "when", "prefixed", "by", "chezscheme", "NUMBER", "Extending", "pretty", "print", "to", "handle", "braces", "the", "way", "you", "want", "when", "the", "parameter", "be", "set", "probably", "wouldn", "t", "make", "anyone", "unhappy", "NUMBER", "sounds", "like", "a", "homework", "assignment", "sir", "NUMBER", "I", "will", "try", "after", "I", "finish", "the", "porgram", "I", "be", "work", "on", "NUMBER", "I", "have", "no", "idea", "if", "ChezScheme", "s", "REPL", "support", "unicode", "NUMBER", "Is", "there", "any", "good", "way", "to", "solve", "this", "problem", "now", "The", "expression", "editor", "uses", "NUMBER", "bit", "characters", "and", "NUMBER", "bit", "ncurses", "function", "NUMBER", "It", "might", "not", "be", "too", "challenging", "to", "modify", "it", "to", "use", "wide", "characters", "and", "the", "wide", "ncursesw", "function", "though", "it", "might", "take", "more", "than", "cosmetic", "change", "NUMBER", "If", "you", "disable", "the", "expression", "editor", "scheme", "eedisable", "Unicode", "should", "already", "work", "in", "a", "terminal", "emulator", "that", "support", "it", "NUMBER", "I", "ve", "spent", "a", "bunch", "of", "time", "today", "reading", "code", "and", "I", "think", "I", "have", "a", "straightforward", "way", "of", "doing", "this", "but", "I", "wanted", "to", "check", "here", "first", "NUMBER", "There", "be", "three", "parts", "to", "it", "NUMBER", "NUMBER", "Write", "characters", "to", "the", "console", "use", "wctombs", "which", "will", "respect", "the", "current", "locale", "and", "should", "output", "utf", "NUMBER", "in", "anything", "modern", "NUMBER", "NUMBER", "Read", "characters", "from", "the", "console", "covering", "with", "mbrtowc", "track", "an", "mbstate_t", "in", "static", "variables", "in", "s_ee_read_char", "the", "windows", "code", "do", "something", "similar", "with", "care", "to", "respect", "the", "blocking", "flag", "NUMBER", "This", "will", "require", "handle", "a", "few", "different", "cases", "like", "EWOULDBLOCK", "in", "the", "middle", "of", "a", "Unicode", "sequence", "NUMBER", "NUMBER", "Make", "the", "key", "mapping", "in", "expeditor", "NUMBER", "ss", "allow", "characters", "over", "NUMBER", "We", "could", "survive", "without", "this", "but", "seems", "like", "a", "good", "idea", "NUMBER", "None", "of", "this", "handles", "Unicode", "character", "composition", "but", "it", "would", "allow", "all", "precomposed", "characters", "emoji", "and", "what", "not", "NUMBER", "AFAICT", "character", "composition", "would", "require", "retrofitting", "a", "significant", "about", "of", "math", "in", "expeditor", "NUMBER", "ss", "NUMBER", "So", "before", "I", "embark", "be", "this", "a", "decent", "approach", "Can", "you", "think", "of", "anything", "specific", "I", "ll", "need", "to", "address", "to", "get", "this", "code", "accepted", "dybvig", "I", "did", "but", "I", "find", "this", "LINK", "L", "NUMBER", "which", "suggested", "a", "different", "approach", "NUMBER", "It", "looks", "like", "I", "have", "a", "bug", "to", "work", "out", "but", "I", "ll", "push", "what", "I", "have", "which", "be", "mostly", "work", "for", "review", "NUMBER", "I", "believe", "this", "has", "since", "be", "fix", "NUMBER", "For", "example", "LINK", "LINK", "_notes", "Makefile", "Including", "Makefile", "in", "NUMBER", "gitignore", "only", "hides", "any", "Makefile", "find", "in", "the", "top", "directory", "of", "the", "project", "it", "do", "not", "apply", "to", "subdirectories", "NUMBER", "The", "NUMBER", "gitignore", "file", "would", "only", "hide", "the", "file", "you", "list", "if", "a", "pattern", "like", "Makefile", "was", "include", "NUMBER", "The", "top", "level", "Makefile", "be", "generate", "by", "the", "configure", "script", "so", "hiding", "it", "be", "appropriate", "NUMBER", "Thanks", "you", "re", "right", "the", "problem", "was", "that", "my", "editor", "was", "applying", "NUMBER", "gitignore", "incorrectly", "NUMBER", "I", "have", "to", "create", "bin", "m", "folder", "under", "ChezScheme", "if", "not", "I", "ll", "get", "this", "error", "LINK", "fatal", "error", "LNK", "NUMBER", "cannot", "open", "file", "csv", "NUMBER", "dll", "NMAKE", "fatal", "error", "U", "NUMBER", "link", "NUMBER", "exe", "return", "code", "NUMBER", "x", "NUMBER", "build", "under", "windows", "NUMBER", "x", "NUMBER", "m", "a", "NUMBER", "nt", "Am", "I", "did", "it", "in", "a", "wrong", "way", "I", "met", "the", "same", "error", "NUMBER", "I", "tried", "to", "compile", "a", "NUMBER", "nt", "in", "my", "Linux", "virtual", "machine", "there", "be", "csv", "NUMBER", "dll", "in", "bin", "folder", "but", "it", "be", "a", "symlink", "NUMBER", "So", "if", "you", "do", "this", "on", "Windows", "there", "will", "not", "be", "csv", "NUMBER", "dll", "NUMBER", "I", "guess", "it", "be", "impossible", "to", "compile", "the", "executable", "on", "Windows", "now", "NUMBER", "akeep", "Does", "it", "mean", "that", "you", "cannot", "use", "the", "compiled", "binary", "in", "a", "REAL", "Windows", "system", "not", "a", "guest", "OS", "now", "Can", "we", "figure", "out", "a", "way", "to", "compile", "without", "use", "symlinks", "same", "problem", "can", "we", "just", "release", "an", "pre", "build", "exe", "then", "we", "can", "use", "this", "to", "build", "our", "production", "I", "update", "the", "build", "procedure", "for", "Windows", "so", "that", "a", "virtual", "machine", "be", "no", "longer", "required", "NUMBER", "It", "uses", "the", "Cygwin", "software", "on", "Windows", "to", "provide", "bash", "make", "etc", "NUMBER", "It", "seems", "that", "this", "project", "can", "be", "configured", "and", "build", "with", "a", "Visual", "Studio", "shell", "run", "a", "POSIX", "compatible", "shell", "Enter", "the", "VS", "shell", "NUMBER", "Enter", "the", "compatible", "shell", "NUMBER", "Run", "NUMBER", "configure", "m", "M", "NUMBER", "Exit", "the", "compatible", "shell", "NUMBER", "Do", "the", "remained", "things", "of", "Build", "step", "Windows", "build", "machine", "in", "the", "BUILDING", "document", "NUMBER", "Technically", "they", "can", "be", "executed", "in", "the", "same", "host", "NUMBER", "There", "be", "several", "distributions", "provide", "the", "compatible", "shell", "like", "bash", "NUMBER", "They", "should", "be", "considerable", "to", "ease", "the", "build", "process", "NUMBER", "They", "may", "also", "provide", "gcc", "make", "and", "other", "POSIX", "compliant", "tool", "which", "makes", "the", "Microsoft", "toolchain", "nmake", "cl", "link", "etc", "optional", "and", "results", "in", "kinds", "of", "smoother", "experience", "of", "migration", "between", "Windows", "and", "POSIX", "platforms", "NUMBER", "I", "suggest", "two", "candidates", "to", "support", "The", "bash", "environment", "provide", "by", "Windows", "NUMBER", "currently", "still", "in", "preview", "NUMBER", "MSYS", "NUMBER", "It", "be", "noticeable", "that", "with", "the", "package", "management", "mechanism", "NUMBER", "party", "dependencies", "like", "libiconv", "and", "even", "gcc", "for", "i", "NUMBER", "x", "NUMBER", "NUMBER", "target", "can", "be", "install", "automatically", "by", "the", "build", "script", "NUMBER", "I", "update", "the", "build", "procedure", "to", "use", "Cygwin", "NUMBER", "I", "suspect", "that", "MSYS", "NUMBER", "may", "also", "work", "but", "I", "haven", "t", "tried", "it", "NUMBER", "I", "think", "the", "Windows", "NUMBER", "POSIX", "environment", "do", "not", "allow", "one", "to", "call", "native", "Windows", "executables", "so", "it", "cannot", "be", "use", "with", "Microsoft", "Visual", "Studio", "NUMBER", "You", "could", "use", "gcc", "but", "you", "ll", "have", "to", "port", "Chez", "Scheme", "to", "this", "new", "machine", "type", "because", "the", "POSIX", "environment", "do", "not", "support", "the", "Windows", "API", "NUMBER", "I", "suspect", "that", "the", "POSIX", "environment", "be", "very", "close", "to", "Linux", "NUMBER", "I", "ve", "succeded", "compile", "with", "Microsoft", "Visual", "C", "Build", "Tools", "NUMBER", "windows", "sdk", "NUMBER", "as", "explained", "by", "FrankHB", "NUMBER", "I", "avoided", "installing", "the", "full", "visual", "studio", "but", "install", "only", "the", "Tools", "for", "Visual", "Studio", "compiler", "tool", "still", "NUMBER", "gb", "of", "disk", "space", "I", "use", "MSYS", "NUMBER", "instead", "of", "cygwin", "without", "any", "problem", "NUMBER", "The", "only", "thing", "I", "had", "problem", "was", "maybe", "a", "bug", "in", "a", "Makefile", "bin", "sh", "line", "NUMBER", "NUMBER", "bin", "scheme", "No", "such", "file", "or", "directory", "Mf", "base", "NUMBER", "recipe", "for", "target", "checkboot", "fail", "I", "ve", "change", "the", "line", "at", "s", "Mf", "Base", "NUMBER", "from", "NUMBER", "bin", "scheme", "b", "NUMBER", "boot", "m", "sbb", "q", "to", "NUMBER", "bin", "m", "scheme", "b", "NUMBER", "boot", "m", "sbb", "q", "then", "the", "compilation", "succeded", "NUMBER", "I", "don", "t", "know", "if", "this", "be", "correct", "though", "NUMBER", "Would", "be", "nice", "to", "support", "also", "mingw", "NUMBER", "as", "an", "option", "instead", "of", "Visual", "C", "ovenpasta", "thanks", "for", "point", "out", "the", "makefile", "s", "use", "of", "the", "symbolic", "link", "NUMBER", "bin", "scheme", "instead", "of", "the", "file", "NUMBER", "bin", "m", "scheme", "NUMBER", "I", "ve", "fix", "that", "NUMBER", "With", "regard", "to", "use", "the", "mingw", "NUMBER", "compiler", "give", "it", "a", "try", "NUMBER", "I", "d", "recommend", "looking", "at", "the", "c", "Mf", "a", "NUMBER", "le", "makefile", "and", "porting", "it", "to", "mingw", "NUMBER", "Be", "sure", "to", "run", "the", "mats", "to", "check", "that", "the", "mingw", "run", "time", "library", "handles", "all", "the", "floating", "point", "library", "edge", "cases", "in", "the", "way", "Chez", "Scheme", "expects", "NUMBER", "Hello", "I", "m", "trying", "to", "package", "Chez", "Scheme", "for", "msys", "NUMBER", "LINK", "package", "tree", "master", "chez", "scheme", "git", "NUMBER", "Currently", "I", "have", "a", "patch", "that", "adjusts", "configure", "so", "it", "recognizes", "MSYS_NT", "in", "uname", "s", "output", "NUMBER", "The", "build", "fail", "with", "the", "following", "output", "Starting", "build", "NUMBER", "cd", "ta", "NUMBER", "nt", "make", "build", "cd", "c", "make", "NUMBER", "make", "NUMBER", "bat", "C", "dev", "MSYS", "NUMBER", "package", "chez", "scheme", "git", "src", "ChezScheme", "ta", "NUMBER", "nt", "c", "make", "NUMBER", "bat", "error", "while", "loading", "shared", "libraries", "cannot", "open", "shared", "object", "file", "No", "such", "file", "or", "directory", "make", "NUMBER", "Makefile", "NUMBER", "NUMBER", "bin", "ta", "NUMBER", "nt", "scheme", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "build", "Error", "NUMBER", "ERROR", "A", "failure", "occur", "in", "build", "NUMBER", "Aborting", "NUMBER", "I", "m", "not", "sure", "where", "the", "problem", "be", "or", "where", "the", "came", "from", "NUMBER", "I", "read", "the", "makefiles", "mention", "in", "the", "log", "but", "was", "unable", "to", "figure", "it", "out", "NUMBER", "ovenpasta", "you", "were", "able", "to", "build", "use", "msys", "NUMBER", "what", "could", "the", "above", "mean", "Can", "you", "reproduce", "this", "behavior", "Just", "very", "few", "steps", "NUMBER", "of", "course", "depends", "if", "you", "want", "NUMBER", "or", "NUMBER", "bit", "build", "threaded", "or", "not", "but", "just", "for", "example", "execute", "Visual", "C", "NUMBER", "x", "NUMBER", "Native", "Build", "Tools", "Command", "Prompt", "from", "there", "run", "c", "msys", "NUMBER", "msys", "NUMBER", "_shell", "NUMBER", "bat", "then", "cd", "to", "the", "ChezScheme", "source", "directory", "and", "run", "NUMBER", "configure", "m", "i", "NUMBER", "nt", "them", "run", "make", "I", "launched", "msys", "NUMBER", "from", "the", "Native", "Build", "Tools", "Prompt", "and", "followed", "those", "exact", "steps", "but", "still", "get", "the", "same", "error", "bash", "cd", "ChezScheme", "NUMBER", "configure", "m", "i", "NUMBER", "nt", "make", "cd", "i", "NUMBER", "nt", "make", "build", "cd", "c", "make", "NUMBER", "make", "NUMBER", "bat", "C", "Users", "Matheus", "Downloads", "dev", "package", "MSYS", "NUMBER", "package", "chez", "scheme", "git", "src", "ChezScheme", "i", "NUMBER", "nt", "c", "make", "NUMBER", "bat", "error", "while", "loading", "shared", "libraries", "cannot", "open", "shared", "object", "file", "No", "such", "file", "or", "directory", "make", "NUMBER", "Makefile", "NUMBER", "NUMBER", "bin", "i", "NUMBER", "nt", "scheme", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "build", "Error", "NUMBER", "Your", "msys", "NUMBER", "environment", "appears", "to", "be", "different", "NUMBER", "You", "have", "an", "msys", "NUMBER", "_shell", "NUMBER", "bat", "file", "here", "it", "be", "call", "msys", "NUMBER", "_shell", "NUMBER", "cmd", "NUMBER", "Can", "you", "please", "post", "the", "output", "of", "uname", "a", "on", "your", "system", "bash", "uname", "a", "MSYS_NT", "NUMBER", "Irlene", "PC", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "x", "NUMBER", "_", "NUMBER", "Msys", "I", "notice", "that", "Chez", "Scheme", "s", "Windows", "build", "target", "depends", "on", "nmake", "NUMBER", "This", "be", "probably", "the", "reason", "why", "msys", "NUMBER", "had", "to", "be", "launched", "from", "the", "Visual", "Studio", "prompt", "NUMBER", "On", "my", "system", "the", "Native", "Build", "Tools", "Prompt", "add", "the", "following", "directories", "to", "the", "PATH", "NUMBER", "C", "Program", "Files", "x", "NUMBER", "MSBuild", "NUMBER", "bin", "amd", "NUMBER", "NUMBER", "C", "Program", "Files", "x", "NUMBER", "Microsoft", "Visual", "Studio", "NUMBER", "VC", "BIN", "amd", "NUMBER", "NUMBER", "C", "Program", "Files", "x", "NUMBER", "Windows", "Kits", "NUMBER", "bin", "x", "NUMBER", "NUMBER", "C", "Program", "Files", "x", "NUMBER", "Windows", "Kits", "NUMBER", "bin", "x", "NUMBER", "The", "second", "entry", "be", "the", "directory", "which", "contains", "nmake", "and", "it", "be", "not", "present", "in", "my", "msys", "NUMBER", "s", "PATH", "even", "when", "it", "be", "launched", "from", "the", "Build", "Tools", "Prompt", "bash", "nmake", "bash", "nmake", "command", "not", "find", "I", "find", "the", "cause", "of", "the", "shared", "library", "error", "when", "I", "tried", "to", "execute", "nmake", "via", "absolute", "path", "bash", "C", "Program", "Files", "x", "NUMBER", "Microsoft", "Visual", "Studio", "NUMBER", "VC", "BIN", "amd", "NUMBER", "nmake", "C", "Program", "Files", "x", "NUMBER", "Microsoft", "Visual", "Studio", "NUMBER", "VC", "BIN", "amd", "NUMBER", "nmake", "NUMBER", "exe", "error", "while", "loading", "shared", "libraries", "api", "ms", "win", "crt", "math", "l", "NUMBER", "NUMBER", "NUMBER", "dll", "cannot", "open", "shared", "object", "file", "No", "such", "file", "or", "directory", "So", "my", "Windows", "build", "system", "be", "probably", "defective", "for", "some", "reason", "NUMBER", "Still", "I", "wonder", "if", "it", "be", "possible", "to", "build", "Chez", "Scheme", "without", "relying", "on", "tool", "outside", "of", "msys", "NUMBER", "Recent", "update", "LINK", "have", "rendered", "user", "configuration", "necessary", "to", "make", "msys", "NUMBER", "inherit", "the", "full", "Windows", "PATH", "To", "void", "this", "either", "launch", "start", "shell", "command", "use", "start_shell", "NUMBER", "cmd", "use", "full", "path", "or", "inside", "Windows", "directly", "set", "an", "environment", "variable", "for", "your", "user", "with", "name", "MSYS", "NUMBER", "_PATH_TYPE", "and", "value", "inherit", "NUMBER", "This", "reflects", "the", "sentiment", "expressed", "in", "msys", "NUMBER", "s", "introduction", "LINK", "NUMBER", "introduction", "When", "use", "the", "shells", "try", "to", "remove", "as", "many", "entries", "from", "PATH", "as", "you", "can", "ideally", "only", "leaving", "something", "like", "C", "Windows", "system", "NUMBER", "Mixing", "in", "program", "from", "other", "MSYS", "NUMBER", "installations", "Cygwin", "installations", "or", "compiler", "toolchains", "be", "not", "support", "and", "will", "probably", "break", "things", "in", "unexpect", "ways", "NUMBER", "Do", "not", "have", "these", "things", "in", "PATH", "when", "run", "MSYS", "NUMBER", "unless", "you", "know", "exactly", "what", "you", "re", "doing", "NUMBER", "Being", "able", "to", "simply", "execute", "pacman", "S", "chez", "scheme", "git", "would", "make", "it", "really", "easy", "for", "Windows", "users", "to", "get", "the", "bleeding", "edge", "Chez", "Scheme", "implementation", "NUMBER", "However", "that", "would", "mean", "build", "it", "as", "an", "msys", "NUMBER", "package", "NUMBER", "In", "my", "attempt", "to", "make", "Chez", "Scheme", "build", "as", "an", "msys", "NUMBER", "package", "on", "my", "machine", "I", "start", "developing", "patches", "that", "will", "create", "a", "new", "ta", "NUMBER", "msys", "NUMBER", "machine", "type", "based", "on", "ta", "NUMBER", "nt", "NUMBER", "I", "m", "not", "sure", "if", "this", "be", "the", "best", "approach", "but", "I", "get", "it", "to", "successfully", "compile", "several", "source", "file", "before", "fail", "with", "miss", "definition", "error", "NUMBER", "Hi", "matheusmoreira", "I", "ve", "succeded", "build", "chez", "with", "mingw", "NUMBER", "there", "be", "still", "some", "work", "to", "do", "but", "the", "basics", "be", "there", "NUMBER", "I", "ve", "created", "some", "new", "target", "i", "NUMBER", "mw", "ti", "NUMBER", "mw", "a", "NUMBER", "mw", "ta", "NUMBER", "mw", "NUMBER", "By", "now", "I", "ve", "finished", "only", "ti", "NUMBER", "mw", "NUMBER", "here", "be", "the", "branch", "LINK", "ovenpasta", "I", "ve", "set", "up", "a", "branch", "on", "my", "package", "repository", "LINK", "package", "commit", "NUMBER", "ded", "NUMBER", "b", "NUMBER", "abee", "NUMBER", "f", "NUMBER", "db", "NUMBER", "ff", "NUMBER", "e", "NUMBER", "da", "NUMBER", "for", "your", "version", "NUMBER", "The", "build", "still", "fail", "because", "it", "s", "trying", "to", "compile", "Chez", "Scheme", "as", "a", "Windows", "package", "NUMBER", "On", "msys", "NUMBER", "it", "should", "build", "as", "a", "POSIX", "package", "NUMBER", "bash", "Starting", "build", "NUMBER", "cd", "ti", "NUMBER", "mw", "make", "build", "cd", "c", "make", "cp", "p", "NUMBER", "NUMBER", "c", "statics", "NUMBER", "c", "statics", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "system", "NUMBER", "h", "system", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "types", "NUMBER", "h", "types", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "version", "NUMBER", "h", "version", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "externs", "NUMBER", "h", "externs", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "globals", "NUMBER", "h", "globals", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "segment", "NUMBER", "h", "segment", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "thread", "NUMBER", "h", "thread", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "sort", "NUMBER", "h", "sort", "NUMBER", "h", "cp", "p", "NUMBER", "NUMBER", "c", "segment", "NUMBER", "c", "segment", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "alloc", "NUMBER", "c", "alloc", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "symbol", "NUMBER", "c", "symbol", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "intern", "NUMBER", "c", "intern", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "gcwrapper", "NUMBER", "c", "gcwrapper", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "gc", "ocd", "NUMBER", "c", "gc", "ocd", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "gc", "NUMBER", "c", "gc", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "gc", "oce", "NUMBER", "c", "gc", "oce", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "number", "NUMBER", "c", "number", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "schsig", "NUMBER", "c", "schsig", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "io", "NUMBER", "c", "io", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "new", "io", "NUMBER", "c", "new", "io", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "print", "NUMBER", "c", "print", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "fasl", "NUMBER", "c", "fasl", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "stats", "NUMBER", "c", "stats", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "foreign", "NUMBER", "c", "foreign", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "prim", "NUMBER", "c", "prim", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "prim", "NUMBER", "c", "prim", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "flushcache", "NUMBER", "c", "flushcache", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "schlib", "NUMBER", "c", "schlib", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "thread", "NUMBER", "c", "thread", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "expeditor", "NUMBER", "c", "expeditor", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "scheme", "NUMBER", "c", "scheme", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "itest", "NUMBER", "c", "itest", "NUMBER", "c", "cp", "p", "NUMBER", "NUMBER", "c", "windows", "NUMBER", "c", "windows", "NUMBER", "c", "cd", "NUMBER", "zlib", "CFLAGS", "m", "NUMBER", "make", "f", "win", "NUMBER", "Makefile", "NUMBER", "gcc", "cp", "p", "NUMBER", "NUMBER", "c", "main", "NUMBER", "c", "main", "NUMBER", "c", "gcc", "D_FORTIFY_SOURCE", "NUMBER", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "O", "NUMBER", "D_REENTRANT", "pthread", "march", "x", "NUMBER", "NUMBER", "mtune", "generic", "O", "NUMBER", "pipe", "c", "DI", "NUMBER", "I", "NUMBER", "boot", "ti", "NUMBER", "mw", "I", "NUMBER", "zlib", "statics", "NUMBER", "c", "gcc", "D_FORTIFY_SOURCE", "NUMBER", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "O", "NUMBER", "D_REENTRANT", "pthread", "march", "x", "NUMBER", "NUMBER", "mtune", "generic", "O", "NUMBER", "pipe", "c", "DI", "NUMBER", "I", "NUMBER", "boot", "ti", "NUMBER", "mw", "I", "NUMBER", "zlib", "segment", "NUMBER", "c", "gcc", "D_FORTIFY_SOURCE", "NUMBER", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "O", "NUMBER", "D_REENTRANT", "pthread", "march", "x", "NUMBER", "NUMBER", "mtune", "generic", "O", "NUMBER", "pipe", "c", "DI", "NUMBER", "I", "NUMBER", "boot", "ti", "NUMBER", "mw", "I", "NUMBER", "zlib", "alloc", "NUMBER", "c", "gcc", "D_FORTIFY_SOURCE", "NUMBER", "m", "NUMBER", "msse", "NUMBER", "Wpointer", "arith", "Wall", "Wextra", "O", "NUMBER", "D_REENTRANT", "pthread", "march", "x", "NUMBER", "NUMBER", "mtune", "generic", "O", "NUMBER", "pipe", "c", "DI", "NUMBER", "I", "NUMBER", "boot", "ti", "NUMBER", "mw", "I", "NUMBER", "zlib", "symbol", "NUMBER", "c", "make", "NUMBER", "warning", "jobserver", "unavailable", "use", "j", "NUMBER", "Add", "to", "parent", "make", "rule", "NUMBER", "make", "NUMBER", "win", "NUMBER", "Makefile", "NUMBER", "gcc", "No", "such", "file", "or", "directory", "make", "NUMBER", "No", "rule", "to", "make", "target", "win", "NUMBER", "Makefile", "NUMBER", "gcc", "NUMBER", "Stop", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "NUMBER", "zlib", "configure", "NUMBER", "log", "Error", "NUMBER", "make", "NUMBER", "Waiting", "for", "unfinished", "jobs", "NUMBER", "In", "file", "include", "from", "system", "NUMBER", "h", "NUMBER", "NUMBER", "from", "alloc", "NUMBER", "c", "NUMBER", "externs", "NUMBER", "h", "NUMBER", "NUMBER", "fatal", "error", "direct", "NUMBER", "h", "No", "such", "file", "or", "directory", "In", "file", "include", "from", "system", "NUMBER", "h", "NUMBER", "NUMBER", "from", "segment", "NUMBER", "c", "NUMBER", "externs", "NUMBER", "h", "NUMBER", "NUMBER", "fatal", "erro", "r", "direct", "NUMBER", "h", "No", "such", "file", "or", "directory", "In", "file", "include", "from", "system", "NUMBER", "h", "NUMBER", "NUMBER", "from", "statics", "NUMBER", "c", "NUMBER", "externs", "NUMBER", "h", "NUMBER", "NUMBER", "fatal", "error", "direct", "NUMBER", "h", "No", "such", "file", "or", "directory", "In", "file", "include", "from", "system", "NUMBER", "h", "NUMBER", "NUMBER", "from", "symbol", "NUMBER", "c", "NUMBER", "externs", "NUMBER", "h", "NUMBER", "NUMBER", "fatal", "error", "direct", "NUMBER", "h", "No", "such", "file", "or", "directory", "compilation", "terminated", "NUMBER", "compilation", "terminated", "NUMBER", "compilation", "terminated", "NUMBER", "compilation", "terminated", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "symbol", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "statics", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "segment", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "alloc", "NUMBER", "o", "Error", "NUMBER", "make", "NUMBER", "Makefile", "NUMBER", "build", "Error", "NUMBER", "make", "Makefile", "NUMBER", "build", "Error", "NUMBER", "ERROR", "A", "failure", "occur", "in", "build", "NUMBER", "Aborting", "NUMBER", "yes", "I", "know", "you", "should", "use", "the", "mingw", "NUMBER", "toolchain", "from", "msys", "NUMBER", "I", "saw", "there", "be", "many", "msys", "NUMBER", "package", "compiled", "that", "way", "ovenpasta", "Success", "I", "created", "a", "mingw", "NUMBER", "version", "of", "the", "package", "LINK", "package", "commit", "a", "NUMBER", "eed", "NUMBER", "f", "NUMBER", "e", "NUMBER", "b", "NUMBER", "cd", "NUMBER", "e", "NUMBER", "c", "as", "you", "suggested", "NUMBER", "I", "test", "the", "build", "on", "the", "MINGW", "NUMBER", "shell", "and", "it", "works", "NUMBER", "It", "even", "links", "against", "the", "system", "zlib", "instead", "of", "use", "the", "submodule", "NUMBER", "I", "ll", "tidy", "up", "the", "installation", "procedure", "later", "NUMBER", "Are", "you", "planning", "on", "add", "support", "for", "the", "other", "machine", "variants", "You", "made", "more", "progress", "on", "that", "front", "than", "I", "did", "NUMBER", "Great", "Actually", "the", "thing", "need", "some", "test", "NUMBER", "I", "ll", "try", "to", "finish", "it", "this", "week", "NUMBER", "The", "actual", "variants", "will", "be", "i", "NUMBER", "mw", "a", "NUMBER", "mw", "ti", "NUMBER", "mw", "ta", "NUMBER", "mw", "NUMBER", "Anyone", "has", "ideas", "on", "the", "naming", "convention", "for", "the", "machine", "type", "I", "use", "mw", "instead", "of", "nt", "NUMBER", "Does", "it", "sound", "good", "Il", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Matheus", "Moreira", "ha", "scritto", "ovenpasta", "LINK", "Success", "I", "created", "a", "mingw", "NUMBER", "version", "of", "the", "package", "LINK", "package", "commit", "a", "NUMBER", "eed", "NUMBER", "f", "NUMBER", "e", "NUMBER", "b", "NUMBER", "cd", "NUMBER", "e", "NUMBER", "c", "as", "you", "suggested", "NUMBER", "I", "test", "the", "build", "on", "the", "MINGW", "NUMBER", "shell", "and", "it", "works", "NUMBER", "It", "even", "links", "against", "the", "system", "zlib", "instead", "of", "use", "the", "submodule", "NUMBER", "I", "ll", "tidy", "up", "the", "installation", "procedure", "later", "NUMBER", "Are", "you", "planning", "on", "add", "support", "for", "the", "other", "machine", "variants", "You", "made", "more", "progress", "on", "that", "front", "than", "I", "did", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "mw", "seems", "fine", "to", "me", "NUMBER", "I", "use", "msys", "NUMBER", "for", "my", "POSIX", "build", "because", "I", "couldn", "t", "think", "of", "a", "good", "two", "letter", "abbreviation", "for", "it", "NUMBER", "To", "track", "progress", "i", "NUMBER", "mw", "a", "NUMBER", "mw", "x", "ti", "NUMBER", "mw", "ta", "NUMBER", "mw", "Hi", "NUMBER", "after", "NUMBER", "years", "I", "ve", "finally", "enable", "also", "i", "NUMBER", "mw", "NUMBER", "Not", "that", "it", "took", "that", "much", "to", "do", "it", "NUMBER", "I", "ve", "even", "did", "a", "small", "change", "excluded", "getenv_s", "for", "the", "i", "NUMBER", "mw", "build", "to", "be", "able", "to", "run", "chez", "scheme", "even", "in", "windows", "xp", "only", "the", "unthreaded", "version", "NUMBER", "I", "could", "cross", "compile", "from", "linux", "and", "even", "run", "the", "mats", "with", "wine", "NUMBER", "There", "was", "a", "minor", "issue", "configuring", "zlib", "NUMBER", "At", "this", "point", "only", "the", "NUMBER", "bit", "version", "be", "miss", "then", "I", "could", "create", "a", "pull", "request", "be", "you", "interested", "in", "integrating", "this", "in", "master", "You", "can", "see", "the", "code", "in", "this", "branch", "LINK", "This", "fix", "a", "variety", "of", "duplicate", "articles", "the", "the", "and", "the", "like", "NUMBER", "in", "csug", "system", "NUMBER", "ex", "on", "line", "NUMBER", "the", "correction", "should", "be", "an", "the", "application", "the", "application", "not", "and", "the", "application", "NUMBER", "I", "was", "curious", "about", "how", "the", "the", "comes", "out", "david", "NUMBER", "Thanks", "I", "had", "misread", "that", "NUMBER", "Fixed", "NUMBER", "The", "test", "Program", "the", "fib", "iterative", "import", "rnrs", "define", "fib", "n", "define", "iter", "a", "b", "c", "cond", "c", "NUMBER", "b", "t", "iter", "a", "b", "a", "c", "NUMBER", "iter", "NUMBER", "NUMBER", "n", "display", "fib", "NUMBER", "Run", "with", "Chez", "Chez", "Scheme", "Version", "NUMBER", "Copyright", "NUMBER", "NUMBER", "Cisco", "Systems", "Inc", "NUMBER", "time", "scheme", "program", "fib", "NUMBER", "scm", "dev", "null", "real", "NUMBER", "m", "NUMBER", "s", "user", "NUMBER", "m", "NUMBER", "s", "sys", "NUMBER", "m", "NUMBER", "s", "Run", "with", "vicare", "Vicare", "Scheme", "version", "NUMBER", "d", "NUMBER", "NUMBER", "bit", "Build", "NUMBER", "NUMBER", "NUMBER", "Copyright", "c", "NUMBER", "NUMBER", "Abdulaziz", "Ghuloum", "and", "contributors", "Copyright", "c", "NUMBER", "NUMBER", "Marco", "Maggi", "and", "contributors", "time", "vicare", "fib", "NUMBER", "scm", "dev", "null", "real", "NUMBER", "m", "NUMBER", "s", "user", "NUMBER", "m", "NUMBER", "s", "sys", "NUMBER", "m", "NUMBER", "s", "lrwxrwxrwx", "NUMBER", "chaos", "chaos", "NUMBER", "Apr", "NUMBER", "NUMBER", "NUMBER", "petite", "scheme", "This", "be", "not", "strange", "NUMBER", "Run", "same", "program", "under", "petite", "you", "ll", "find", "that", "the", "run", "time", "be", "not", "change", "so", "much", "NUMBER", "Therefore", "it", "s", "not", "compiler", "s", "issue", "but", "runtime", "library", "s", "NUMBER", "Chez", "Scheme", "s", "bignum", "operation", "be", "indeed", "not", "as", "optimized", "as", "Vicare", "s", "which", "be", "powered", "by", "GMP", "NUMBER", "dybvig", "what", "s", "the", "reason", "not", "use", "GMP", "maybe", "because", "of", "licenses", "hyln", "NUMBER", "Thanks", "for", "point", "out", "it", "NUMBER", "I", "update", "the", "test", "program", "import", "rnrs", "NUMBER", "define", "fib", "n", "define", "iter", "a", "b", "c", "cond", "c", "NUMBER", "b", "t", "iter", "mod", "a", "b", "NUMBER", "a", "c", "NUMBER", "iter", "NUMBER", "NUMBER", "n", "display", "fib", "NUMBER", "and", "the", "output", "becames", "time", "scheme", "script", "fib", "NUMBER", "scm", "NUMBER", "real", "NUMBER", "m", "NUMBER", "s", "user", "NUMBER", "m", "NUMBER", "s", "sys", "NUMBER", "m", "NUMBER", "s", "time", "vicare", "r", "NUMBER", "rs", "script", "fib", "NUMBER", "scm", "real", "NUMBER", "m", "NUMBER", "s", "user", "NUMBER", "m", "NUMBER", "s", "sys", "NUMBER", "m", "NUMBER", "s", "I", "m", "actually", "happy", "to", "see", "issue", "relate", "to", "performance", "NUMBER", "Good", "performance", "be", "after", "all", "one", "of", "our", "primary", "goal", "NUMBER", "It", "s", "true", "that", "a", "thorough", "comparison", "would", "involve", "a", "lot", "more", "and", "more", "careful", "benchmarking", "but", "it", "s", "nice", "to", "have", "examples", "where", "we", "aren", "t", "doing", "as", "well", "as", "we", "could", "especially", "if", "it", "motivates", "contributors", "to", "submit", "fix", "NUMBER", "Using", "gmp", "would", "indeed", "speed", "up", "program", "that", "operate", "on", "large", "numbers", "particularly", "program", "that", "multiply", "and", "divide", "very", "large", "numbers", "NUMBER", "Licensing", "be", "the", "primary", "issue", "blocking", "us", "from", "use", "it", "NUMBER", "Another", "be", "that", "our", "own", "different", "representation", "of", "bignums", "be", "baked", "into", "the", "compiler", "and", "run", "time", "system", "in", "a", "couple", "of", "ways", "NUMBER", "dybvig", "Thanks", "for", "explaining", "Now", "that", "Chez", "has", "its", "own", "bignum", "system", "maybe", "it", "s", "unnecessary", "to", "do", "porting", "contribution", "for", "it", "and", "there", "s", "license", "issue", "maybe", "it", "s", "just", "need", "polishing", "if", "any", "possible", "NUMBER", "That", "s", "the", "reason", "why", "I", "ask", "NUMBER", "The", "original", "motivation", "makes", "me", "submit", "this", "issue", "be", "that", "I", "be", "suspecting", "whether", "the", "code", "release", "here", "be", "the", "same", "as", "Chez", "use", "to", "be", "blame", "me", "NUMBER", "Thanks", "to", "hyln", "NUMBER", "s", "help", "I", "finally", "realize", "that", "the", "performance", "difference", "be", "introduce", "by", "GMP", "NUMBER", "So", "i", "change", "the", "subject", "to", "the", "current", "one", "NUMBER", "If", "it", "subject", "be", "still", "inappropriate", "I", "can", "change", "it", "to", "anything", "else", "NUMBER", "But", "My", "opinion", "be", "that", "the", "issue", "be", "valid", "and", "awaits", "to", "be", "resolve", "NUMBER", "I", "think", "gmplib", "be", "LGPLv", "NUMBER", "hence", "it", "be", "compatible", "with", "apache", "NUMBER", "license", "NUMBER", "libgmp", "be", "an", "extremely", "large", "and", "complex", "body", "of", "code", "that", "would", "weigh", "down", "the", "rest", "of", "the", "system", "make", "it", "larger", "compile", "would", "take", "longer", "NUMBER", "I", "don", "t", "think", "it", "be", "necessarily", "a", "good", "idea", "to", "include", "it", "NUMBER", "Are", "you", "planning", "on", "implement", "this", "ChaosEternal", "If", "so", "I", "would", "urge", "you", "to", "consider", "other", "bignum", "libraries", "NUMBER", "Apache", "NUMBER", "licensed", "software", "can", "be", "use", "in", "LGPLv", "NUMBER", "licensed", "projects", "but", "not", "the", "other", "way", "around", "NUMBER", "For", "what", "it", "s", "worth", "the", "Scheme", "NUMBER", "library", "also", "use", "in", "the", "Chicken", "numbers", "egg", "be", "write", "in", "Scheme", "NUMBER", "Sorry", "about", "my", "comment", "NUMBER", "I", "have", "seen", "many", "biased", "and", "premature", "benchmark", "comparisons", "recently", "so", "I", "tend", "to", "be", "sensitive", "such", "things", "may", "get", "into", "the", "issue", "system", "converting", "github", "into", "a", "discussion", "forum", "It", "seems", "this", "one", "be", "sorta", "valid", "question", "about", "bignums", "NUMBER", "I", "d", "still", "suggest", "remove", "the", "word", "poor", "from", "the", "title", "because", "the", "performance", "be", "not", "poor", "as", "compared", "to", "similar", "languages", "with", "bignum", "implementations", "such", "as", "Java", "NUMBER", "Bignum", "results", "Just", "for", "interest", "I", "implement", "the", "semantically", "same", "iterative", "fib", "function", "in", "three", "languages", "Scheme", "Java", "use", "java", "s", "BigInteger", "class", "and", "Python", "NUMBER", "racket", "define", "fib", "lambda", "n", "define", "iter", "lambda", "a", "b", "n", "cond", "n", "NUMBER", "b", "else", "iter", "a", "b", "a", "n", "NUMBER", "iter", "NUMBER", "NUMBER", "n", "The", "run", "results", "be", "quite", "interesting", "NUMBER", "I", "couldn", "t", "get", "Vicare", "build", "properly", "on", "the", "Mac", "after", "fix", "several", "things", "in", "its", "build", "system", "but", "it", "be", "essentially", "just", "Ikarus", "NUMBER", "Here", "be", "the", "results", "run", "fib", "NUMBER", "on", "my", "Macbook", "Pro", "NUMBER", "Ikarus", "NUMBER", "NUMBER", "s", "Chez", "Scheme", "NUMBER", "s", "Petite", "Chez", "NUMBER", "s", "Java", "NUMBER", "NUMBER", "s", "Python", "NUMBER", "s", "So", "Chez", "s", "bignum", "performance", "be", "similar", "to", "that", "of", "Java", "NUMBER", "It", "s", "interesting", "how", "Python", "stands", "out", "in", "performance", "for", "bignums", "NUMBER", "The", "performance", "of", "bignums", "in", "Ikarus", "be", "due", "to", "GMP", "NUMBER", "I", "took", "a", "look", "at", "the", "code", "of", "GMP", "and", "there", "be", "lots", "of", "processor", "specific", "optimizations", "do", "use", "assembly", "language", "and", "fancy", "instructions", "Given", "how", "rarely", "people", "want", "super", "fast", "bignum", "arithmetic", "I", "doubt", "Chez", "Scheme", "would", "want", "to", "have", "all", "that", "nasty", "details", "in", "the", "compiler", "Recursive", "fib", "results", "But", "if", "you", "write", "a", "recursive", "implementation", "of", "fib", "racket", "define", "fib", "lambda", "n", "cond", "TAG", "NUMBER", "mins", "and", "still", "not", "finished", "Take", "a", "look", "at", "Python", "s", "performance", "and", "compare", "with", "its", "bignum", "times", "Do", "you", "want", "super", "fast", "bignum", "arithmetic", "that", "normal", "program", "rarely", "use", "and", "sacrifice", "everyday", "performance", "on", "function", "calls", "data", "structures", "closures", "After", "all", "you", "can", "still", "call", "GMP", "and", "fast", "C", "code", "for", "such", "rare", "computations", "with", "FFI", "so", "I", "don", "t", "think", "this", "be", "a", "big", "issue", "NUMBER", "yinwang", "NUMBER", "Agree", "NUMBER", "People", "often", "misunderstand", "where", "Chez", "s", "progressiveness", "lies", "so", "toy", "code", "benchmark", "seems", "popular", "However", "efficient", "numeric", "tower", "operation", "be", "also", "essential", "NUMBER", "For", "bignum", "addition", "GMP", "maybe", "wins", "on", "hardware", "specific", "optimization", "which", "be", "not", "generic", "and", "may", "not", "suitable", "for", "current", "Chez", "but", "for", "multiplication", "and", "division", "Chez", "s", "algorithm", "be", "already", "not", "desirable", "which", "can", "be", "improved", "by", "a", "wide", "margin", "in", "common", "c", "NUMBER", "There", "might", "be", "a", "way", "NUMBER", "I", "find", "that", "Ruby", "and", "Python", "both", "use", "GMP", "which", "makes", "them", "quite", "fast", "in", "this", "test", "NUMBER", "But", "Ruby", "be", "BSD", "license", "and", "they", "seem", "to", "be", "able", "to", "call", "GMP", "which", "be", "LGPL", "NUMBER", "From", "this", "line", "you", "can", "see", "that", "Ruby", "be", "use", "GMP", "LINK", "NUMBER", "L", "NUMBER", "But", "from", "doc", "ChangeLog", "NUMBER", "line", "NUMBER", "you", "can", "see", "that", "they", "remove", "all", "LGPL", "code", "from", "the", "source", "LINK", "NUMBER", "Since", "Chez", "Scheme", "be", "Apache", "license", "which", "be", "very", "similar", "to", "BSD", "I", "wonder", "if", "Chez", "Scheme", "can", "do", "the", "same", "thing", "as", "Ruby", "link", "to", "GMP", "library", "but", "not", "include", "its", "code", "NUMBER", "Just", "ask", "the", "users", "install", "GMP", "by", "themselves", "if", "they", "need", "it", "NUMBER", "That", "might", "be", "an", "option", "NUMBER", "It", "would", "require", "conversions", "from", "Chez", "Scheme", "s", "representation", "to", "GMP", "s", "and", "back", "for", "each", "call", "into", "GMP", "and", "presumably", "use", "only", "in", "cases", "where", "that", "overhead", "be", "justified", "NUMBER", "Or", "Chez", "Scheme", "s", "representation", "could", "be", "change", "to", "match", "GMP", "s", "if", "GMP", "s", "representation", "be", "part", "of", "the", "public", "interface", "and", "the", "change", "doesn", "t", "add", "undue", "overhead", "of", "some", "other", "sort", "NUMBER", "Gambit", "Scheme", "s", "Bignums", "be", "pure", "scheme", "and", "quite", "fast", "not", "as", "fast", "as", "GMP", "right", "now", "but", "it", "has", "be", "faster", "on", "certain", "operations", "for", "brief", "periods", "in", "the", "past", "NUMBER", "Maybe", "porting", "their", "algorithms", "would", "be", "better", "than", "add", "a", "dependency", "on", "GMP", "NUMBER", "I", "just", "tried", "the", "bignum", "fib", "program", "on", "Gambit", "and", "it", "s", "slower", "than", "Chez", "NUMBER", "I", "m", "not", "sure", "if", "I", "get", "the", "right", "way", "of", "run", "it", "but", "run", "both", "gsi", "fib", "NUMBER", "ss", "and", "gsc", "fib", "NUMBER", "ss", "gsi", "fib", "NUMBER", "o", "NUMBER", "get", "similar", "results", "NUMBER", "It", "takes", "at", "least", "twice", "as", "much", "time", "as", "Chez", "NUMBER", "I", "have", "run", "my", "second", "program", "with", "chicken", "scheme", "it", "cost", "around", "NUMBER", "minutes", "to", "finish", "as", "a", "compiled", "chicken", "program", "NUMBER", "You", "have", "to", "add", "some", "declarations", "to", "have", "gambit", "actually", "enable", "most", "of", "its", "optimizations", "NUMBER", "At", "minimum", "declare", "block", "standard", "bindings", "NUMBER", "It", "also", "depends", "on", "how", "you", "build", "gambit", "s", "own", "runtime", "NUMBER", "A", "micro", "benchmark", "like", "this", "might", "be", "test", "the", "allocator", "more", "than", "the", "bignum", "routines", "anyway", "NUMBER", "I", "also", "wonder", "if", "I", "enable", "Chez", "Scheme", "s", "optimizations", "properly", "NUMBER", "Any", "suggestions", "My", "only", "real", "suggestion", "be", "to", "properly", "test", "bignum", "implementations", "head", "to", "head", "it", "makes", "sense", "to", "find", "some", "real", "bignum", "benchmarks", "NUMBER", "Like", "I", "said", "above", "this", "fib", "function", "be", "properly", "more", "aaffected", "by", "the", "allocation", "and", "grabage", "collection", "policies", "than", "the", "implementation", "of", "bignum", "Aubrey", "Jaffer", "s", "note", "The", "Distribution", "of", "Integer", "Magnitudes", "in", "Polynomial", "Arithmetic", "be", "worth", "a", "read", "LINK", "Using", "a", "symbolic", "algebra", "system", "he", "examines", "the", "sizes", "of", "the", "integers", "use", "in", "the", "program", "NUMBER", "The", "conclusion", "be", "that", "it", "be", "the", "performance", "of", "small", "bignums", "that", "be", "the", "most", "important", "NUMBER", "He", "add", "The", "large", "reduction", "in", "frequency", "of", "occurrence", "versus", "bit", "length", "means", "that", "small", "improvement", "in", "asymptotic", "run", "times", "for", "exotic", "bignum", "algorithms", "would", "bring", "negligible", "benefit", "in", "run", "this", "computer", "algebra", "program", "NUMBER", "I", "have", "similar", "opinion", "the", "fib", "example", "be", "more", "like", "a", "GC", "stress", "test", "NUMBER", "Guile", "use", "libgmp", "for", "bignum", "will", "be", "faster", "for", "fib", "if", "disabled", "GC", "NUMBER", "The", "note", "given", "by", "soegaard", "reveals", "that", "Guile", "will", "do", "more", "collecting", "work", "if", "GC", "enable", "which", "seems", "the", "main", "reason", "of", "the", "loss", "NUMBER", "If", "gc", "be", "activated", "however", "guile", "performs", "the", "calculation", "within", "NUMBER", "KB", "and", "calls", "gc", "several", "times", "NUMBER", "The", "whole", "thing", "takes", "about", "NUMBER", "seconds", "I", "don", "t", "know", "the", "difference", "of", "GC", "strategy", "between", "Chez", "and", "Vicare", "yet", "NUMBER", "But", "obviously", "this", "fib", "issue", "contains", "two", "parts", "NUMBER", "operation", "efficiency", "of", "bignum", "relate", "to", "bignum", "system", "NUMBER", "alloc", "collect", "efficiency", "of", "bignum", "relate", "to", "GC", "IMO", "it", "be", "too", "early", "to", "come", "to", "a", "conclusion", "about", "the", "bottleneck", "before", "deeper", "research", "NUMBER", "Well", "I", "have", "some", "results", "after", "simple", "research", "NUMBER", "I", "was", "planning", "to", "disable", "GC", "in", "Chez", "but", "seems", "no", "option", "for", "it", "NUMBER", "Fortunately", "Chez", "provides", "useful", "function", "for", "tweaking", "GC", "NUMBER", "The", "original", "result", "be", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "The", "I", "tweaked", "these", "two", "collect", "trip", "bytes", "NUMBER", "collect", "trip", "bytes", "enlarge", "the", "allocate", "block", "each", "time", "collect", "generation", "radix", "NUMBER", "set", "to", "very", "large", "to", "avoid", "collect", "frequently", "Then", "the", "result", "be", "NUMBER", "collections", "NUMBER", "s", "elapse", "cpu", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "s", "elapse", "real", "time", "including", "NUMBER", "s", "collecting", "NUMBER", "bytes", "allocated", "including", "NUMBER", "bytes", "reclaimed", "Well", "the", "collection", "and", "the", "cost", "time", "reduce", "effectively", "but", "the", "cpu", "time", "seems", "almost", "unchanged", "NUMBER", "I", "don", "t", "know", "if", "it", "s", "the", "reasonably", "tweaking", "but", "if", "it", "s", "correct", "for", "decreasing", "GC", "s", "activity", "then", "my", "assumption", "be", "wrong", "GC", "has", "little", "effect", "on", "this", "issue", "and", "bignum", "operation", "matters", "NUMBER", "The", "fib", "test", "will", "indeed", "stress", "the", "GC", "a", "little", "but", "this", "will", "only", "make", "the", "bignum", "calculation", "time", "worse", "for", "Chez", "Scheme", "because", "Ikarus", "spends", "a", "lot", "more", "time", "in", "GC", "NUMBER", "s", "Ikarus", "vs", "NUMBER", "s", "Chez", "NUMBER", "Actually", "I", "doubt", "if", "you", "can", "do", "bignum", "benchmarks", "without", "use", "GC", "because", "bignums", "be", "allocated", "in", "the", "heap", "NUMBER", "To", "be", "sure", "what", "we", "be", "talking", "about", "this", "be", "the", "code", "define", "fib", "it", "lambda", "n", "define", "iter", "lambda", "a", "b", "n", "cond", "n", "NUMBER", "b", "else", "iter", "a", "b", "a", "n", "NUMBER", "iter", "NUMBER", "NUMBER", "n", "It", "be", "iterative", "tail", "recursive", "so", "in", "principle", "we", "could", "allocate", "all", "stuff", "on", "stack", "and", "don", "t", "really", "need", "heap", "allocations", "or", "GC", "NUMBER", "But", "GC", "do", "happen", "because", "bignums", "be", "stored", "in", "the", "heap", "NUMBER", "I", "guess", "we", "can", "put", "them", "on", "the", "stack", "with", "the", "help", "of", "escape", "analysis", "NUMBER", "Running", "fib", "it", "NUMBER", "cost", "Chez", "only", "NUMBER", "seconds", "in", "GC", "time", "thanks", "to", "the", "generational", "collector", "NUMBER", "So", "most", "of", "the", "time", "NUMBER", "s", "was", "spent", "in", "bignum", "calculations", "NUMBER", "Running", "bignum", "test", "in", "Chez", "Scheme", "NUMBER", "s", "GC", "time", "time", "display", "TAG", "time", "display", "TAG", "time", "TAG", "time", "TAG", "time", "TAG", "time", "TAG", "include", "TAG", "int", "main", "mpz_t", "a", "b", "c", "mpz_init", "a", "mpz_init", "b", "mpz_init", "c", "mpz_ui_pow_ui", "a", "NUMBER", "NUMBER", "mpz_ui_pow_ui", "b", "NUMBER", "NUMBER", "printf", "start", "n", "for", "int", "i", "NUMBER", "i", "TAG", "LINK", "The", "main", "part", "of", "the", "demo", "be", "exactly", "following", "the", "names", "in", "big_add_pos", "so", "it", "s", "easy", "to", "swap", "the", "code", "into", "Chez", "Scheme", "NUMBER", "The", "demo", "itself", "seems", "to", "be", "correct", "but", "after", "swapping", "the", "code", "into", "big_add_pos", "and", "rebuild", "Chez", "Scheme", "after", "make", "clean", "I", "get", "some", "error", "saying", "nonrecoverable", "invalid", "memory", "reference", "NUMBER", "It", "looks", "like", "a", "good", "starting", "point", "NUMBER", "I", "m", "going", "to", "look", "more", "but", "to", "make", "the", "development", "parallel", "some", "of", "you", "may", "want", "to", "try", "and", "find", "out", "how", "to", "make", "it", "work", "NUMBER", "For", "your", "convenience", "of", "offering", "help", "I", "commit", "the", "change", "to", "my", "fork", "LINK", "big", "add", "NalaGinrut", "It", "looks", "Scheme", "doesn", "t", "provide", "that", "many", "bignum", "operators", "and", "the", "open", "sourced", "Chez", "Scheme", "doesn", "t", "support", "that", "many", "architectures", "NUMBER", "I", "think", "it", "s", "worthwhile", "enough", "if", "we", "can", "just", "make", "the", "few", "operations", "fast", "under", "x", "NUMBER", "because", "that", "s", "what", "most", "people", "use", "NUMBER", "The", "operations", "on", "bignums", "that", "be", "needed", "be", "those", "listed", "in", "section", "NUMBER", "of", "R", "NUMBER", "RS", "that", "be", "meaningful", "when", "applied", "to", "exact", "integers", "namely", "inexact", "TAG", "TAG", "zero", "positive", "negative", "odd", "even", "max", "min", "div", "mod", "div", "and", "mod", "div", "NUMBER", "mod", "NUMBER", "div", "NUMBER", "and", "mod", "NUMBER", "gcd", "lcm", "expt", "number", "string", "string", "number", "NUMBER", "yinwang", "NUMBER", "I", "haven", "t", "read", "the", "code", "carefully", "but", "the", "inlined", "assembly", "code", "contains", "side", "effect", "it", "be", "generally", "to", "add", "volatile", "or", "__volatile__", "to", "avoid", "the", "compiler", "breaking", "assembly", "code", "block", "while", "optimizing", "NUMBER", "LINK", "Inline", "Assembly", "HOWTO", "NUMBER", "html", "ss", "NUMBER", "Or", "it", "may", "not", "safe", "nalaginrut", "debian", "tmp", "cc", "ba", "NUMBER", "c", "o", "ba", "nalaginrut", "debian", "tmp", "NUMBER", "ba", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "nalaginrut", "debian", "tmp", "cc", "ba", "NUMBER", "c", "o", "ba", "O", "NUMBER", "nalaginrut", "debian", "tmp", "NUMBER", "ba", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "z", "NUMBER", "NUMBER", "johnwcowan", "Maybe", "we", "don", "t", "have", "to", "optimize", "them", "all", "and", "it", "be", "necessary", "to", "do", "more", "benchmarks", "first", "NUMBER", "NalaGinrut", "Indeed", "not", "having", "__volatile__", "be", "one", "of", "the", "reasons", "that", "it", "s", "not", "right", "NUMBER", "Adding", "__volatile__", "and", "I", "see", "other", "kinds", "of", "issue", "NUMBER", "But", "it", "seems", "I", "m", "get", "closer", "to", "get", "it", "work", "NUMBER", "NalaGinrut", "yinwang", "NUMBER", "On", "an", "inline", "assembly", "block", "volatile", "basically", "means", "that", "the", "block", "has", "effect", "other", "than", "those", "explicitly", "indicated", "to", "GCC", "use", "the", "extend", "asm", "syntax", "input", "and", "output", "specifiers", "indeed", "one", "of", "the", "reasons", "for", "the", "extend", "syntax", "be", "to", "allow", "GCC", "to", "do", "CSE", "DCE", "and", "similar", "optimizations", "on", "inline", "assembly", "blocks", "NUMBER", "Writing", "asm", "volatile", "be", "basically", "giving", "up", "on", "explaining", "to", "the", "compiler", "what", "the", "assembly", "block", "do", "think", "mov", "cr", "NUMBER", "I", "don", "t", "see", "how", "this", "should", "be", "required", "here", "NUMBER", "A", "smaller", "but", "still", "probably", "excessive", "hammer", "be", "the", "memory", "output", "NUMBER", "On", "the", "other", "hand", "it", "looks", "like", "the", "function", "signature", "may", "need", "some", "restrict", "qualifiers", "i", "NUMBER", "e", "NUMBER", "the", "code", "doesn", "t", "work", "correctly", "unless", "the", "pointers", "don", "t", "alias", "each", "other", "but", "I", "ll", "leave", "that", "to", "the", "person", "that", "write", "it", "NUMBER", "If", "you", "require", "GCC", "ICC", "clang", "you", "might", "as", "well", "assume", "support", "for", "restrict", "I", "think", "NUMBER", "alex", "shpilkin", "I", "don", "t", "see", "why", "it", "s", "needed", "there", "but", "I", "get", "wrong", "results", "with", "gcc", "optimizations", "O", "NUMBER", "and", "above", "if", "there", "be", "no", "__volatile__", "NUMBER", "Maybe", "that", "s", "a", "hint", "why", "the", "code", "be", "still", "not", "correct", "NUMBER", "I", "fix", "bug", "in", "my", "code", "and", "now", "it", "can", "be", "build", "with", "Chez", "and", "produce", "correct", "results", "NUMBER", "The", "__volatile__", "can", "be", "remove", "and", "still", "produce", "correct", "results", "with", "O", "NUMBER", "NUMBER", "The", "code", "be", "here", "in", "my", "fork", "LINK", "big", "add", "It", "s", "basically", "a", "translation", "of", "Chez", "s", "original", "code", "but", "use", "ADC", "instruction", "to", "handle", "the", "carry", "NUMBER", "Unfortunately", "the", "performance", "of", "the", "assembly", "code", "be", "not", "even", "as", "good", "as", "Chez", "s", "original", "C", "code", "NUMBER", "The", "timing", "be", "about", "NUMBER", "s", "my", "change", "vs", "NUMBER", "s", "chez", "s", "original", "NUMBER", "So", "I", "m", "no", "longer", "sure", "about", "ADC", "instruction", "be", "the", "real", "reason", "that", "GMP", "be", "fast", "NUMBER", "We", "could", "do", "some", "loop", "unrolling", "and", "see", "if", "that", "helps", "NUMBER", "Slowness", "fix", "NUMBER", "That", "s", "because", "I", "use", "x", "NUMBER", "s", "loop", "instruction", "NUMBER", "Changed", "loop", "control", "to", "use", "jecxz", "and", "lea", "and", "now", "it", "s", "faster", "than", "Chez", "s", "original", "code", "although", "not", "much", "NUMBER", "s", "vs", "NUMBER", "s", "NUMBER", "I", "have", "no", "idea", "why", "loop", "instruction", "be", "so", "slow", "maybe", "just", "old", "circuit", "leftover", "in", "the", "processor", "yinwang", "NUMBER", "Indeed", "as", "Agner", "Fog", "s", "tables", "LINK", "_tables", "NUMBER", "pdf", "show", "LOOP", "which", "existed", "in", "NUMBER", "already", "be", "a", "whopping", "NUMBER", "cycles", "on", "Sandy", "Bridge", "compared", "to", "two", "cycles", "for", "JECXZ", "introduce", "in", "NUMBER", "IIRC", "NUMBER", "In", "turn", "JECXZ", "be", "not", "needed", "because", "recent", "Intel", "processors", "be", "able", "to", "fuse", "the", "CMP", "JNE", "pair", "into", "one", "microinstruction", "internally", "NUMBER", "Most", "probably", "the", "loop", "would", "benefit", "from", "unrolling", "but", "the", "degree", "of", "it", "be", "to", "be", "determined", "empirically", "preferably", "on", "benchmarks", "with", "realistic", "number", "magnitudes", "NUMBER", "Would", "the", "tail", "dominate", "Can", "we", "just", "declare", "that", "bignums", "be", "allocated", "in", "NUMBER", "x", "NUMBER", "NUMBER", "chunks", "Should", "we", "align", "to", "NUMBER", "bit", "memory", "fetch", "lines", "C", "NUMBER", "alignas", "c", "NUMBER", "alex", "shpilkin", "I", "unrolled", "the", "loops", "and", "adjusted", "the", "way", "for", "indexing", "into", "the", "arrays", "NUMBER", "Now", "the", "timing", "be", "reduced", "to", "about", "NUMBER", "s", "as", "compared", "to", "its", "original", "NUMBER", "s", "NUMBER", "It", "s", "still", "a", "little", "long", "as", "compared", "to", "Ikarus", "s", "NUMBER", "s", "NUMBER", "I", "can", "t", "use", "CMP", "JNE", "because", "CMP", "may", "change", "the", "CF", "flag", "which", "ADC", "will", "need", "NUMBER", "It", "s", "quite", "some", "tricks", "that", "it", "do", "by", "use", "LEA", "for", "addition", "into", "ECX", "and", "JECXZ", "for", "looping", "NUMBER", "The", "unrolling", "be", "do", "only", "NUMBER", "x", "NUMBER", "I", "tried", "to", "unroll", "the", "loops", "use", "NUMBER", "x", "NUMBER", "chunks", "but", "it", "didn", "t", "improve", "over", "NUMBER", "x", "NUMBER", "so", "I", "m", "currently", "keep", "it", "at", "NUMBER", "x", "just", "for", "clarity", "of", "the", "code", "NUMBER", "Some", "other", "things", "can", "be", "do", "for", "example", "use", "NUMBER", "bit", "addition", "NUMBER", "Also", "it", "needs", "some", "if", "s", "for", "targeting", "correct", "architecture", "NUMBER", "dybvig", "I", "get", "some", "endianness", "problem", "when", "trying", "to", "use", "NUMBER", "bit", "instructions", "NUMBER", "Since", "the", "NUMBER", "bit", "chunks", "of", "bignums", "be", "stored", "in", "a", "big", "endian", "way", "I", "get", "wrong", "byte", "order", "when", "use", "movq", "instruction", "of", "x", "NUMBER", "which", "assumes", "little", "endian", "NUMBER", "I", "could", "do", "my", "own", "byte", "order", "swapping", "back", "and", "forth", "but", "this", "may", "not", "be", "efficient", "NUMBER", "I", "wonder", "if", "Chez", "already", "conditionally", "handles", "the", "endianness", "regard", "bignums", "Is", "there", "an", "easy", "variable", "to", "change", "so", "can", "I", "switch", "it", "to", "NUMBER", "bit", "mode", "NalaGinrut", "ADC", "has", "nothing", "to", "do", "with", "AVX", "but", "indeed", "EADDC", "should", "be", "preserved", "for", "fallback", "NUMBER", "yinwang", "NUMBER", "Currently", "bigit_bits", "be", "always", "NUMBER", "regardless", "of", "machine", "type", "NUMBER", "I", "d", "like", "to", "discuss", "some", "design", "decisions", "here", "before", "going", "any", "further", "NUMBER", "I", "d", "prefer", "to", "use", "assembly", "source", "file", "directly", "instead", "of", "inline", "assembly", "or", "intrinsics", "which", "be", "not", "portable", "e", "NUMBER", "g", "NUMBER", "x", "NUMBER", "_", "NUMBER", "inline", "assembly", "be", "not", "available", "in", "msvc", "stable", "depends", "on", "compiler", "behavior", "or", "optimal", "e", "NUMBER", "g", "NUMBER", "adc", "intrinsics", "be", "not", "well", "optimized", "NUMBER", "We", "can", "create", "a", "folder", "call", "a", "and", "put", "assembly", "code", "into", "different", "folders", "distinguished", "by", "machine", "types", "NUMBER", "In", "c", "sources", "we", "can", "use", "ifdefs", "to", "tell", "whether", "a", "function", "be", "implement", "in", "asm", "or", "c", "NUMBER", "hyln", "NUMBER", "Indeed", "inline", "assembly", "be", "not", "as", "good", "as", "separate", "assembly", "file", "NUMBER", "My", "implementation", "can", "be", "considered", "a", "proof", "of", "concept", "that", "ADC", "can", "run", "faster", "NUMBER", "GCC", "s", "inline", "assembly", "be", "also", "quirky", "to", "get", "right", "and", "be", "thus", "just", "for", "small", "snippets", "NUMBER", "It", "s", "better", "to", "use", "a", "portable", "assembly", "language", "line", "NASM", "to", "write", "those", "NUMBER", "hyln", "NUMBER", "I", "thought", "we", "may", "choose", "AVX", "for", "bignum", "but", "seems", "it", "s", "more", "inconvenient", "than", "ADC", "NUMBER", "And", "libgmp", "proves", "ADC", "be", "enough", "NUMBER", "My", "bad", "English", "NUMBER", "I", "agree", "with", "you", "to", "create", "folder", "for", "assembly", "code", "NUMBER", "But", "maybe", "we", "could", "find", "better", "way", "to", "optimize", "the", "current", "prove", "of", "concept", "first", "NUMBER", "It", "be", "not", "as", "fast", "as", "expected", "NUMBER", "NalaGinrut", "You", "be", "right", "NUMBER", "My", "code", "be", "still", "not", "as", "fast", "as", "GMP", "s", "although", "they", "look", "very", "similar", "so", "you", "may", "want", "to", "play", "with", "it", "and", "see", "if", "there", "be", "easy", "way", "to", "improve", "NUMBER", "I", "also", "unrolled", "it", "NUMBER", "and", "NUMBER", "times", "but", "it", "didn", "t", "improve", "the", "performance", "NUMBER", "I", "don", "t", "know", "yet", "what", "other", "tricks", "be", "in", "GMP", "for", "addition", "NUMBER", "yinwang", "NUMBER", "After", "a", "quick", "look", "at", "number", "NUMBER", "c", "I", "find", "that", "maybe", "the", "copy", "operation", "of", "copy_normalize", "be", "not", "optimized", "NUMBER", "Tried", "to", "use", "ROL", "and", "ROR", "for", "switching", "endians", "but", "unfortunately", "they", "change", "the", "carry", "flag", "CF", "NUMBER", "Keep", "in", "mind", "the", "trick", "with", "ADC", "lies", "in", "that", "you", "can", "t", "use", "instructions", "that", "can", "change", "the", "CF", "flag", "between", "the", "ADCs", "NUMBER", "So", "it", "seems", "we", "really", "need", "to", "store", "the", "bignum", "in", "different", "order", "with", "NUMBER", "bit", "machines", "NUMBER", "akeep", "After", "some", "investigations", "into", "Ikarus", "I", "think", "the", "DCE", "issue", "be", "actually", "a", "loop", "invariant", "hoisting", "one", "NUMBER", "Actually", "I", "don", "t", "see", "where", "this", "code", "be", "relate", "to", "DCE", "NUMBER", "yinwang", "NUMBER", "It", "has", "no", "return", "values", "or", "side", "effect", "NUMBER", "hyln", "NUMBER", "Are", "we", "talking", "about", "the", "same", "piece", "of", "code", "define", "fib", "it", "lambda", "n", "define", "iter", "lambda", "a", "b", "n", "cond", "n", "NUMBER", "b", "else", "iter", "a", "b", "a", "n", "NUMBER", "iter", "NUMBER", "NUMBER", "n", "time", "display", "TAG", "TAG", "so", "that", "I", "can", "make", "you", "an", "op", "NUMBER", "That", "barfed", "NUMBER", "It", "s", "msg", "nickserv", "register", "password", "email", "address", "This", "be", "on", "Linux", "with", "gcc", "NUMBER", "the", "same", "conditions", "as", "issue", "NUMBER", "The", "contains", "of", "a", "NUMBER", "le", "mats", "summary", "be", "o", "NUMBER", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "spi", "t", "p", "t", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "spi", "t", "p", "t", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "eval", "interpret", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "eval", "interpret", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "ehc", "t", "eoc", "f", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "ehc", "t", "eval", "interpret", "NUMBER", "a", "NUMBER", "NUMBER", "NUMBER", "mo", "Bug", "in", "mat", "filesystem", "operations", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "NUMBER", "ms", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "I", "can", "supply", "additional", "file", "if", "needed", "NUMBER", "I", "have", "only", "data", "NUMBER", "mo", "bug", "NUMBER", "Here", "s", "some", "information", "Linux", "debian", "NUMBER", "NUMBER", "SMP", "PREEMPT", "Mon", "Apr", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "CST", "NUMBER", "x", "NUMBER", "_", "NUMBER", "GNU", "Linux", "gcc", "Debian", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "The", "NUMBER", "ms", "bug", "likely", "occur", "because", "of", "file", "permissions", "that", "be", "different", "from", "our", "test", "environment", "and", "the", "mat", "will", "need", "to", "be", "remove", "or", "replaced", "NUMBER", "The", "date", "NUMBER", "ms", "bug", "be", "presumably", "cause", "by", "differences", "in", "the", "C", "library", "asctime_r", "function", "NUMBER", "I", "d", "be", "interested", "in", "knowing", "what", "write", "time", "utc", "date", "make", "time", "time", "utc", "NUMBER", "NUMBER", "prints", "on", "your", "systems", "to", "help", "determine", "whether", "there", "be", "some", "pattern", "we", "could", "be", "checking", "in", "place", "of", "the", "specific", "one", "that", "works", "in", "our", "test", "environment", "NUMBER", "On", "my", "mac", "this", "prints", "with", "output", "to", "string", "lambda", "write", "time", "utc", "date", "make", "time", "time", "utc", "NUMBER", "NUMBER", "TAG", "the", "value", "compared", "with", "in", "the", "test", "be", "TAG", "It", "seems", "that", "it", "has", "an", "offset", "of", "NUMBER", "hours", "NUMBER", "I", "be", "in", "timezone", "NUMBER", "Similar", "issue", "in", "my", "mats", "test", "also", "but", "restricted", "to", "line", "NUMBER", "date", "time", "output", "TAG", "I", "be", "pacific", "time", "as", "well", "OS", "X", "NUMBER", "A", "NUMBER", "o", "NUMBER", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "spi", "t", "p", "t", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "spi", "t", "p", "t", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "eval", "interpret", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "eval", "interpret", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "cp", "NUMBER", "t", "eval", "interpret", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "ehc", "t", "eoc", "f", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "o", "NUMBER", "ehc", "t", "eval", "interpret", "NUMBER", "a", "NUMBER", "date", "NUMBER", "mo", "Bug", "in", "mat", "time", "date", "printing", "clause", "NUMBER", "at", "line", "NUMBER", "char", "NUMBER", "of", "date", "NUMBER", "ms", "write", "time", "utc", "date", "make", "time", "time", "utc", "NUMBER", "NUMBER", "TAG", "Here", "s", "what", "I", "see", "write", "time", "utc", "date", "make", "time", "time", "utc", "NUMBER", "NUMBER", "TAG", "In", "case", "it", "be", "useful", "here", "be", "the", "output", "of", "timedatectl", "Local", "time", "Wed", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "PDT", "Universal", "time", "Wed", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "UTC", "RTC", "time", "n", "a", "Time", "zone", "America", "Los_Angeles", "PDT", "NUMBER", "Network", "time", "on", "yes", "NTP", "synchronized", "yes", "RTC", "in", "local", "TZ", "no", "The", "TZ", "environment", "variable", "be", "not", "set", "NUMBER", "And", "here", "s", "my", "uname", "a", "output", "Linux", "vrici", "NUMBER", "digitalkingdom", "NUMBER", "org", "NUMBER", "NUMBER", "rc", "NUMBER", "git", "NUMBER", "fc", "NUMBER", "x", "NUMBER", "_", "NUMBER", "NUMBER", "SMP", "Mon", "Apr", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "UTC", "NUMBER", "x", "NUMBER", "_", "NUMBER", "x", "NUMBER", "_", "NUMBER", "x", "NUMBER", "_", "NUMBER", "GNU", "Linux", "I", "have", "the", "date", "test", "fail", "on", "openbsd", "too", "with", "output", "to", "string", "lambda", "write", "time", "utc", "date", "make", "time", "time", "utc", "NUMBER", "NUMBER", "TAG", "I", "commit", "a", "change", "that", "should", "address", "the", "NUMBER", "ms", "problem", "NUMBER", "Looks", "like", "Andy", "be", "work", "on", "the", "date", "NUMBER", "ms", "one", "NUMBER", "akeep", "I", "don", "t", "think", "this", "be", "exactly", "what", "you", "be", "ask", "for", "but", "if", "I", "change", "my", "time", "zone", "to", "EDT", "I", "be", "usually", "in", "MDT", "the", "error", "goes", "away", "NUMBER"], "text_count": [0, 28293, 5935, 2877, 2019, 185, 2113, 14, 127, 3047, 4764, 7649, 3970, 2634, 3498, 1137, 0, 0, 0, 0, 8239, 2667, 1679, 866, 1887, 1527, 0, 0, 0, 0, 17422, 11508, 6151, 518, 3630, 864, 0, 0, 0, 0, 20442, 161, 7733, 6634, 7527, 0, 0, 0, 0, 0, 6737, 2306, 3594, 1276, 2180, 1071, 2319, 0, 0, 0, 14793, 837, 12134, 959, 0, 0, 0, 0, 0, 0, 11760, 1188, 7568, 3410, 2395, 0, 0, 0, 0, 0, 17979, 8029, 1579, 7442, 939, 1047, 0, 0, 0, 0, 1182, 5992, 496, 0, 0, 0, 0, 0, 0, 0, 14811, 2847, 8798, 3720, 0, 0, 0, 0, 0, 0, 32099, 62295, 772, 2632, 609, 1072, 0, 0, 0, 0, 82060, 556, 61257, 885, 15838, 17292]}]