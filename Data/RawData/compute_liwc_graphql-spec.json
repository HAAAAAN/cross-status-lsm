[{"repo": "graphql-spec", "type": "elite", "title": "", "number of text": 318, "text": "  AFAIK, the spec doesn't prevent `null` or `{}` and there is only one relevant place on how `variables` are handled:\r\nhttp://facebook.github.io/graphql/June2018/#CoerceVariableValues()\r\n\r\nSo de jure even `{ foo: \"bar\" }` is valid.\r\n  @iamclaytonray GraphQL already supports full CommonMark (a dialect of Markdown):\r\nhttp://facebook.github.io/graphql/June2018/#sec-Descriptions\r\n>To allow GraphQL service designers to easily publish documentation alongside the capabilities of a GraphQL service, GraphQL descriptions are defined using the Markdown syntax (as specified by CommonMark).\r\n\r\nNote: that SDL syntax was changed during preparation for public release so in final version you need to use description strings instead of comments and now comments are just comments:\r\n```graphql\r\nenum MessageStatus {\r\n  \"If a message could not successfully be delivered.\"\r\n  Failed\r\n  \"If a message was successfully delivered but _has not been_ read by the other user(s).\"\r\n  Delivered\r\n  # TODO: add write\r\n  \"If a message was successfully delivered and _has been_ read by the other user(s).\"\r\n  Read\r\n}\r\n```  Changed from:\r\n> or integer (such as `4`) input value\r\n\r\nto\r\n> or non-negative integer (such as `0` or `4`) input value @OlegIlyenko Looks like negative IDs is a thing:\r\nhttps://dba.stackexchange.com/questions/2895/what-are-negative-keys-used-for\r\n\r\nIn this case, I think the specification should have an example of such conversion to show that this is intentional behavior.\r\nI changed PR to:\r\n> or integer (such as `4` or `-4`) input value  @liweinan0423 Because `A-Za-z0-9_` is the only characters that supported in all environments.\r\nFor example, the majority of programming languages don't support `-` inside property names so it will make code/typings generation harder.\r\n @liweinan0423 Using dash definitely makes sense for locale names but off the top of my head I can't come up with any other domain where the dash is an essential part of terminology.\r\nAt the same time it's very easy to give an example of some other domain where other symbols are essential, e.g. MIME types as field name also make sense:\r\n```\r\ndata {\r\n  \"application/json\": \"data in JSON format\",\r\n  \"application/xml\":  \"data in XML format\r\n}\r\n```\r\nSo real question here should we support bigger subset of ASCII range or not?\r\n\r\nAnd I personally think it's not worth added complexity and we should stick with biggest common denominator in form of `/[_A-Za-z][_0-9A-Za-z]*/`. @liweinan0423 Can I close this issue?  Given that Mutations and Subscriptions only comprise a couple sections of the spec, I'm not sure removing them into separate spec document accomplishes anything of value.\r\n\r\nAre you concerned that your GraphQL implementation is not spec compliant because it does not include mutations or subscriptions? http://facebook.github.io/graphql/June2018/#sec-Root-Operation-Types claims that Mutation and Subscription types are not required in a GraphQL service This might also be a challenge since aspects of GraphQL like Introspection make reference to mutation and subscription root types - presumably any service, even if only supporting queries, would need to respond well to introspection queries that reference these I\u2019m also a big fan of PEP and the additive nature of spec proposals as they gain adoption. In fact, we\u2019ve been following a related process with RFC documents. Subscriptions went through this process and was an RFC only for almost 2 years before being added to the spec (with minimal requirements). Another good example is the GraphQLHTTP spec which is intended to forever be a separate document.\r\n\r\n\r\nWhat I\u2019m more skeptical about is backwards breaking changes that *remove* functionality from the current spec into separate documents without a highly compelling reason to do so. \r\n\r\nIn this case what I mean by highly compelling is that it should unlock the ability to do something that is currently not possible today. \r\n\r\nIf it does not do at least that then we\u2019re looking at pure cost (breaking changes, harder to read spec, more opportunity for ambiguity) with only theoretical benefit of creating \u201cmodular concepts\u201d. \r\n\r\nI\u2019m not excited to put in the work for something that is net-costly instead of net-beneficial.    This was an intentional decision to balance between expressiveness and complexity. While the subject of your proposal is absolutely true: we cannot communicate the difference between optionality and nullability in input types, our previous discussions have determined that this is a reasonable cost for the benefit of avoiding the additional syntax you've suggested and avoiding multiplication of possible states an input object can be in. In doing so we've left this sort of additional behavior of how to treat scenarios where \"required null\" or \"optional nonnull\" up to the much fewer services which require these.\r\n\r\nIn your particular scenario, I think you can add exactly what you're suggesting to your server, especially since you say that all mutations behave as full overwrite. I would suggest adding additional validation rules or throwing additional coercion errors relevant to the types where the ambiguity could result in unexpected results.  > Maybe you have some good examples of non-standard directives that are widely used and either need to be unique or non-unique? (would be interesting to compare both cases).\r\n\r\n@OlegIlyenko In majority of cases directives are used to attach additional metadata to the SDL entity like: `@scopes`, [@cacheControl](https://www.apollographql.com/docs/engine/caching.html#hints-to-schema), etc.\r\nSo if you makes such directive non unique by default it could be breaking change for some implementations.\r\n\r\nA few examples of unique directives from my own tools would be: `@fake` from `graphql-faker` and `@_` from `graphql-lodash`.\r\n\r\n> I think the reason I used unique directive ... syntax is because it makes presence of an additional constraint on directives explicit.\r\n\r\nIf we decide to add `unique` prefix to any other top-level keyword it will require non-trivial changes to parser and make parser more complex overall.\r\n\r\n> For me personally, it is more intuitive to assume that without any explicitly stated information, the entity is unconstrained. SQL DDL is one example of this approach. As well as the GraphQL itself, where you need to put an explicit ! to add extra not-null constraint on the field.\r\n\r\nIn case of describing constrains on data I totally agree with you that everything should be unconstrained by default.\r\nBut directives are intended as GraphQL language extensions and in language specification keywords/constructs are unique by default.\r\n\r\n> Also in my experience, directives are very rarely authored in the SDL.\r\n\r\nNot sure about other language but in JS it looks like defining directives in SDL is quite popular approach:\r\nhttps://www.apollographql.com/docs/graphql-tools/schema-directives.html#Uppercasing-strings\r\nA few more examples from my own source code:\r\nhttps://github.com/APIs-guru/graphql-faker/blob/master/src/fake_definition.graphql#L192\r\nhttps://github.com/APIs-guru/graphql-lodash/blob/master/src/lodash_idl.ts#L101 @mjmahone I like `repeatable` \ud83d\udc4d \r\n```graphql\r\ndirective @example repeatable on OBJECT | INTERFACE\r\n```\r\n\r\n> I also wonder if, instead of adding a language keyword, we should instead allow directives on directive definitions\r\n\r\nIt creates one more source of recursion in GraphQL schema and requires to add additional validation rules.\r\nI think to keep specification simple and straightforward we need to add such features only based on real-life use cases.\r\n\r\nAs for `@repeatable` in particular, I think it better suited for keyword because:\r\n1. it doesn't accept arguments\r\n1. in the position that you propose it will look strange for directives without arguments `directive @test @repeatable on QUERY`\r\n1. it only applies to directive definitions and that means `@repetable` became reserved for all other locations. \r\n\r\nThis why I think `@deprecate` make sense as a directive but it better to specify `repeatable` as a keyword.  Thankss fore the kareful reed  Thanks for putting this up - I'll add it as an agenda item for next week's WG session since it's notable  Hey all, sorry for the delayed response. I was actually about to add a comment with support and work on the merge, but I see @mjmahone already pushed forward - we had spoken about a plan for this PR offline first.\r\n\r\nSince a primary goal in future editions of the spec is to limit breaking previously spec-complaint implementations, and that this particular change caused issue with both Facebook's implementation and @OlegIlyenko's - I think that is merit enough to roll back the change. I also think there are likely to be cases during active development of a GraphQL API where an interface is used as a placeholder describing future types which do not yet exist - a legitimate scenario where 0 implementing types could still result in a working schema.\r\n\r\nBecause we've been talking in the WG sessions about cutting the spec release, testing release candidates of GraphQL.js was a priority which helped expose this issue - so merging this in an expedited way makes sense, we'd rather not introduce a new rule in the next released spec we knew was problematic.\r\n\r\nAdditionally, we knew that some variation of this rule might still make sense and wanted to leave open discussion around re-introducing the rule to provide value while limiting the identified costs. That was the reason for opening #460   schema definition language is synonymous and fine to continue to use (as is SDL) when discussing - but type system definition language was more specifically correct relative to the rest of the document's use of the terminology\r\n\r\nI don't think we need an acronym / abbreviation since we don't use abbreviations within the spec - I think talking about it as SDL in discussion is still clear  Agreed  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fgraphql%20%23453). Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Great edit, thank you!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fgraphql%20%23451). Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Great catch and fix! Thanks for your help  I think we mention this elsewhere, but it's hard to find a consistent reference to link to which I think we should improve  GraphQL intentionally does not require any specific serialization or transport. JSON is preferred, but explicitly not required (http://facebook.github.io/graphql/October2016/#sec-Serialization-Format) so any existing binary protocol can be used with GraphQL. There are plenty in the gRPC space that would work well alongside GraphQL for the use cases you're describing.\r\n\r\nThere are no plans for the GraphQL spec to explicitly specify any specific binary protocol  I'd prefer to avoid the type of a field changing based on how its queried. That greatly limits the power available to tools, especially smart clients like Relay and Apollo which store normalized results, such that both types could be encountered in a single application at the same point.\r\n\r\nI think this also introduces a serious foot-gun where a query that previously would clearly be a validation error now returns a value, however its not clear that the user intended on the new usage and may result in a hard-to-spot error in their software.\r\n\r\nAn alternative to this which should work today is simply to provide a field like this (maybe without the underscores, which are system-reserved) and explicitly query it:\r\n\r\n```graphql\r\ntype DateTimeObject {\r\n    year: Int!\r\n    month: Int!\r\n    # ...\r\n    ago: String!\r\n    format(format: String!): String!\r\n    toScalar: DateTime!\r\n}\r\n```\r\n\r\n### As Scalar\r\n\r\n```graphql\r\n{\r\n    date { \r\n      toScalar \r\n    }\r\n}\r\n```\r\n\r\n```json\r\n{\r\n    \"date\": {\r\n      \"toScalar\": \"2018-04-28T04:53:23+03:00\"\r\n    }\r\n}\r\n```  While I appreciate and agree with your suggestion, the `@skip` directive has been in the spec for a number of years and the cost of changing this for all existing implementors is too high.\r\n\r\nYou're always more than welcome to include additional directives with whatever behavior you like, including aliases for the specified directives  This adds new grammar to the GraphQL SDL:\r\n\r\n```graphql\r\nextend schema {\r\n  mutation: MutationType\r\n}\r\n```\r\n\r\nThis feels like the missing piece of the type system extension framework. In addition to extending types in a type system, the top level schema should be extendable as well. That's certainly something we could reconsider. I remember when applying that rule we did so intentionally to carve out the space for future exploration. Would you mind creating a new issue about that topic where we can discuss further? Leaving this open for review for a shorter period of time - I hope this is an easy win :) Thanks for the online and offline feedback everyone!  Merging into #411   Sorry, I'm not sure what you're suggesting. Perhaps you have the wrong repo? \r\n\r\nI'm closing this issue, but if you like please reopen with a suggested specification text change?  Thanks for accounting for this schema validation addition!  Thanks for spotting this  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fgraphql%20%23421). Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thanks for the careful eye and edit!  GraphQL is on a different layer of abstraction from message delivery. GraphQL only represents the request for and sequence of a message stream.\r\n\r\nYou might layer GraphQL subscriptions over Kafka or some other protocol-level service to get the QoS you need.  @eapache - great points. I actually think what I now have here is very close to what I would propose in a \"from scratch\" design.\r\n\r\nThe execution behavior is almost exactly as I would expect it in a from-scratch design as it respects explicit values over default values in the same way as other programming languages. The only difference I might have expected in a from-scratch design is to be even more trusting of variable values in `CoerceArgumentValues()`, where this proposal explicitly checks for null values and throws field errors. This isn't trading on correctness however, so I'm not concerned at all about that extra check. This is still *technically* a \"breaking change\" by the definition that execution behavior of existing queries will now be different. Previously null values could be provided to non-null typed arguments; after this proposal this is an error. I think it's pretty uncontroversial to explain this as a bug fix.\r\n\r\nThe validation behavior is really where we've made specific considerations to avoid breaking existing queries, however this proposal is still very close to what I would propose in a \"from scratch\" design. \r\n\r\nThis proposal makes 3 important changes to query validation:\r\n\r\n* Removal of the \"Variable Default Value Is Allowed\" rule. I argue this should have been removed when we introduced explicit null values with the expectation that they supersede default values. This rule originally sought to prevent \"dead code\" style misunderstandings, however in the present context it does not succeed at that and instead it prevents real possibilities. In a \"from scratch\" design I would include this change exactly as is.\r\n\r\n* Changes the definition of \"required\" arguments and input fields. Previously a non-null type meant that an argument or input field was required to be provided. However because arguments may have default values, this limits their expressivity in the same was the previous rule. This proposal changes this such that non-null typed arguments/input-fields are only considered required if they *also* do not have a default value. This, again, I would propose unchanged in a \"from scratch\" design.\r\n\r\n* Change the \"Variable Usages are Allowed\" rule tweaking the rules for treating nullable variables as non-null for the sake of determining where they're allowed to be used. This is *not* what I would do in a from-scratch design. Instead I would propose removing the ability for nullable variables to flow into non-null arguments *at all*. Where the previous two changes expanded the possible set of queries that pass validation, this change would have restricted that possible set. This is also, unfortunately, a very common pattern so that restriction could be a very costly breaking change. However, I definitely agree that enforcing that strictness for newly produced GraphQL services would be valuable! \r\n\r\nI will look at editing this to both make it more clear where the caveat for existing systems is while making it possible (or even encouraged) for new systems not to adopt that caveat.\r\n\r\n@eapache are there other differences from the current state of this PR that you would consider approaching differently in a from-scratch design? @eapache - I just updated this with your feedback incorporated. I'm glad we agree on the ideal outcome of this proposal.\r\n\r\nMy last update is one step further towards the idealized \"from scratch\" proposal, this makes it more explicitly clear that changing the effective type of a variable definition is only relevant when supporting legacy clients and suggests that new services should not use this behavior. I like that this balances a clear description of how this rule should work for existing services along with a stricter and therefore safer future path for new services.\r\n\r\nI also just updated https://github.com/graphql/graphql-js/pull/1274 to include this and make this a breaking change by default while providing an API for using this legacy behavior.\r\n\r\nI'd love a last look by anyone else interested Updating this a bit. I'm still trying to convince myself that the breaking change is worth doing. I realized that it also has a side effect of not allowing an optional variable to be provided to a optional non-null argument.\r\n\r\n```graphql\r\nquery Example($var: Int!) {\r\n  field(arg: $var)\r\n}\r\n\r\ntype Query {\r\n  field(arg: Int! = 0): Int\r\n}\r\n```\r\n\r\nWhile the above query is valid, it is invalid to not provide a runtime value for `$var`, even though arg supplies a default value. Perhaps this is just an acceptable cost.\r\n\r\nAn alternative, (which I'm also not sure about) is allowing nullable (optional) variables to flow into non-null optional positions, while still throwing at runtime for explicitly provided null values (already included in this proposal).\r\n\r\nFor example, this is currently invalid but would become valid in the alternative proposal:\r\n\r\n```graphql\r\nquery Example($var: Int) { # nullable\r\n  field(arg: $var) # non-null but optional\r\n}\r\n\r\ntype Query {\r\n  field(arg: Int! = 0): Int\r\n}\r\n```\r\n\r\nIn that case, omitting `$var` at runtime could just use `arg`'s default value.\r\n\r\nThoughts on this? After discussing this in depth with @dschafer at a whiteboard - we've talked ourselves out of any breaking change - I think that having a fork in the expected behavior of validation rules is just too easy to get wrong, liable to cause issues during deployment, and could create a bifurcation of tooling environments. We came up with mitigation strategies for Facebook's codebases and APIs, however also agreed that public APIs like Github would be much much more challenging to solve for.\r\n\r\nEven though the behavior is not an ideal \"from scratch\" - I think that it's worth avoiding the breaking change. I still think the spec should call out this potential issue directly in a non-normative note for clarity. I've just updated the description to mirror the current change. I believe this is ready to merge and will first wait for a bit for others to review and comment. Thanks for the reviews, @mike-marcacci and @IvanGoncharov.\r\n\r\n@IvanGoncharov I think there are too many critical issues with the versioning approach you're suggesting. Beyond being fundamentally inconsistent with one of GraphQL's core values to not need versioning, the introduction of versions causes even more breaking changes that we're trying to avoid.\r\n\r\n>  Currently, all GraphQL clients send GraphQL request document inside query field. But ExecuteRequest names the same parameter document\r\n\r\nThis seems like it is an issue not for the spec but for HTTP services, and is just a naming convention so probably not a viable mechanism for specification algorithms. The spec document should be pretty consistent in referring to \"document\" and \"operation\" terms already.\r\n\r\n> I also think we should use an integer for version field and increment it only when breaking change is made.\r\n\r\nI would much prefer to not make breaking changes at all - I still believe our goal for evolving the GraphQL specification should be to arrive at a stable base and project confidence and stability. An incrementing integer version implies that there will be a continuous stream of breaking changes. Also, having worked on API surfaces (including public facing) that have dealt with breaking changes in the past, incrementing integer versions do not adequately capture scenarios where a client has adopted support for one breaking change while it has not yet adopted support for another - the fixed ordering of the version numbers forces an adoption curve that does not align with client expectation or capability. I'd like to strongly avoid making the same mistake with GraphQL.\r\n\r\n@mike-marcacci I know you had similar ideas:\r\n\r\n> This is probably unavoidable, and makes me think that there should be a \"graphql version\" or programmatically readable \"feature set\" (as discussed in the WG meeting) supplied in the result of an introspection query.\r\n\r\nI think these are interesting ideas, but I'd love to avoid expanding the surface area of this proposal since I believe it is in a final reviewable state. I believe that finding consensus on programmable feature set support in a client-server communication is going to be quite challenging and require a lot of exploration. Just the two proposals you two offered are very different.\r\n\r\nMy hope is that we can arrive at consensus around this proposal in its current form. I'm not comfortable proposing a change which breaks the validation of existing queries. Thanks for the reviews and offline conversations to everyone involves. Super pleased with how this ended up.  Closing this aging issue.\r\n\r\nTo answer the question directly - GraphQL does not support conditions like this. Multiple booleans may be a fit for your use case  Sorry for letting this sit, I'm closing aging issues.\r\n\r\nI'm not sure this proposal will gain much traction because it seems to be introducing a lot of new ideas and concepts for which there are existing concepts. In general GraphQL services philosophically avoid the Mutative-CRUD model in favor of an action-oriented data access pattern, which this proposal seems to be counter to. \r\n\r\nThere are a lot of ideas here. If you were to formalize a proposal, I suggest starting small with an incremental change which provides value at a lower change cost  This does a last pass over the subscriptions specification to clean up some ambiguities and crisp up some language.\r\n\r\nTwo important things to take note of:\r\n\r\n1. The `CreateSourceEventStream` algo was underspecified and did not articulate how fields should be collected from the selection set. This makes it clear that `CollectFields` is used, just like any other selection set. It also did not describe behavior when executing an invalid query, this adds that a query-level error should be thrown.\r\n\r\n2. The Subscription Operation validation is similarly underspecified, and does not describe what should happen if a fragment spread is found as the first selection in a selection set. This clarifies that it is *fields* that exactly one is expected, rather than selections. Correct - this limitation solves a whole class of ambiguities regarding merging event streams. We've found in practice it's almost always preferable to have multiple open subscriptions rather than a single subscription that attempts to merge streams Yeah - we could lift this restriction in the future should crisp semantics become more clear and the value outweigh the cost of the potential for confusion. At Facebook we faced some serious roadblocks to supporting multiple subscription root fields for this and other reasons - so felt it was best to specify a more limited functionality set out of the gates  GraphQL errors encode exceptional scenarios - like a service being down or some other internal failure. Errors which are part of the API domain should be captured within that domain.\r\n\r\nOf the two suggestions you make here, I strongly prefer the first one. It is much simpler, the behavior is clear to any reader, and it requires no new changes to GraphQL. However the second accomplishes the same task but requires new syntax and behavior and is less clear how \"fields\" on errors would be selected.  This feels like an implementation detail, and not something that would affect the GraphQL specification. I'm going to close this issue, but feel free to open issues on repos for GraphQL server implementations to further the conversation.\r\n\r\nThough to give early feedback, I'm not sure I see the value offsetting the complexity cost. \r\n\r\n```\r\nargs: {\r\n  limit: {\r\n    type: GraphQLInt,\r\n    prepare: (arg) => {\r\n      return arg + 1;\r\n    },\r\n  },\r\n},\r\nresolve: (obj, args) => {\r\n  // args.limit is incremented by 1\r\n}\r\n```\r\n\r\nSeems like strictly more and more complicated code than\r\n\r\n```\r\nargs: {\r\n  limit: {type: GraphQLInt},\r\n},\r\nresolve: (obj, args) => {\r\n  const limit = args.limit + 1;\r\n}\r\n```  I think the initial intent was for \"query errors\" to be errors having to do with the query itself (syntax or validation) while \"field errors\" were errors encountered while evaluating a field. Though a good clarification this PR makes is that query errors are not just syntax and validation but also variable coercion  Excellent point, @stubailo - I think perhaps \"document\" error might be a better fit. I think at Facebook we've also called these \"fatal error\" since they result in no execution result (no `data` key in response)\r\n\r\nIn terms of clarifying the spec, I definitely agree that defining the different kinds of errors is important (and could lead to error codes proposals in the future) but what is most important in this immediate context is the behavioral differences between them. In that sense there are really 2 behaviorally different errors - those that result in no `data` key, and those that are local to one field in the response. Merging since this is a pretty straightforward editing suggestion that's not changing anything - I still agree that the overall language around errors could be more clear  \"A response to a GraphQL operation must be a map.\" does not imply order (otherwise it would say \"ordered map\") - I agree that the \"first\" and \"next\" terminology is more ambiguous than helpful in this context, though I like declaring the order via the order of paragraphs.\r\n\r\nI think we can add a more explicit phrase about ordering errors first in a formatted output as a convenience  I'm going to close this issue since it sounds like you got answers, @iamclaytonray \r\n\r\nThe example query you wrote at the top of this issue is very much fulfillable today. I don't see any missing features to fulfill such a use case that the spec does not provide for. The `Version` type you propose could easily be a custom scalar type, or more often I've seen versions for resources like this be represented as incrementing `Int` values.  Please open specific bug issues like this on gatsby's github   I'm going to close this since it sounds like there's consensus that the separate proposal could would cover this use case.\r\n\r\nHowever in general I'm less convinced by the desire to add utilities to GraphQL or GraphiQL to encourage CRUD style mutations. In my experience a GraphQL-first API design typically would not always have mutations with a coherent \"group\" which could lead to abuse of the feature or tool.\r\n\r\nAs for GraphiQL and other tools, I think improved typeahead quality can better help solve this issue  I'm going to close this issue for repo maintenance but here are some of my opinions on this topic and suggestions for how to move forward:\r\n\r\nFirst just a point of clarification for the schema definition language. The expectation is that SDL will be read far more often than it is written (in fact in many cases it is even \"written\" by a code generation script) and therefore is optimized for legibility over terseness. It is valuable to see all fields defined on a type without having to follow references to mixins or interfaces. However for cases where you are *writing* more often than reading (perhaps for quick prototyping or using tools like AppSync or Graphcool) then I certainly see the appeal for having tools to allow for more terse representations.\r\n\r\nSpec proposals typically intentionally lag behind real world experimentation. The goal for the GraphQL spec is to dictate what is required to be considered GraphQL by codifying the most successful explorations into new capabilities by GraphQL services and tools. That means new ideas are best served by being built out and used for their intended purpose and learned from before being codified in spec.\r\n\r\nIf adding `mixin` support is important to you, I would recommend you build it! Try it out and learn along with the community and if that lends itself to broad support then a spec proposal would be a good final step to codify the best version.  Find the full text of the agreement: http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0\r\n\r\nRead more about this change at: https://medium.com/@leeb/relicensing-the-graphql-specification-e7d07a52301b\r\n\r\nResolves #351 For anyone looking for this change within the spec, note that new changes will appear at http://facebook.github.io/graphql/draft/  I'm going to close this issue since I think it's been thoroughly discussed. To conclude:\r\n\r\n> So, what is the recommended universal default way to represent such numbers in GraphQL?\r\n\r\nThere is no recommended universal default. Different APIs will come to different conclusions based on the type of data they need to represent and the kinds of clients they expect to support. All of the options you offered are reasonable to consider when making this choice. `Float` may be best if you can guarantee < 52bit ints and expect clients to do math on them. `String` may be best if you aren't sure about precision but only expect clients to print the number anyhow. A custom scalar type may be best if you need to encode rules for a specific transport (Protobuf?) or client paring (BigInt?)  The link you're looking for is: https://www.facebook.com/groups/graphql.community/  This structure is not possible, I recommend using a list of small structures:\r\n\r\n```json\r\n{\r\n  \"data\": {\r\n    \"operative_control\": {\r\n      \"que\": [\r\n        { \"index\": 1, \"R\": \"4\" },\r\n        { \"index\": 26, \"R\": \"6\" },\r\n        ...\r\n      ]\r\n    }\r\n  }\r\n}\r\n``` In the future, I recommend asking questions like this on stack overflow  These days I share your opinion @omouse that software patents are typically negative. They're very often too broad and don't match the pace of the industry. Unfortunately, at least here in the US, they're the law of the land and there's massive costs to those involved.\r\n\r\nI'll refer you to a blog post from our team's director related to this topic: https://code.facebook.com/posts/112130496157735/explaining-react-s-license/ Hey all, thanks for your continued attention, care, and patience on this issue.\r\n\r\nI wanted to share an update that this is still something I'm working hard on resolving. While it's become more clear to me what the spectrum of acceptable to ideal looks like from the perspective of the broader community, reconciling all other interests is a challenge and takes some time. Also, working on licensing for a specification instead of an open source codebase is somewhat new territory, which is causing this to take some additional time. Hey everyone, speculation on legal interpretation is really unhelpful in this forum. Let's keep this thread only as a high signal channel for those looking for updates as they arrive.\r\n\r\nResolving this is still my top priority and I'm working to a conclusion with our legal team. I understand patience is hard to ask for when your company's legal counsel may be asking questions or making demands from you, and that open source licenses and patents are frustrating topics to operate around as an engineer.\r\n\r\nI expect to have more updates soon, thanks for caring about this issue and granting me a bit of your patience. I have an update to share. The GraphQL spec will be relicensed under the Open Web Foundation Agreement v1.0, which has explicit terms concerning patent non-assert and license commitments. I hope this is a satisfactory resolution to the patent licensing issue.\r\n\r\nIn light of this change and the release of React 16 under MIT, our reference implementation GraphQL.js and client framework Relay will also relicense under MIT. I'll be working on updating those repositories as well. The first PR is already up: https://github.com/graphql/graphql-js/pull/1046 For anyone looking for this change within the spec, note that new changes will appear at http://facebook.github.io/graphql/draft/ once they make their way through the Travis CI gauntlet.  Thanks for this @raderio. I believe this is very much outside the scope (\ud83d\ude06 ) of the GraphQL spec itself and is unlikely to make it into the core. It's certainly possible to build something like this in userspace, however, by extending the schema with your own directives and then augmenting your tooling to take the \"according\" actions (which will most likely be *very* implementation- and domain-specific).\r\n\r\nIn any case, if you'd like to lobby further on behalf of this idea, I'd suggest taking a look at [this PR](https://github.com/facebook/graphql/pull/342) that tries to flesh out in more detail the (currently underspecified) process of how major changes should make it into the GraphQL spec.\r\n\r\nAs mentioned there, we want to start from a default position of favoring no change by asking these questions:\r\n\r\n1. Are we solving a real problem?\r\n2. Does this enable new use cases?\r\n3. How common is this use case?\r\n4. Can we enable it without a change to GraphQL?\r\n5. If so, just how awkward is it?\r\n\r\nClearly, access control is almost certainly a \"real problem\" (1) and a \"common\" one (3), but the bigger barriers to clear here are answering points (4) and (5).  What you've linked to there is the validation rule that ensures merging fields is safe, the actual work is done in:\r\n\r\nhttp://facebook.github.io/graphql/draft/#CollectFields()\r\n\r\nI'll add a reference from the validation rule so as you're reading you find that back-reference  Thanks again @burner.  Thanks @burner. That reads quite a bit more nicely.  > Are there *any* alternatives?\r\n\r\nFWIW, Facebook has gotten pretty far without having imports, even building (almost certainly) the largest and (definitely) the oldest GraphQL-powered apps in the world. Query and fragment names are \"globally\" unique (within each project), and it is quite easy to jump  from the place where a fragment is spread to where it is defined thanks to tooling like [graphql-language-service](https://github.com/graphql/graphql-language-service). Furthermore, our experience building the Relay compiler has shown us that it is possible to build an optimizing pipeline that eliminates redundancy, and our use of persisted queries mean that query size doesn't matter (in terms of client-to-server network transport, the cost is basically fixed; and in the other direction you pay only for what you use, so it's best to make sure you're declaring what you use as close as possible to the use site so as to avoid accidental overfetching).\r\n\r\nThis is not to suggest that the idea is a non-starter: just that the value isn't necessarily obvious compared to a world without imports. > I do think this is one case though where the existence of a system where imports weren't used doesn't mean they are never going to be valuable.\r\n\r\nI certainly didn't make that claim. Where did you see me make it? I was just offering a (significant, I would think) data point. What I said was (with emphasis added):\r\n\r\n> This is not to suggest that the idea is a non-starter: just that the value isn't necessarily *obvious* compared to a world without imports.\r\n\r\nYour list of benefits is good. But the proposal is not without costs. One example: any system that moves away from the current global system towards one involving relative paths means that you won't be able to move a heavily-depended upon fragment without modifying all the `import` sites. There are probably others.\r\n\r\nOnce again, just to be clear: I'm not trying to shut the discussion down, I'm just trying to offer a counterpoint to make sure that we're considering as many sides of the issue as possible. > How are full queries constructed at Facebook? From what I gather you have a collection of (named?) queries and fragments. Looking at Relay, they're written in code directly (not files) \u2014 is this also true for your native clients?\r\n>\r\n> Do you have equivalents to the Relay compiler for Android and iOS queries?\r\n\r\nFor native codebases, developers write GraphQL in `.graphql` files. We do have an equivalent to the Relay compiler that builds native artifacts (persisted queries, fragment/type model classes, query \"builders\" etc). We configure projects using `.graphqlconfig` files. And use [graphql-language-service](https://github.com/graphql/graphql-language-service) to provide code intelligence (autocompletion, diagnostics, \"go to definition\" etc). Going into further detail is probably beyond the scope of this issue, though; the nutshell version is that it is basically analogous to how Relay works.  Idea: perhaps this file should be named `CONTRIBUTING.md` (matching a pattern used by a lot of projects, and [some of GitHub's tooling makes use of it automatically](https://github.com/blog/1184-contributing-guidelines)). So, with this we have a draft definition of \"stages for changes to GraphQL specification\".\r\n\r\nWhat we don't have is a definition of \"stages for changes to the definition of stages for changes to the GraphQL specification\".\r\n\r\nMy inclination is to merge this as-is (but add a \"Draft\" label) and iterate from there. I'd say we can afford to move a little more quickly/scrappily on merging a change like this: it is not a change to the spec itself, it requires no implementation work from library or product developers, it is easily revised once landed, and you've *already* canvassed the idea in the [last (first?) WG meeting](https://github.com/graphql/graphql-wg/blob/master/notes/2017-08-14.md) to broad (informal) approval. I wouldn't want something like this PR to get bogged down too heavily in process, especially when we can make the non-final nature of the document clear by labeling it as a draft (and at that point I think it *would* make sense to discuss it in detail at the next WG meeting). > Should I add something to the document itself?\r\n\r\nYeah, that's almost exactly what I was thinking.\r\n\r\n```\r\n> **Document status:** [Draft](https://github.com/facebook/graphql/pull/342)\r\n```\r\n\r\n(Blockquote to make it stand out a bit.) Ok, great. This is a good starting point. We can iterate from here. Thanks @IvanGoncharov. Added discussion of this to the agenda for the next meeting: https://github.com/graphql/graphql-wg/pull/22  Thanks for the question @raderio (and the answer, @stubailo).\r\n\r\n@raderio, if you hit Stack Overflow and search for \"graphql filter\" you'll see some questions/answers with examples of how to filter (and paginate). Just say you end up exposing your results under a `people` field, you may end up setting up arguments for it like `people(minAge: 18)`, and if you require pagination, `people(first: 10, minAge: 18)` etc. Those are just examples, because there are plenty of valid ways to do this. Like @stubailo said, the specification is (intentionally) silent on schema design patterns, so I'd suggest you look around at the prior art out there in order to guide you.  Thanks for the question, @raderio. The spec is intentionally silent on the subject of how requests and responses should be serialized and transported, because it is intended to concern itself only with the lower-level matters of how to parse, validate, execute, introspect GraphQL queries. As the readme says, this is in order:\r\n\r\n>  ... to be broadly adopted ... GraphQL will have to target a wide variety of backends, frameworks, and languages ...\r\n\r\nYou'll find only the briefest of mentions of actual transport in the spec text, and non-normatively at that:\r\n\r\n> ... values of which are often serialized when sent over a transport like HTTP ... not all platforms and transports support encoding integer numbers larger than 32-bit ... etc ...\r\n\r\nYou say:\r\n\r\n> graphql-js respond with status 400 on invalid query\r\n\r\ngraphql-js has no notion of HTTP at all. Perhaps you are referring to express-graphql? In express-graphql, we elect to deal with invalid queries using a 400 status code, because codes in the 400 range are intended to indicate client errors, and supplying an invalid query is a client error.  Thanks for the question @raderio, and also for the answer @brokenpeace.\r\n\r\nGraphQL itself doesn't have any opinion on how you should do permissions or roles, although it is flexible enough to accommodate a number of possible approaches. Exploring those is probably beyond the scope that we can tackle on this issue tracker, and may be better suited to a dedicated question-and-answer platform like Stack Overflow (or a library-specific community: depending on what tools you are using, people may have solved similar issues with them in the past).\r\n\r\nSee also similar question from @raderio on the GraphiQL repo: https://github.com/graphql/graphiql/issues/564  As you've noted, it's a breaking change, and there is no way to make the change without it being a breaking change (that's why it is a breaking change). So, your choices in a situation like this are to chose from among the following:\r\n\r\n- Not make the change.\r\n- Make the change, and suffer the consequences (breakage of old clients).\r\n- Make a different change instead.\r\n\r\nThat second one (making the change anyway) may end up being viable under some circumstances, such as:\r\n\r\n- The code never shipped to end-users.\r\n- The count of users on the old client, and specifically the subset that uses features that rely on this data, may be below a certain business-defined threshold that make the breakage acceptable.\r\n- You may have client-side exception handling logic that makes failure to render the related subset of the UI acceptable, according to some business-specific parameters.\r\n\r\nThe third one (making a different change), could be something like *adding* a new field (eg. `dob`, or \"date of birth\", that is non-null), and shipping down a non-null (eg. empty string) value for `birthday` if the birthdate is missing. Once again, this depends on product specifics (will your client do a reasonable thing if supplied an empty date string? Do you have date-parsing code that is going to throw an exception and does your client handle it? etc).\r\n\r\nThis is why it is generally easier to make things nullable by default, because moving things towards non-null is a non-breaking change. Note: *easier*, but not necessarily *better*; an almost-everything-nullable schema is not so pleasant to work with on the client side.\r\n\r\nThe difficulty here also makes it clear why it is desirable to let schema additions \"bake\" for an adequate period before rolling them out to public clients. You can save yourself some painful iterations in public if you instead let additions cook for a while internally first. I should add, the concrete example that I gave of `dob` was a bit contrived: if you were really going to do that you would probably just keep `birthday` as non-null and make sure that you always shipped at least and empty string (I just wanted to give an example of adding a new field rather than changing an existing one).   Good catch. Thanks @RichardLitt.  Splitting this off from #330.\r\n\r\nWe'd like to enable translations of the spec into other languages in a scalable (ie. crowd-sourced), convenient (ie. minimizing manual synchronization work), high-quality (ie. community-reviewed and supported) way. [Crowdin](https://crowdin.com/) has been successfully used by other projects with FB involvement (eg. [Jest](https://github.com/facebook/jest), [Yarn](https://yarnpkg.com/en/)), although I am not sure how easily it can be adapted to our Markdown-centric workflow. Let's investigate. @rmosolgo: Yep. Let me edit the title to clarify that.  Thanks for this @wanghaisheng. I think the approach that we want to take to internationalizing the docs here is going to be similar to the one taken by other FB projects like [Jest](https://github.com/facebook/jest). They store only the English docs in the source branch of the repo, and then use [Crowdin](https://crowdin.com/) as a platform to manage the translations (which at build-time get written out to the `gh-pages` branch).\r\n\r\nSo I don't think we'd want to proceed with this PR as-is (and even if we did, we'd want to squash the history to remove the extraneous commits and unwanted changes such as setting the executable bit on image files etc) but rather do this the \"right\" way and set up Crowdin. Let me create another issue for that and we can continue the discussion there. Hopefully we can leverage the work that you've already done.  Sure, although we should probably just change the end of the range to \"present\", once and for all. We do this in a lot of our projects ([example](https://github.com/facebook/relay/blob/ef5ab894fc5279e78bb36b077803f7c5b196a5e5/LICENSE#L5)). I'll merge this in any case as it is still better than having a stale year in there. @eriknstr:\r\n\r\n> Regarding the practice of setting the end of the range to \"present\", is this something that Facebook lawyers have okayed, or was that something developers came up with?\r\n\r\nIt's all over our internal codebases, so is an established practice here.\r\n\r\n> IMO it's unfortunate for a project to be using \"present\" because it makes it more difficult to determine in the future what years apply to a full or partial snapshot of some project, e.g. if a file from one project is copied into another project in accordance with the terms of the license of the originating project.\r\n\r\nIn general we try to avoid copying files from one project to another, but in any case, version control is probably the most reliable source of information here (compared to a possibly stale, human-maintained code comment): you can see when a file entered the project, and when it was modified, pretty trivially with both `git` on the command-line and in the UI, along with the generally useful context that you'll get from whatever commit messages apply.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  I've merged this into the RFC in #90 \ud83e\udd47   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thanks for pressing forward with this, @mike-marcacci, and my apologies for not addressing this PR much earlier. Perhaps you could speak to this at the next GraphQL working group meeting (I'm working on putting up an agenda for that today).\r\n\r\nI believe we considered this during the original design and turned it down for YAGNI reasons. It's just much simpler to have Object types describe all the interfaces they implement directly rather than having to walk a hierarchy. I think having concrete examples of type systems which are challenging or unsustainable without this feature could make a really compelling argument.\r\n\r\nMy opinion based on what you've drafted up so far is that it's eminently reasonable, and requiring `implements` and explicitly defining the fields solves any multiple inheritance issues. I think the true cost of this is only partly complexity cost, but mostly change cost. Tools built around interfaces would need to expand to support this, and that's non-trivial. So we should just ensure the value it provides would be worth that cost.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  If I understand correctly, you would like some capability to organize your mutations hierarchically?   Re-define Live Queries? Can Live Queries make Subscriptions unnecessary?\r\n@smolinari @paralin @laneyk @dschafer @taion @Siyfion @jamesgorman2 @leebyron\r\n\r\nContinuing the conversation from: https://github.com/facebook/graphql/pull/267#issuecomment-281576156 I'll quote my original definition in the RFC: \r\n\r\n> **Live Queries**- the client issues a standard query. Whenever the answer to the query changes, the server pushes the new data to the client. The key difference between Live Queries and Event-based Subscriptions is that Live Queries do not depend on the notion of events. The data itself is live and includes mechanisms to communicate changes. \r\n\r\nAnother way @stubailo and I have described it is: \"infinitely fast/cheap polling\".  > \"live queries at scale isn't a solved science, so we're going to ignore the concept entirely.\"\r\n\r\nI don't think anyone is ignoring the concept. But \"live queries at scale isn't a solved science\" has some truth to it. We hope to share more details in the coming months as we continue to learn from our live query experiments at Facebook. However, assuming live queries work perfectly, we believe live queries and subscriptions are different tools in the real-time API toolbox.  > For example, in my case, where I have many microservices on my backend, where some nested fields go to other services, it's not really straightforward to define how live queries would work, and I've chosen explicitly to model things as event streams.\r\n\r\n@taion I'm curious to know if you think of subscriptions and live queries as semantically different. Suppose you had both subscriptions and live queries at your disposal, when would you use one over the other? Thanks everyone for the enlightening discussion here. I think the consensus is clear: Live Queries are not simply \"better Subscriptions\". Subscriptions and Live Queries are mechanically similar but semantically distinct: \r\n\r\n## Executable\r\nA standing query can be made \"live\" with the addition of a \"live\" directive, which means nothing is inherently live about the query itself. Live queries will always return a meaningful initial result. Subscriptions typically do not return an initial result because the data to \"execute\" the subscription's selection set is only present when an event has been triggered.\r\n\r\n## Domain-specific reason for data change\r\nWhen a subscription pushes data to the client, the _reason_ why the data changed is implicit; for example, someone liked a comment, a new email has arrived, a friend has logged on, etc. Live Queries only observe data, and reason why the data changed must be explicitly modeled on the schema and queried. \r\n\r\n_Note on Isomorphism:_\r\nSubscriptions and Live Queries are isomorphic. For example, take an online friends list: we can create a subscription to two separate events: friendLoggedOn and friendLoggedOff or we can model a CQRS-like event table and execute a live query against it. However, just because it's possible to model Subscriptions as Live Queries and vice-versa does not mean it is desirable. Doing so may compel us to model our data in awkward ways and we continue to discover use cases that are more ergonomically served by one model or the other.   Fetching initial state when subscribing.\r\n@stubailo @rzachariah @romandvoskin @taion\r\n\r\nContinuing the conversation from: https://github.com/facebook/graphql/pull/267#issuecomment-282529953 > The server may respond to a subscription operation with a response?\r\n\r\nPerhaps we can merge this with the \"subscription active\" response. Something like: \"The server *may* respond to a subscription operation. This response can be useful for returning initial data or indicating whether the operation was successful.\" Sounds like there's consensus on this. Summarizing: \r\n\r\n- The server may respond to a subscription operation with a response.\r\n- \"Subscription Active\"/ACK is separate from the initial response. \r\n\r\n@rmosolgo I like your wording for the requirement, would you please submit a PR? For example, at the end of this paragraph: \r\n\r\n> Subscribe: the Client initializes a subscription by sending a query and its variables to the server. When the Subscription is created, the input query and variables are mapped to a set of events to which the Subscription listens.\r\n\r\nWithin https://github.com/facebook/graphql/blob/master/rfcs/Subscriptions.md Updated the RFC: https://github.com/facebook/graphql/commit/48dac3f2d26df97bc8a6ff72e62a342cd7603c30  The \"event stream\" should be derived purely from the subscription root field (and ignore selection set).\r\n@dschafer @leebyron @rmosolgo @taion @OlegIlyenko @stubailo\r\n\r\nContinuing the conversation from: https://github.com/facebook/graphql/pull/267#issuecomment-281452518  Re-model the concept of \"events\" as an abstract \"event stream\".\r\n@dschafer @leebyron @rmosolgo @taion @OlegIlyenko @stubailo\r\n\r\nContinuing the conversation from: https://github.com/facebook/graphql/pull/267#issuecomment-282111436  How should we pass event payloads/data into the subscription resolvers?\r\n@stubailo @taion @leebyron @dschafer @wincent\r\n\r\nContinuing the conversation from: https://github.com/facebook/graphql/pull/267#issuecomment-280740586 rootValue it is. Since this is specific to the GraphQL-js implementation, it will be left out of the spec.   Where should subscription state be stored? (inside GraphQL-js or as a separate component?)\r\n@theorygeek @taion @stubailo @rmosolgo @jamesgorman2\r\n\r\nContinuing the conversation from: https://github.com/facebook/graphql/pull/267#issuecomment-280720673 @leebyron this is relevant to the discussion we had about subscription state. \r\n\r\n@taion, @rmosolgo Looks like we have consensus to leave this out of the spec. I'll submit a PR to clarify the message in the RFC. \r\n\r\nEDIT: Upon re-reading the RFC, there's are no implied constraints or recommendations for packaging/module breakdown, so I won't submit a PR after all. Closing this issue.  Do we need a \"bi-directional\" channel between client and server?\r\n@taion @stubailo @OlegIlyenko\r\n\r\nContinuing the conversation from: https://github.com/facebook/graphql/pull/267#issuecomment-280200236 I agree, SSE is fine for pushing messages from the server to the client, but SSE alone is not the full story. Perhaps the wording/semantics could be more explicit-- there had to be a request going from client to server for subscribe and unsubscribe. So we essentially have a logical channel where data flows both ways and can be initiated by either client or server. Whether that channel consists of SSE/WS/web hooks can be an implementation detail.   @OlegIlyenko, awesome way to break it down. \r\n\r\n> GraphQL execution engine may experience an unrecoverable error. This will \"complete\" stream as well.\r\n\r\nThis is the one point I would object trying to tackle in this issue. I agree with everything else you said. My intent was not to describe specific transport capabilities, merely that the communication flow throughout the subscription lifecycle is bi-directional because there are both client and server initiated communications (in the case of SSE + HTTP, I consider the initial HTTP request to be an instance of client-initiated communication). \r\n\r\nI think everyone is mostly in agreement on this topic. The only follow up action is to make the wording more clear. Any objections? Removed the mention of \"bi-directional\" with this commit: https://github.com/facebook/graphql/commit/96184f012b87af60128b14afb83946a92109c123  Thanks! In the future feel free to send pull requests for things like this, which get much more visibility  Here's my attempt to organize this thread into topics:\r\n\r\n### Closed\r\n* Add clearer notice that the RFC is a work-in-progress.\r\n* Add backward arrow from GraphQL to Subscriptions box in diagram (@rmosolgo)\r\n* Make \"subscription active\" part of the lifecycle optional and recommended for client-side error-handling (@taion, @stubailo)\r\n\r\n### Open\r\n* Do we need a \"bi-directional\" channel between client and server? \r\n@taion @stubailo @OlegIlyenko \r\n* Where should subscription state be stored? (inside GraphQL-js or as a separate component?)\r\n@theorygeek @taion @stubailo @rmosolgo @jamesgorman2 \r\n* How should we pass event payloads/data into the subscription resolvers? \r\n@stubailo @taion @leebyron @dschafer @wincent \r\n* Re-model the concept of \"events\" as an abstract \"event stream\". \r\n@dschafer @leebyron @rmosolgo @taion @OlegIlyenko @stubailo \r\n* The \"event stream\" should be derived purely from the subscription root field (and ignore selection set). \r\n@dschafer @leebyron @rmosolgo @taion @OlegIlyenko @stubailo \r\n* Fetching initial state when subscribing. \r\n@stubailo @rzachariah @romandvoskin @taion \r\n* Re-define Live Queries? Can Live Queries make Subscriptions unnecessary? \r\n@smolinari @paralin @laneyk @dschafer  @taion @Siyfion @jamesgorman2 @leebyron \r\n* Intermediate Subscription event processing \r\n@rzachariah @romandvoskin \r\n\r\nPlease let me know if I've missed your topic or if you would like to be added/removed from anything. I'll leave this post here for a bit so everyone tagged has a chance to review. After that, I'm going to merge this PR and file issues for all open topics.   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thanks @sogko!  Thanks for the correction, @sogko. I'll merge this. I also think your further suggested edit looks good, so feel free to submit a PR for that too.  The spec chapter on introspection mentions that type artifacts must not be named with \"__\" since it is reserved. This clarification repeats this information closer to the spec on type system itself along with the rules for determining if object/interface types are valid. Certainly if ids end up both using `__` and not being part of the introspection system then the existing language would need to change. \r\n\r\nI'd hope we can avoid that outcome though. \r\n\r\nSo if ids are not defined in the schema and are accessed as meta-fields, they should use `__`, however if ids *are* defined in the schema (not a metafield) then they should not use `__`.  Sorry for letting this issue sit.\r\n\r\nhttp://facebook.github.io/graphql/October2016/#sec-Float-Value claims that a FloatValue needs either `FractionalPart` or `ExponentPart` or both, but not neither (which would be `IntValue`). \r\n\r\ngraphql-js correctly lexes these, see the unit tests for error cases: https://github.com/graphql/graphql-js/blob/master/src/language/__tests__/lexer-test.js#L570-L582  Unfortunately this would be a breaking change to the spec for a couple reasons - but I'm not convinced that Unions are not useful simply because they're harder to use in pattern matching scenarios. I also disagree with that, I've seen pattern matching at play with GraphQL Unions to great effect, in fact it's one of a few reasons why Unions in GraphQL are powerful.\n\n---\n\nFirst Let's look at client's pattern matching on return types for a Union:\n\n``` graphql\nunion OneOf = A | B | C\n```\n\nThen in my client code (pseudo code):\n\n```\nswitch (oneOf) {\n  case A:\n  case B:\n  case C:\n} \n```\n\nOne of two things can happen: First, a type could be removed. Perhaps `B` gets removed from the union. Clients are naturally resilient to this - they assume B could theoretically appear at some point, even if it never does. Second, and more importantly, a type could be _added_ to the union. Perhaps `D` gets added. Client's need to be resilient to this as well, so clients that support this kind of exhaustive pattern matching always add one more case:\n\n```\nswitch (oneOf) {\n  case A:\n  case B:\n  case C:\n  case Unknown:\n} \n```\n\nBecause of how unions must be queried, the unknown type is the empty object type.\n\n---\n\nNext let's look at the ergonomics of defining Unions and Interfaces and the rationale for the restrictions in place.\n\nAs you quoted from the spec, Unions are defined locally while Interfaces are defined by implementation of each Object type. This models the data domain in different ways. \n\nA Union is a way to say \"I may return one of a few things at this location\" - it should be defined locally to the field. For example, a `Video` type doesn't need to describe that it might appear alongside `Photo` for some specific fields, though a specific fields needs to describe that it might return `Video | Photo`.\n\nAn Interface is a way to say \"I conform to this contract\" - it should be defined locally to the thing which conforms, the Object type. For example, a `User` type should be able to say that it fulfills the contract of `Profile` such that any type current known or unknown can be used knowing that it fulfills the contract.\n\nThis also drives the requirement that Interfaces must define at least one field - otherwise the Interface would not actually describe a contract to be fulfilled. This concept of contract-less interfaces is often called \"marker interfaces\" and in my opinion (hopefully not an uncommon opinion) are a bad practice borrowed from limited object-oriented languages. They're typically used either as a backfill for languages like Java that don't have a good concept of Union, or are used as metadata annotations for languages that don't have metadata annotations. I don't think either should apply to GraphQL for modeling data domains.\n @kafkahw I'm personally for keeping unions for semantic reasoning but here are a few problems in your arguments:\r\n\r\n> Without union, you'll have to declare more types because each type will be strictly coupled with only one interface.\r\n\r\nYou can inherit multiple interfaces:\r\n```graphql\r\ninterface U1 {}\r\ninterface U2 {}\r\n\r\ntype ObjA implements U1  {}\r\ntype ObjB implements U1 & U2 {}\r\ntype ObjC implements U2 {}\r\n```\r\n\r\n> Another use case is when you need to deal with existing types, interface can't help. Say, I need to define a field in a type that could be String, Int or Float.\r\n\r\nYou can't make unions with scalars only with object types. Even if you have external object types you can always extend it with new interface:\r\n```graphql\r\ninterface UnionImitation {}\r\n\r\nextend type SomeExternalType implements UnionImitation\r\n```   Currently http://facebook.github.io/graphql/#sec-Input-Objects reads:\r\n\r\n> This unordered map should not contain any entries with names not defined by a field of this input object type, otherwise an error should be thrown.\r\n\r\nWhich is designed to help detect runtime errors which may be the result of typos. However this unnecessarily introduces a vector for breaking changes. If a field of an input object is removed in the schema, then existing queries may all the sudden result in execution errors even though they're providing strictly more inputs to the server than it requires.\r\n\r\nVariations of this have been requested in graphql-js before (https://github.com/graphql/graphql-js/pull/343)\r\n\r\nNotably, the same restriction is not placed on field arguments, additional field arguments on a field does not result in an execution error (however it does result in a validation error).\r\n\r\nValidation should still insist on not allowing unknown fields to an input object. I think that's right, though it's all up for debate.\n\nhttp://facebook.github.io/graphql/#sec-Argument-Values-Type-Correctness and http://facebook.github.io/graphql/#sec-Variable-Default-Values-Are-Correctly-Typed encapsulate this behavior right now. Values provided must be of the right type.\n\nCombine that with http://facebook.github.io/graphql/#sec-Input-Objects input coercion rules which says \"... should not contain any entries with names not defined by a field of this input object type, otherwise an error should be thrown.\"\n\nIt's maybe a little weird for literal values and runtime variable values to diverge in behavior, so that deserves fair criticism. It seems to me that having the validation to enforce only allowing the fields of an input object for literals may still be valuable, but I think we could make a similar argument above about what should and shouldn't be considered a breaking change.\n\nWhat was most motivating to me along the lines of breaking changes was that variable values are checked at runtime before executing, which breaks the execution of queries if additional variable data is provided. We already have precedent for schema changes that cause previously-valid queries to appear invalid though still have totally reasonable execution behavior, and this is a nice property to have. We could apply the same judgement to this case - removing an input object field from the schema would render queries invalid but at least still executable with expected behavior.\n  I just fixed the table and bold rendering issues you pointed out here, so thank you for the careful read!\n  This is looking good - thanks for coalescing the RFC.\n\nIn my mind the biggest question is how `__id` should be represented in introspection. It seems like it should be a meta-field like `__typename` in as many ways as possible, however _every_ object type has a name, so it's clear that you can always request `__typename`, but not every object type is uniquely identifiable or cacheable. We need some way to allow some types to have ids and others to not.\n\nI'm not sure that expressing ids as nullable is what we want, for example if I fetched a bunch of `User` types that I expected to all be cacheable, and I encountered one with `{ __id: null }` then I might have relied on a flawed assumption. Having ids be non-nullable is very valuable property to be able to rely on, so ideally we can enforce non-nullable ids as often as possible, if not as the default.\n Another piece of feedback is just at a high level - why should we be including this in the spec with additional behavior rather than simply making an `id: ID!` field a best practice for cacheable types? The spec should be as small as possible and no smaller, so we should ensure we have a strong argument for moving this from best practice to spec.\n\nSpecifically I think the argument \"client caches would like to rely on this\" is a little faulty as we already have client caches that rely on different forms of pagination and connection models with those as best practices and no impact on the spec.\n\nI know we've talked before about changes to the GraphQL execution engine itself before that needed some way to identify objects that perhaps we should allude to in this RFC. For example, one of the reasons that led me to think that `__id` might be necessary was trying to figure out how GraphQL could respond in an already normalized graph format rather than it's current tree format.\n > Which means, would this not be instance specific and better off served by having common conventions and practices of a meaningful id field?\n\nMore generally, `__` is reserved for use by the GraphQL system itself which so far has only used this preserved space for introspection. \n\nPractically, using a non prefixed field is only reasonable when suggesting common practice, and not appropriate for use by the GraphQL spec itself, since perhaps clients already have a field called `id`, and the potential for the spec to collide with user definitions is high. \n\nIn a final decision where this should be a common practice, then `id: ID!` would be the recommendation. In a final decision where this is encoded in the spec, then a `__id` meta-field would be more appropriate.\n Great conversation so far. Let me try to round up where we are and some decisions that need to be clarified and made:\r\n\r\n### `id` vs `__id`\r\n\r\nFirst is what to name this field. The name `id` lends itself to user-created schema. Because `__` is reserved by GraphQL introspection, we shouldn't be using it for user-created types and fields. However if this field is a \"meta\" field, then `__id` is more appropriate, making it more similar to `__typename` which is of course never defined in user-created schema.\r\n\r\nAnother notable drawback to `id` is that adding constraints to it would add a constraint for existing systems to work around should they want to expose some field called \"id\" which has different semantics. They would have to rename their other field.\r\n\r\n> I'll refer to it as `__id` through the rest of this comment, but the question still is open.\r\n\r\n### Should `__id` always have a value?\r\n\r\nIt seems clear from the conversation that if `__id` is queried on an object which is capable of providing ids, that it must provide a non-null value.\r\n\r\nHowever should *all* types provide non-null `__id`? I think we've proven that's not really possible. Some combination of parent-id + field-path could be used, but there are issues with this approach.\r\n\r\n### Can the `__id` field be requested anywhere?\r\n\r\nI think it's reasonable to consider an exception to the validation rules for meta fields. Meta fields are *not* part of a schema, so they have different rules.\r\n\r\n### Should there be an `__Identifiable` interface?\r\n\r\nNot sure if this was proposed as a counter-proposal to `__id` having different validation rules. \r\n\r\n### How is `__id` represented in the schema language?\r\n\r\nAre types which support the `__id` field required to declare it explicitly so as a regular field? If so, then perhaps `id` is more appropriate as that would make it not a meta field. Should the schema language having an `@identifiable` directive? It seems like *most* types would be identifiable, so perhaps non-identifiable should be called out differently?\r\n\r\n### How is `__id` represented in the introspection result?\r\n\r\nIf `__id` is a meta field, then it shouldn't appear as part of the schema (just as `__typename` does not), however some indication of a type being identifiable needs to be available if not all types are available, so schema-aware clients know what to expect. Here's a counter-proposal to consider: we could standardize a clarified version of the current best practice.\r\n\r\n## Constrain `id` with musts\r\n\r\n*Specifically:*\r\n\r\nTypes are not required to provide a field `id`, however if they do it *must*:\r\n\r\n- be of type `ID!`.\r\n- return values unique for the entire schema domain.\r\n\r\nA field named `id` is valid to be queried in any selection set. Execution behavior is unchanged, which means if `id` is queried on a type which does not implement it, then no entry is added to the response for that field.\r\n\r\n*Pros:*\r\n\r\n- This is the simplest thing that works. \r\n- No changes are required to introspection. \r\n- No changes are required to the schema language. \r\n- There is no addition of new meta-fields. \r\n- Critically: this is backwards compatible with existing libraries & tools.\r\n- All Relay-esque apps and APIs continue to work.\r\n- Easy to auto-add to queries for schemaless clients.\r\n- Does not require interfaces.\r\n\r\n*Cons:*\r\n\r\n- This highly constrains `id` as a field to use.\r\n- This change is potentially breaking with existing APIs if they use `id` in a non-best-practice way or of a different type.\r\n- Potentiall for confusion if non-refetchable, `id` sometimes used to refetch when used with a `Node` interface.\r\n\r\n### Alternative: Same, but `__id`.\r\n\r\nSame as above, but replace `id` with `__id`. In my personal opinion the cons of this blurring the meaning of `__` would be pretty damning for this particular approach.\r\n\r\n*Pros:*\r\n\r\n- No collisions with existing APIs.\r\n\r\n*Cons:*\r\n\r\n- This is not a meta-field, blurs the line as all other `__` fields are meta.\r\n- Requiring people to define `__id` manually is confusing between user domain and graphql introspection domain.\r\n Ya, to be clear the \"Easy to auto-add to queries for schemaless clients.\" has nothing to do with `id` vs `__id` - that's just about the making the validation exception. > I think taking up the name id can be a pretty big disadvantage because then you have to start having fields like sqlId or something.\r\n\r\nYeah - it certainly can require people to work around this which is a disadvantage for moving quickly, however perhaps it's an *advantage* for the design quality of the resulting APIs? Directly exposing SQL IDs is a \"code smell\" since it leaks implementation details about the API. (we had similar issues at Facebook - to interop with old APIs we exposed `legacy_id` on some types)\r\n\r\nI could also argue that the [\"pit of success\"](https://blog.codinghorror.com/falling-into-the-pit-of-success/) would have us make the `id` field which corresponds to caching (and occasionally refetching) as easy to guess and use as possible.  An API which exposes type-local SQL ids as `id` and global cacheable ids as `__id` could cause confusion. Which should a user of the API use? They will probably use the one called `id` since it's easier to type than `__id`.\r\n\r\nAnother thing to consider is the case where objects are both uniquely cacheable AND are refetchable. It is probably confusing to say that you should use the `id` field for refetching things, but use the `__id` field for caching things. Not only is that potentially confusing, but if an API exposes the same value for `id` and `__id` all of the time, then perhaps clients will only fetch one or the other but use the one value for both contexts. That might be fine up until the point where they stop returning the same value! Or for APIs where the two fields return *different* values, then it could be too easy to accidentally use the value for `__id` somewhere that expects `id` and vice-versa causing bugs.\r\n\r\nI guess another way to rephrase this concern is that clear API design would lead us to use *only* `id` *or* `__id` but not both.\r\n\r\nShould we actually allow for this kind of confusing scenario?  This proposes support for the entire unicode character range in a source document, rather than explicitly excluding certain characters.\n\nBecause this doesn't add any new characters to the ignored sequences, in practice this allows for adding more characters to comments (low value) and strings (high value).\n\nThis allows strings to include literal unicode points as a way to represent supplemental plane characters. In fact, it almost allows ignoring escape sequences altogether as all characters can be represented literally.\n\nSuggested by #214\n Drawbacks and concerns I'd like feedback on from folks with more experience dealing with unicode corner cases:\n\nBy encouraging use of non-ascii characters in strings, we will inevitably see utf8 files that include supplemental plane and surrogate pair points. Will this break any common tools or create an unnecessary burden?\n\nThis removes the restriction of excluding control flow characters from the source. This is in the name of simplicity, however it may have real drawbacks for interaction with other tools. For example, could sources that contain U+0000 be interpreted as the end of a file? If this remains a real concern, it might be worth adding back that restriction just as a point of practical convenience.\n Check out a rendering of this patch applied here: https://ns-gxioxiaqyc.now.sh\n Updated to incorporate feedback\n  This is looking good, thanks for writing this\n  This rule was suggested by @jjergus (#223) to remove ambiguity from execution where the `@skip` and `@ignore` directive rules make the assumption that only one is defined per selection.\n\nIn general I think this assumption should be upheld by valid queries overall, not just for `@skip` and `@include` so that it can be relied upon for any usage of directives. For example, this allows a potential optimization to use a hashmap keyed on directive name to represent the directives at a location rather than an array.\n\nCloses #223\n Exactly. I think the latter API is more explicit to the possible behavior.\n Further rationale after an offline discussion with @dschafer:\n\nWhile this is explicitly a limiting change and therefore potentially breaking, by reducing what is possible now it _increases_ future option value. This change is one that we could always change back in some capacity in the future in a non-breaking way should an explicit need arise. Barring any such need today, it's in our best interest to preserve that option-value.\n  There were some recent clarification improvements to the execution phase. Specifically http://facebook.github.io/graphql/#sec-Value-Completion should describe the interrelationship between List and Non-Null types during the execution of field values.\n\nPlease let me know if you still have questions after reading this section, and hopefully we can use your feedback to further clarify or perhaps to add examples.\n Let me try to use your example and attempt to simplify and then show some example data:\n\nJust for simplicity I'll use the following simple forms to represent values:\n\n| Simple | Typed |\n| --- | --- |\n| 1 | {some, Value: 1} |\n| null | {none} |\n| Error(whoops) | {error, Reason: \"whoops\"} |\n\nWith this schema:\n\n``` graphql\ntype Query {\n  a: Wrapper\n}\n\n# Where Type is one of the types below\ntype Wrapper {\n  b: Type\n}\n```\n\nWhere `Type` is one of:\n- Int\n- Int!\n- [Int]\n- [Int]!\n- [Int!]\n- [Int!]!\n\nWhere the value found at `a.b` is one of:\n- `1`\n- `null`\n- `Error(whoops)`\n- `[]`\n- `[1, 2]`\n- `[1, null]`\n- `[1, Error(whoops)]`\n\n## Int\n\n**Int, `1`**\n\n``` graphql\n{\n  data: { a: { b: 1 } }\n}\n```\n\n**Int, `null`**\n\n``` graphql\n{\n  data: { a: { b: null } }\n}\n```\n\n**Int, `Error(whoops)`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int, `[]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int, `[1, 2]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int, `[1, null]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int, `[1, Error(whoops)]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n## Int!\n\n**Int!, `1`**\n\n``` graphql\n{\n  data: { a: { b: 1 } }\n}\n```\n\n**Int!, `null`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"invalid null\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int!, `Error(whoops)`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int!, `[]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int!, `[1, 2]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int!, `[1, null]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**Int!, `[1, Error(whoops)]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n## [Int]\n\n**[Int], `1`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int], `null`**\n\n``` graphql\n{\n  data: { a: { b: null } }\n}\n```\n\n**[Int], `Error(whoops)`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int], `[]`**\n\n``` graphql\n{\n  data: { a: { b: [] } }\n}\n```\n\n**[Int], `[1, 2]`**\n\n``` graphql\n{\n  data: { a: { b: [1, 2] } }\n}\n```\n\n**[Int], `[1, null]`**\n\n``` graphql\n{\n  data: { a: { b: [1, null] } }\n}\n```\n\n**[Int], `[1, Error(whoops)]`**\n\n``` graphql\n{\n  data: { a: { b: [1, null] } },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\", 1 ] } ]\n}\n```\n\n## [Int]!\n\n**[Int]!, `1`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int]!, `null`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"invalid null\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int]!, `Error(whoops)`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int]!, `[]`**\n\n``` graphql\n{\n  data: { a: { b: [] } }\n}\n```\n\n**[Int]!, `[1, 2]`**\n\n``` graphql\n{\n  data: { a: { b: [1, 2] } }\n}\n```\n\n**[Int]!, `[1, null]`**\n\n``` graphql\n{\n  data: { a: { b: [1, null] } }\n}\n```\n\n**[Int]!, `[1, Error(whoops)]`**\n\n``` graphql\n{\n  data: { a: { b: [1, null] } },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\", 1 ] } ]\n}\n```\n\n## [Int!]\n\n**[Int!], `1`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int!], `null`**\n\n``` graphql\n{\n  data: { a: { b: null } }\n}\n```\n\n**[Int!], `Error(whoops)`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int!], `[]`**\n\n``` graphql\n{\n  data: { a: { b: [] } }\n}\n```\n\n**[Int!], `[1, 2]`**\n\n``` graphql\n{\n  data: { a: { b: [1, 2] } }\n}\n```\n\n**[Int!], `[1, null]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"invalid null\", path: [ \"a\", \"b\", 1 ] } ]\n}\n```\n\n**[Int!], `[1, Error(whoops)]`**\n\n``` graphql\n{\n  data: { a: { b: null } },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\", 1 ] } ]\n}\n```\n\n## [Int!]!\n\n**[Int!]!, `1`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"invalid value\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int!]!, `null`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"invalid null\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int!]!, `Error(whoops)`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\" ] } ]\n}\n```\n\n**[Int!]!, `[]`**\n\n``` graphql\n{\n  data: { a: { b: [] } }\n}\n```\n\n**[Int!]!, `[1, 2]`**\n\n``` graphql\n{\n  data: { a: { b: [1, 2] } }\n}\n```\n\n**[Int!]!, `[1, null]`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"invalid null\", path: [ \"a\", \"b\", 1 ] } ]\n}\n```\n\n**[Int!]!, `[1, Error(whoops)]`**\n\n``` graphql\n{\n  data: { a: null },\n  errors: [ { message: \"whoops\", path: [ \"a\", \"b\", 1 ] } ]\n}\n```\n Some notes on constraints and interpretations:\n\n`[Int]!` means that the value itself must not be null, but items in the list can be null.\n`[Int!]` means that the value itself can be null, but items in the list must not be null.\n\nWhen propagating errors and inserting nulls, the index of items in a list must never be changed. So converting `[1, null, 3]` to `[1, 3]` would be illegal\n  Fragments are definitely the answer :)\n  This adds a specific limitation to the Variable parsing rules to make it impossible to put ignored characters between the `$` and the name of the variable.\n\nThis was suggested by @martijnwalraven as he was building syntax highlighters for some IDEs.\n\nI'm not sure if this is necessary or good - but wanted to capture it so we can have a conversation about it.\n\nTo be specific about the issue and the impact of this change, currently the following are legal variables:\n\n``` graphql\n$variable\n\n$ variable\n\n$\nvariable\n\n$       variable\n\n$,,,variable\n```\n\nWith this change, only `$variable` will be a parsable Variable form, the others with ignored characters will not be allowed.\n This is also not the only case where punctuation comes before a Name and we would expect no spaces. Another example is `...Fragment` That's also possible to write as `... Fragment` or `...,,,Fragment`.\n\nPerhaps the right fix for this is a linter with a lint rule that looks for this sort of thing?\n Ah sorry, just some overzealous spring cleaning, as it has been sitting mostly untouched for the better part of a year (save for your comment, which I didn't even see). Happy to revive this if there is still interest.  A Schema only needs to include the scalars that are present in a schema. However note that introspection is part of the schema, and the introspection system uses String and Boolean, so those are essentially always going to appear in every schema.\n And @stubailo, by the spec, as long as you have a type named `String` (as an example) - it must conform to the spec's description of how `String` works. So that doesn't leave much room for overriding.\n  \ud83c\udf90 \n  Thanks!\n  Thanks for bringing this up! Great thought process already happening.\n\nI agree that surrogate pairs is an obtuse API. I'd like to avoid it if possible, though there is one serious upside to consider: it mirrors JSON. That might not be enough to motivate it as the solution, but it certainly shouldn't be discredited.\n\nHere are some action items:\n- [x] Editing of the language section describing Unicode to correct and clarify.\n- [x] Propose expanding the parsable character set to all represented in latest Unicode including supplemental planes.\n- [ ] Propose a new escape sequence for string literals (or prescribe to always use Unicode characters directly) for supplemental planes.\n @dylanahsmith and @chris-morgan I'd love your feedback on #231 \n  I'm not sure I understand what you're suggesting. It would be helpful to see an example of the query you would like to write following this proposal. \n  GraphQL is designed first as a data access API. It's not always well suited for RPC style write-only services. The default constraints are set up to reflect this.\n\nRequiring the query type provides a guarantee for tools. You can _always_ query a GraphQL API because of the introspection meta fields. Requiring the query type avoids a scenario where an introspection query is run, but the underlying system is unsure of what type to use throughout validation and execution. Avoiding this edge case helps avoid quirks during implementation.\n\nIf you are building a write-only GraphQL service, or just writing tests. A simple near-empty query type should work.\n  There are already quite a few discussion forums available listed on http://graphql.org/community/\n I'm conflicted on this. I understand the desire for those who have preferred chat tools to want to use those tools to discuss live, however there is also the problem of fragmenting the community across these various discussion platforms. We already have this problem today with more slack rooms than core contributors can keep up with in addition to a freenode irc room where the core team is frequently around, but is otherwise often quiet. \n\nAre more platforms better at the expense of further fragmentation? Or is consolidating community discussion better at the expense of lack of platform choice?\n\nAnother way to frame this is, would it be acceptable to have the gitter room open if it was unofficial and had no promise of any segment of the community or maintainers being available via that channel?\n  Where the spec points out that Names are case sensitive, what that means is that a query: `{ foo, Foo, FOO }` is always querying three different fields, and not querying one case-insensitive field three times.\n\nThat also means that any names of types or fields referenced in the spec are required to be in the case they're described. \n\nFor example, if you implemented your introspection field to use `Name` instead of `name` that would be invalid according to the spec. And if you implemented a type `sTrInG` instead of `String`, that would also be invalid. Similarly, the response objects should use the fields `data` and `errors`, not `Data` and `Errors` so that clients can predictably use a graphql API without needing to check for case sensitivity first.\n\nHowever any field or type not described directly in the GraphQL spec can be cased however you like. This is all valid:\n\n``` graphql\ntype my_custom_type {\n  MYCUSTOMFIELD: String\n  my_custom_field: String\n  MyCustomField: String\n}\n```\n\nThere's nothing stopping you from doing that.\n\nHowever I would say that if you wanted to follow the _conventions_ used throughout the spec, then I'd suggest using camelCase for fields and PascalCase for types.\n  There is not a way to destructure input objects themselves. You could instead define a variable to use specifically for the `firstName`.\n\nThe reason this feature does not exist is that it would require defining an input object type for every field which accepts arguments - that would be non-intuitive and inflate the number of types in the system.\n  Thanks for the feedback - this was fixed in the October release by adding an explicit table\n  Yeah I think this is probably an interesting idea, though we haven't put a lot of thought into it yet.\n\nI'm less sure about making types themselves deprecated - rather the references to those types should be deprecated. Perhaps that means also being able to mark arguments as deprecated. If input obj fields can be transitioned from required to optional to deprecated, then arguments should be the same.\n\nThe next steps for an idea like this would be to draft an RFC, probably in the form of a PR against the spec along with a good description of how deprecation best practice should work and any potential caveats.\n  GraphQL explicitly does not allow this because of backwards compatibility.\n\nAn important characteristic of a query is that it completely describes the data being requested. Critically, that allows the freedom to evolve a schema over time, including adding new fields to existing types, with the knowledge that all existing queries will be unaffected.\n\nThis is very related to the old wisdom to never use `SELECT *` in your production SQL queries.\n  Going to close this issue since it's a question and not a tracking RFC.\n\nThe concrete answer to the question is that __id will need to go through the RFC process, and that hasn't begun yet.\n\nI definitely would like to address it before the April-2017 edition of the spec.\n That would be great, @stubailo! Happy to collaborate on this one. We've spoken about some of the open concerns before, so perhaps you could start with the document we started a while back.\n  Refreshing this RFC since I think it's really important to get included. This is critical information to let clients deduce which errors correspond to which fields.\n I think the spec addition needs to be a little more descriptive. Definitely it needs to include some examples and deeper explanation of the expected behavior for some of the edge cases:\n- When a field used an alias, the alias should be used in the path (so this is a path of _response keys_, not field names).\n- When a field that errored is contained with an array, that the position in the array response is included.\n- When a error occurs in a field that's non-nullable and the `null` ends up appearing in a parent field, the path should follow to the original erroring field, not the field that was nulled.\n  Going to close this issue since the original question was answered.\n\nWe want to continue to preserve the limitation that object fields always request further fields. If you only care about existence, typically you can ask for `id` or `__typename` as a cheap way to fill this in.\n  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n  NB: implemented in the reference implementation in https://github.com/graphql/graphql-js/pull/296\n  I wonder if this is the right thing? I think perhaps it should be okay for some things to be description-less.\n  This is nice work, thank you!\n  Thanks for keeping this open!\n\nI think we may come back to this as we work out our 2016 roadmap. We considered this feature for the initial version of the spec, but there are some pretty serious concerns to weigh. \n\nThe primary concern is response confusion. This feature can be powerful, but it can also lead to harder to understand queries. Right now one JSON object always corresponds to one GraphQL object, but this feature allows for deeply nested \n\nThe second concern is it can become easy to accidentally produce field over-fetching. For example consider:\n\n```\nfragment Example on User {\n  foo: ...ChildFrag1\n  bar: ...ChildFrag2\n}\n\nfragment ChildFrag1 on User {\n  name\n  age\n  birthday\n  more: ...ChildFrag2\n}\n\nfragment ChildFrag2 on User {\n  name\n  birthday\n  profilePicture { url }\n}\n```\n\nThe result of this will be duplicate querying and returning of the `name` and `birthday` fields on the first level, and fetches everything in `ChildFrag2` twice. Without the fragment aliases, there would be no over-fetching at all. \n\nConsidering that one major motivation for this is more safely separating fragments from each other so they are unlikely to overlap, this motivation is exactly what would cause this duplicate over-fetching to occur.\n\nWe should keep the issue open though as a place to collect discussion, and perhaps reconsider should we come up with new response formats that makes such a thing possible.\n  Yeah I think this is a good idea. Any concrete proposals on what this should actually look like in terms of the spec?\n One clarification here, as this topic was also brought up in #117. Your error type number 3 I interpreted as \"user of the GraphQL endpoint\" aka \"the client developer\" and not \"user of the product\". I think it is useful to disambiguate between errors that are due to a bad query vs errors that are due to something having gone wrong within the server (e.g. a database was down or some server code threw an error).\n\nFor errors that are the fault of the product end-users, we don't want to spec an Error type because different products and different interfaces where user-errors could occur will all represent different kinds of information and should be represented by data. While you're free to refer to this type as \"Error\" if you like, from GraphQL's point of view it is just another data type.\n\nFor example, an error when filling out a form might want to report back which part of the form had an issue so a UI could highlight it. Or maybe an error about not being able to deliver a message in an IM client might want to include information about if the user should retry or if the server is retrying on their behalf. This information is hard to globally standardize as one single type since each context has these specific details. So it's important to distinguish between the _data_ that represents a \"user error\" vs the _error_ that represents the GraphQL server's inability to accomplish what a GraphQL query requested.\n @arunoda it sounds like that idea could be easily accomplished without any changes to the spec. We could add some thrown error post-processing to determine if (or how) an error should be reported or not. That is something we were planning to add anyhow to improve error debugging in general\n  This is a good question @CatTail and one that comes up all the time.\n\nWe encourage GraphQL endpoints to take an add-only approach to schema evolution over time instead of changing existing fields. This is important for the preservation of behavior for existing clients without creating another dimension to implement on the server.\n\nTo be clear, this has its tradeoffs. You're exactly right that if you wanted to change your field `\"key\"` from returning one String to returning a List of Strings then this could potentially break your existing clients which are querying for the string. It means that instead you would have to pick a new field name to represent the new concept, maybe `\"keyList\"` or `\"keys\"` instead and leave the old one.\n\nThe addition of new fields is always safe for older clients. You can add your `\"additional\"` field without any ill effect since GraphQL queries always specify exactly what they want and nothing more. You can think of this as similar to what would happen if you added a new column in a SQL table. Existing queries could run against the same table without any issue and without any change to the result of their queries. The same concept applies for GraphQL.\n\nOf course, there is nothing stopping you from changing a field's type in your GraphQL schema other than this concern. So for example, at Facebook, we often are developing new features and new applications which undergo rapid development and often require their GraphQL schema to change. However since no users are using them yet, we can safely cheat and change a field's type, knowing that we're only going to break our prototype builds for our internal developers. However once we've shipped a feature to our users, we do everything we can to avoid breaking it including not changing the GraphQL schema.\n  Thanks for the report. spec-md should really be detecting this and produce more specific links. I will investigate.\n Now fixed by #129!\n  Perhaps we'll consider this as we expand documentation to include a \"best practices\" section. Right now Relay is the only tool which requires connections to be modeled in this way, which is why those documentation details are in a Relay specific place. But we think connections are a good idea in general that many GraphQL backends could take advantage of.\n  Most excellent. That fixed the link issue but also makes the docs clearer, so thank you!\n  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n  I'm no expert on service workers, but I'm not sure GraphQL needs to be anything other than agnostic towards it as a technology? I believe you should be able to run your GraphQL queries from a service worker if you wish.\n I should mention though that a pure HTTP cache is acceptable but often underwhelming when paired with GraphQL, for similar reasons for why directly caching the results of SQL queries are underwhelming. \n\nA great GraphQL cache is aware of the relevant schema and can ensure new information gleaned from one query can benefit the cached results of other queries.\n\nSince a great example of a GraphQL client cache is [Relay](https://github.com/facebook/relay), you might consider furthering this conversation there. I know offline support is something they've been thinking about within future plans.\n  This proposes loosening the definition of implementing an interface by allowing an implementing field to return a subtype of the interface field's return type.\n\nThis example would previously be an illegal schema, but becomes legal after this diff:\n\n``` graphql\ninterface Friendly {\n  bestFriend: Friendly\n}\n\ntype Person implements Friendly {\n  bestFriend: Person\n}\n```\n Yeah, currently the only possible pseudo-contravariance in input types in required (non-null) vs optional (nullable) but supporting that causes other issues. I think we'll need to divorce argument requirement from argument type nullability to support argument contravariance in the future. For now, the spec and impl for inputs remains invariant.\n  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n thank you thank you\n  Sound cool! Mind opening an issue or PR on https://github.com/graphql/graphiql ?\n  Magnificent, thanks\n  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n Thank you @joliss!\n  The data in the errors object is definitely typical for debugging. But of course the existence of an error could be used to render something in a UI about data not being available.\n\nMy suggestion for the example you bring up here is to allow for data for a user-facing report in the payload of your mutation. It's often the case that mutation payloads include a `\"didSucceed\"` field and a `\"userError\"` field. If your UI requires rich information about potential errors, then you should include this information in your payload as well. For example, maybe you want to highlight the email field red, you might include something like a boolean \"wasBadEmail\".\n\nThe general philosophy at play is that Errors are considered exceptional. Your user data should never be represented as an Error. If your users can do something that needs to provide negative guidance, then you should represent that kind of information in GraphQL as Data not as an Error. Errors should always represent either developer errors or exceptional circumstances (e.g. the database was offline).\n  Closing this since it was fixed in the Dec spec and has since been implemented in graphql-js!\n\nWe refer to this as covariant interface implementation. That is you have implemented the interface, but you just supplied a covariant type (Page is an Entry) instead of an _invariant_ type (must be Entry and only Entry).\n\nWe started with invariant interface implementation mostly as a simplifying force. Adding this kind of type system rule can add complexity to the rest of the system by introducing new kinds of cases that validation needs to consider, but in this case the complexity added was not untenable and it is worth it to enable this kind of query.\n  We did in fact consider this and decided that the legibility of the query language was one of the critical factors we wanted to include. We were not able to come up with a JSON-specific representation that both covered all the cases and was easy to write and read. If someone wants to produce a library which defines such a thing and converts to and from GraphQL, I think that would be a perfectly good community project, but for now GraphQL will continue to maintain its language.\n Another important consideration is that GraphQL is defined to be a common request language regardless of frontend or backend languages involved. Since different languages have different representations of data structures, we still must agree upon a serialization format which can represent these concepts across most environments. JSON is probably the go-to for this sort of thing, but JSON feels pretty limiting for this task.\n\nEDN is an interesting alternative because it is far more flexible than JSON, and [datascript](https://github.com/tonsky/datascript) is a pretty great example of how EDN can be used to define this kind of macro language / datastructure. Taking a dependency on EDN is probably not the right decision for GraphQL, but we would encourage experimentation with EDN-macro style GraphQL-like systems. \n  This is something we want to consider. Interfaces may be less valuable because it becomes less clear what the semantics should be, though Unions are pretty interesting. This is all interesting area to explore further.\n  Great suggestion. We will change links to encourage usage of Discord.\n  It would be better if the auto-generated TOC was just easier to navigate, which would be a change to https://github.com/leebyron/spec-md\n Yes. spec-md currently already generates a table of contents, so any improvements to it should be made there\u00a0\n\n\u2014\nSent from Mailbox\n\nOn Tue, Nov 10, 2015 at 6:02 PM, Michael Lancaster\nnotifications@github.com wrote:\n\n> ## Sorry @leebyron but I did not understand what you mean by that.. are you suggesting that spec-md auto generate navigation based on the md? or I got wrong.\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/facebook/graphql/pull/112#issuecomment-155631251\n Sorry for the delayed response here (holidays).\n\nThe built spec http://facebook.github.io/graphql/ already includes a table of contents, so I believe this diff would create a second redundant one which we want to avoid.\n The TOC is automatically generated by [spec-md](https://github.com/leebyron/spec-md/) so any improvements to the table of contents should be applied to that tool.\n  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n Thank you!\n  Adding the introspection bit is a good idea, but the actual execution of these subscription queries should be intentionally under-defined for now. The spec should make it clear that subscription queries are experimental in a note.\n  Nice work\n  Thanks :)\n  Thanks!\n  I think this would be an awesome project for someone to start up if anyone in the community is looking for ideas.\n Closing this aging issue. \r\n\r\nSeems like the consensus is that field cost alone is not always enough to estimate a query\u2019s cost. Different approaches by different libraries indicate that there are many useful approaches with different trade offs, so there is not much to incorporate into the spec to account for this  I believe `first` and `last` assume positive integers. They should probably throw errors if they're negative. But I agree that you should take this up with https://github.com/facebook/relay\n  I'm a bit confused about your proposal. The concern that this validation error is reporting is that you're using a variable which hasn't been defined. This is very often the result of programmer-error where a variable was spelled incorrectly or added to a fragment but forgot to be defined.\n  I don't think we will consider doing this because GraphQL wishes to be compatible with many languages and so have designed valid identifiers to be that which is common across many popular languages. Unfortunately characters like `$`, `!` and `?` which are legal identifier characters in some languages are not in other popular languages.\n\nIt looks like handling this at the relay layer to ensure that any code that is generating GraphQL identifiers from JavaScript identifiers properly handles the conversion is the correct decision.\n  Support in the JS library itself for arbitrary iterables rather than just Arrays is coming soon.\n\nThere are significant tradeoffs to a Map type vs a list of key/value pairs. One issue is paginating over the collection. Lists of values can have clear pagination rules while Maps which often have non-ordered key-value pairs are much more difficult to paginate.\n\nAnother issue is usage. Most often Map is used within APIs where one field of the value is being indexed, which is in my opinion is an API anti-pattern as indexing is an issue of storage and an issue of client caching but not an issue of transport. This anti-pattern concerns me. While there are some good uses for Maps in APIs, I fear that the common usage will be for these anti-patterns so I'm suggesting proceeding with caution.\n\nFor the original post, I think there are two good ways to solve this API puzzle:\n\nFirst is what @OlegIlyenko suggests. That you explicitly ask for the languages which you care about fetching. If you need multiple you can use aliases to query for multiple. This may be the right path if you know up front which you want to query.\n\n```\nitem {\n  title: title(lang: $custom_lang)\n  title_en: title(lang: \"en\")\n  title_fr: title(lang: \"fr\")\n}\n```\n\nSecond is returning a list of tuples. This may be the right path if you don't know up front which you want, or if you specifically want them all.\n\n```\nitem {\n  titles {\n    language\n    text\n  }\n}\n```\n\nsuch that you might get the result:\n\n```\n\"item\": {\n  \"titles\": [\n    { \"language\": \"en\", text: \"Hello\" },\n    { \"language\": \"fr\", text: \"Bonjour\" }\n  ]\n}\n```\n  Originally proposed by @josephsavona, this allows inline fragments to omit a type condition and thus always be considered for inclusion. If a type condition is omitted, no type refinement is done to the contained fields.\n\nThis enables a new kind of usecase where the only purpose for using an inline fragment is applying a directive to a grouping of fields:\n\n``` graphql\nfragment Foo on Type {\n  fieldA\n  fieldB\n  ... @include(if: $wat) {\n    fieldC\n    fieldD\n  }\n}\n```\n  Based on feedback from those using GraphQL and inspired by RelayQL's syntax, this makes operation names optional.\n\nThe primary value is the ability to express mutations (or eventually subscriptions) without being required to provide a name if the name adds no value for your use case. (Value typically being query disambiguation and logging). Systems which want to enforce a name for queries should have a separate linting/validation rule - such a rule would probably also want to ban \"query shorthand\"\n  Thanks!\n  Thank you for this!\n  The issue is that GraphQL has no way of actually confirming that the data it encounters is not infinitely recursive. Without an ability to make this guarantee, allowing for cyclic queries could in fact expose infinite execution queries which could be used as an attack vector.\n\nAlso - infinite isn't really the only issue here. The other issue is reasonable limits per your application. For the same reason that we suggest using [pagination](http://graphql.org/learn/pagination/) to limit the amount of data fetched when accessing a list of unknown length, we also should be cautious not to fetch at an unknown depth and result in accessing way more information than desired.\n\nTake Reddit as an example since it's close to this hypothetical nested comments example. They don't actually query to an unknown depth when fetching nested comments. Instead, they eventually bottom out with a \"show more comments\" link which can trigger a new query fetch. The technique I illustrated in a prior comment allows for this _maximum_ depth control.\n\nThere's no magic number of 3, the technique can be expanded or shrunken for whatever _maximum_ depth makes sense. For example, here's the same example expanded to fetch up to 8 levels deep:\n\n``` graphql\n{\n  messages {\n    ...CommentsRecursive\n  }\n}\n\nfragment CommentsRecursive on Message {\n  comments {\n    ...CommentFields\n    comments {\n      ...CommentFields\n      comments {\n        ...CommentFields\n        comments {\n          ...CommentFields\n          comments {\n            ...CommentFields\n            comments {\n              ...CommentFields\n              comments {\n                ...CommentFields\n                comments {\n                  ...CommentFields\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfragment CommentFields on Comment {\n  id\n  content\n}\n```\n I agree with you. For now this limitation continues to exist for this balance of simplicity for the common case and protection from inadvertent infinite recursion. Perhaps we can revisit it in the future if a solid proposal to do what you suggest is compelling.\n  This adds the type definition syntax to the GraphQL specification.\r\n\r\nThere are some remaining issues to solve:\r\n- [x] Include reference in Execution chapter about non-executable GraphQL\r\n- [x] Description is not yet represented\r\n- [x] Deprecation is not yet represented\r\n- [x] Directives are not yet represented\r\n- [x] Top level Schema is not yet represented\r\n- [x] Investigate impact on validation rules\r\n- [x] Decide on _any_ or _many_ rules for type fields / enum values\r\n- [x] Combine into type system chapter\r\n- [x] Consider separating into two top level grammars\r\n- [x] Solve ambiguity for extending interfaces (https://github.com/graphql/graphql-js/pull/1166) Proposal for schema:\n\n```\nschema {\n  query: QueryType\n  mutation: MutationType\n}\n```\n\n```\nSchemaDefinition : schema { OperationTypeDefinition+ }\nOperationTypeDefinition : OperationType : NamedType\n```\n @exogen - developer ergonomics are better specifically because descriptions are often multiple lines and include markdown syntax. Embedding that into a directive would make reading the schema language much more difficult, and legibility is primarily important.\n\nFor example, the description appearing before the `__TypeKind` introspection type in graphql-js:\n\n``` graphql\n# The fundamental unit of any GraphQL Schema is the type. There are many kinds of\n# types in GraphQL as represented by the `__TypeKind` enum.\n#\n# Depending on the kind of a type, certain fields describe information about that\n# type. Scalar types provide no information beyond a name and description, while\n# Enum types provide their values. Object and Interface types provide the fields\n# they describe. Abstract types, Union and Interface, provide the Object types\n# possible at runtime. List and NonNull types compose other types.\ntype __Type {\n  kind: __TypeKind!\n  name: String\n  description: String\n  fields(includeDeprecated: Boolean = false): [__Field!]\n  interfaces: [__Type!]\n  possibleTypes: [__Type!]\n  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n  inputFields: [__InputValue!]\n  ofType: __Type\n}\n```\n\nVs\n\n``` graphql\ntype __Type @description(msg: \"The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\\n\\n Depending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.\") {\n  kind: __TypeKind!\n  name: String\n  description: String\n  fields(includeDeprecated: Boolean = false): [__Field!]\n  interfaces: [__Type!]\n  possibleTypes: [__Type!]\n  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]\n  inputFields: [__InputValue!]\n  ofType: __Type\n}\n```\n It's also not too late to introduce a new kind of token for descriptions. There are certainly pros and cons to using comments for this.\n\nPros:\n- It follows prior art. Comments in source code as descriptions for the following declaration is prevalent in almost every programming language. Nearly every popular language has some tool which consumes these comments to use as documentation.\n- It's obvious, making it easy to fall into [the pit of success](https://blogs.msdn.microsoft.com/brada/2003/10/02/the-pit-of-success/) - essentially there is no other obvious way to add descriptions, and the reasonable assumption of just putting them in comments \"just works\".\n- It minimizes additional syntax to the language. In fact, no additional syntax is necessary. This is beneficial for interoperation with existing tools.\n- For tools which don't care about descriptions, they can be safely treated only as comments.\n\nCons:\n- Parsers need to be more sophisticated and cannot simply skip over comments but instead need to track which comment lines appear before which definitions so they can be interpreted as descriptions.\n- There is potential for ambiguity where commenting out lines could cause them to be misinterpreted as a description for the following line.\n- Actual comments (ignored) need to be separated from descriptions (currently proposed via an empty line)\n\nOther proposals suggest a different leading character, similar to comments:\n\n```\n# comment\n## description\n## using `##` chars\ntype SomeType {\n  field: String\n}\n```\n\nOr\n\n```\n# comment\n% description\n% using `%` char\ntype SomeType {\n  field: String\n}\n```\n\nAnother option is to use something like a [docstring](https://en.wikipedia.org/wiki/Docstring):\n\n```\n\"\"\"\nThis is a python-inspired doc string style description\n\"\"\"\ntype SomeType {\n  field: String\n}\n```\n\nOr\n\n```\n###\nSimilar style, perhaps interpreted as a multi-line comment\n###\ntype SomeType {\n  field: String\n}\n```\n > I would vote for parser friendly solution.\n\nI disagree. We should be aiming for whatever will have the best developer experience. Parsers are written rarely and by people who are capable and can write tests. Schema in the language will be written far more often and by a broader set of people. That's what we should be optimizing for, and that's why most of the \"pros\" for using comments center around ergonomics and being the most obvious.\n Using comments for descriptions has a lot of advantages, but we'll need to decide if it's worth these drawbacks:\n- There is potential for ambiguity where commenting out lines could cause them to be misinterpreted as a description for the following line.\n- Actual comments (ignored) need to be separated from descriptions (currently proposed via an empty line)\n\nUsing some other mechanism for adding descriptions can solve these, but could reduce the benefits of using comment lines or add drawbacks of their own.\n\nThe drawbacks for `##` is that it's easy to get wrong and miss a `##` for a `#` and accidentally lose a documentation. It adds some ambiguity with comments, and I could careless commenting out of lines repeatedly converting a `#` into a `##` and falling into the same drawbacks.\n\nThe drawbacks for `%` is that it consumes a punctuator not in use (those are fairly precious) and it's not particularly easy to remember, nor is there much precedence for such a documentation scheme in modern languages so it's more to learn for newcomers.\n\nMulti-line comments and Doc-strings are both interesting to me in that while they're maybe slightly less ergonomic, they may add additional value elsewhere (though not in a way that solves a real need at the moment)\n\n**Multi-line comments**:\n\nThis adds two different comment forms to GraphQL. I originally avoided this in the sake of simplicity. Any multi-line comment can be easily represented as multiple single-line comments.\n\n``` graphql\n###\nMulti \nline \ndescription\n###\ntype Foo {\n  bar: String\n}\n```\n\nPerhaps there's some value in including them, even if only for this use case. Though I think they still suffer from the same drawbacks of single-line comments, just to a lesser degree. \n\n**Doc-strings** would really be doing two things: \n- Adding a new kind of multi-line string literal that presumably could be used anywhere string literals are used today. \n- Optionally parsing `String` before parsing anything that may have a description.\n\nThat's interesting in that very short descriptions could be inline with typical string literals:\n\n``` graphql\n\"\"\"\nMultiline string \ndescription of Foo\n\"\"\"\ntype Foo {\n  \"Short description of a bar field\"\n  bar(\"arg described inline\" arg: Int): String\n}\n```\n\nAdding this multiline string literal probably otherwise had only minor value, but one use case that comes to mind is deprecation warnings:\n\n``` graphql\ntype Foo {\n  bar @deprecated(reason: \"\"\"\n    There's a lengthy reason why bar is deprecated\n    that takes multiple lines to fully describe, and\n    fitting into a single line string literal would be illegible\n    \"\"\")\n}\n```\n\nI think that's a pretty interesting use for multi-line strings and brings some parity between descriptions and deprecation reasons.\n\nThe drawbacks of strings as descriptions I think is mostly ergonomic. \n\nComments can include any characters while strings need to escape some characters, it could definitely be the case that quote marks appear in some descriptions.\n\nIt's also less obvious that you should use a string literal instead of a comment to describe something. Instead newcomers to the language may see that string and be curious how it's affecting the schema. This is a common drawback to docstrings in languages like Python and Clojure - it's easy for those less familiar with the language to misinterpret the strings a important to runtime behavior and become confused.\n I like the docstring approach as well, but I do think it's important to be sober about the drawbacks.\n\n> Maybe I'm misunderstanding what you mean by \"runtime behavior\" though.\n\nFor example:\n\n``` clojure\n(defn myFn\n  \"Some fn\"\n  [x]\n  (doSomethingWith x))\n```\n\nIf you weren't familiar with clojure, you might encounter this and be curious how this argument to the `defn` function was being interpreted and used at runtime or perhaps how it might affect performance or API design. Only once you become more familiar would you realize that `defn` is a macro, not a function, and that none of those early concerns apply.\n\nIt's mostly about matching existing mental models. I think if we've been docstring documenting our stuff since the 70's that this sort of thing would be obvious to all of us, and confusion wouldn't be a drawback.\n\nFor GraphQL I think the same thing applies:\n\n``` graphql\ntype Foo {\n  bar(\"this is an argument\" arg: String): String\n}\n```\n\nIs that string literal another argument in some way? Is it some hint to `bar`? Is it the default value for `arg`? If that string gets longer will it affect performance? I think it's totally reasonable to expect some portion of people who encounter this for the first time to be confused with these sorts of questions or probably others I haven't thought of.\n > That kind of seems to ruin the idea of ignoring whitespace.\n\nYeah it's definitely a drawback of the approach.\n @vergenzt - I think that's certainly a topic worth discussion.\r\n\r\nCurrently it's not uncommon for client codebases to define both their schema extensions and set of definitions across the same documents. We would expect these definitions to be separated by tooling before validation and execution.  Good feedback, @OlegIlyenko. I still had some reservations about the any/many fields in field sets. My previous understanding was that the use cause for empty fields was for type extensions, where an extension sought to add a directive or interface and no additional fields.\r\n\r\nA minor concern is consistency with the rest of the grammar. For example [SelectionSet](http://facebook.github.io/graphql/draft/#SelectionSet) and [Arguments](http://facebook.github.io/graphql/draft/#Arguments) and [VariableDefinitions](http://facebook.github.io/graphql/draft/#VariableDefinitions) share this property of requiring the grammar to have non-empty lists - similarly these could be validation rules instead, however requiring them in the grammar ensures unambiguous text.\r\n\r\nAnother use case I've come across (and one I personally wouldn't advocate, but people seem to find value in it) is to define a type with no fields followed by numerous extensions:\r\n\r\n```graphql\r\ntype Example {}\r\nextend type Example {\r\n  foo: String\r\n}\r\nextend type Example {\r\n  bar: Int\r\n}\r\n```\r\n\r\nThis pattern seems to reduce the legibility of the document, however it certainly still seems semantically valid and unambiguous in its entirety.\r\n\r\nWhile these use cases for empty field sets are not particularly compelling to me personally, I think the strongest argument is simply that people are already using them and smoothing the migration path from the experimental SDL to the spec SDL is valuable in its own right, and it's the cost we pay for experimenting in the open. I like that suggestion, @OlegIlyenko. That formulation almost makes it more immediately apparent that no fields are defined rather than an empty set being defined. However one drawback is that it still presents a breaking change against the experimental SDL, however at least it is very easy to fix by simply removing `{}` Thanks for the review @vergenzt! I'll go through and address the issues you spotted!  Thanks\n  Closing this aging issue  Just wanted to add that a blog post was written on this topic as well: http://graphql.org/blog/subscriptions-in-graphql-and-relay/\n\nSubscriptions is one piece of a larger topic of live data and asynchronicity that we plan on covering in the future with GraphQL. There are already experiments underway to better understand what the right decisions will be.\n  Can you share the introspection query in particular? GraphQL does not have a concept of keyed sets or maps, only lists, so I'm a little confused with the issue.\n\ninputFields and fields have different names in introspection because they return different types. Since introspection uses one simplified and flattened \"__Type\" type that can represent all of the types in a type system, it needs differently named fields to refer to these two different concepts. \n No problem, this has been good feedback!\n  Thanks for pointing this out! I just re-wrote this section to be more clear, I hope it helps.\n  This proposal adds a null literal to the GraphQL language and allows it to be provided to nullable typed arguments and input object fields.\n\nThis presents an opportunity for a GraphQL service to interpret the explicitly provided null differently from the implicitly not-provided value, which may be especially useful when performing mutations using a per-field set API.\n\nFor example, this query may represent the removal/clearing of the \"bar\" field from thing with id: 4.\n\n```\nmutation editThing {\n  editThing(id: 4, edits: { foo: \"added\", bar: null }) {\n    # ...\n  }\n}\n```\n\nIn addition to allowing `null` as a literal value, this also proposes interpretting the variables JSON to distinguish between explicit null and implicit not provided:\n\n```\nmutation editThing($edits: EditObj) {\n  editThing(id: 4, edits: $edits) {\n    # ...\n  }\n}\n```\n\nThis variables results in the unsetting of `bar`\n\n```\n{ \"edits\": { \"foo\": \"added\", \"bar\": null } }\n```\n\nFinally, this proposes following the not-provided-ness of variables to their positions in arguments and input-obj fields\n\n```\nmutation editThing($editBaz: String) {\n  editThing(id: 4, edits: { foo: \"added\", bar: null, baz: $editBaz }) {\n    # ...\n  }\n}\n```\n\nSuch that the three variables are semantically different:\n- `{}` The \"baz\" input field is \"not provided\"\n- `{\"editBaz\": null}` The \"baz\" input field is `null`\n- `{\"editBaz\": \"added\"}` The \"baz\" input field is `\"added\"`\n cc @dschafer @schrockn \n >  I think this behavior would surprise most people, and in fact I don't even think most implementations behave like this. \n\nThanks for this feedback - I agree that it's easy to misinterpret the spec in this way - the way implementations behave is spec compliant so your suggestion is really just to clarify how things are supposed to work rather than being a change. I'll make it happen.\n @jbinto - graphql-js should be compliant and if not is a bug. Please feel free to file a bug there or open a PR with a failing test case if you've found one!\n Rebased this just now. For reviewers, here's what this looks like https://ns-ykdwgdukwo.now.sh/\n Just got a careful review from @dschafer offline - so merging this now.\n  We're working on richer documentation which will definitely cover mutations further.\n Closing this individual task - but the work there continues, stay tuned!\n  Thanks, next time feel free to submit a PR!\n https://graphql-slack.herokuapp.com/\n  This would be a great task to claim for an aspiring contributor.\n IntelliJ would be great\n  `CompleteValue` is missing reference to abstract type resolution.\n\nThanks to @seanchas for the careful read and highlighting this issue.\n  I would prefer not to do this. While it helps clarity when viewed in Github, it makes the text files themselves a bit harder to read.\n Thanks for the exploration though!\n  Thanks!\n  It wasn't included because it's not available across all platforms, most importantly and practically in our case: JavaScript. \n\nThe GraphQL spec does not specify a maximum byte width or storage size for its Int and Float type, but there is a note about the caveat of platform specific restrictions. The two types only represent the semantic difference between whole and part numbers. \n\nThis means that you can use Int as a Long or Float as a Double as long as the platforms you're using support that size. \n\nGraphQL allows you to define custom scalars as well, in the case that you want to distinguish between Long and Int, or define a custom serialization for it. \n\nCustom scalars is how we expect these kinds of desired Scalars to be introduced in a way that doesn't burden spec-following GraphQL core libraries. \n Sorry I may be quoting outdated information. It appears you are correct that we decided on stricter language for the spec out of concern for the exact reasons you brought up. I believe the JavaScript reference implementation is more lenient and allows up to 52bit Int (the max JS number type can represent)\n This is intentional. Note that the same is true for many programming languages including JavaScript. You can type a number in syntax that's larger than what the underlying memory can represent. \n\nIn GraphQL's case it's also useful for exactly what you mentioned: being able to create custom scalars which represent large numbers. \n However the Int scalar type does enforce 32bit both in spec and the reference implementation to be maximally compatible. \n  Thanks, for opening this. I'm renaming the task to use the terminology we have been using to talk about this.\n\nWe agree that this is really important, but are not yet actively working on it.\n > do you already have an idea which form it will take?\n\nSort of. \n\nI think it will specify a schema to implement, along with a data set to use. Ideally this schema is as small as possible while still illustrating every feature of GraphiQL and supporting all of the acceptance tests. Ideally this schema is written in the GraphQL Type DSL so it is easy to understand.\n\nThen there should be a list of \"tests\" where each test includes the following:\n- Description: what is this test testing and why\n- Query: a document to submit to the GraphQL service\n- Response: The response expected from the GraphQL service\n\nThen optionally also include Variables and OperationName when those are relevant to a test.\n\nThis form should allow us to test everything from parser corner cases and proper detection and reporting of syntax errors, to validation errors for all the rules we specify, to execution behavior.\n > I guess implementing something like this can be a challenging task, considering that it suppose to test implementations written in different languages.\n\nIdeally, the form I wrote above only needs to be written once and can leverage the fact that the GraphQL language is represented as a string independent of any one backend language and the output can be serialized to JSON.\n\nHowever the provided schema still needs to be implemented by that backend. Either by interpreting the GraphQL Type DSL or by manually implementing it. Hopefully that is not too much of a burden. \n\nHowever overall I would certainly rate this task as \"challenging\" :D\n  Thanks for the suggestion - I'll forward this to someone on our team who knows more about licensing.\n  Thanks for this feedback. This is a lot, so let me try to address each point.\n\nFor colons in the type definition field arguments and variable definitions, we're hoping to do two things:\n1. Create a visual mirroring between the definition of the field arguments and the usage of them.\n2. More importantly, leverage existing knowledge of other languages where syntax works this way: Flow, TypeScript, Swift, amidst others.\n\n>  is the dollar sign really required? \n\nYes, it syntactically avoids an ambiguity between a possible enum values and variables.\n\n```\nenum Color {\n  red\n  green\n  blue\n}\n\nquery coloredThing($color: Color) {\n  variableThing: thing(color: $color)\n  redThing: thing(color: red)\n}\n```\n\nAlso, variables have a different frequency and importance in a query language than they do in a programming language. When using a programming language, variables are often the most common token you use, so keeping them unadorned is important for legibility. In query languages, however, variables are fairly rare relative to data description identifiers. When variables are used, it's important to visually highlight them so that it's clear. We use the `$` sigil as a way to visually identify variables.\n  Moves the source files into their own directory, to clarify to someone just looking at the top level directory that they are source files and not designed to be read.\n  This was the subject of considerable internal debate prior to the release of the spec, so it's definitely a discussion worth having, thanks for raising it! A few things came up when we were considering this that convinced us nullability by default was a reasonable call.\n\nBecause the type system on a GraphQL server is application-specific, not feature-specific, it can be difficult to provide universally valid default values. For example, what's the right behavior if someone's profile picture fails to load? In some features, it might be to replace it with a default silhouette; in others it might be to omit the person from the list. The correct behavior in the presence of an error is dependent not on the field, but on the feature, and only the client knows about the feature. By making the field be nullable and providing an error indicating that we nulled this field out because of the error, the feature can handle it as it sees fit.\n\nEspecially as queries and type systems grow, the probability that _something_ will go wrong in the backend increases, and we need some way of handling that and expressing that in the query. The entirety of news feed for Facebook is powered by one GraphQL query, and there are a number of places where a backend system might (for any number of reasons) not be able to provide a result for a field. In a system where things are non-null by default, this could mean that a backend failure at a leaf node deep in the tree causes the entire query to fail.\n\nTo be clear, though: while nullable fields is a feature of GraphQL (and one that we think is valuable), it's _absolutely_ not a requirement of it. Non-null fields and nullable fields are both first class citizens of GraphQL. We had to choose one to be the default, though, and based on the above, we chose nullable.\n Closing this task now.\n  Updates the README with a more clear `hero` field, that takes an argument. This matches the changes in https://github.com/graphql/graphql-js/pull/70.\n  Thanks!\n  Thanks!\n  Thanks!\n  Thanks!\n  Good find!\n\nBased on https://github.com/graphql/graphql-js/blob/master/src/validator/__tests__/harness.js#L38-43, I think we should probably remove `nickname` from `Pet`, which will make this example invalid again, and demonstrate the case it was trying to establish (even if all of the implementations have a field, it is still not valid to query it if the interface doesn't).\n Thanks!\n  > For example what is the expected answer for this graphql query (dumb query just for the example):\n\nWe'd describe that as a `Document` at the parser layer that contains two `Operation`s: `LukeAndLeiaNames` and `LukeAndLeiaHomePlanet`.\n\nWhen executing, we need to know which `Operation` to run; http://facebook.github.io/graphql/#sec-Evaluating-requests covers this in the spec and https://github.com/graphql/graphql-js/blob/master/src/executor/executor.js#L162-168 in the reference implementation.\n\nIf you only have one operation in a `Document`, the common case, then it's implied to run that one. If you have more than one, you specify which operation to run in a given execution.\n\nHope this helps!\n > What do I get in response from the server?\n\nAn error. The `Document` contained multiple operations and the client didn't specify which one to run. If you wanted to send that document and run one specific query, you could pass an `operationName` parameter.\n\nThe spec:\n\n> To evaluate a request, the executor must have a parsed Document (as defined in the \u201cQuery Language\u201d part of this spec) and a selected operation name to run.\n> \n> The executor should find the Operation in the Document with the given operation name. If no such operation exists, the executor should throw an error. If the operation is found, then the result of evaluating the request should be the result of evaluating the operation according to the \u201cEvaluating operations\u201d section.\n\nIn our reference implementation, we implemented a helper where if there's only one operation in the document, it's implied that the operation name is the name of that operation (since that simplifies the common case). But you can't run multiple queries in the same request; if that's the desired behavior, a single query that combines them can be run instead. With fragments, that would become simple:\n\n```\nquery LukeAndLeiaNames {\n    ...LukeAndLeiaNamesFragment\n}\n\nfragment LukeAndLeiaNamesFragment on Query {\n    luke: human(id: \"1000\") {\n        name\n    }\n    leia: human(id: \"1003\") {\n        name\n    }\n}\n\nquery LukeAndLeiaHomePlanet {\n    ...LukeAndLeiaHomePlanetFragment\n}\n\nfragment LukeAndLeiaHomePlanetFragment on Query {\n    luke: human(id: \"1000\") {\n        homePlanet\n    }\n    leia: human(id: \"1003\") {\n        homePlanet\n    }\n}\n\nquery LukeAndLeiaBoth {\n    ...LukeAndLeiaHomePlanetFragment\n    ...LukeAndLeiaNamesFragment\n}\n```\n > And to finish: how the client is supposed to send which operation to run if there are many operations in the document ?\n\nUp to the server; the reference implementation just has the `operationName` as another parameter, so I could imagine having a HTTP Param for the operation name.\n\n> Until now I imagined graphql as a simple GraphQLQuery => Server => Response behavior. The client sending its query in string at a server endpoint. So I'm a bit disappointed by this many-operations document :-/\n\nThis is definitely the right way to think about things; a Document is just an additional concept that can contain many GraphQLQueries. If you send a document with only one query, then graphql is just QueryInDocument => Server => Response. If the document has many queries, then you specify a query so that we can go Document => Query => Server => Response\n\n> So now what wonder me is... what's the point of having a document that can contains many operations ?\n\nThe use is threefold:\n1. It's often useful to store GraphQL documents in a client side file; we use `.graphql` files on iOS and Android for this. We wanted the parser to work on these files as well (so the parser is universal), but you can (and we often do) include multiple queries in a single document. \n2. One optimization that can be made (and that we'll discuss in more detail in the future, I'm sure) is \"persisting\" documents; you send the document to the server who stores it for you and gives you an identifier for that, that way you don't have to send the whole document string up every time. If you do that, you can send a document up with all your queries, and then pass the document ID + operation name over the wire. This would optimize bytes being sent from the client to the server.\n3. It's possible to write a \"batch\" API for GraphQL, where you use the results from one query as the parameters to another. We're still working out the exact details there, but if you do that, it's useful to specify multiple queries in a single document; you'd specify which one you wanted to run at the start and the relationships between them.\n\nYou're absolutely correct that in the model we describe (pass a string to the server, get a response back), a Document with multiple operations isn't that useful; we wanted to permit it for the reasons described above.\n Thanks for the great questions!\n  Thanks! \n  Good catch! We'll make sure to fix this!\n  Thanks!\n  Thanks!\n  Thanks!\n  @graue Yep, we're definitely planning on doing so!\n  Closing this thread since this discussion should be driven from loopback and there's no action to be taken from this repo.\n See https://github.com/strongloop/loopback/issues/1841\n", "text_all_count": 24249, "text_word_token": ["AFAIK", "the", "spec", "doesn", "t", "prevent", "null", "or", "and", "there", "be", "only", "one", "relevant", "place", "on", "how", "variables", "be", "handle", "LINK", "CoerceVariableValues", "So", "de", "jure", "even", "foo", "bar", "be", "valid", "NUMBER", "iamclaytonray", "GraphQL", "already", "support", "full", "CommonMark", "a", "dialect", "of", "Markdown", "LINK", "sec", "Descriptions", "To", "allow", "GraphQL", "service", "designers", "to", "easily", "publish", "documentation", "alongside", "the", "capabilities", "of", "a", "GraphQL", "service", "GraphQL", "descriptions", "be", "defined", "use", "the", "Markdown", "syntax", "as", "specified", "by", "CommonMark", "NUMBER", "Note", "that", "SDL", "syntax", "was", "change", "during", "preparation", "for", "public", "release", "so", "in", "final", "version", "you", "need", "to", "use", "description", "strings", "instead", "of", "comments", "and", "now", "comments", "be", "just", "comments", "graphql", "enum", "MessageStatus", "If", "a", "message", "could", "not", "successfully", "be", "delivered", "NUMBER", "Failed", "If", "a", "message", "was", "successfully", "delivered", "but", "_has", "not", "been_", "read", "by", "the", "other", "user", "s", "NUMBER", "Delivered", "TODO", "add", "write", "If", "a", "message", "was", "successfully", "delivered", "and", "_has", "been_", "read", "by", "the", "other", "user", "s", "NUMBER", "Read", "Changed", "from", "or", "integer", "such", "as", "NUMBER", "input", "value", "to", "or", "non", "negative", "integer", "such", "as", "NUMBER", "or", "NUMBER", "input", "value", "OlegIlyenko", "Looks", "like", "negative", "IDs", "be", "a", "thing", "LINK", "be", "negative", "keys", "use", "for", "In", "this", "case", "I", "think", "the", "specification", "should", "have", "an", "example", "of", "such", "conversion", "to", "show", "that", "this", "be", "intentional", "behavior", "NUMBER", "I", "change", "PR", "to", "or", "integer", "such", "as", "NUMBER", "or", "NUMBER", "input", "value", "liweinan", "NUMBER", "Because", "A", "Za", "z", "NUMBER", "NUMBER", "_", "be", "the", "only", "characters", "that", "support", "in", "all", "environments", "NUMBER", "For", "example", "the", "majority", "of", "programming", "languages", "don", "t", "support", "inside", "property", "names", "so", "it", "will", "make", "code", "typings", "generation", "harder", "NUMBER", "liweinan", "NUMBER", "Using", "dash", "definitely", "makes", "sense", "for", "locale", "names", "but", "off", "the", "top", "of", "my", "head", "I", "can", "t", "come", "up", "with", "any", "other", "domain", "where", "the", "dash", "be", "an", "essential", "part", "of", "terminology", "NUMBER", "At", "the", "same", "time", "it", "s", "very", "easy", "to", "give", "an", "example", "of", "some", "other", "domain", "where", "other", "symbols", "be", "essential", "e", "NUMBER", "g", "NUMBER", "MIME", "types", "as", "field", "name", "also", "make", "sense", "data", "application", "json", "data", "in", "JSON", "format", "application", "xml", "data", "in", "XML", "format", "So", "real", "question", "here", "should", "we", "support", "bigger", "subset", "of", "ASCII", "range", "or", "not", "And", "I", "personally", "think", "it", "s", "not", "worth", "add", "complexity", "and", "we", "should", "stick", "with", "biggest", "common", "denominator", "in", "form", "of", "_A", "Za", "z", "_", "NUMBER", "NUMBER", "A", "Za", "z", "NUMBER", "liweinan", "NUMBER", "Can", "I", "close", "this", "issue", "Given", "that", "Mutations", "and", "Subscriptions", "only", "comprise", "a", "couple", "sections", "of", "the", "spec", "I", "m", "not", "sure", "remove", "them", "into", "separate", "spec", "document", "accomplishes", "anything", "of", "value", "NUMBER", "Are", "you", "concerned", "that", "your", "GraphQL", "implementation", "be", "not", "spec", "compliant", "because", "it", "do", "not", "include", "mutations", "or", "subscriptions", "LINK", "sec", "Root", "Operation", "Types", "claims", "that", "Mutation", "and", "Subscription", "types", "be", "not", "required", "in", "a", "GraphQL", "service", "This", "might", "also", "be", "a", "challenge", "since", "aspects", "of", "GraphQL", "like", "Introspection", "make", "reference", "to", "mutation", "and", "subscription", "root", "types", "presumably", "any", "service", "even", "if", "only", "support", "queries", "would", "need", "to", "respond", "well", "to", "introspection", "queries", "that", "reference", "these", "I", "m", "also", "a", "big", "fan", "of", "PEP", "and", "the", "additive", "nature", "of", "spec", "proposals", "as", "they", "gain", "adoption", "NUMBER", "In", "fact", "we", "ve", "be", "following", "a", "relate", "process", "with", "RFC", "documents", "NUMBER", "Subscriptions", "went", "through", "this", "process", "and", "was", "an", "RFC", "only", "for", "almost", "NUMBER", "years", "before", "be", "add", "to", "the", "spec", "with", "minimal", "requirements", "NUMBER", "Another", "good", "example", "be", "the", "GraphQLHTTP", "spec", "which", "be", "intended", "to", "forever", "be", "a", "separate", "document", "NUMBER", "What", "I", "m", "more", "skeptical", "about", "be", "backwards", "breaking", "change", "that", "remove", "functionality", "from", "the", "current", "spec", "into", "separate", "documents", "without", "a", "highly", "compelling", "reason", "to", "do", "so", "NUMBER", "In", "this", "case", "what", "I", "mean", "by", "highly", "compelling", "be", "that", "it", "should", "unlock", "the", "ability", "to", "do", "something", "that", "be", "currently", "not", "possible", "today", "NUMBER", "If", "it", "do", "not", "do", "at", "least", "that", "then", "we", "re", "looking", "at", "pure", "cost", "breaking", "change", "harder", "to", "read", "spec", "more", "opportunity", "for", "ambiguity", "with", "only", "theoretical", "benefit", "of", "creating", "modular", "concepts", "NUMBER", "I", "m", "not", "excited", "to", "put", "in", "the", "work", "for", "something", "that", "be", "net", "costly", "instead", "of", "net", "beneficial", "NUMBER", "This", "was", "an", "intentional", "decision", "to", "balance", "between", "expressiveness", "and", "complexity", "NUMBER", "While", "the", "subject", "of", "your", "proposal", "be", "absolutely", "true", "we", "cannot", "communicate", "the", "difference", "between", "optionality", "and", "nullability", "in", "input", "types", "our", "previous", "discussions", "have", "determined", "that", "this", "be", "a", "reasonable", "cost", "for", "the", "benefit", "of", "avoiding", "the", "additional", "syntax", "you", "ve", "suggested", "and", "avoiding", "multiplication", "of", "possible", "state", "an", "input", "object", "can", "be", "in", "NUMBER", "In", "doing", "so", "we", "ve", "left", "this", "sort", "of", "additional", "behavior", "of", "how", "to", "treat", "scenarios", "where", "required", "null", "or", "optional", "nonnull", "up", "to", "the", "much", "fewer", "services", "which", "require", "these", "NUMBER", "In", "your", "particular", "scenario", "I", "think", "you", "can", "add", "exactly", "what", "you", "re", "suggesting", "to", "your", "server", "especially", "since", "you", "say", "that", "all", "mutations", "behave", "as", "full", "overwrite", "NUMBER", "I", "would", "suggest", "add", "additional", "validation", "rules", "or", "throw", "additional", "coercion", "error", "relevant", "to", "the", "types", "where", "the", "ambiguity", "could", "result", "in", "unexpect", "results", "NUMBER", "Maybe", "you", "have", "some", "good", "examples", "of", "non", "standard", "directives", "that", "be", "widely", "use", "and", "either", "need", "to", "be", "unique", "or", "non", "unique", "would", "be", "interesting", "to", "compare", "both", "cases", "NUMBER", "OlegIlyenko", "In", "majority", "of", "cases", "directives", "be", "use", "to", "attach", "additional", "metadata", "to", "the", "SDL", "entity", "like", "scopes", "cacheControl", "LINK", "hints", "to", "schema", "etc", "NUMBER", "So", "if", "you", "makes", "such", "directive", "non", "unique", "by", "default", "it", "could", "be", "breaking", "change", "for", "some", "implementations", "NUMBER", "A", "few", "examples", "of", "unique", "directives", "from", "my", "own", "tool", "would", "be", "fake", "from", "graphql", "faker", "and", "_", "from", "graphql", "lodash", "NUMBER", "I", "think", "the", "reason", "I", "use", "unique", "directive", "NUMBER", "syntax", "be", "because", "it", "makes", "presence", "of", "an", "additional", "constraint", "on", "directives", "explicit", "NUMBER", "If", "we", "decide", "to", "add", "unique", "prefix", "to", "any", "other", "top", "level", "keyword", "it", "will", "require", "non", "trivial", "change", "to", "parser", "and", "make", "parser", "more", "complex", "overall", "NUMBER", "For", "me", "personally", "it", "be", "more", "intuitive", "to", "assume", "that", "without", "any", "explicitly", "stated", "information", "the", "entity", "be", "unconstrained", "NUMBER", "SQL", "DDL", "be", "one", "example", "of", "this", "approach", "NUMBER", "As", "well", "as", "the", "GraphQL", "itself", "where", "you", "need", "to", "put", "an", "explicit", "to", "add", "extra", "not", "null", "constraint", "on", "the", "field", "NUMBER", "In", "case", "of", "describing", "constrains", "on", "data", "I", "totally", "agree", "with", "you", "that", "everything", "should", "be", "unconstrained", "by", "default", "NUMBER", "But", "directives", "be", "intended", "as", "GraphQL", "language", "extensions", "and", "in", "language", "specification", "keywords", "constructs", "be", "unique", "by", "default", "NUMBER", "Also", "in", "my", "experience", "directives", "be", "very", "rarely", "authored", "in", "the", "SDL", "NUMBER", "Not", "sure", "about", "other", "language", "but", "in", "JS", "it", "looks", "like", "defining", "directives", "in", "SDL", "be", "quite", "popular", "approach", "LINK", "tool", "schema", "directives", "NUMBER", "html", "Uppercasing", "strings", "A", "few", "more", "examples", "from", "my", "own", "source", "code", "LINK", "guru", "graphql", "faker", "blob", "master", "src", "fake_definition", "NUMBER", "graphql", "L", "NUMBER", "LINK", "guru", "graphql", "lodash", "blob", "master", "src", "lodash_idl", "NUMBER", "ts", "L", "NUMBER", "mjmahone", "I", "like", "repeatable", "graphql", "directive", "example", "repeatable", "on", "OBJECT", "INTERFACE", "I", "also", "wonder", "if", "instead", "of", "add", "a", "language", "keyword", "we", "should", "instead", "allow", "directives", "on", "directive", "definitions", "It", "creates", "one", "more", "source", "of", "recursion", "in", "GraphQL", "schema", "and", "requires", "to", "add", "additional", "validation", "rules", "NUMBER", "I", "think", "to", "keep", "specification", "simple", "and", "straightforward", "we", "need", "to", "add", "such", "features", "only", "based", "on", "real", "life", "use", "cases", "NUMBER", "As", "for", "repeatable", "in", "particular", "I", "think", "it", "better", "suited", "for", "keyword", "because", "NUMBER", "it", "doesn", "t", "accept", "argument", "NUMBER", "in", "the", "position", "that", "you", "propose", "it", "will", "look", "strange", "for", "directives", "without", "argument", "directive", "test", "repeatable", "on", "QUERY", "NUMBER", "it", "only", "applies", "to", "directive", "definitions", "and", "that", "means", "repetable", "became", "reserved", "for", "all", "other", "locations", "NUMBER", "This", "why", "I", "think", "deprecate", "make", "sense", "as", "a", "directive", "but", "it", "better", "to", "specify", "repeatable", "as", "a", "keyword", "NUMBER", "Thankss", "fore", "the", "kareful", "reed", "Thanks", "for", "putting", "this", "up", "I", "ll", "add", "it", "as", "an", "agenda", "item", "for", "next", "week", "s", "WG", "session", "since", "it", "s", "notable", "Hey", "all", "sorry", "for", "the", "delayed", "response", "NUMBER", "I", "was", "actually", "about", "to", "add", "a", "comment", "with", "support", "and", "work", "on", "the", "merge", "but", "I", "see", "mjmahone", "already", "push", "forward", "we", "had", "spoken", "about", "a", "plan", "for", "this", "PR", "offline", "first", "NUMBER", "Since", "a", "primary", "goal", "in", "future", "editions", "of", "the", "spec", "be", "to", "limit", "breaking", "previously", "spec", "complaint", "implementations", "and", "that", "this", "particular", "change", "cause", "issue", "with", "both", "Facebook", "s", "implementation", "and", "OlegIlyenko", "s", "I", "think", "that", "be", "merit", "enough", "to", "roll", "back", "the", "change", "NUMBER", "I", "also", "think", "there", "be", "likely", "to", "be", "cases", "during", "active", "development", "of", "a", "GraphQL", "API", "where", "an", "interface", "be", "use", "as", "a", "placeholder", "describing", "future", "types", "which", "do", "not", "yet", "exist", "a", "legitimate", "scenario", "where", "NUMBER", "implement", "types", "could", "still", "result", "in", "a", "work", "schema", "NUMBER", "Because", "we", "ve", "be", "talking", "in", "the", "WG", "sessions", "about", "cutting", "the", "spec", "release", "test", "release", "candidates", "of", "GraphQL", "NUMBER", "js", "was", "a", "priority", "which", "helped", "expose", "this", "issue", "so", "merge", "this", "in", "an", "expedited", "way", "makes", "sense", "we", "d", "rather", "not", "introduce", "a", "new", "rule", "in", "the", "next", "release", "spec", "we", "knew", "was", "problematic", "NUMBER", "Additionally", "we", "knew", "that", "some", "variation", "of", "this", "rule", "might", "still", "make", "sense", "and", "wanted", "to", "leave", "open", "discussion", "around", "re", "introduce", "the", "rule", "to", "provide", "value", "while", "limiting", "the", "identified", "costs", "NUMBER", "That", "was", "the", "reason", "for", "open", "NUMBER", "schema", "definition", "language", "be", "synonymous", "and", "fine", "to", "continue", "to", "use", "as", "be", "SDL", "when", "discussing", "but", "type", "system", "definition", "language", "was", "more", "specifically", "correct", "relative", "to", "the", "rest", "of", "the", "document", "s", "use", "of", "the", "terminology", "I", "don", "t", "think", "we", "need", "an", "acronym", "abbreviation", "since", "we", "don", "t", "use", "abbreviations", "within", "the", "spec", "I", "think", "talking", "about", "it", "as", "SDL", "in", "discussion", "be", "still", "clear", "Agreed", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "mailto", "cla", "fb", "NUMBER", "com", "subject", "CLA", "NUMBER", "for", "NUMBER", "facebook", "NUMBER", "Fgraphql", "NUMBER", "NUMBER", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Great", "edit", "thank", "you", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "mailto", "cla", "fb", "NUMBER", "com", "subject", "CLA", "NUMBER", "for", "NUMBER", "facebook", "NUMBER", "Fgraphql", "NUMBER", "NUMBER", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Great", "catch", "and", "fix", "Thanks", "for", "your", "help", "I", "think", "we", "mention", "this", "elsewhere", "but", "it", "s", "hard", "to", "find", "a", "consistent", "reference", "to", "link", "to", "which", "I", "think", "we", "should", "improve", "GraphQL", "intentionally", "do", "not", "require", "any", "specific", "serialization", "or", "transport", "NUMBER", "JSON", "be", "preferred", "but", "explicitly", "not", "required", "LINK", "sec", "Serialization", "Format", "so", "any", "exist", "binary", "protocol", "can", "be", "use", "with", "GraphQL", "NUMBER", "There", "be", "plenty", "in", "the", "gRPC", "space", "that", "would", "work", "well", "alongside", "GraphQL", "for", "the", "use", "cases", "you", "re", "describing", "NUMBER", "There", "be", "no", "plan", "for", "the", "GraphQL", "spec", "to", "explicitly", "specify", "any", "specific", "binary", "protocol", "I", "d", "prefer", "to", "avoid", "the", "type", "of", "a", "field", "change", "based", "on", "how", "its", "queried", "NUMBER", "That", "greatly", "limits", "the", "power", "available", "to", "tool", "especially", "smart", "clients", "like", "Relay", "and", "Apollo", "which", "store", "normalized", "results", "such", "that", "both", "types", "could", "be", "encountered", "in", "a", "single", "application", "at", "the", "same", "point", "NUMBER", "I", "think", "this", "also", "introduces", "a", "serious", "foot", "gun", "where", "a", "query", "that", "previously", "would", "clearly", "be", "a", "validation", "error", "now", "returns", "a", "value", "however", "its", "not", "clear", "that", "the", "user", "intended", "on", "the", "new", "usage", "and", "may", "result", "in", "a", "hard", "to", "spot", "error", "in", "their", "software", "NUMBER", "An", "alternative", "to", "this", "which", "should", "work", "today", "be", "simply", "to", "provide", "a", "field", "like", "this", "maybe", "without", "the", "underscores", "which", "be", "system", "reserved", "and", "explicitly", "query", "it", "graphql", "type", "DateTimeObject", "year", "Int", "month", "Int", "NUMBER", "ago", "String", "format", "format", "String", "String", "toScalar", "DateTime", "As", "Scalar", "graphql", "date", "toScalar", "json", "date", "toScalar", "NUMBER", "NUMBER", "NUMBER", "T", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "While", "I", "appreciate", "and", "agree", "with", "your", "suggestion", "the", "skip", "directive", "has", "be", "in", "the", "spec", "for", "a", "number", "of", "years", "and", "the", "cost", "of", "change", "this", "for", "all", "exist", "implementors", "be", "too", "high", "NUMBER", "You", "re", "always", "more", "than", "welcome", "to", "include", "additional", "directives", "with", "whatever", "behavior", "you", "like", "including", "aliases", "for", "the", "specified", "directives", "This", "add", "new", "grammar", "to", "the", "GraphQL", "SDL", "graphql", "extend", "schema", "mutation", "MutationType", "This", "feels", "like", "the", "miss", "piece", "of", "the", "type", "system", "extension", "framework", "NUMBER", "In", "addition", "to", "extending", "types", "in", "a", "type", "system", "the", "top", "level", "schema", "should", "be", "extendable", "as", "well", "NUMBER", "That", "s", "certainly", "something", "we", "could", "reconsider", "NUMBER", "I", "remember", "when", "applying", "that", "rule", "we", "did", "so", "intentionally", "to", "carve", "out", "the", "space", "for", "future", "exploration", "NUMBER", "Would", "you", "mind", "creating", "a", "new", "issue", "about", "that", "topic", "where", "we", "can", "discuss", "further", "Leaving", "this", "open", "for", "review", "for", "a", "shorter", "period", "of", "time", "I", "hope", "this", "be", "an", "easy", "win", "Thanks", "for", "the", "online", "and", "offline", "feedback", "everyone", "Merging", "into", "NUMBER", "Sorry", "I", "m", "not", "sure", "what", "you", "re", "suggesting", "NUMBER", "Perhaps", "you", "have", "the", "wrong", "repo", "I", "m", "closing", "this", "issue", "but", "if", "you", "like", "please", "reopen", "with", "a", "suggested", "specification", "text", "change", "Thanks", "for", "accounting", "for", "this", "schema", "validation", "addition", "Thanks", "for", "spotting", "this", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "mailto", "cla", "fb", "NUMBER", "com", "subject", "CLA", "NUMBER", "for", "NUMBER", "facebook", "NUMBER", "Fgraphql", "NUMBER", "NUMBER", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thanks", "for", "the", "careful", "eye", "and", "edit", "GraphQL", "be", "on", "a", "different", "layer", "of", "abstraction", "from", "message", "delivery", "NUMBER", "GraphQL", "only", "represents", "the", "request", "for", "and", "sequence", "of", "a", "message", "stream", "NUMBER", "You", "might", "layer", "GraphQL", "subscriptions", "over", "Kafka", "or", "some", "other", "protocol", "level", "service", "to", "get", "the", "QoS", "you", "need", "NUMBER", "eapache", "great", "points", "NUMBER", "I", "actually", "think", "what", "I", "now", "have", "here", "be", "very", "close", "to", "what", "I", "would", "propose", "in", "a", "from", "scratch", "design", "NUMBER", "The", "execution", "behavior", "be", "almost", "exactly", "as", "I", "would", "expect", "it", "in", "a", "from", "scratch", "design", "as", "it", "respects", "explicit", "values", "over", "default", "values", "in", "the", "same", "way", "as", "other", "programming", "languages", "NUMBER", "The", "only", "difference", "I", "might", "have", "expected", "in", "a", "from", "scratch", "design", "be", "to", "be", "even", "more", "trusting", "of", "variable", "values", "in", "CoerceArgumentValues", "where", "this", "proposal", "explicitly", "checks", "for", "null", "values", "and", "throw", "field", "error", "NUMBER", "This", "isn", "t", "trading", "on", "correctness", "however", "so", "I", "m", "not", "concerned", "at", "all", "about", "that", "extra", "check", "NUMBER", "This", "be", "still", "technically", "a", "breaking", "change", "by", "the", "definition", "that", "execution", "behavior", "of", "exist", "queries", "will", "now", "be", "different", "NUMBER", "Previously", "null", "values", "could", "be", "provide", "to", "non", "null", "typed", "argument", "after", "this", "proposal", "this", "be", "an", "error", "NUMBER", "I", "think", "it", "s", "pretty", "uncontroversial", "to", "explain", "this", "as", "a", "bug", "fix", "NUMBER", "The", "validation", "behavior", "be", "really", "where", "we", "ve", "made", "specific", "considerations", "to", "avoid", "breaking", "exist", "queries", "however", "this", "proposal", "be", "still", "very", "close", "to", "what", "I", "would", "propose", "in", "a", "from", "scratch", "design", "NUMBER", "This", "proposal", "makes", "NUMBER", "important", "change", "to", "query", "validation", "Removal", "of", "the", "Variable", "Default", "Value", "Is", "Allowed", "rule", "NUMBER", "I", "argue", "this", "should", "have", "be", "remove", "when", "we", "introduce", "explicit", "null", "values", "with", "the", "expectation", "that", "they", "supersede", "default", "values", "NUMBER", "This", "rule", "originally", "sought", "to", "prevent", "dead", "code", "style", "misunderstandings", "however", "in", "the", "present", "context", "it", "do", "not", "succeed", "at", "that", "and", "instead", "it", "prevents", "real", "possibilities", "NUMBER", "In", "a", "from", "scratch", "design", "I", "would", "include", "this", "change", "exactly", "as", "be", "NUMBER", "Changes", "the", "definition", "of", "required", "argument", "and", "input", "field", "NUMBER", "Previously", "a", "non", "null", "type", "meant", "that", "an", "argument", "or", "input", "field", "was", "required", "to", "be", "provide", "NUMBER", "However", "because", "argument", "may", "have", "default", "values", "this", "limits", "their", "expressivity", "in", "the", "same", "was", "the", "previous", "rule", "NUMBER", "This", "proposal", "change", "this", "such", "that", "non", "null", "typed", "argument", "input", "field", "be", "only", "considered", "required", "if", "they", "also", "do", "not", "have", "a", "default", "value", "NUMBER", "This", "again", "I", "would", "propose", "unchanged", "in", "a", "from", "scratch", "design", "NUMBER", "Change", "the", "Variable", "Usages", "be", "Allowed", "rule", "tweaking", "the", "rules", "for", "treating", "nullable", "variables", "as", "non", "null", "for", "the", "sake", "of", "determining", "where", "they", "re", "allow", "to", "be", "use", "NUMBER", "This", "be", "not", "what", "I", "would", "do", "in", "a", "from", "scratch", "design", "NUMBER", "Instead", "I", "would", "propose", "remove", "the", "ability", "for", "nullable", "variables", "to", "flow", "into", "non", "null", "argument", "at", "all", "NUMBER", "Where", "the", "previous", "two", "change", "expanded", "the", "possible", "set", "of", "queries", "that", "pass", "validation", "this", "change", "would", "have", "restricted", "that", "possible", "set", "NUMBER", "This", "be", "also", "unfortunately", "a", "very", "common", "pattern", "so", "that", "restriction", "could", "be", "a", "very", "costly", "breaking", "change", "NUMBER", "However", "I", "definitely", "agree", "that", "enforcing", "that", "strictness", "for", "newly", "produced", "GraphQL", "services", "would", "be", "valuable", "I", "will", "look", "at", "editing", "this", "to", "both", "make", "it", "more", "clear", "where", "the", "caveat", "for", "exist", "systems", "be", "while", "make", "it", "possible", "or", "even", "encourage", "for", "new", "systems", "not", "to", "adopt", "that", "caveat", "NUMBER", "eapache", "be", "there", "other", "differences", "from", "the", "current", "state", "of", "this", "PR", "that", "you", "would", "consider", "approaching", "differently", "in", "a", "from", "scratch", "design", "eapache", "I", "just", "update", "this", "with", "your", "feedback", "incorporated", "NUMBER", "I", "m", "glad", "we", "agree", "on", "the", "ideal", "outcome", "of", "this", "proposal", "NUMBER", "My", "last", "update", "be", "one", "step", "further", "towards", "the", "idealized", "from", "scratch", "proposal", "this", "makes", "it", "more", "explicitly", "clear", "that", "change", "the", "effective", "type", "of", "a", "variable", "definition", "be", "only", "relevant", "when", "support", "legacy", "clients", "and", "suggests", "that", "new", "services", "should", "not", "use", "this", "behavior", "NUMBER", "I", "like", "that", "this", "balances", "a", "clear", "description", "of", "how", "this", "rule", "should", "work", "for", "exist", "services", "along", "with", "a", "stricter", "and", "therefore", "safer", "future", "path", "for", "new", "services", "NUMBER", "I", "also", "just", "update", "LINK", "js", "pull", "NUMBER", "to", "include", "this", "and", "make", "this", "a", "breaking", "change", "by", "default", "while", "provide", "an", "API", "for", "use", "this", "legacy", "behavior", "NUMBER", "I", "d", "love", "a", "last", "look", "by", "anyone", "else", "interested", "Updating", "this", "a", "bit", "NUMBER", "I", "m", "still", "trying", "to", "convince", "myself", "that", "the", "breaking", "change", "be", "worth", "doing", "NUMBER", "I", "realized", "that", "it", "also", "has", "a", "side", "effect", "of", "not", "allowing", "an", "optional", "variable", "to", "be", "provide", "to", "a", "optional", "non", "null", "argument", "NUMBER", "graphql", "query", "Example", "var", "Int", "field", "arg", "var", "type", "Query", "field", "arg", "Int", "NUMBER", "Int", "While", "the", "above", "query", "be", "valid", "it", "be", "invalid", "to", "not", "provide", "a", "runtime", "value", "for", "var", "even", "though", "arg", "supplies", "a", "default", "value", "NUMBER", "Perhaps", "this", "be", "just", "an", "acceptable", "cost", "NUMBER", "An", "alternative", "which", "I", "m", "also", "not", "sure", "about", "be", "allowing", "nullable", "optional", "variables", "to", "flow", "into", "non", "null", "optional", "positions", "while", "still", "throw", "at", "runtime", "for", "explicitly", "provide", "null", "values", "already", "include", "in", "this", "proposal", "NUMBER", "For", "example", "this", "be", "currently", "invalid", "but", "would", "become", "valid", "in", "the", "alternative", "proposal", "graphql", "query", "Example", "var", "Int", "nullable", "field", "arg", "var", "non", "null", "but", "optional", "type", "Query", "field", "arg", "Int", "NUMBER", "Int", "In", "that", "case", "omitting", "var", "at", "runtime", "could", "just", "use", "arg", "s", "default", "value", "NUMBER", "Thoughts", "on", "this", "After", "discussing", "this", "in", "depth", "with", "dschafer", "at", "a", "whiteboard", "we", "ve", "talked", "ourselves", "out", "of", "any", "breaking", "change", "I", "think", "that", "having", "a", "fork", "in", "the", "expected", "behavior", "of", "validation", "rules", "be", "just", "too", "easy", "to", "get", "wrong", "liable", "to", "cause", "issue", "during", "deployment", "and", "could", "create", "a", "bifurcation", "of", "tooling", "environments", "NUMBER", "We", "came", "up", "with", "mitigation", "strategies", "for", "Facebook", "s", "codebases", "and", "APIs", "however", "also", "agreed", "that", "public", "APIs", "like", "Github", "would", "be", "much", "much", "more", "challenging", "to", "solve", "for", "NUMBER", "Even", "though", "the", "behavior", "be", "not", "an", "ideal", "from", "scratch", "I", "think", "that", "it", "s", "worth", "avoiding", "the", "breaking", "change", "NUMBER", "I", "still", "think", "the", "spec", "should", "call", "out", "this", "potential", "issue", "directly", "in", "a", "non", "normative", "note", "for", "clarity", "NUMBER", "I", "ve", "just", "update", "the", "description", "to", "mirror", "the", "current", "change", "NUMBER", "I", "believe", "this", "be", "ready", "to", "merge", "and", "will", "first", "wait", "for", "a", "bit", "for", "others", "to", "review", "and", "comment", "NUMBER", "Thanks", "for", "the", "reviews", "mike", "marcacci", "and", "IvanGoncharov", "NUMBER", "IvanGoncharov", "I", "think", "there", "be", "too", "many", "critical", "issue", "with", "the", "version", "approach", "you", "re", "suggesting", "NUMBER", "Beyond", "be", "fundamentally", "inconsistent", "with", "one", "of", "GraphQL", "s", "core", "values", "to", "not", "need", "version", "the", "introduction", "of", "version", "causes", "even", "more", "breaking", "change", "that", "we", "re", "trying", "to", "avoid", "NUMBER", "Currently", "all", "GraphQL", "clients", "send", "GraphQL", "request", "document", "inside", "query", "field", "NUMBER", "But", "ExecuteRequest", "names", "the", "same", "parameter", "document", "This", "seems", "like", "it", "be", "an", "issue", "not", "for", "the", "spec", "but", "for", "HTTP", "services", "and", "be", "just", "a", "naming", "convention", "so", "probably", "not", "a", "viable", "mechanism", "for", "specification", "algorithms", "NUMBER", "The", "spec", "document", "should", "be", "pretty", "consistent", "in", "referring", "to", "document", "and", "operation", "terms", "already", "NUMBER", "I", "also", "think", "we", "should", "use", "an", "integer", "for", "version", "field", "and", "increment", "it", "only", "when", "breaking", "change", "be", "made", "NUMBER", "I", "would", "much", "prefer", "to", "not", "make", "breaking", "change", "at", "all", "I", "still", "believe", "our", "goal", "for", "evolving", "the", "GraphQL", "specification", "should", "be", "to", "arrive", "at", "a", "stable", "base", "and", "project", "confidence", "and", "stability", "NUMBER", "An", "incrementing", "integer", "version", "implies", "that", "there", "will", "be", "a", "continuous", "stream", "of", "breaking", "change", "NUMBER", "Also", "having", "worked", "on", "API", "surfaces", "including", "public", "facing", "that", "have", "dealt", "with", "breaking", "change", "in", "the", "past", "incrementing", "integer", "version", "do", "not", "adequately", "capture", "scenarios", "where", "a", "client", "has", "adopted", "support", "for", "one", "breaking", "change", "while", "it", "has", "not", "yet", "adopted", "support", "for", "another", "the", "fix", "ordering", "of", "the", "version", "numbers", "forces", "an", "adoption", "curve", "that", "do", "not", "align", "with", "client", "expectation", "or", "capability", "NUMBER", "I", "d", "like", "to", "strongly", "avoid", "make", "the", "same", "mistake", "with", "GraphQL", "NUMBER", "mike", "marcacci", "I", "know", "you", "had", "similar", "ideas", "This", "be", "probably", "unavoidable", "and", "makes", "me", "think", "that", "there", "should", "be", "a", "graphql", "version", "or", "programmatically", "readable", "feature", "set", "as", "discussed", "in", "the", "WG", "meeting", "supplied", "in", "the", "result", "of", "an", "introspection", "query", "NUMBER", "I", "think", "these", "be", "interesting", "ideas", "but", "I", "d", "love", "to", "avoid", "expanding", "the", "surface", "area", "of", "this", "proposal", "since", "I", "believe", "it", "be", "in", "a", "final", "reviewable", "state", "NUMBER", "I", "believe", "that", "finding", "consensus", "on", "programmable", "feature", "set", "support", "in", "a", "client", "server", "communication", "be", "going", "to", "be", "quite", "challenging", "and", "require", "a", "lot", "of", "exploration", "NUMBER", "Just", "the", "two", "proposals", "you", "two", "offered", "be", "very", "different", "NUMBER", "My", "hope", "be", "that", "we", "can", "arrive", "at", "consensus", "around", "this", "proposal", "in", "its", "current", "form", "NUMBER", "I", "m", "not", "comfortable", "proposing", "a", "change", "which", "breaks", "the", "validation", "of", "exist", "queries", "NUMBER", "Thanks", "for", "the", "reviews", "and", "offline", "conversations", "to", "everyone", "involves", "NUMBER", "Super", "pleased", "with", "how", "this", "ended", "up", "NUMBER", "Closing", "this", "aging", "issue", "NUMBER", "To", "answer", "the", "question", "directly", "GraphQL", "do", "not", "support", "conditions", "like", "this", "NUMBER", "Multiple", "booleans", "may", "be", "a", "fit", "for", "your", "use", "case", "Sorry", "for", "letting", "this", "sit", "I", "m", "closing", "aging", "issue", "NUMBER", "I", "m", "not", "sure", "this", "proposal", "will", "gain", "much", "traction", "because", "it", "seems", "to", "be", "introduce", "a", "lot", "of", "new", "ideas", "and", "concepts", "for", "which", "there", "be", "exist", "concepts", "NUMBER", "In", "general", "GraphQL", "services", "philosophically", "avoid", "the", "Mutative", "CRUD", "model", "in", "favor", "of", "an", "action", "oriented", "data", "access", "pattern", "which", "this", "proposal", "seems", "to", "be", "counter", "to", "NUMBER", "There", "be", "a", "lot", "of", "ideas", "here", "NUMBER", "If", "you", "were", "to", "formalize", "a", "proposal", "I", "suggest", "starting", "small", "with", "an", "incremental", "change", "which", "provides", "value", "at", "a", "lower", "change", "cost", "This", "do", "a", "last", "pass", "over", "the", "subscriptions", "specification", "to", "clean", "up", "some", "ambiguities", "and", "crisp", "up", "some", "language", "NUMBER", "Two", "important", "things", "to", "take", "note", "of", "NUMBER", "The", "CreateSourceEventStream", "algo", "was", "underspecified", "and", "did", "not", "articulate", "how", "field", "should", "be", "collected", "from", "the", "selection", "set", "NUMBER", "This", "makes", "it", "clear", "that", "CollectFields", "be", "use", "just", "like", "any", "other", "selection", "set", "NUMBER", "It", "also", "did", "not", "describe", "behavior", "when", "executing", "an", "invalid", "query", "this", "add", "that", "a", "query", "level", "error", "should", "be", "throw", "NUMBER", "NUMBER", "The", "Subscription", "Operation", "validation", "be", "similarly", "underspecified", "and", "do", "not", "describe", "what", "should", "happen", "if", "a", "fragment", "spread", "be", "find", "as", "the", "first", "selection", "in", "a", "selection", "set", "NUMBER", "This", "clarifies", "that", "it", "be", "field", "that", "exactly", "one", "be", "expected", "rather", "than", "selections", "NUMBER", "Correct", "this", "limitation", "solves", "a", "whole", "class", "of", "ambiguities", "regard", "merge", "event", "streams", "NUMBER", "We", "ve", "find", "in", "practice", "it", "s", "almost", "always", "preferable", "to", "have", "multiple", "open", "subscriptions", "rather", "than", "a", "single", "subscription", "that", "attempts", "to", "merge", "streams", "Yeah", "we", "could", "lift", "this", "restriction", "in", "the", "future", "should", "crisp", "semantics", "become", "more", "clear", "and", "the", "value", "outweigh", "the", "cost", "of", "the", "potential", "for", "confusion", "NUMBER", "At", "Facebook", "we", "faced", "some", "serious", "roadblocks", "to", "support", "multiple", "subscription", "root", "field", "for", "this", "and", "other", "reasons", "so", "felt", "it", "was", "best", "to", "specify", "a", "more", "limited", "functionality", "set", "out", "of", "the", "gates", "GraphQL", "error", "encode", "exceptional", "scenarios", "like", "a", "service", "be", "down", "or", "some", "other", "internal", "failure", "NUMBER", "Errors", "which", "be", "part", "of", "the", "API", "domain", "should", "be", "captured", "within", "that", "domain", "NUMBER", "Of", "the", "two", "suggestions", "you", "make", "here", "I", "strongly", "prefer", "the", "first", "one", "NUMBER", "It", "be", "much", "simpler", "the", "behavior", "be", "clear", "to", "any", "reader", "and", "it", "requires", "no", "new", "change", "to", "GraphQL", "NUMBER", "However", "the", "second", "accomplishes", "the", "same", "task", "but", "requires", "new", "syntax", "and", "behavior", "and", "be", "less", "clear", "how", "field", "on", "error", "would", "be", "selected", "NUMBER", "This", "feels", "like", "an", "implementation", "detail", "and", "not", "something", "that", "would", "affect", "the", "GraphQL", "specification", "NUMBER", "I", "m", "going", "to", "close", "this", "issue", "but", "feel", "free", "to", "open", "issue", "on", "repos", "for", "GraphQL", "server", "implementations", "to", "further", "the", "conversation", "NUMBER", "Though", "to", "give", "early", "feedback", "I", "m", "not", "sure", "I", "see", "the", "value", "offsetting", "the", "complexity", "cost", "NUMBER", "args", "limit", "type", "GraphQLInt", "prepare", "arg", "return", "arg", "NUMBER", "resolve", "obj", "args", "args", "NUMBER", "limit", "be", "incremented", "by", "NUMBER", "Seems", "like", "strictly", "more", "and", "more", "complicated", "code", "than", "args", "limit", "type", "GraphQLInt", "resolve", "obj", "args", "const", "limit", "args", "NUMBER", "limit", "NUMBER", "I", "think", "the", "initial", "intent", "was", "for", "query", "error", "to", "be", "error", "having", "to", "do", "with", "the", "query", "itself", "syntax", "or", "validation", "while", "field", "error", "were", "error", "encountered", "while", "evaluating", "a", "field", "NUMBER", "Though", "a", "good", "clarification", "this", "PR", "makes", "be", "that", "query", "error", "be", "not", "just", "syntax", "and", "validation", "but", "also", "variable", "coercion", "Excellent", "point", "stubailo", "I", "think", "perhaps", "document", "error", "might", "be", "a", "better", "fit", "NUMBER", "I", "think", "at", "Facebook", "we", "ve", "also", "call", "these", "fatal", "error", "since", "they", "result", "in", "no", "execution", "result", "no", "data", "key", "in", "response", "In", "terms", "of", "clarifying", "the", "spec", "I", "definitely", "agree", "that", "defining", "the", "different", "kinds", "of", "error", "be", "important", "and", "could", "lead", "to", "error", "code", "proposals", "in", "the", "future", "but", "what", "be", "most", "important", "in", "this", "immediate", "context", "be", "the", "behavioral", "differences", "between", "them", "NUMBER", "In", "that", "sense", "there", "be", "really", "NUMBER", "behaviorally", "different", "error", "those", "that", "result", "in", "no", "data", "key", "and", "those", "that", "be", "local", "to", "one", "field", "in", "the", "response", "NUMBER", "Merging", "since", "this", "be", "a", "pretty", "straightforward", "editing", "suggestion", "that", "s", "not", "change", "anything", "I", "still", "agree", "that", "the", "overall", "language", "around", "error", "could", "be", "more", "clear", "A", "response", "to", "a", "GraphQL", "operation", "must", "be", "a", "map", "NUMBER", "do", "not", "imply", "order", "otherwise", "it", "would", "say", "ordered", "map", "I", "agree", "that", "the", "first", "and", "next", "terminology", "be", "more", "ambiguous", "than", "helpful", "in", "this", "context", "though", "I", "like", "declaring", "the", "order", "via", "the", "order", "of", "paragraphs", "NUMBER", "I", "think", "we", "can", "add", "a", "more", "explicit", "phrase", "about", "ordering", "error", "first", "in", "a", "formatted", "output", "as", "a", "convenience", "I", "m", "going", "to", "close", "this", "issue", "since", "it", "sounds", "like", "you", "get", "answers", "iamclaytonray", "The", "example", "query", "you", "write", "at", "the", "top", "of", "this", "issue", "be", "very", "much", "fulfillable", "today", "NUMBER", "I", "don", "t", "see", "any", "miss", "features", "to", "fulfill", "such", "a", "use", "case", "that", "the", "spec", "do", "not", "provide", "for", "NUMBER", "The", "Version", "type", "you", "propose", "could", "easily", "be", "a", "custom", "scalar", "type", "or", "more", "often", "I", "ve", "seen", "version", "for", "resources", "like", "this", "be", "represented", "as", "incrementing", "Int", "values", "NUMBER", "Please", "open", "specific", "bug", "issue", "like", "this", "on", "gatsby", "s", "github", "I", "m", "going", "to", "close", "this", "since", "it", "sounds", "like", "there", "s", "consensus", "that", "the", "separate", "proposal", "could", "would", "cover", "this", "use", "case", "NUMBER", "However", "in", "general", "I", "m", "less", "convinced", "by", "the", "desire", "to", "add", "utilities", "to", "GraphQL", "or", "GraphiQL", "to", "encourage", "CRUD", "style", "mutations", "NUMBER", "In", "my", "experience", "a", "GraphQL", "first", "API", "design", "typically", "would", "not", "always", "have", "mutations", "with", "a", "coherent", "group", "which", "could", "lead", "to", "abuse", "of", "the", "feature", "or", "tool", "NUMBER", "As", "for", "GraphiQL", "and", "other", "tool", "I", "think", "improved", "typeahead", "quality", "can", "better", "help", "solve", "this", "issue", "I", "m", "going", "to", "close", "this", "issue", "for", "repo", "maintenance", "but", "here", "be", "some", "of", "my", "opinions", "on", "this", "topic", "and", "suggestions", "for", "how", "to", "move", "forward", "First", "just", "a", "point", "of", "clarification", "for", "the", "schema", "definition", "language", "NUMBER", "The", "expectation", "be", "that", "SDL", "will", "be", "read", "far", "more", "often", "than", "it", "be", "write", "in", "fact", "in", "many", "cases", "it", "be", "even", "write", "by", "a", "code", "generation", "script", "and", "therefore", "be", "optimized", "for", "legibility", "over", "terseness", "NUMBER", "It", "be", "valuable", "to", "see", "all", "field", "defined", "on", "a", "type", "without", "having", "to", "follow", "references", "to", "mixins", "or", "interfaces", "NUMBER", "However", "for", "cases", "where", "you", "be", "write", "more", "often", "than", "reading", "perhaps", "for", "quick", "prototyping", "or", "use", "tool", "like", "AppSync", "or", "Graphcool", "then", "I", "certainly", "see", "the", "appeal", "for", "having", "tool", "to", "allow", "for", "more", "terse", "representations", "NUMBER", "Spec", "proposals", "typically", "intentionally", "lag", "behind", "real", "world", "experimentation", "NUMBER", "The", "goal", "for", "the", "GraphQL", "spec", "be", "to", "dictate", "what", "be", "required", "to", "be", "considered", "GraphQL", "by", "codifying", "the", "most", "successful", "explorations", "into", "new", "capabilities", "by", "GraphQL", "services", "and", "tool", "NUMBER", "That", "means", "new", "ideas", "be", "best", "served", "by", "be", "build", "out", "and", "use", "for", "their", "intended", "purpose", "and", "learned", "from", "before", "be", "codified", "in", "spec", "NUMBER", "If", "add", "mixin", "support", "be", "important", "to", "you", "I", "would", "recommend", "you", "build", "it", "Try", "it", "out", "and", "learn", "along", "with", "the", "community", "and", "if", "that", "lends", "itself", "to", "broad", "support", "then", "a", "spec", "proposal", "would", "be", "a", "good", "final", "step", "to", "codify", "the", "best", "version", "NUMBER", "Find", "the", "full", "text", "of", "the", "agreement", "LINK", "owf", "NUMBER", "NUMBER", "agreements", "owfa", "NUMBER", "NUMBER", "Read", "more", "about", "this", "change", "at", "LINK", "leeb", "relicensing", "the", "graphql", "specification", "e", "NUMBER", "d", "NUMBER", "a", "NUMBER", "b", "Resolves", "NUMBER", "For", "anyone", "looking", "for", "this", "change", "within", "the", "spec", "note", "that", "new", "change", "will", "appear", "at", "LINK", "I", "m", "going", "to", "close", "this", "issue", "since", "I", "think", "it", "s", "be", "thoroughly", "discussed", "NUMBER", "To", "conclude", "So", "what", "be", "the", "recommended", "universal", "default", "way", "to", "represent", "such", "numbers", "in", "GraphQL", "There", "be", "no", "recommended", "universal", "default", "NUMBER", "Different", "APIs", "will", "come", "to", "different", "conclusions", "based", "on", "the", "type", "of", "data", "they", "need", "to", "represent", "and", "the", "kinds", "of", "clients", "they", "expect", "to", "support", "NUMBER", "All", "of", "the", "options", "you", "offered", "be", "reasonable", "to", "consider", "when", "make", "this", "choice", "NUMBER", "Float", "may", "be", "best", "if", "you", "can", "guarantee", "TAG", "Are", "there", "any", "alternatives", "FWIW", "Facebook", "has", "gotten", "pretty", "far", "without", "having", "imports", "even", "build", "almost", "certainly", "the", "largest", "and", "definitely", "the", "oldest", "GraphQL", "powered", "apps", "in", "the", "world", "NUMBER", "Query", "and", "fragment", "names", "be", "globally", "unique", "within", "each", "project", "and", "it", "be", "quite", "easy", "to", "jump", "from", "the", "place", "where", "a", "fragment", "be", "spread", "to", "where", "it", "be", "defined", "thanks", "to", "tooling", "like", "graphql", "language", "service", "LINK", "language", "service", "NUMBER", "Furthermore", "our", "experience", "build", "the", "Relay", "compiler", "has", "shown", "us", "that", "it", "be", "possible", "to", "build", "an", "optimizing", "pipeline", "that", "eliminates", "redundancy", "and", "our", "use", "of", "persisted", "queries", "mean", "that", "query", "size", "doesn", "t", "matter", "in", "terms", "of", "client", "to", "server", "network", "transport", "the", "cost", "be", "basically", "fix", "and", "in", "the", "other", "direction", "you", "pay", "only", "for", "what", "you", "use", "so", "it", "s", "best", "to", "make", "sure", "you", "re", "declaring", "what", "you", "use", "as", "close", "as", "possible", "to", "the", "use", "site", "so", "as", "to", "avoid", "accidental", "overfetching", "NUMBER", "This", "be", "not", "to", "suggest", "that", "the", "idea", "be", "a", "non", "starter", "just", "that", "the", "value", "isn", "t", "necessarily", "obvious", "compared", "to", "a", "world", "without", "imports", "NUMBER", "I", "do", "think", "this", "be", "one", "case", "though", "where", "the", "existence", "of", "a", "system", "where", "imports", "weren", "t", "use", "doesn", "t", "mean", "they", "be", "never", "going", "to", "be", "valuable", "NUMBER", "I", "certainly", "didn", "t", "make", "that", "claim", "NUMBER", "Where", "did", "you", "see", "me", "make", "it", "I", "was", "just", "offering", "a", "significant", "I", "would", "think", "data", "point", "NUMBER", "What", "I", "said", "was", "with", "emphasis", "add", "This", "be", "not", "to", "suggest", "that", "the", "idea", "be", "a", "non", "starter", "just", "that", "the", "value", "isn", "t", "necessarily", "obvious", "compared", "to", "a", "world", "without", "imports", "NUMBER", "Your", "list", "of", "benefits", "be", "good", "NUMBER", "But", "the", "proposal", "be", "not", "without", "costs", "NUMBER", "One", "example", "any", "system", "that", "moves", "away", "from", "the", "current", "global", "system", "towards", "one", "involving", "relative", "paths", "means", "that", "you", "won", "t", "be", "able", "to", "move", "a", "heavily", "depended", "upon", "fragment", "without", "modifying", "all", "the", "import", "sites", "NUMBER", "There", "be", "probably", "others", "NUMBER", "Once", "again", "just", "to", "be", "clear", "I", "m", "not", "trying", "to", "shut", "the", "discussion", "down", "I", "m", "just", "trying", "to", "offer", "a", "counterpoint", "to", "make", "sure", "that", "we", "re", "considering", "as", "many", "sides", "of", "the", "issue", "as", "possible", "NUMBER", "How", "be", "full", "queries", "constructed", "at", "Facebook", "From", "what", "I", "gather", "you", "have", "a", "collection", "of", "named", "queries", "and", "fragment", "NUMBER", "Looking", "at", "Relay", "they", "re", "write", "in", "code", "directly", "not", "file", "be", "this", "also", "true", "for", "your", "native", "clients", "Do", "you", "have", "equivalents", "to", "the", "Relay", "compiler", "for", "Android", "and", "iOS", "queries", "For", "native", "codebases", "developers", "write", "GraphQL", "in", "NUMBER", "graphql", "file", "NUMBER", "We", "do", "have", "an", "equivalent", "to", "the", "Relay", "compiler", "that", "build", "native", "artifacts", "persisted", "queries", "fragment", "type", "model", "classes", "query", "builders", "etc", "NUMBER", "We", "configure", "projects", "use", "NUMBER", "graphqlconfig", "file", "NUMBER", "And", "use", "graphql", "language", "service", "LINK", "language", "service", "to", "provide", "code", "intelligence", "autocompletion", "diagnostics", "go", "to", "definition", "etc", "NUMBER", "Going", "into", "further", "detail", "be", "probably", "beyond", "the", "scope", "of", "this", "issue", "though", "the", "nutshell", "version", "be", "that", "it", "be", "basically", "analogous", "to", "how", "Relay", "works", "NUMBER", "Idea", "perhaps", "this", "file", "should", "be", "named", "CONTRIBUTING", "NUMBER", "md", "matching", "a", "pattern", "use", "by", "a", "lot", "of", "projects", "and", "some", "of", "GitHub", "s", "tooling", "makes", "use", "of", "it", "automatically", "LINK", "contribute", "guidelines", "NUMBER", "So", "with", "this", "we", "have", "a", "draft", "definition", "of", "stages", "for", "change", "to", "GraphQL", "specification", "NUMBER", "What", "we", "don", "t", "have", "be", "a", "definition", "of", "stages", "for", "change", "to", "the", "definition", "of", "stages", "for", "change", "to", "the", "GraphQL", "specification", "NUMBER", "My", "inclination", "be", "to", "merge", "this", "as", "be", "but", "add", "a", "Draft", "label", "and", "iterate", "from", "there", "NUMBER", "I", "d", "say", "we", "can", "afford", "to", "move", "a", "little", "more", "quickly", "scrappily", "on", "merge", "a", "change", "like", "this", "it", "be", "not", "a", "change", "to", "the", "spec", "itself", "it", "requires", "no", "implementation", "work", "from", "library", "or", "product", "developers", "it", "be", "easily", "revised", "once", "landed", "and", "you", "ve", "already", "canvassed", "the", "idea", "in", "the", "last", "first", "WG", "meeting", "LINK", "wg", "blob", "master", "note", "NUMBER", "NUMBER", "NUMBER", "md", "to", "broad", "informal", "approval", "NUMBER", "I", "wouldn", "t", "want", "something", "like", "this", "PR", "to", "get", "bogged", "down", "too", "heavily", "in", "process", "especially", "when", "we", "can", "make", "the", "non", "final", "nature", "of", "the", "document", "clear", "by", "labeling", "it", "as", "a", "draft", "and", "at", "that", "point", "I", "think", "it", "would", "make", "sense", "to", "discuss", "it", "in", "detail", "at", "the", "next", "WG", "meeting", "NUMBER", "Should", "I", "add", "something", "to", "the", "document", "itself", "Yeah", "that", "s", "almost", "exactly", "what", "I", "was", "thinking", "NUMBER", "Document", "status", "Draft", "LINK", "Blockquote", "to", "make", "it", "stand", "out", "a", "bit", "NUMBER", "Ok", "great", "NUMBER", "This", "be", "a", "good", "starting", "point", "NUMBER", "We", "can", "iterate", "from", "here", "NUMBER", "Thanks", "IvanGoncharov", "NUMBER", "Added", "discussion", "of", "this", "to", "the", "agenda", "for", "the", "next", "meeting", "LINK", "wg", "pull", "NUMBER", "Thanks", "for", "the", "question", "raderio", "and", "the", "answer", "stubailo", "NUMBER", "raderio", "if", "you", "hit", "Stack", "Overflow", "and", "search", "for", "graphql", "filter", "you", "ll", "see", "some", "question", "answers", "with", "examples", "of", "how", "to", "filter", "and", "paginate", "NUMBER", "Just", "say", "you", "end", "up", "exposing", "your", "results", "under", "a", "people", "field", "you", "may", "end", "up", "setting", "up", "argument", "for", "it", "like", "people", "minAge", "NUMBER", "and", "if", "you", "require", "pagination", "people", "first", "NUMBER", "minAge", "NUMBER", "etc", "NUMBER", "Those", "be", "just", "examples", "because", "there", "be", "plenty", "of", "valid", "ways", "to", "do", "this", "NUMBER", "Like", "stubailo", "said", "the", "specification", "be", "intentionally", "silent", "on", "schema", "design", "patterns", "so", "I", "d", "suggest", "you", "look", "around", "at", "the", "prior", "art", "out", "there", "in", "order", "to", "guide", "you", "NUMBER", "Thanks", "for", "the", "question", "raderio", "NUMBER", "The", "spec", "be", "intentionally", "silent", "on", "the", "subject", "of", "how", "request", "and", "responses", "should", "be", "serialized", "and", "transported", "because", "it", "be", "intended", "to", "concern", "itself", "only", "with", "the", "lower", "level", "matters", "of", "how", "to", "parse", "validate", "execute", "introspect", "GraphQL", "queries", "NUMBER", "As", "the", "readme", "says", "this", "be", "in", "order", "NUMBER", "to", "be", "broadly", "adopted", "NUMBER", "GraphQL", "will", "have", "to", "target", "a", "wide", "variety", "of", "backends", "frameworks", "and", "languages", "NUMBER", "You", "ll", "find", "only", "the", "briefest", "of", "mentions", "of", "actual", "transport", "in", "the", "spec", "text", "and", "non", "normatively", "at", "that", "NUMBER", "values", "of", "which", "be", "often", "serialized", "when", "sent", "over", "a", "transport", "like", "HTTP", "NUMBER", "not", "all", "platforms", "and", "transports", "support", "encoding", "integer", "numbers", "larger", "than", "NUMBER", "bit", "NUMBER", "etc", "NUMBER", "You", "say", "graphql", "js", "respond", "with", "status", "NUMBER", "on", "invalid", "query", "graphql", "js", "has", "no", "notion", "of", "HTTP", "at", "all", "NUMBER", "Perhaps", "you", "be", "referring", "to", "express", "graphql", "In", "express", "graphql", "we", "elect", "to", "deal", "with", "invalid", "queries", "use", "a", "NUMBER", "status", "code", "because", "code", "in", "the", "NUMBER", "range", "be", "intended", "to", "indicate", "client", "error", "and", "supplying", "an", "invalid", "query", "be", "a", "client", "error", "NUMBER", "Thanks", "for", "the", "question", "raderio", "and", "also", "for", "the", "answer", "brokenpeace", "NUMBER", "GraphQL", "itself", "doesn", "t", "have", "any", "opinion", "on", "how", "you", "should", "do", "permissions", "or", "roles", "although", "it", "be", "flexible", "enough", "to", "accommodate", "a", "number", "of", "possible", "approaches", "NUMBER", "Exploring", "those", "be", "probably", "beyond", "the", "scope", "that", "we", "can", "tackle", "on", "this", "issue", "tracker", "and", "may", "be", "better", "suited", "to", "a", "dedicated", "question", "and", "answer", "platform", "like", "Stack", "Overflow", "or", "a", "library", "specific", "community", "depending", "on", "what", "tool", "you", "be", "use", "people", "may", "have", "solve", "similar", "issue", "with", "them", "in", "the", "past", "NUMBER", "See", "also", "similar", "question", "from", "raderio", "on", "the", "GraphiQL", "repo", "LINK", "As", "you", "ve", "noted", "it", "s", "a", "breaking", "change", "and", "there", "be", "no", "way", "to", "make", "the", "change", "without", "it", "be", "a", "breaking", "change", "that", "s", "why", "it", "be", "a", "breaking", "change", "NUMBER", "So", "your", "choices", "in", "a", "situation", "like", "this", "be", "to", "chose", "from", "among", "the", "following", "Not", "make", "the", "change", "NUMBER", "Make", "the", "change", "and", "suffer", "the", "consequences", "breakage", "of", "old", "clients", "NUMBER", "Make", "a", "different", "change", "instead", "NUMBER", "That", "second", "one", "make", "the", "change", "anyway", "may", "end", "up", "be", "viable", "under", "some", "circumstances", "such", "as", "The", "code", "never", "shipped", "to", "end", "users", "NUMBER", "The", "count", "of", "users", "on", "the", "old", "client", "and", "specifically", "the", "subset", "that", "uses", "features", "that", "rely", "on", "this", "data", "may", "be", "below", "a", "certain", "business", "defined", "threshold", "that", "make", "the", "breakage", "acceptable", "NUMBER", "You", "may", "have", "client", "side", "exception", "handle", "logic", "that", "makes", "failure", "to", "render", "the", "relate", "subset", "of", "the", "UI", "acceptable", "according", "to", "some", "business", "specific", "parameters", "NUMBER", "The", "third", "one", "make", "a", "different", "change", "could", "be", "something", "like", "add", "a", "new", "field", "eg", "NUMBER", "dob", "or", "date", "of", "birth", "that", "be", "non", "null", "and", "shipping", "down", "a", "non", "null", "eg", "NUMBER", "empty", "string", "value", "for", "birthday", "if", "the", "birthdate", "be", "miss", "NUMBER", "Once", "again", "this", "depends", "on", "product", "specifics", "will", "your", "client", "do", "a", "reasonable", "thing", "if", "supplied", "an", "empty", "date", "string", "Do", "you", "have", "date", "parsing", "code", "that", "be", "going", "to", "throw", "an", "exception", "and", "do", "your", "client", "handle", "it", "etc", "NUMBER", "This", "be", "why", "it", "be", "generally", "easier", "to", "make", "things", "nullable", "by", "default", "because", "moving", "things", "towards", "non", "null", "be", "a", "non", "breaking", "change", "NUMBER", "Note", "easier", "but", "not", "necessarily", "better", "an", "almost", "everything", "nullable", "schema", "be", "not", "so", "pleasant", "to", "work", "with", "on", "the", "client", "side", "NUMBER", "The", "difficulty", "here", "also", "makes", "it", "clear", "why", "it", "be", "desirable", "to", "let", "schema", "additions", "bake", "for", "an", "adequate", "period", "before", "rolling", "them", "out", "to", "public", "clients", "NUMBER", "You", "can", "save", "yourself", "some", "painful", "iterations", "in", "public", "if", "you", "instead", "let", "additions", "cook", "for", "a", "while", "internally", "first", "NUMBER", "I", "should", "add", "the", "concrete", "example", "that", "I", "gave", "of", "dob", "was", "a", "bit", "contrived", "if", "you", "were", "really", "going", "to", "do", "that", "you", "would", "probably", "just", "keep", "birthday", "as", "non", "null", "and", "make", "sure", "that", "you", "always", "shipped", "at", "least", "and", "empty", "string", "I", "just", "wanted", "to", "give", "an", "example", "of", "add", "a", "new", "field", "rather", "than", "change", "an", "exist", "one", "NUMBER", "Good", "catch", "NUMBER", "Thanks", "RichardLitt", "NUMBER", "Splitting", "this", "off", "from", "NUMBER", "We", "d", "like", "to", "enable", "translations", "of", "the", "spec", "into", "other", "languages", "in", "a", "scalable", "ie", "NUMBER", "crowd", "sourced", "convenient", "ie", "NUMBER", "minimizing", "manual", "synchronization", "work", "high", "quality", "ie", "NUMBER", "community", "review", "and", "support", "way", "NUMBER", "Crowdin", "LINK", "has", "be", "successfully", "use", "by", "other", "projects", "with", "FB", "involvement", "eg", "NUMBER", "Jest", "LINK", "Yarn", "LINK", "although", "I", "be", "not", "sure", "how", "easily", "it", "can", "be", "adapted", "to", "our", "Markdown", "centric", "workflow", "NUMBER", "Let", "s", "investigate", "NUMBER", "rmosolgo", "Yep", "NUMBER", "Let", "me", "edit", "the", "title", "to", "clarify", "that", "NUMBER", "Thanks", "for", "this", "wanghaisheng", "NUMBER", "I", "think", "the", "approach", "that", "we", "want", "to", "take", "to", "internationalizing", "the", "docs", "here", "be", "going", "to", "be", "similar", "to", "the", "one", "taken", "by", "other", "FB", "projects", "like", "Jest", "LINK", "NUMBER", "They", "store", "only", "the", "English", "docs", "in", "the", "source", "branch", "of", "the", "repo", "and", "then", "use", "Crowdin", "LINK", "as", "a", "platform", "to", "manage", "the", "translations", "which", "at", "build", "time", "get", "write", "out", "to", "the", "gh", "pages", "branch", "NUMBER", "So", "I", "don", "t", "think", "we", "d", "want", "to", "proceed", "with", "this", "PR", "as", "be", "and", "even", "if", "we", "did", "we", "d", "want", "to", "squash", "the", "history", "to", "remove", "the", "extraneous", "commit", "and", "unwanted", "change", "such", "as", "setting", "the", "executable", "bit", "on", "image", "file", "etc", "but", "rather", "do", "this", "the", "right", "way", "and", "set", "up", "Crowdin", "NUMBER", "Let", "me", "create", "another", "issue", "for", "that", "and", "we", "can", "continue", "the", "discussion", "there", "NUMBER", "Hopefully", "we", "can", "leverage", "the", "work", "that", "you", "ve", "already", "do", "NUMBER", "Sure", "although", "we", "should", "probably", "just", "change", "the", "end", "of", "the", "range", "to", "present", "once", "and", "for", "all", "NUMBER", "We", "do", "this", "in", "a", "lot", "of", "our", "projects", "example", "LINK", "L", "NUMBER", "NUMBER", "I", "ll", "merge", "this", "in", "any", "case", "as", "it", "be", "still", "better", "than", "having", "a", "stale", "year", "in", "there", "NUMBER", "eriknstr", "Regarding", "the", "practice", "of", "setting", "the", "end", "of", "the", "range", "to", "present", "be", "this", "something", "that", "Facebook", "lawyers", "have", "okayed", "or", "was", "that", "something", "developers", "came", "up", "with", "It", "s", "all", "over", "our", "internal", "codebases", "so", "be", "an", "established", "practice", "here", "NUMBER", "IMO", "it", "s", "unfortunate", "for", "a", "project", "to", "be", "use", "present", "because", "it", "makes", "it", "more", "difficult", "to", "determine", "in", "the", "future", "what", "years", "apply", "to", "a", "full", "or", "partial", "snapshot", "of", "some", "project", "e", "NUMBER", "g", "NUMBER", "if", "a", "file", "from", "one", "project", "be", "copied", "into", "another", "project", "in", "accordance", "with", "the", "terms", "of", "the", "license", "of", "the", "originating", "project", "NUMBER", "In", "general", "we", "try", "to", "avoid", "copying", "file", "from", "one", "project", "to", "another", "but", "in", "any", "case", "version", "control", "be", "probably", "the", "most", "reliable", "source", "of", "information", "here", "compared", "to", "a", "possibly", "stale", "human", "maintained", "code", "comment", "you", "can", "see", "when", "a", "file", "entered", "the", "project", "and", "when", "it", "was", "modify", "pretty", "trivially", "with", "both", "git", "on", "the", "command", "line", "and", "in", "the", "UI", "along", "with", "the", "generally", "useful", "context", "that", "you", "ll", "get", "from", "whatever", "commit", "message", "apply", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "I", "ve", "merge", "this", "into", "the", "RFC", "in", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thanks", "for", "pressing", "forward", "with", "this", "mike", "marcacci", "and", "my", "apologies", "for", "not", "addressing", "this", "PR", "much", "earlier", "NUMBER", "Perhaps", "you", "could", "speak", "to", "this", "at", "the", "next", "GraphQL", "work", "group", "meeting", "I", "m", "work", "on", "putting", "up", "an", "agenda", "for", "that", "today", "NUMBER", "I", "believe", "we", "considered", "this", "during", "the", "original", "design", "and", "turned", "it", "down", "for", "YAGNI", "reasons", "NUMBER", "It", "s", "just", "much", "simpler", "to", "have", "Object", "types", "describe", "all", "the", "interfaces", "they", "implement", "directly", "rather", "than", "having", "to", "walk", "a", "hierarchy", "NUMBER", "I", "think", "having", "concrete", "examples", "of", "type", "systems", "which", "be", "challenging", "or", "unsustainable", "without", "this", "feature", "could", "make", "a", "really", "compelling", "argument", "NUMBER", "My", "opinion", "based", "on", "what", "you", "ve", "drafted", "up", "so", "far", "be", "that", "it", "s", "eminently", "reasonable", "and", "requiring", "implement", "and", "explicitly", "defining", "the", "field", "solves", "any", "multiple", "inheritance", "issue", "NUMBER", "I", "think", "the", "true", "cost", "of", "this", "be", "only", "partly", "complexity", "cost", "but", "mostly", "change", "cost", "NUMBER", "Tools", "build", "around", "interfaces", "would", "need", "to", "expand", "to", "support", "this", "and", "that", "s", "non", "trivial", "NUMBER", "So", "we", "should", "just", "ensure", "the", "value", "it", "provides", "would", "be", "worth", "that", "cost", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "If", "I", "understand", "correctly", "you", "would", "like", "some", "capability", "to", "organize", "your", "mutations", "hierarchically", "Re", "define", "Live", "Queries", "Can", "Live", "Queries", "make", "Subscriptions", "unnecessary", "smolinari", "paralin", "laneyk", "dschafer", "taion", "Siyfion", "jamesgorman", "NUMBER", "leebyron", "Continuing", "the", "conversation", "from", "LINK", "issuecomment", "NUMBER", "I", "ll", "quote", "my", "original", "definition", "in", "the", "RFC", "Live", "Queries", "the", "client", "issue", "a", "standard", "query", "NUMBER", "Whenever", "the", "answer", "to", "the", "query", "change", "the", "server", "pushes", "the", "new", "data", "to", "the", "client", "NUMBER", "The", "key", "difference", "between", "Live", "Queries", "and", "Event", "based", "Subscriptions", "be", "that", "Live", "Queries", "do", "not", "depend", "on", "the", "notion", "of", "events", "NUMBER", "The", "data", "itself", "be", "live", "and", "include", "mechanisms", "to", "communicate", "change", "NUMBER", "Another", "way", "stubailo", "and", "I", "have", "describe", "it", "be", "infinitely", "fast", "cheap", "polling", "NUMBER", "live", "queries", "at", "scale", "isn", "t", "a", "solve", "science", "so", "we", "re", "going", "to", "ignore", "the", "concept", "entirely", "NUMBER", "I", "don", "t", "think", "anyone", "be", "ignoring", "the", "concept", "NUMBER", "But", "live", "queries", "at", "scale", "isn", "t", "a", "solve", "science", "has", "some", "truth", "to", "it", "NUMBER", "We", "hope", "to", "share", "more", "details", "in", "the", "come", "months", "as", "we", "continue", "to", "learn", "from", "our", "live", "query", "experiments", "at", "Facebook", "NUMBER", "However", "assuming", "live", "queries", "work", "perfectly", "we", "believe", "live", "queries", "and", "subscriptions", "be", "different", "tool", "in", "the", "real", "time", "API", "toolbox", "NUMBER", "For", "example", "in", "my", "case", "where", "I", "have", "many", "microservices", "on", "my", "backend", "where", "some", "nested", "field", "go", "to", "other", "services", "it", "s", "not", "really", "straightforward", "to", "define", "how", "live", "queries", "would", "work", "and", "I", "ve", "chosen", "explicitly", "to", "model", "things", "as", "event", "streams", "NUMBER", "taion", "I", "m", "curious", "to", "know", "if", "you", "think", "of", "subscriptions", "and", "live", "queries", "as", "semantically", "different", "NUMBER", "Suppose", "you", "had", "both", "subscriptions", "and", "live", "queries", "at", "your", "disposal", "when", "would", "you", "use", "one", "over", "the", "other", "Thanks", "everyone", "for", "the", "enlightening", "discussion", "here", "NUMBER", "I", "think", "the", "consensus", "be", "clear", "Live", "Queries", "be", "not", "simply", "better", "Subscriptions", "NUMBER", "Subscriptions", "and", "Live", "Queries", "be", "mechanically", "similar", "but", "semantically", "distinct", "Executable", "A", "standing", "query", "can", "be", "made", "live", "with", "the", "addition", "of", "a", "live", "directive", "which", "means", "nothing", "be", "inherently", "live", "about", "the", "query", "itself", "NUMBER", "Live", "queries", "will", "always", "return", "a", "meaningful", "initial", "result", "NUMBER", "Subscriptions", "typically", "do", "not", "return", "an", "initial", "result", "because", "the", "data", "to", "execute", "the", "subscription", "s", "selection", "set", "be", "only", "present", "when", "an", "event", "has", "be", "triggered", "NUMBER", "Domain", "specific", "reason", "for", "data", "change", "When", "a", "subscription", "pushes", "data", "to", "the", "client", "the", "_reason_", "why", "the", "data", "change", "be", "implicit", "for", "example", "someone", "liked", "a", "comment", "a", "new", "email", "has", "arrived", "a", "friend", "has", "logged", "on", "etc", "NUMBER", "Live", "Queries", "only", "observe", "data", "and", "reason", "why", "the", "data", "change", "must", "be", "explicitly", "modeled", "on", "the", "schema", "and", "queried", "NUMBER", "_Note", "on", "Isomorphism", "_", "Subscriptions", "and", "Live", "Queries", "be", "isomorphic", "NUMBER", "For", "example", "take", "an", "online", "friends", "list", "we", "can", "create", "a", "subscription", "to", "two", "separate", "events", "friendLoggedOn", "and", "friendLoggedOff", "or", "we", "can", "model", "a", "CQRS", "like", "event", "table", "and", "execute", "a", "live", "query", "against", "it", "NUMBER", "However", "just", "because", "it", "s", "possible", "to", "model", "Subscriptions", "as", "Live", "Queries", "and", "vice", "versa", "do", "not", "mean", "it", "be", "desirable", "NUMBER", "Doing", "so", "may", "compel", "us", "to", "model", "our", "data", "in", "awkward", "ways", "and", "we", "continue", "to", "discover", "use", "cases", "that", "be", "more", "ergonomically", "served", "by", "one", "model", "or", "the", "other", "NUMBER", "Fetching", "initial", "state", "when", "subscribing", "NUMBER", "stubailo", "rzachariah", "romandvoskin", "taion", "Continuing", "the", "conversation", "from", "LINK", "issuecomment", "NUMBER", "The", "server", "may", "respond", "to", "a", "subscription", "operation", "with", "a", "response", "Perhaps", "we", "can", "merge", "this", "with", "the", "subscription", "active", "response", "NUMBER", "Something", "like", "The", "server", "may", "respond", "to", "a", "subscription", "operation", "NUMBER", "This", "response", "can", "be", "useful", "for", "returning", "initial", "data", "or", "indicating", "whether", "the", "operation", "was", "successful", "NUMBER", "Sounds", "like", "there", "s", "consensus", "on", "this", "NUMBER", "Summarizing", "The", "server", "may", "respond", "to", "a", "subscription", "operation", "with", "a", "response", "NUMBER", "Subscription", "Active", "ACK", "be", "separate", "from", "the", "initial", "response", "NUMBER", "rmosolgo", "I", "like", "your", "word", "for", "the", "requirement", "would", "you", "please", "submit", "a", "PR", "For", "example", "at", "the", "end", "of", "this", "paragraph", "Subscribe", "the", "Client", "initializes", "a", "subscription", "by", "sending", "a", "query", "and", "its", "variables", "to", "the", "server", "NUMBER", "When", "the", "Subscription", "be", "created", "the", "input", "query", "and", "variables", "be", "mapped", "to", "a", "set", "of", "events", "to", "which", "the", "Subscription", "listens", "NUMBER", "Within", "LINK", "Updated", "the", "RFC", "LINK", "The", "event", "stream", "should", "be", "derived", "purely", "from", "the", "subscription", "root", "field", "and", "ignore", "selection", "set", "NUMBER", "dschafer", "leebyron", "rmosolgo", "taion", "OlegIlyenko", "stubailo", "Continuing", "the", "conversation", "from", "LINK", "issuecomment", "NUMBER", "Re", "model", "the", "concept", "of", "events", "as", "an", "abstract", "event", "stream", "NUMBER", "dschafer", "leebyron", "rmosolgo", "taion", "OlegIlyenko", "stubailo", "Continuing", "the", "conversation", "from", "LINK", "issuecomment", "NUMBER", "How", "should", "we", "pass", "event", "payloads", "data", "into", "the", "subscription", "resolvers", "stubailo", "taion", "leebyron", "dschafer", "wincent", "Continuing", "the", "conversation", "from", "LINK", "issuecomment", "NUMBER", "rootValue", "it", "be", "NUMBER", "Since", "this", "be", "specific", "to", "the", "GraphQL", "js", "implementation", "it", "will", "be", "left", "out", "of", "the", "spec", "NUMBER", "Where", "should", "subscription", "state", "be", "stored", "inside", "GraphQL", "js", "or", "as", "a", "separate", "component", "theorygeek", "taion", "stubailo", "rmosolgo", "jamesgorman", "NUMBER", "Continuing", "the", "conversation", "from", "LINK", "issuecomment", "NUMBER", "leebyron", "this", "be", "relevant", "to", "the", "discussion", "we", "had", "about", "subscription", "state", "NUMBER", "taion", "rmosolgo", "Looks", "like", "we", "have", "consensus", "to", "leave", "this", "out", "of", "the", "spec", "NUMBER", "I", "ll", "submit", "a", "PR", "to", "clarify", "the", "message", "in", "the", "RFC", "NUMBER", "EDIT", "Upon", "re", "reading", "the", "RFC", "there", "s", "be", "no", "implied", "constraints", "or", "recommendations", "for", "packaging", "module", "breakdown", "so", "I", "won", "t", "submit", "a", "PR", "after", "all", "NUMBER", "Closing", "this", "issue", "NUMBER", "Do", "we", "need", "a", "bi", "directional", "channel", "between", "client", "and", "server", "taion", "stubailo", "OlegIlyenko", "Continuing", "the", "conversation", "from", "LINK", "issuecomment", "NUMBER", "I", "agree", "SSE", "be", "fine", "for", "push", "message", "from", "the", "server", "to", "the", "client", "but", "SSE", "alone", "be", "not", "the", "full", "story", "NUMBER", "Perhaps", "the", "word", "semantics", "could", "be", "more", "explicit", "there", "had", "to", "be", "a", "request", "going", "from", "client", "to", "server", "for", "subscribe", "and", "unsubscribe", "NUMBER", "So", "we", "essentially", "have", "a", "logical", "channel", "where", "data", "flows", "both", "ways", "and", "can", "be", "initiated", "by", "either", "client", "or", "server", "NUMBER", "Whether", "that", "channel", "consists", "of", "SSE", "WS", "web", "hooks", "can", "be", "an", "implementation", "detail", "NUMBER", "OlegIlyenko", "awesome", "way", "to", "break", "it", "down", "NUMBER", "GraphQL", "execution", "engine", "may", "experience", "an", "unrecoverable", "error", "NUMBER", "This", "will", "complete", "stream", "as", "well", "NUMBER", "This", "be", "the", "one", "point", "I", "would", "object", "trying", "to", "tackle", "in", "this", "issue", "NUMBER", "I", "agree", "with", "everything", "else", "you", "said", "NUMBER", "My", "intent", "was", "not", "to", "describe", "specific", "transport", "capabilities", "merely", "that", "the", "communication", "flow", "throughout", "the", "subscription", "lifecycle", "be", "bi", "directional", "because", "there", "be", "both", "client", "and", "server", "initiated", "communications", "in", "the", "case", "of", "SSE", "HTTP", "I", "consider", "the", "initial", "HTTP", "request", "to", "be", "an", "instance", "of", "client", "initiated", "communication", "NUMBER", "I", "think", "everyone", "be", "mostly", "in", "agreement", "on", "this", "topic", "NUMBER", "The", "only", "follow", "up", "action", "be", "to", "make", "the", "word", "more", "clear", "NUMBER", "Any", "objections", "Removed", "the", "mention", "of", "bi", "directional", "with", "this", "commit", "LINK", "Thanks", "In", "the", "future", "feel", "free", "to", "send", "pull", "request", "for", "things", "like", "this", "which", "get", "much", "more", "visibility", "Here", "s", "my", "attempt", "to", "organize", "this", "thread", "into", "topics", "Closed", "Add", "clearer", "notice", "that", "the", "RFC", "be", "a", "work", "in", "progress", "NUMBER", "Add", "backward", "arrow", "from", "GraphQL", "to", "Subscriptions", "box", "in", "diagram", "rmosolgo", "Make", "subscription", "active", "part", "of", "the", "lifecycle", "optional", "and", "recommended", "for", "client", "side", "error", "handle", "taion", "stubailo", "Open", "Do", "we", "need", "a", "bi", "directional", "channel", "between", "client", "and", "server", "taion", "stubailo", "OlegIlyenko", "Where", "should", "subscription", "state", "be", "stored", "inside", "GraphQL", "js", "or", "as", "a", "separate", "component", "theorygeek", "taion", "stubailo", "rmosolgo", "jamesgorman", "NUMBER", "How", "should", "we", "pass", "event", "payloads", "data", "into", "the", "subscription", "resolvers", "stubailo", "taion", "leebyron", "dschafer", "wincent", "Re", "model", "the", "concept", "of", "events", "as", "an", "abstract", "event", "stream", "NUMBER", "dschafer", "leebyron", "rmosolgo", "taion", "OlegIlyenko", "stubailo", "The", "event", "stream", "should", "be", "derived", "purely", "from", "the", "subscription", "root", "field", "and", "ignore", "selection", "set", "NUMBER", "dschafer", "leebyron", "rmosolgo", "taion", "OlegIlyenko", "stubailo", "Fetching", "initial", "state", "when", "subscribing", "NUMBER", "stubailo", "rzachariah", "romandvoskin", "taion", "Re", "define", "Live", "Queries", "Can", "Live", "Queries", "make", "Subscriptions", "unnecessary", "smolinari", "paralin", "laneyk", "dschafer", "taion", "Siyfion", "jamesgorman", "NUMBER", "leebyron", "Intermediate", "Subscription", "event", "processing", "rzachariah", "romandvoskin", "Please", "let", "me", "know", "if", "I", "ve", "miss", "your", "topic", "or", "if", "you", "would", "like", "to", "be", "add", "remove", "from", "anything", "NUMBER", "I", "ll", "leave", "this", "post", "here", "for", "a", "bit", "so", "everyone", "tag", "has", "a", "chance", "to", "review", "NUMBER", "After", "that", "I", "m", "going", "to", "merge", "this", "PR", "and", "file", "issue", "for", "all", "open", "topics", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thanks", "sogko", "Thanks", "for", "the", "correction", "sogko", "NUMBER", "I", "ll", "merge", "this", "NUMBER", "I", "also", "think", "your", "further", "suggested", "edit", "looks", "good", "so", "feel", "free", "to", "submit", "a", "PR", "for", "that", "too", "NUMBER", "The", "spec", "chapter", "on", "introspection", "mentions", "that", "type", "artifacts", "must", "not", "be", "named", "with", "__", "since", "it", "be", "reserved", "NUMBER", "This", "clarification", "repeats", "this", "information", "closer", "to", "the", "spec", "on", "type", "system", "itself", "along", "with", "the", "rules", "for", "determining", "if", "object", "interface", "types", "be", "valid", "NUMBER", "Certainly", "if", "ids", "end", "up", "both", "use", "__", "and", "not", "be", "part", "of", "the", "introspection", "system", "then", "the", "exist", "language", "would", "need", "to", "change", "NUMBER", "I", "d", "hope", "we", "can", "avoid", "that", "outcome", "though", "NUMBER", "So", "if", "ids", "be", "not", "defined", "in", "the", "schema", "and", "be", "accessed", "as", "meta", "field", "they", "should", "use", "__", "however", "if", "ids", "be", "defined", "in", "the", "schema", "not", "a", "metafield", "then", "they", "should", "not", "use", "__", "NUMBER", "Sorry", "for", "letting", "this", "issue", "sit", "NUMBER", "LINK", "sec", "Float", "Value", "claims", "that", "a", "FloatValue", "needs", "either", "FractionalPart", "or", "ExponentPart", "or", "both", "but", "not", "neither", "which", "would", "be", "IntValue", "NUMBER", "graphql", "js", "correctly", "lexes", "these", "see", "the", "unit", "test", "for", "error", "cases", "LINK", "js", "blob", "master", "src", "language", "test", "lexer", "test", "NUMBER", "js", "L", "NUMBER", "L", "NUMBER", "Unfortunately", "this", "would", "be", "a", "breaking", "change", "to", "the", "spec", "for", "a", "couple", "reasons", "but", "I", "m", "not", "convinced", "that", "Unions", "be", "not", "useful", "simply", "because", "they", "re", "harder", "to", "use", "in", "pattern", "matching", "scenarios", "NUMBER", "I", "also", "disagree", "with", "that", "I", "ve", "seen", "pattern", "matching", "at", "play", "with", "GraphQL", "Unions", "to", "great", "effect", "in", "fact", "it", "s", "one", "of", "a", "few", "reasons", "why", "Unions", "in", "GraphQL", "be", "powerful", "NUMBER", "First", "Let", "s", "look", "at", "client", "s", "pattern", "matching", "on", "return", "types", "for", "a", "Union", "graphql", "union", "OneOf", "A", "B", "C", "Then", "in", "my", "client", "code", "pseudo", "code", "switch", "oneOf", "case", "A", "case", "B", "case", "C", "One", "of", "two", "things", "can", "happen", "First", "a", "type", "could", "be", "remove", "NUMBER", "Perhaps", "B", "gets", "remove", "from", "the", "union", "NUMBER", "Clients", "be", "naturally", "resilient", "to", "this", "they", "assume", "B", "could", "theoretically", "appear", "at", "some", "point", "even", "if", "it", "never", "do", "NUMBER", "Second", "and", "more", "importantly", "a", "type", "could", "be", "_added_", "to", "the", "union", "NUMBER", "Perhaps", "D", "gets", "add", "NUMBER", "Client", "s", "need", "to", "be", "resilient", "to", "this", "as", "well", "so", "clients", "that", "support", "this", "kind", "of", "exhaustive", "pattern", "matching", "always", "add", "one", "more", "case", "switch", "oneOf", "case", "A", "case", "B", "case", "C", "case", "Unknown", "Because", "of", "how", "unions", "must", "be", "queried", "the", "unknown", "type", "be", "the", "empty", "object", "type", "NUMBER", "Next", "let", "s", "look", "at", "the", "ergonomics", "of", "defining", "Unions", "and", "Interfaces", "and", "the", "rationale", "for", "the", "restrictions", "in", "place", "NUMBER", "As", "you", "quoted", "from", "the", "spec", "Unions", "be", "defined", "locally", "while", "Interfaces", "be", "defined", "by", "implementation", "of", "each", "Object", "type", "NUMBER", "This", "models", "the", "data", "domain", "in", "different", "ways", "NUMBER", "A", "Union", "be", "a", "way", "to", "say", "I", "may", "return", "one", "of", "a", "few", "things", "at", "this", "location", "it", "should", "be", "defined", "locally", "to", "the", "field", "NUMBER", "For", "example", "a", "Video", "type", "doesn", "t", "need", "to", "describe", "that", "it", "might", "appear", "alongside", "Photo", "for", "some", "specific", "field", "though", "a", "specific", "field", "needs", "to", "describe", "that", "it", "might", "return", "Video", "Photo", "NUMBER", "An", "Interface", "be", "a", "way", "to", "say", "I", "conform", "to", "this", "contract", "it", "should", "be", "defined", "locally", "to", "the", "thing", "which", "conforms", "the", "Object", "type", "NUMBER", "For", "example", "a", "User", "type", "should", "be", "able", "to", "say", "that", "it", "fulfills", "the", "contract", "of", "Profile", "such", "that", "any", "type", "current", "know", "or", "unknown", "can", "be", "use", "knowing", "that", "it", "fulfills", "the", "contract", "NUMBER", "This", "also", "drives", "the", "requirement", "that", "Interfaces", "must", "define", "at", "least", "one", "field", "otherwise", "the", "Interface", "would", "not", "actually", "describe", "a", "contract", "to", "be", "fulfilled", "NUMBER", "This", "concept", "of", "contract", "less", "interfaces", "be", "often", "call", "marker", "interfaces", "and", "in", "my", "opinion", "hopefully", "not", "an", "uncommon", "opinion", "be", "a", "bad", "practice", "borrowed", "from", "limited", "object", "oriented", "languages", "NUMBER", "They", "re", "typically", "use", "either", "as", "a", "backfill", "for", "languages", "like", "Java", "that", "don", "t", "have", "a", "good", "concept", "of", "Union", "or", "be", "use", "as", "metadata", "annotations", "for", "languages", "that", "don", "t", "have", "metadata", "annotations", "NUMBER", "I", "don", "t", "think", "either", "should", "apply", "to", "GraphQL", "for", "modeling", "data", "domains", "NUMBER", "kafkahw", "I", "m", "personally", "for", "keep", "unions", "for", "semantic", "reasoning", "but", "here", "be", "a", "few", "problem", "in", "your", "argument", "Without", "union", "you", "ll", "have", "to", "declare", "more", "types", "because", "each", "type", "will", "be", "strictly", "coupled", "with", "only", "one", "interface", "NUMBER", "You", "can", "inherit", "multiple", "interfaces", "graphql", "interface", "U", "NUMBER", "interface", "U", "NUMBER", "type", "ObjA", "implement", "U", "NUMBER", "type", "ObjB", "implement", "U", "NUMBER", "U", "NUMBER", "type", "ObjC", "implement", "U", "NUMBER", "Another", "use", "case", "be", "when", "you", "need", "to", "deal", "with", "exist", "types", "interface", "can", "t", "help", "NUMBER", "Say", "I", "need", "to", "define", "a", "field", "in", "a", "type", "that", "could", "be", "String", "Int", "or", "Float", "NUMBER", "You", "can", "t", "make", "unions", "with", "scalars", "only", "with", "object", "types", "NUMBER", "Even", "if", "you", "have", "external", "object", "types", "you", "can", "always", "extend", "it", "with", "new", "interface", "graphql", "interface", "UnionImitation", "extend", "type", "SomeExternalType", "implement", "UnionImitation", "Currently", "LINK", "sec", "Input", "Objects", "reads", "This", "unordered", "map", "should", "not", "contain", "any", "entries", "with", "names", "not", "defined", "by", "a", "field", "of", "this", "input", "object", "type", "otherwise", "an", "error", "should", "be", "throw", "NUMBER", "Which", "be", "designed", "to", "help", "detect", "runtime", "error", "which", "may", "be", "the", "result", "of", "typo", "NUMBER", "However", "this", "unnecessarily", "introduces", "a", "vector", "for", "breaking", "change", "NUMBER", "If", "a", "field", "of", "an", "input", "object", "be", "remove", "in", "the", "schema", "then", "exist", "queries", "may", "all", "the", "sudden", "result", "in", "execution", "error", "even", "though", "they", "re", "provide", "strictly", "more", "inputs", "to", "the", "server", "than", "it", "requires", "NUMBER", "Variations", "of", "this", "have", "be", "request", "in", "graphql", "js", "before", "LINK", "js", "pull", "NUMBER", "Notably", "the", "same", "restriction", "be", "not", "placed", "on", "field", "argument", "additional", "field", "argument", "on", "a", "field", "do", "not", "result", "in", "an", "execution", "error", "however", "it", "do", "result", "in", "a", "validation", "error", "NUMBER", "Validation", "should", "still", "insist", "on", "not", "allowing", "unknown", "field", "to", "an", "input", "object", "NUMBER", "I", "think", "that", "s", "right", "though", "it", "s", "all", "up", "for", "debate", "NUMBER", "LINK", "sec", "Argument", "Values", "Type", "Correctness", "and", "LINK", "sec", "Variable", "Default", "Values", "Are", "Correctly", "Typed", "encapsulate", "this", "behavior", "right", "now", "NUMBER", "Values", "provide", "must", "be", "of", "the", "right", "type", "NUMBER", "Combine", "that", "with", "LINK", "sec", "Input", "Objects", "input", "coercion", "rules", "which", "says", "NUMBER", "should", "not", "contain", "any", "entries", "with", "names", "not", "defined", "by", "a", "field", "of", "this", "input", "object", "type", "otherwise", "an", "error", "should", "be", "throw", "NUMBER", "It", "s", "maybe", "a", "little", "weird", "for", "literal", "values", "and", "runtime", "variable", "values", "to", "diverge", "in", "behavior", "so", "that", "deserves", "fair", "criticism", "NUMBER", "It", "seems", "to", "me", "that", "having", "the", "validation", "to", "enforce", "only", "allowing", "the", "field", "of", "an", "input", "object", "for", "literals", "may", "still", "be", "valuable", "but", "I", "think", "we", "could", "make", "a", "similar", "argument", "above", "about", "what", "should", "and", "shouldn", "t", "be", "considered", "a", "breaking", "change", "NUMBER", "What", "was", "most", "motivating", "to", "me", "along", "the", "lines", "of", "breaking", "change", "was", "that", "variable", "values", "be", "checked", "at", "runtime", "before", "executing", "which", "breaks", "the", "execution", "of", "queries", "if", "additional", "variable", "data", "be", "provide", "NUMBER", "We", "already", "have", "precedent", "for", "schema", "change", "that", "cause", "previously", "valid", "queries", "to", "appear", "invalid", "though", "still", "have", "totally", "reasonable", "execution", "behavior", "and", "this", "be", "a", "nice", "property", "to", "have", "NUMBER", "We", "could", "apply", "the", "same", "judgement", "to", "this", "case", "remove", "an", "input", "object", "field", "from", "the", "schema", "would", "render", "queries", "invalid", "but", "at", "least", "still", "executable", "with", "expected", "behavior", "NUMBER", "I", "just", "fix", "the", "table", "and", "bold", "rendering", "issue", "you", "point", "out", "here", "so", "thank", "you", "for", "the", "careful", "read", "This", "be", "looking", "good", "thanks", "for", "coalescing", "the", "RFC", "NUMBER", "In", "my", "mind", "the", "biggest", "question", "be", "how", "__id", "should", "be", "represented", "in", "introspection", "NUMBER", "It", "seems", "like", "it", "should", "be", "a", "meta", "field", "like", "__typename", "in", "as", "many", "ways", "as", "possible", "however", "_every_", "object", "type", "has", "a", "name", "so", "it", "s", "clear", "that", "you", "can", "always", "request", "__typename", "but", "not", "every", "object", "type", "be", "uniquely", "identifiable", "or", "cacheable", "NUMBER", "We", "need", "some", "way", "to", "allow", "some", "types", "to", "have", "ids", "and", "others", "to", "not", "NUMBER", "I", "m", "not", "sure", "that", "expressing", "ids", "as", "nullable", "be", "what", "we", "want", "for", "example", "if", "I", "fetched", "a", "bunch", "of", "User", "types", "that", "I", "expected", "to", "all", "be", "cacheable", "and", "I", "encountered", "one", "with", "__id", "null", "then", "I", "might", "have", "relied", "on", "a", "flawed", "assumption", "NUMBER", "Having", "ids", "be", "non", "nullable", "be", "very", "valuable", "property", "to", "be", "able", "to", "rely", "on", "so", "ideally", "we", "can", "enforce", "non", "nullable", "ids", "as", "often", "as", "possible", "if", "not", "as", "the", "default", "NUMBER", "Another", "piece", "of", "feedback", "be", "just", "at", "a", "high", "level", "why", "should", "we", "be", "including", "this", "in", "the", "spec", "with", "additional", "behavior", "rather", "than", "simply", "make", "an", "id", "ID", "field", "a", "best", "practice", "for", "cacheable", "types", "The", "spec", "should", "be", "as", "small", "as", "possible", "and", "no", "smaller", "so", "we", "should", "ensure", "we", "have", "a", "strong", "argument", "for", "moving", "this", "from", "best", "practice", "to", "spec", "NUMBER", "Specifically", "I", "think", "the", "argument", "client", "caches", "would", "like", "to", "rely", "on", "this", "be", "a", "little", "faulty", "as", "we", "already", "have", "client", "caches", "that", "rely", "on", "different", "form", "of", "pagination", "and", "connection", "models", "with", "those", "as", "best", "practices", "and", "no", "impact", "on", "the", "spec", "NUMBER", "I", "know", "we", "ve", "talked", "before", "about", "change", "to", "the", "GraphQL", "execution", "engine", "itself", "before", "that", "needed", "some", "way", "to", "identify", "objects", "that", "perhaps", "we", "should", "allude", "to", "in", "this", "RFC", "NUMBER", "For", "example", "one", "of", "the", "reasons", "that", "led", "me", "to", "think", "that", "__id", "might", "be", "necessary", "was", "trying", "to", "figure", "out", "how", "GraphQL", "could", "respond", "in", "an", "already", "normalized", "graph", "format", "rather", "than", "it", "s", "current", "tree", "format", "NUMBER", "Which", "means", "would", "this", "not", "be", "instance", "specific", "and", "better", "off", "served", "by", "having", "common", "conventions", "and", "practices", "of", "a", "meaningful", "id", "field", "More", "generally", "__", "be", "reserved", "for", "use", "by", "the", "GraphQL", "system", "itself", "which", "so", "far", "has", "only", "use", "this", "preserved", "space", "for", "introspection", "NUMBER", "Practically", "use", "a", "non", "prefixed", "field", "be", "only", "reasonable", "when", "suggesting", "common", "practice", "and", "not", "appropriate", "for", "use", "by", "the", "GraphQL", "spec", "itself", "since", "perhaps", "clients", "already", "have", "a", "field", "call", "id", "and", "the", "potential", "for", "the", "spec", "to", "collide", "with", "user", "definitions", "be", "high", "NUMBER", "In", "a", "final", "decision", "where", "this", "should", "be", "a", "common", "practice", "then", "id", "ID", "would", "be", "the", "recommendation", "NUMBER", "In", "a", "final", "decision", "where", "this", "be", "encoded", "in", "the", "spec", "then", "a", "__id", "meta", "field", "would", "be", "more", "appropriate", "NUMBER", "Great", "conversation", "so", "far", "NUMBER", "Let", "me", "try", "to", "round", "up", "where", "we", "be", "and", "some", "decisions", "that", "need", "to", "be", "clarified", "and", "made", "id", "vs", "__id", "First", "be", "what", "to", "name", "this", "field", "NUMBER", "The", "name", "id", "lends", "itself", "to", "user", "created", "schema", "NUMBER", "Because", "__", "be", "reserved", "by", "GraphQL", "introspection", "we", "shouldn", "t", "be", "use", "it", "for", "user", "created", "types", "and", "field", "NUMBER", "However", "if", "this", "field", "be", "a", "meta", "field", "then", "__id", "be", "more", "appropriate", "make", "it", "more", "similar", "to", "__typename", "which", "be", "of", "course", "never", "defined", "in", "user", "created", "schema", "NUMBER", "Another", "notable", "drawback", "to", "id", "be", "that", "add", "constraints", "to", "it", "would", "add", "a", "constraint", "for", "exist", "systems", "to", "work", "around", "should", "they", "want", "to", "expose", "some", "field", "call", "id", "which", "has", "different", "semantics", "NUMBER", "They", "would", "have", "to", "rename", "their", "other", "field", "NUMBER", "I", "ll", "refer", "to", "it", "as", "__id", "through", "the", "rest", "of", "this", "comment", "but", "the", "question", "still", "be", "open", "NUMBER", "Should", "__id", "always", "have", "a", "value", "It", "seems", "clear", "from", "the", "conversation", "that", "if", "__id", "be", "queried", "on", "an", "object", "which", "be", "capable", "of", "provide", "ids", "that", "it", "must", "provide", "a", "non", "null", "value", "NUMBER", "However", "should", "all", "types", "provide", "non", "null", "__id", "I", "think", "we", "ve", "proven", "that", "s", "not", "really", "possible", "NUMBER", "Some", "combination", "of", "parent", "id", "field", "path", "could", "be", "use", "but", "there", "be", "issue", "with", "this", "approach", "NUMBER", "Can", "the", "__id", "field", "be", "request", "anywhere", "I", "think", "it", "s", "reasonable", "to", "consider", "an", "exception", "to", "the", "validation", "rules", "for", "meta", "field", "NUMBER", "Meta", "field", "be", "not", "part", "of", "a", "schema", "so", "they", "have", "different", "rules", "NUMBER", "Should", "there", "be", "an", "__Identifiable", "interface", "Not", "sure", "if", "this", "was", "propose", "as", "a", "counter", "proposal", "to", "__id", "having", "different", "validation", "rules", "NUMBER", "How", "be", "__id", "represented", "in", "the", "schema", "language", "Are", "types", "which", "support", "the", "__id", "field", "required", "to", "declare", "it", "explicitly", "so", "as", "a", "regular", "field", "If", "so", "then", "perhaps", "id", "be", "more", "appropriate", "as", "that", "would", "make", "it", "not", "a", "meta", "field", "NUMBER", "Should", "the", "schema", "language", "having", "an", "identifiable", "directive", "It", "seems", "like", "most", "types", "would", "be", "identifiable", "so", "perhaps", "non", "identifiable", "should", "be", "call", "out", "differently", "How", "be", "__id", "represented", "in", "the", "introspection", "result", "If", "__id", "be", "a", "meta", "field", "then", "it", "shouldn", "t", "appear", "as", "part", "of", "the", "schema", "just", "as", "__typename", "do", "not", "however", "some", "indication", "of", "a", "type", "be", "identifiable", "needs", "to", "be", "available", "if", "not", "all", "types", "be", "available", "so", "schema", "aware", "clients", "know", "what", "to", "expect", "NUMBER", "Here", "s", "a", "counter", "proposal", "to", "consider", "we", "could", "standardize", "a", "clarified", "version", "of", "the", "current", "best", "practice", "NUMBER", "Constrain", "id", "with", "musts", "Specifically", "Types", "be", "not", "required", "to", "provide", "a", "field", "id", "however", "if", "they", "do", "it", "must", "be", "of", "type", "ID", "NUMBER", "return", "values", "unique", "for", "the", "entire", "schema", "domain", "NUMBER", "A", "field", "named", "id", "be", "valid", "to", "be", "queried", "in", "any", "selection", "set", "NUMBER", "Execution", "behavior", "be", "unchanged", "which", "means", "if", "id", "be", "queried", "on", "a", "type", "which", "do", "not", "implement", "it", "then", "no", "entry", "be", "add", "to", "the", "response", "for", "that", "field", "NUMBER", "Pros", "This", "be", "the", "simplest", "thing", "that", "works", "NUMBER", "No", "change", "be", "required", "to", "introspection", "NUMBER", "No", "change", "be", "required", "to", "the", "schema", "language", "NUMBER", "There", "be", "no", "addition", "of", "new", "meta", "field", "NUMBER", "Critically", "this", "be", "backwards", "compatible", "with", "exist", "libraries", "tool", "NUMBER", "All", "Relay", "esque", "apps", "and", "APIs", "continue", "to", "work", "NUMBER", "Easy", "to", "auto", "add", "to", "queries", "for", "schemaless", "clients", "NUMBER", "Does", "not", "require", "interfaces", "NUMBER", "Cons", "This", "highly", "constrains", "id", "as", "a", "field", "to", "use", "NUMBER", "This", "change", "be", "potentially", "breaking", "with", "exist", "APIs", "if", "they", "use", "id", "in", "a", "non", "best", "practice", "way", "or", "of", "a", "different", "type", "NUMBER", "Potentiall", "for", "confusion", "if", "non", "refetchable", "id", "sometimes", "use", "to", "refetch", "when", "use", "with", "a", "Node", "interface", "NUMBER", "Alternative", "Same", "but", "__id", "NUMBER", "Same", "as", "above", "but", "replace", "id", "with", "__id", "NUMBER", "In", "my", "personal", "opinion", "the", "cons", "of", "this", "blurring", "the", "meaning", "of", "__", "would", "be", "pretty", "damning", "for", "this", "particular", "approach", "NUMBER", "Pros", "No", "collisions", "with", "exist", "APIs", "NUMBER", "Cons", "This", "be", "not", "a", "meta", "field", "blurs", "the", "line", "as", "all", "other", "__", "field", "be", "meta", "NUMBER", "Requiring", "people", "to", "define", "__id", "manually", "be", "confusing", "between", "user", "domain", "and", "graphql", "introspection", "domain", "NUMBER", "Ya", "to", "be", "clear", "the", "Easy", "to", "auto", "add", "to", "queries", "for", "schemaless", "clients", "NUMBER", "has", "nothing", "to", "do", "with", "id", "vs", "__id", "that", "s", "just", "about", "the", "make", "the", "validation", "exception", "NUMBER", "I", "think", "taking", "up", "the", "name", "id", "can", "be", "a", "pretty", "big", "disadvantage", "because", "then", "you", "have", "to", "start", "having", "field", "like", "sqlId", "or", "something", "NUMBER", "Yeah", "it", "certainly", "can", "require", "people", "to", "work", "around", "this", "which", "be", "a", "disadvantage", "for", "moving", "quickly", "however", "perhaps", "it", "s", "an", "advantage", "for", "the", "design", "quality", "of", "the", "resulting", "APIs", "Directly", "exposing", "SQL", "IDs", "be", "a", "code", "smell", "since", "it", "leaks", "implementation", "details", "about", "the", "API", "NUMBER", "we", "had", "similar", "issue", "at", "Facebook", "to", "interop", "with", "old", "APIs", "we", "expose", "legacy_id", "on", "some", "types", "I", "could", "also", "argue", "that", "the", "pit", "of", "success", "LINK", "into", "the", "pit", "of", "success", "would", "have", "us", "make", "the", "id", "field", "which", "corresponds", "to", "caching", "and", "occasionally", "refetching", "as", "easy", "to", "guess", "and", "use", "as", "possible", "NUMBER", "An", "API", "which", "exposes", "type", "local", "SQL", "ids", "as", "id", "and", "global", "cacheable", "ids", "as", "__id", "could", "cause", "confusion", "NUMBER", "Which", "should", "a", "user", "of", "the", "API", "use", "They", "will", "probably", "use", "the", "one", "call", "id", "since", "it", "s", "easier", "to", "type", "than", "__id", "NUMBER", "Another", "thing", "to", "consider", "be", "the", "case", "where", "objects", "be", "both", "uniquely", "cacheable", "AND", "be", "refetchable", "NUMBER", "It", "be", "probably", "confusing", "to", "say", "that", "you", "should", "use", "the", "id", "field", "for", "refetching", "things", "but", "use", "the", "__id", "field", "for", "caching", "things", "NUMBER", "Not", "only", "be", "that", "potentially", "confusing", "but", "if", "an", "API", "exposes", "the", "same", "value", "for", "id", "and", "__id", "all", "of", "the", "time", "then", "perhaps", "clients", "will", "only", "fetch", "one", "or", "the", "other", "but", "use", "the", "one", "value", "for", "both", "contexts", "NUMBER", "That", "might", "be", "fine", "up", "until", "the", "point", "where", "they", "stop", "returning", "the", "same", "value", "Or", "for", "APIs", "where", "the", "two", "field", "return", "different", "values", "then", "it", "could", "be", "too", "easy", "to", "accidentally", "use", "the", "value", "for", "__id", "somewhere", "that", "expects", "id", "and", "vice", "versa", "cause", "bug", "NUMBER", "I", "guess", "another", "way", "to", "rephrase", "this", "concern", "be", "that", "clear", "API", "design", "would", "lead", "us", "to", "use", "only", "id", "or", "__id", "but", "not", "both", "NUMBER", "Should", "we", "actually", "allow", "for", "this", "kind", "of", "confusing", "scenario", "This", "proposes", "support", "for", "the", "entire", "unicode", "character", "range", "in", "a", "source", "document", "rather", "than", "explicitly", "excluding", "certain", "characters", "NUMBER", "Because", "this", "doesn", "t", "add", "any", "new", "characters", "to", "the", "ignored", "sequences", "in", "practice", "this", "allows", "for", "add", "more", "characters", "to", "comments", "low", "value", "and", "strings", "high", "value", "NUMBER", "This", "allows", "strings", "to", "include", "literal", "unicode", "points", "as", "a", "way", "to", "represent", "supplemental", "plane", "characters", "NUMBER", "In", "fact", "it", "almost", "allows", "ignoring", "escape", "sequences", "altogether", "as", "all", "characters", "can", "be", "represented", "literally", "NUMBER", "Suggested", "by", "NUMBER", "Drawbacks", "and", "concerns", "I", "d", "like", "feedback", "on", "from", "folks", "with", "more", "experience", "dealing", "with", "unicode", "corner", "cases", "By", "encouraging", "use", "of", "non", "ascii", "characters", "in", "strings", "we", "will", "inevitably", "see", "utf", "NUMBER", "file", "that", "include", "supplemental", "plane", "and", "surrogate", "pair", "points", "NUMBER", "Will", "this", "break", "any", "common", "tool", "or", "create", "an", "unnecessary", "burden", "This", "remove", "the", "restriction", "of", "excluding", "control", "flow", "characters", "from", "the", "source", "NUMBER", "This", "be", "in", "the", "name", "of", "simplicity", "however", "it", "may", "have", "real", "drawbacks", "for", "interaction", "with", "other", "tool", "NUMBER", "For", "example", "could", "sources", "that", "contain", "U", "NUMBER", "be", "interpreted", "as", "the", "end", "of", "a", "file", "If", "this", "remains", "a", "real", "concern", "it", "might", "be", "worth", "add", "back", "that", "restriction", "just", "as", "a", "point", "of", "practical", "convenience", "NUMBER", "Check", "out", "a", "rendering", "of", "this", "patch", "applied", "here", "LINK", "gxioxiaqyc", "NUMBER", "now", "NUMBER", "sh", "Updated", "to", "incorporate", "feedback", "This", "be", "looking", "good", "thanks", "for", "write", "this", "This", "rule", "was", "suggested", "by", "jjergus", "NUMBER", "to", "remove", "ambiguity", "from", "execution", "where", "the", "skip", "and", "ignore", "directive", "rules", "make", "the", "assumption", "that", "only", "one", "be", "defined", "per", "selection", "NUMBER", "In", "general", "I", "think", "this", "assumption", "should", "be", "upheld", "by", "valid", "queries", "overall", "not", "just", "for", "skip", "and", "include", "so", "that", "it", "can", "be", "relied", "upon", "for", "any", "usage", "of", "directives", "NUMBER", "For", "example", "this", "allows", "a", "potential", "optimization", "to", "use", "a", "hashmap", "keyed", "on", "directive", "name", "to", "represent", "the", "directives", "at", "a", "location", "rather", "than", "an", "array", "NUMBER", "Closes", "NUMBER", "Exactly", "NUMBER", "I", "think", "the", "latter", "API", "be", "more", "explicit", "to", "the", "possible", "behavior", "NUMBER", "Further", "rationale", "after", "an", "offline", "discussion", "with", "dschafer", "While", "this", "be", "explicitly", "a", "limiting", "change", "and", "therefore", "potentially", "breaking", "by", "reducing", "what", "be", "possible", "now", "it", "_increases_", "future", "option", "value", "NUMBER", "This", "change", "be", "one", "that", "we", "could", "always", "change", "back", "in", "some", "capacity", "in", "the", "future", "in", "a", "non", "breaking", "way", "should", "an", "explicit", "need", "arise", "NUMBER", "Barring", "any", "such", "need", "today", "it", "s", "in", "our", "best", "interest", "to", "preserve", "that", "option", "value", "NUMBER", "There", "were", "some", "recent", "clarification", "improvement", "to", "the", "execution", "phase", "NUMBER", "Specifically", "LINK", "sec", "Value", "Completion", "should", "describe", "the", "interrelationship", "between", "List", "and", "Non", "Null", "types", "during", "the", "execution", "of", "field", "values", "NUMBER", "Please", "let", "me", "know", "if", "you", "still", "have", "question", "after", "reading", "this", "section", "and", "hopefully", "we", "can", "use", "your", "feedback", "to", "further", "clarify", "or", "perhaps", "to", "add", "examples", "NUMBER", "Let", "me", "try", "to", "use", "your", "example", "and", "attempt", "to", "simplify", "and", "then", "show", "some", "example", "data", "Just", "for", "simplicity", "I", "ll", "use", "the", "following", "simple", "form", "to", "represent", "values", "Simple", "Typed", "NUMBER", "some", "Value", "NUMBER", "null", "none", "Error", "whoops", "error", "Reason", "whoops", "With", "this", "schema", "graphql", "type", "Query", "a", "Wrapper", "Where", "Type", "be", "one", "of", "the", "types", "below", "type", "Wrapper", "b", "Type", "Where", "Type", "be", "one", "of", "Int", "Int", "Int", "Int", "Int", "Int", "Where", "the", "value", "find", "at", "a", "NUMBER", "b", "be", "one", "of", "NUMBER", "null", "Error", "whoops", "NUMBER", "NUMBER", "NUMBER", "null", "NUMBER", "Error", "whoops", "Int", "Int", "NUMBER", "graphql", "data", "a", "b", "NUMBER", "Int", "null", "graphql", "data", "a", "b", "null", "Int", "Error", "whoops", "graphql", "data", "a", "b", "null", "error", "message", "whoops", "path", "a", "b", "Int", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "NUMBER", "NUMBER", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "NUMBER", "null", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "NUMBER", "Error", "whoops", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "Int", "NUMBER", "graphql", "data", "a", "b", "NUMBER", "Int", "null", "graphql", "data", "a", "null", "error", "message", "invalid", "null", "path", "a", "b", "Int", "Error", "whoops", "graphql", "data", "a", "null", "error", "message", "whoops", "path", "a", "b", "Int", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "NUMBER", "NUMBER", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "NUMBER", "null", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "NUMBER", "Error", "whoops", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "Int", "NUMBER", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "null", "graphql", "data", "a", "b", "null", "Int", "Error", "whoops", "graphql", "data", "a", "b", "null", "error", "message", "whoops", "path", "a", "b", "Int", "graphql", "data", "a", "b", "Int", "NUMBER", "NUMBER", "graphql", "data", "a", "b", "NUMBER", "NUMBER", "Int", "NUMBER", "null", "graphql", "data", "a", "b", "NUMBER", "null", "Int", "NUMBER", "Error", "whoops", "graphql", "data", "a", "b", "NUMBER", "null", "error", "message", "whoops", "path", "a", "b", "NUMBER", "Int", "Int", "NUMBER", "graphql", "data", "a", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "null", "graphql", "data", "a", "null", "error", "message", "invalid", "null", "path", "a", "b", "Int", "Error", "whoops", "graphql", "data", "a", "null", "error", "message", "whoops", "path", "a", "b", "Int", "graphql", "data", "a", "b", "Int", "NUMBER", "NUMBER", "graphql", "data", "a", "b", "NUMBER", "NUMBER", "Int", "NUMBER", "null", "graphql", "data", "a", "b", "NUMBER", "null", "Int", "NUMBER", "Error", "whoops", "graphql", "data", "a", "b", "NUMBER", "null", "error", "message", "whoops", "path", "a", "b", "NUMBER", "Int", "Int", "NUMBER", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "null", "graphql", "data", "a", "b", "null", "Int", "Error", "whoops", "graphql", "data", "a", "b", "null", "error", "message", "whoops", "path", "a", "b", "Int", "graphql", "data", "a", "b", "Int", "NUMBER", "NUMBER", "graphql", "data", "a", "b", "NUMBER", "NUMBER", "Int", "NUMBER", "null", "graphql", "data", "a", "b", "null", "error", "message", "invalid", "null", "path", "a", "b", "NUMBER", "Int", "NUMBER", "Error", "whoops", "graphql", "data", "a", "b", "null", "error", "message", "whoops", "path", "a", "b", "NUMBER", "Int", "Int", "NUMBER", "graphql", "data", "a", "null", "error", "message", "invalid", "value", "path", "a", "b", "Int", "null", "graphql", "data", "a", "null", "error", "message", "invalid", "null", "path", "a", "b", "Int", "Error", "whoops", "graphql", "data", "a", "null", "error", "message", "whoops", "path", "a", "b", "Int", "graphql", "data", "a", "b", "Int", "NUMBER", "NUMBER", "graphql", "data", "a", "b", "NUMBER", "NUMBER", "Int", "NUMBER", "null", "graphql", "data", "a", "null", "error", "message", "invalid", "null", "path", "a", "b", "NUMBER", "Int", "NUMBER", "Error", "whoops", "graphql", "data", "a", "null", "error", "message", "whoops", "path", "a", "b", "NUMBER", "Some", "note", "on", "constraints", "and", "interpretations", "Int", "means", "that", "the", "value", "itself", "must", "not", "be", "null", "but", "items", "in", "the", "list", "can", "be", "null", "NUMBER", "Int", "means", "that", "the", "value", "itself", "can", "be", "null", "but", "items", "in", "the", "list", "must", "not", "be", "null", "NUMBER", "When", "propagating", "error", "and", "inserting", "nulls", "the", "index", "of", "items", "in", "a", "list", "must", "never", "be", "change", "NUMBER", "So", "converting", "NUMBER", "null", "NUMBER", "to", "NUMBER", "NUMBER", "would", "be", "illegal", "Fragments", "be", "definitely", "the", "answer", "This", "add", "a", "specific", "limitation", "to", "the", "Variable", "parsing", "rules", "to", "make", "it", "impossible", "to", "put", "ignored", "characters", "between", "the", "and", "the", "name", "of", "the", "variable", "NUMBER", "This", "was", "suggested", "by", "martijnwalraven", "as", "he", "was", "build", "syntax", "highlighters", "for", "some", "IDEs", "NUMBER", "I", "m", "not", "sure", "if", "this", "be", "necessary", "or", "good", "but", "wanted", "to", "capture", "it", "so", "we", "can", "have", "a", "conversation", "about", "it", "NUMBER", "To", "be", "specific", "about", "the", "issue", "and", "the", "impact", "of", "this", "change", "currently", "the", "following", "be", "legal", "variables", "graphql", "variable", "variable", "variable", "variable", "variable", "With", "this", "change", "only", "variable", "will", "be", "a", "parsable", "Variable", "form", "the", "others", "with", "ignored", "characters", "will", "not", "be", "allow", "NUMBER", "This", "be", "also", "not", "the", "only", "case", "where", "punctuation", "comes", "before", "a", "Name", "and", "we", "would", "expect", "no", "spaces", "NUMBER", "Another", "example", "be", "NUMBER", "Fragment", "That", "s", "also", "possible", "to", "write", "as", "NUMBER", "Fragment", "or", "NUMBER", "Fragment", "NUMBER", "Perhaps", "the", "right", "fix", "for", "this", "be", "a", "linter", "with", "a", "lint", "rule", "that", "looks", "for", "this", "sort", "of", "thing", "Ah", "sorry", "just", "some", "overzealous", "spring", "cleaning", "as", "it", "has", "be", "sitting", "mostly", "untouched", "for", "the", "better", "part", "of", "a", "year", "save", "for", "your", "comment", "which", "I", "didn", "t", "even", "see", "NUMBER", "Happy", "to", "revive", "this", "if", "there", "be", "still", "interest", "NUMBER", "A", "Schema", "only", "needs", "to", "include", "the", "scalars", "that", "be", "present", "in", "a", "schema", "NUMBER", "However", "note", "that", "introspection", "be", "part", "of", "the", "schema", "and", "the", "introspection", "system", "uses", "String", "and", "Boolean", "so", "those", "be", "essentially", "always", "going", "to", "appear", "in", "every", "schema", "NUMBER", "And", "stubailo", "by", "the", "spec", "as", "long", "as", "you", "have", "a", "type", "named", "String", "as", "an", "example", "it", "must", "conform", "to", "the", "spec", "s", "description", "of", "how", "String", "works", "NUMBER", "So", "that", "doesn", "t", "leave", "much", "room", "for", "overriding", "NUMBER", "Thanks", "Thanks", "for", "bringing", "this", "up", "Great", "thought", "process", "already", "happening", "NUMBER", "I", "agree", "that", "surrogate", "pairs", "be", "an", "obtuse", "API", "NUMBER", "I", "d", "like", "to", "avoid", "it", "if", "possible", "though", "there", "be", "one", "serious", "upside", "to", "consider", "it", "mirrors", "JSON", "NUMBER", "That", "might", "not", "be", "enough", "to", "motivate", "it", "as", "the", "solution", "but", "it", "certainly", "shouldn", "t", "be", "discredited", "NUMBER", "Here", "be", "some", "action", "items", "x", "Editing", "of", "the", "language", "section", "describing", "Unicode", "to", "correct", "and", "clarify", "NUMBER", "x", "Propose", "expanding", "the", "parsable", "character", "set", "to", "all", "represented", "in", "latest", "Unicode", "including", "supplemental", "planes", "NUMBER", "Propose", "a", "new", "escape", "sequence", "for", "string", "literals", "or", "prescribe", "to", "always", "use", "Unicode", "characters", "directly", "for", "supplemental", "planes", "NUMBER", "dylanahsmith", "and", "chris", "morgan", "I", "d", "love", "your", "feedback", "on", "NUMBER", "I", "m", "not", "sure", "I", "understand", "what", "you", "re", "suggesting", "NUMBER", "It", "would", "be", "helpful", "to", "see", "an", "example", "of", "the", "query", "you", "would", "like", "to", "write", "following", "this", "proposal", "NUMBER", "GraphQL", "be", "designed", "first", "as", "a", "data", "access", "API", "NUMBER", "It", "s", "not", "always", "well", "suited", "for", "RPC", "style", "write", "only", "services", "NUMBER", "The", "default", "constraints", "be", "set", "up", "to", "reflect", "this", "NUMBER", "Requiring", "the", "query", "type", "provides", "a", "guarantee", "for", "tool", "NUMBER", "You", "can", "_always_", "query", "a", "GraphQL", "API", "because", "of", "the", "introspection", "meta", "field", "NUMBER", "Requiring", "the", "query", "type", "avoids", "a", "scenario", "where", "an", "introspection", "query", "be", "run", "but", "the", "underlying", "system", "be", "unsure", "of", "what", "type", "to", "use", "throughout", "validation", "and", "execution", "NUMBER", "Avoiding", "this", "edge", "case", "helps", "avoid", "quirks", "during", "implementation", "NUMBER", "If", "you", "be", "build", "a", "write", "only", "GraphQL", "service", "or", "just", "write", "test", "NUMBER", "A", "simple", "near", "empty", "query", "type", "should", "work", "NUMBER", "There", "be", "already", "quite", "a", "few", "discussion", "forums", "available", "listed", "on", "LINK", "I", "m", "conflicted", "on", "this", "NUMBER", "I", "understand", "the", "desire", "for", "those", "who", "have", "preferred", "chat", "tool", "to", "want", "to", "use", "those", "tool", "to", "discuss", "live", "however", "there", "be", "also", "the", "problem", "of", "fragmenting", "the", "community", "across", "these", "various", "discussion", "platforms", "NUMBER", "We", "already", "have", "this", "problem", "today", "with", "more", "slack", "rooms", "than", "core", "contributors", "can", "keep", "up", "with", "in", "addition", "to", "a", "freenode", "irc", "room", "where", "the", "core", "team", "be", "frequently", "around", "but", "be", "otherwise", "often", "quiet", "NUMBER", "Are", "more", "platforms", "better", "at", "the", "expense", "of", "further", "fragmentation", "Or", "be", "consolidating", "community", "discussion", "better", "at", "the", "expense", "of", "lack", "of", "platform", "choice", "Another", "way", "to", "frame", "this", "be", "would", "it", "be", "acceptable", "to", "have", "the", "gitter", "room", "open", "if", "it", "was", "unofficial", "and", "had", "no", "promise", "of", "any", "segment", "of", "the", "community", "or", "maintainers", "be", "available", "via", "that", "channel", "Where", "the", "spec", "points", "out", "that", "Names", "be", "case", "sensitive", "what", "that", "means", "be", "that", "a", "query", "foo", "Foo", "FOO", "be", "always", "querying", "three", "different", "field", "and", "not", "querying", "one", "case", "insensitive", "field", "three", "times", "NUMBER", "That", "also", "means", "that", "any", "names", "of", "types", "or", "field", "referenced", "in", "the", "spec", "be", "required", "to", "be", "in", "the", "case", "they", "re", "describe", "NUMBER", "For", "example", "if", "you", "implement", "your", "introspection", "field", "to", "use", "Name", "instead", "of", "name", "that", "would", "be", "invalid", "according", "to", "the", "spec", "NUMBER", "And", "if", "you", "implement", "a", "type", "sTrInG", "instead", "of", "String", "that", "would", "also", "be", "invalid", "NUMBER", "Similarly", "the", "response", "objects", "should", "use", "the", "field", "data", "and", "error", "not", "Data", "and", "Errors", "so", "that", "clients", "can", "predictably", "use", "a", "graphql", "API", "without", "needing", "to", "check", "for", "case", "sensitivity", "first", "NUMBER", "However", "any", "field", "or", "type", "not", "describe", "directly", "in", "the", "GraphQL", "spec", "can", "be", "cased", "however", "you", "like", "NUMBER", "This", "be", "all", "valid", "graphql", "type", "my_custom_type", "MYCUSTOMFIELD", "String", "my_custom_field", "String", "MyCustomField", "String", "There", "s", "nothing", "stopping", "you", "from", "doing", "that", "NUMBER", "However", "I", "would", "say", "that", "if", "you", "wanted", "to", "follow", "the", "_conventions_", "use", "throughout", "the", "spec", "then", "I", "d", "suggest", "use", "camelCase", "for", "field", "and", "PascalCase", "for", "types", "NUMBER", "There", "be", "not", "a", "way", "to", "destructure", "input", "objects", "themselves", "NUMBER", "You", "could", "instead", "define", "a", "variable", "to", "use", "specifically", "for", "the", "firstName", "NUMBER", "The", "reason", "this", "feature", "do", "not", "exist", "be", "that", "it", "would", "require", "defining", "an", "input", "object", "type", "for", "every", "field", "which", "accepts", "argument", "that", "would", "be", "non", "intuitive", "and", "inflate", "the", "number", "of", "types", "in", "the", "system", "NUMBER", "Thanks", "for", "the", "feedback", "this", "was", "fix", "in", "the", "October", "release", "by", "add", "an", "explicit", "table", "Yeah", "I", "think", "this", "be", "probably", "an", "interesting", "idea", "though", "we", "haven", "t", "put", "a", "lot", "of", "thought", "into", "it", "yet", "NUMBER", "I", "m", "less", "sure", "about", "make", "types", "themselves", "deprecate", "rather", "the", "references", "to", "those", "types", "should", "be", "deprecate", "NUMBER", "Perhaps", "that", "means", "also", "be", "able", "to", "mark", "argument", "as", "deprecate", "NUMBER", "If", "input", "obj", "field", "can", "be", "transitioned", "from", "required", "to", "optional", "to", "deprecate", "then", "argument", "should", "be", "the", "same", "NUMBER", "The", "next", "steps", "for", "an", "idea", "like", "this", "would", "be", "to", "draft", "an", "RFC", "probably", "in", "the", "form", "of", "a", "PR", "against", "the", "spec", "along", "with", "a", "good", "description", "of", "how", "deprecation", "best", "practice", "should", "work", "and", "any", "potential", "caveats", "NUMBER", "GraphQL", "explicitly", "do", "not", "allow", "this", "because", "of", "backwards", "compatibility", "NUMBER", "An", "important", "characteristic", "of", "a", "query", "be", "that", "it", "completely", "describes", "the", "data", "be", "request", "NUMBER", "Critically", "that", "allows", "the", "freedom", "to", "evolve", "a", "schema", "over", "time", "including", "add", "new", "field", "to", "exist", "types", "with", "the", "knowledge", "that", "all", "exist", "queries", "will", "be", "unaffected", "NUMBER", "This", "be", "very", "relate", "to", "the", "old", "wisdom", "to", "never", "use", "SELECT", "in", "your", "production", "SQL", "queries", "NUMBER", "Going", "to", "close", "this", "issue", "since", "it", "s", "a", "question", "and", "not", "a", "track", "RFC", "NUMBER", "The", "concrete", "answer", "to", "the", "question", "be", "that", "__id", "will", "need", "to", "go", "through", "the", "RFC", "process", "and", "that", "hasn", "t", "begun", "yet", "NUMBER", "I", "definitely", "would", "like", "to", "address", "it", "before", "the", "April", "NUMBER", "edition", "of", "the", "spec", "NUMBER", "That", "would", "be", "great", "stubailo", "Happy", "to", "collaborate", "on", "this", "one", "NUMBER", "We", "ve", "spoken", "about", "some", "of", "the", "open", "concerns", "before", "so", "perhaps", "you", "could", "start", "with", "the", "document", "we", "start", "a", "while", "back", "NUMBER", "Refreshing", "this", "RFC", "since", "I", "think", "it", "s", "really", "important", "to", "get", "include", "NUMBER", "This", "be", "critical", "information", "to", "let", "clients", "deduce", "which", "error", "correspond", "to", "which", "field", "NUMBER", "I", "think", "the", "spec", "addition", "needs", "to", "be", "a", "little", "more", "descriptive", "NUMBER", "Definitely", "it", "needs", "to", "include", "some", "examples", "and", "deeper", "explanation", "of", "the", "expected", "behavior", "for", "some", "of", "the", "edge", "cases", "When", "a", "field", "use", "an", "alias", "the", "alias", "should", "be", "use", "in", "the", "path", "so", "this", "be", "a", "path", "of", "_response", "keys_", "not", "field", "names", "NUMBER", "When", "a", "field", "that", "error", "be", "contained", "with", "an", "array", "that", "the", "position", "in", "the", "array", "response", "be", "include", "NUMBER", "When", "a", "error", "occur", "in", "a", "field", "that", "s", "non", "nullable", "and", "the", "null", "ends", "up", "appearing", "in", "a", "parent", "field", "the", "path", "should", "follow", "to", "the", "original", "error", "field", "not", "the", "field", "that", "was", "nulled", "NUMBER", "Going", "to", "close", "this", "issue", "since", "the", "original", "question", "was", "answered", "NUMBER", "We", "want", "to", "continue", "to", "preserve", "the", "limitation", "that", "object", "field", "always", "request", "further", "field", "NUMBER", "If", "you", "only", "care", "about", "existence", "typically", "you", "can", "ask", "for", "id", "or", "__typename", "as", "a", "cheap", "way", "to", "fill", "this", "in", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "NB", "implement", "in", "the", "reference", "implementation", "in", "LINK", "js", "pull", "NUMBER", "I", "wonder", "if", "this", "be", "the", "right", "thing", "I", "think", "perhaps", "it", "should", "be", "okay", "for", "some", "things", "to", "be", "description", "less", "NUMBER", "This", "be", "nice", "work", "thank", "you", "Thanks", "for", "keep", "this", "open", "I", "think", "we", "may", "come", "back", "to", "this", "as", "we", "work", "out", "our", "NUMBER", "roadmap", "NUMBER", "We", "considered", "this", "feature", "for", "the", "initial", "version", "of", "the", "spec", "but", "there", "be", "some", "pretty", "serious", "concerns", "to", "weigh", "NUMBER", "The", "primary", "concern", "be", "response", "confusion", "NUMBER", "This", "feature", "can", "be", "powerful", "but", "it", "can", "also", "lead", "to", "harder", "to", "understand", "queries", "NUMBER", "Right", "now", "one", "JSON", "object", "always", "corresponds", "to", "one", "GraphQL", "object", "but", "this", "feature", "allows", "for", "deeply", "nested", "The", "second", "concern", "be", "it", "can", "become", "easy", "to", "accidentally", "produce", "field", "over", "fetching", "NUMBER", "For", "example", "consider", "fragment", "Example", "on", "User", "foo", "NUMBER", "ChildFrag", "NUMBER", "bar", "NUMBER", "ChildFrag", "NUMBER", "fragment", "ChildFrag", "NUMBER", "on", "User", "name", "age", "birthday", "more", "NUMBER", "ChildFrag", "NUMBER", "fragment", "ChildFrag", "NUMBER", "on", "User", "name", "birthday", "profilePicture", "url", "The", "result", "of", "this", "will", "be", "duplicate", "querying", "and", "returning", "of", "the", "name", "and", "birthday", "field", "on", "the", "first", "level", "and", "fetches", "everything", "in", "ChildFrag", "NUMBER", "twice", "NUMBER", "Without", "the", "fragment", "aliases", "there", "would", "be", "no", "over", "fetching", "at", "all", "NUMBER", "Considering", "that", "one", "major", "motivation", "for", "this", "be", "more", "safely", "separating", "fragment", "from", "each", "other", "so", "they", "be", "unlikely", "to", "overlap", "this", "motivation", "be", "exactly", "what", "would", "cause", "this", "duplicate", "over", "fetching", "to", "occur", "NUMBER", "We", "should", "keep", "the", "issue", "open", "though", "as", "a", "place", "to", "collect", "discussion", "and", "perhaps", "reconsider", "should", "we", "come", "up", "with", "new", "response", "formats", "that", "makes", "such", "a", "thing", "possible", "NUMBER", "Yeah", "I", "think", "this", "be", "a", "good", "idea", "NUMBER", "Any", "concrete", "proposals", "on", "what", "this", "should", "actually", "look", "like", "in", "terms", "of", "the", "spec", "One", "clarification", "here", "as", "this", "topic", "was", "also", "brought", "up", "in", "NUMBER", "Your", "error", "type", "number", "NUMBER", "I", "interpreted", "as", "user", "of", "the", "GraphQL", "endpoint", "aka", "the", "client", "developer", "and", "not", "user", "of", "the", "product", "NUMBER", "I", "think", "it", "be", "useful", "to", "disambiguate", "between", "error", "that", "be", "due", "to", "a", "bad", "query", "vs", "error", "that", "be", "due", "to", "something", "having", "gone", "wrong", "within", "the", "server", "e", "NUMBER", "g", "NUMBER", "a", "database", "was", "down", "or", "some", "server", "code", "throw", "an", "error", "NUMBER", "For", "error", "that", "be", "the", "fault", "of", "the", "product", "end", "users", "we", "don", "t", "want", "to", "spec", "an", "Error", "type", "because", "different", "products", "and", "different", "interfaces", "where", "user", "error", "could", "occur", "will", "all", "represent", "different", "kinds", "of", "information", "and", "should", "be", "represented", "by", "data", "NUMBER", "While", "you", "re", "free", "to", "refer", "to", "this", "type", "as", "Error", "if", "you", "like", "from", "GraphQL", "s", "point", "of", "view", "it", "be", "just", "another", "data", "type", "NUMBER", "For", "example", "an", "error", "when", "filling", "out", "a", "form", "might", "want", "to", "report", "back", "which", "part", "of", "the", "form", "had", "an", "issue", "so", "a", "UI", "could", "highlight", "it", "NUMBER", "Or", "maybe", "an", "error", "about", "not", "be", "able", "to", "deliver", "a", "message", "in", "an", "IM", "client", "might", "want", "to", "include", "information", "about", "if", "the", "user", "should", "retry", "or", "if", "the", "server", "be", "retrying", "on", "their", "behalf", "NUMBER", "This", "information", "be", "hard", "to", "globally", "standardize", "as", "one", "single", "type", "since", "each", "context", "has", "these", "specific", "details", "NUMBER", "So", "it", "s", "important", "to", "distinguish", "between", "the", "_data_", "that", "represents", "a", "user", "error", "vs", "the", "_error_", "that", "represents", "the", "GraphQL", "server", "s", "inability", "to", "accomplish", "what", "a", "GraphQL", "query", "request", "NUMBER", "arunoda", "it", "sounds", "like", "that", "idea", "could", "be", "easily", "accomplished", "without", "any", "change", "to", "the", "spec", "NUMBER", "We", "could", "add", "some", "throw", "error", "post", "processing", "to", "determine", "if", "or", "how", "an", "error", "should", "be", "report", "or", "not", "NUMBER", "That", "be", "something", "we", "were", "planning", "to", "add", "anyhow", "to", "improve", "error", "debugging", "in", "general", "This", "be", "a", "good", "question", "CatTail", "and", "one", "that", "comes", "up", "all", "the", "time", "NUMBER", "We", "encourage", "GraphQL", "endpoints", "to", "take", "an", "add", "only", "approach", "to", "schema", "evolution", "over", "time", "instead", "of", "change", "exist", "field", "NUMBER", "This", "be", "important", "for", "the", "preservation", "of", "behavior", "for", "exist", "clients", "without", "creating", "another", "dimension", "to", "implement", "on", "the", "server", "NUMBER", "To", "be", "clear", "this", "has", "its", "tradeoffs", "NUMBER", "You", "re", "exactly", "right", "that", "if", "you", "wanted", "to", "change", "your", "field", "key", "from", "returning", "one", "String", "to", "returning", "a", "List", "of", "Strings", "then", "this", "could", "potentially", "break", "your", "exist", "clients", "which", "be", "querying", "for", "the", "string", "NUMBER", "It", "means", "that", "instead", "you", "would", "have", "to", "pick", "a", "new", "field", "name", "to", "represent", "the", "new", "concept", "maybe", "keyList", "or", "keys", "instead", "and", "leave", "the", "old", "one", "NUMBER", "The", "addition", "of", "new", "field", "be", "always", "safe", "for", "older", "clients", "NUMBER", "You", "can", "add", "your", "additional", "field", "without", "any", "ill", "effect", "since", "GraphQL", "queries", "always", "specify", "exactly", "what", "they", "want", "and", "nothing", "more", "NUMBER", "You", "can", "think", "of", "this", "as", "similar", "to", "what", "would", "happen", "if", "you", "add", "a", "new", "column", "in", "a", "SQL", "table", "NUMBER", "Existing", "queries", "could", "run", "against", "the", "same", "table", "without", "any", "issue", "and", "without", "any", "change", "to", "the", "result", "of", "their", "queries", "NUMBER", "The", "same", "concept", "applies", "for", "GraphQL", "NUMBER", "Of", "course", "there", "be", "nothing", "stopping", "you", "from", "change", "a", "field", "s", "type", "in", "your", "GraphQL", "schema", "other", "than", "this", "concern", "NUMBER", "So", "for", "example", "at", "Facebook", "we", "often", "be", "developing", "new", "features", "and", "new", "applications", "which", "undergo", "rapid", "development", "and", "often", "require", "their", "GraphQL", "schema", "to", "change", "NUMBER", "However", "since", "no", "users", "be", "use", "them", "yet", "we", "can", "safely", "cheat", "and", "change", "a", "field", "s", "type", "knowing", "that", "we", "re", "only", "going", "to", "break", "our", "prototype", "build", "for", "our", "internal", "developers", "NUMBER", "However", "once", "we", "ve", "shipped", "a", "feature", "to", "our", "users", "we", "do", "everything", "we", "can", "to", "avoid", "breaking", "it", "including", "not", "change", "the", "GraphQL", "schema", "NUMBER", "Thanks", "for", "the", "report", "NUMBER", "spec", "md", "should", "really", "be", "detecting", "this", "and", "produce", "more", "specific", "links", "NUMBER", "I", "will", "investigate", "NUMBER", "Now", "fix", "by", "NUMBER", "Perhaps", "we", "ll", "consider", "this", "as", "we", "expand", "documentation", "to", "include", "a", "best", "practices", "section", "NUMBER", "Right", "now", "Relay", "be", "the", "only", "tool", "which", "requires", "connections", "to", "be", "modeled", "in", "this", "way", "which", "be", "why", "those", "documentation", "details", "be", "in", "a", "Relay", "specific", "place", "NUMBER", "But", "we", "think", "connections", "be", "a", "good", "idea", "in", "general", "that", "many", "GraphQL", "backends", "could", "take", "advantage", "of", "NUMBER", "Most", "excellent", "NUMBER", "That", "fix", "the", "link", "issue", "but", "also", "makes", "the", "docs", "clearer", "so", "thank", "you", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "I", "m", "no", "expert", "on", "service", "workers", "but", "I", "m", "not", "sure", "GraphQL", "needs", "to", "be", "anything", "other", "than", "agnostic", "towards", "it", "as", "a", "technology", "I", "believe", "you", "should", "be", "able", "to", "run", "your", "GraphQL", "queries", "from", "a", "service", "worker", "if", "you", "wish", "NUMBER", "I", "should", "mention", "though", "that", "a", "pure", "HTTP", "cache", "be", "acceptable", "but", "often", "underwhelming", "when", "paired", "with", "GraphQL", "for", "similar", "reasons", "for", "why", "directly", "caching", "the", "results", "of", "SQL", "queries", "be", "underwhelming", "NUMBER", "A", "great", "GraphQL", "cache", "be", "aware", "of", "the", "relevant", "schema", "and", "can", "ensure", "new", "information", "gleaned", "from", "one", "query", "can", "benefit", "the", "cached", "results", "of", "other", "queries", "NUMBER", "Since", "a", "great", "example", "of", "a", "GraphQL", "client", "cache", "be", "Relay", "LINK", "you", "might", "consider", "furthering", "this", "conversation", "there", "NUMBER", "I", "know", "offline", "support", "be", "something", "they", "ve", "be", "thinking", "about", "within", "future", "plan", "NUMBER", "This", "proposes", "loosening", "the", "definition", "of", "implement", "an", "interface", "by", "allowing", "an", "implement", "field", "to", "return", "a", "subtype", "of", "the", "interface", "field", "s", "return", "type", "NUMBER", "This", "example", "would", "previously", "be", "an", "illegal", "schema", "but", "becomes", "legal", "after", "this", "diff", "graphql", "interface", "Friendly", "bestFriend", "Friendly", "type", "Person", "implement", "Friendly", "bestFriend", "Person", "Yeah", "currently", "the", "only", "possible", "pseudo", "contravariance", "in", "input", "types", "in", "required", "non", "null", "vs", "optional", "nullable", "but", "support", "that", "causes", "other", "issue", "NUMBER", "I", "think", "we", "ll", "need", "to", "divorce", "argument", "requirement", "from", "argument", "type", "nullability", "to", "support", "argument", "contravariance", "in", "the", "future", "NUMBER", "For", "now", "the", "spec", "and", "impl", "for", "inputs", "remains", "invariant", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "thank", "you", "thank", "you", "Sound", "cool", "Mind", "open", "an", "issue", "or", "PR", "on", "LINK", "Magnificent", "thanks", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "joliss", "The", "data", "in", "the", "error", "object", "be", "definitely", "typical", "for", "debugging", "NUMBER", "But", "of", "course", "the", "existence", "of", "an", "error", "could", "be", "use", "to", "render", "something", "in", "a", "UI", "about", "data", "not", "be", "available", "NUMBER", "My", "suggestion", "for", "the", "example", "you", "bring", "up", "here", "be", "to", "allow", "for", "data", "for", "a", "user", "facing", "report", "in", "the", "payload", "of", "your", "mutation", "NUMBER", "It", "s", "often", "the", "case", "that", "mutation", "payloads", "include", "a", "didSucceed", "field", "and", "a", "userError", "field", "NUMBER", "If", "your", "UI", "requires", "rich", "information", "about", "potential", "error", "then", "you", "should", "include", "this", "information", "in", "your", "payload", "as", "well", "NUMBER", "For", "example", "maybe", "you", "want", "to", "highlight", "the", "email", "field", "red", "you", "might", "include", "something", "like", "a", "boolean", "wasBadEmail", "NUMBER", "The", "general", "philosophy", "at", "play", "be", "that", "Errors", "be", "considered", "exceptional", "NUMBER", "Your", "user", "data", "should", "never", "be", "represented", "as", "an", "Error", "NUMBER", "If", "your", "users", "can", "do", "something", "that", "needs", "to", "provide", "negative", "guidance", "then", "you", "should", "represent", "that", "kind", "of", "information", "in", "GraphQL", "as", "Data", "not", "as", "an", "Error", "NUMBER", "Errors", "should", "always", "represent", "either", "developer", "error", "or", "exceptional", "circumstances", "e", "NUMBER", "g", "NUMBER", "the", "database", "was", "offline", "NUMBER", "Closing", "this", "since", "it", "was", "fix", "in", "the", "Dec", "spec", "and", "has", "since", "be", "implement", "in", "graphql", "js", "We", "refer", "to", "this", "as", "covariant", "interface", "implementation", "NUMBER", "That", "be", "you", "have", "implement", "the", "interface", "but", "you", "just", "supplied", "a", "covariant", "type", "Page", "be", "an", "Entry", "instead", "of", "an", "_invariant_", "type", "must", "be", "Entry", "and", "only", "Entry", "NUMBER", "We", "start", "with", "invariant", "interface", "implementation", "mostly", "as", "a", "simplifying", "force", "NUMBER", "Adding", "this", "kind", "of", "type", "system", "rule", "can", "add", "complexity", "to", "the", "rest", "of", "the", "system", "by", "introduce", "new", "kinds", "of", "cases", "that", "validation", "needs", "to", "consider", "but", "in", "this", "case", "the", "complexity", "add", "was", "not", "untenable", "and", "it", "be", "worth", "it", "to", "enable", "this", "kind", "of", "query", "NUMBER", "We", "did", "in", "fact", "consider", "this", "and", "decided", "that", "the", "legibility", "of", "the", "query", "language", "was", "one", "of", "the", "critical", "factors", "we", "wanted", "to", "include", "NUMBER", "We", "were", "not", "able", "to", "come", "up", "with", "a", "JSON", "specific", "representation", "that", "both", "covered", "all", "the", "cases", "and", "was", "easy", "to", "write", "and", "read", "NUMBER", "If", "someone", "wants", "to", "produce", "a", "library", "which", "defines", "such", "a", "thing", "and", "converts", "to", "and", "from", "GraphQL", "I", "think", "that", "would", "be", "a", "perfectly", "good", "community", "project", "but", "for", "now", "GraphQL", "will", "continue", "to", "maintain", "its", "language", "NUMBER", "Another", "important", "consideration", "be", "that", "GraphQL", "be", "defined", "to", "be", "a", "common", "request", "language", "regardless", "of", "frontend", "or", "backend", "languages", "involved", "NUMBER", "Since", "different", "languages", "have", "different", "representations", "of", "data", "structures", "we", "still", "must", "agree", "upon", "a", "serialization", "format", "which", "can", "represent", "these", "concepts", "across", "most", "environments", "NUMBER", "JSON", "be", "probably", "the", "go", "to", "for", "this", "sort", "of", "thing", "but", "JSON", "feels", "pretty", "limiting", "for", "this", "task", "NUMBER", "EDN", "be", "an", "interesting", "alternative", "because", "it", "be", "far", "more", "flexible", "than", "JSON", "and", "datascript", "LINK", "be", "a", "pretty", "great", "example", "of", "how", "EDN", "can", "be", "use", "to", "define", "this", "kind", "of", "macro", "language", "datastructure", "NUMBER", "Taking", "a", "dependency", "on", "EDN", "be", "probably", "not", "the", "right", "decision", "for", "GraphQL", "but", "we", "would", "encourage", "experimentation", "with", "EDN", "macro", "style", "GraphQL", "like", "systems", "NUMBER", "This", "be", "something", "we", "want", "to", "consider", "NUMBER", "Interfaces", "may", "be", "less", "valuable", "because", "it", "becomes", "less", "clear", "what", "the", "semantics", "should", "be", "though", "Unions", "be", "pretty", "interesting", "NUMBER", "This", "be", "all", "interesting", "area", "to", "explore", "further", "NUMBER", "Great", "suggestion", "NUMBER", "We", "will", "change", "links", "to", "encourage", "usage", "of", "Discord", "NUMBER", "It", "would", "be", "better", "if", "the", "auto", "generate", "TOC", "was", "just", "easier", "to", "navigate", "which", "would", "be", "a", "change", "to", "LINK", "md", "Yes", "NUMBER", "spec", "md", "currently", "already", "generates", "a", "table", "of", "contents", "so", "any", "improvement", "to", "it", "should", "be", "made", "there", "Sent", "from", "Mailbox", "On", "Tue", "Nov", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "Michael", "Lancaster", "notifications", "github", "NUMBER", "com", "write", "Sorry", "leebyron", "but", "I", "did", "not", "understand", "what", "you", "mean", "by", "that", "NUMBER", "be", "you", "suggesting", "that", "spec", "md", "auto", "generate", "navigation", "based", "on", "the", "md", "or", "I", "get", "wrong", "NUMBER", "Reply", "to", "this", "email", "directly", "or", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "Sorry", "for", "the", "delayed", "response", "here", "holidays", "NUMBER", "The", "build", "spec", "LINK", "already", "include", "a", "table", "of", "contents", "so", "I", "believe", "this", "diff", "would", "create", "a", "second", "redundant", "one", "which", "we", "want", "to", "avoid", "NUMBER", "The", "TOC", "be", "automatically", "generate", "by", "spec", "md", "LINK", "md", "so", "any", "improvement", "to", "the", "table", "of", "contents", "should", "be", "applied", "to", "that", "tool", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "Adding", "the", "introspection", "bit", "be", "a", "good", "idea", "but", "the", "actual", "execution", "of", "these", "subscription", "queries", "should", "be", "intentionally", "under", "defined", "for", "now", "NUMBER", "The", "spec", "should", "make", "it", "clear", "that", "subscription", "queries", "be", "experimental", "in", "a", "note", "NUMBER", "Nice", "work", "Thanks", "Thanks", "I", "think", "this", "would", "be", "an", "awesome", "project", "for", "someone", "to", "start", "up", "if", "anyone", "in", "the", "community", "be", "looking", "for", "ideas", "NUMBER", "Closing", "this", "aging", "issue", "NUMBER", "Seems", "like", "the", "consensus", "be", "that", "field", "cost", "alone", "be", "not", "always", "enough", "to", "estimate", "a", "query", "s", "cost", "NUMBER", "Different", "approaches", "by", "different", "libraries", "indicate", "that", "there", "be", "many", "useful", "approaches", "with", "different", "trade", "offs", "so", "there", "be", "not", "much", "to", "incorporate", "into", "the", "spec", "to", "account", "for", "this", "I", "believe", "first", "and", "last", "assume", "positive", "integers", "NUMBER", "They", "should", "probably", "throw", "error", "if", "they", "re", "negative", "NUMBER", "But", "I", "agree", "that", "you", "should", "take", "this", "up", "with", "LINK", "I", "m", "a", "bit", "confused", "about", "your", "proposal", "NUMBER", "The", "concern", "that", "this", "validation", "error", "be", "report", "be", "that", "you", "re", "use", "a", "variable", "which", "hasn", "t", "be", "defined", "NUMBER", "This", "be", "very", "often", "the", "result", "of", "programmer", "error", "where", "a", "variable", "was", "spelled", "incorrectly", "or", "add", "to", "a", "fragment", "but", "forgot", "to", "be", "defined", "NUMBER", "I", "don", "t", "think", "we", "will", "consider", "doing", "this", "because", "GraphQL", "wishes", "to", "be", "compatible", "with", "many", "languages", "and", "so", "have", "designed", "valid", "identifiers", "to", "be", "that", "which", "be", "common", "across", "many", "popular", "languages", "NUMBER", "Unfortunately", "characters", "like", "and", "which", "be", "legal", "identifier", "characters", "in", "some", "languages", "be", "not", "in", "other", "popular", "languages", "NUMBER", "It", "looks", "like", "handle", "this", "at", "the", "relay", "layer", "to", "ensure", "that", "any", "code", "that", "be", "generating", "GraphQL", "identifiers", "from", "JavaScript", "identifiers", "properly", "handles", "the", "conversion", "be", "the", "correct", "decision", "NUMBER", "Support", "in", "the", "JS", "library", "itself", "for", "arbitrary", "iterables", "rather", "than", "just", "Arrays", "be", "come", "soon", "NUMBER", "There", "be", "significant", "tradeoffs", "to", "a", "Map", "type", "vs", "a", "list", "of", "key", "value", "pairs", "NUMBER", "One", "issue", "be", "paginating", "over", "the", "collection", "NUMBER", "Lists", "of", "values", "can", "have", "clear", "pagination", "rules", "while", "Maps", "which", "often", "have", "non", "ordered", "key", "value", "pairs", "be", "much", "more", "difficult", "to", "paginate", "NUMBER", "Another", "issue", "be", "usage", "NUMBER", "Most", "often", "Map", "be", "use", "within", "APIs", "where", "one", "field", "of", "the", "value", "be", "be", "indexed", "which", "be", "in", "my", "opinion", "be", "an", "API", "anti", "pattern", "as", "indexing", "be", "an", "issue", "of", "storage", "and", "an", "issue", "of", "client", "caching", "but", "not", "an", "issue", "of", "transport", "NUMBER", "This", "anti", "pattern", "concerns", "me", "NUMBER", "While", "there", "be", "some", "good", "uses", "for", "Maps", "in", "APIs", "I", "fear", "that", "the", "common", "usage", "will", "be", "for", "these", "anti", "patterns", "so", "I", "m", "suggesting", "proceeding", "with", "caution", "NUMBER", "For", "the", "original", "post", "I", "think", "there", "be", "two", "good", "ways", "to", "solve", "this", "API", "puzzle", "First", "be", "what", "OlegIlyenko", "suggests", "NUMBER", "That", "you", "explicitly", "ask", "for", "the", "languages", "which", "you", "care", "about", "fetching", "NUMBER", "If", "you", "need", "multiple", "you", "can", "use", "aliases", "to", "query", "for", "multiple", "NUMBER", "This", "may", "be", "the", "right", "path", "if", "you", "know", "up", "front", "which", "you", "want", "to", "query", "NUMBER", "item", "title", "title", "lang", "custom_lang", "title_en", "title", "lang", "en", "title_fr", "title", "lang", "fr", "Second", "be", "returning", "a", "list", "of", "tuples", "NUMBER", "This", "may", "be", "the", "right", "path", "if", "you", "don", "t", "know", "up", "front", "which", "you", "want", "or", "if", "you", "specifically", "want", "them", "all", "NUMBER", "item", "titles", "language", "text", "such", "that", "you", "might", "get", "the", "result", "item", "titles", "language", "en", "text", "Hello", "language", "fr", "text", "Bonjour", "Originally", "propose", "by", "josephsavona", "this", "allows", "inline", "fragment", "to", "omit", "a", "type", "condition", "and", "thus", "always", "be", "considered", "for", "inclusion", "NUMBER", "If", "a", "type", "condition", "be", "omitted", "no", "type", "refinement", "be", "do", "to", "the", "contained", "field", "NUMBER", "This", "enable", "a", "new", "kind", "of", "usecase", "where", "the", "only", "purpose", "for", "use", "an", "inline", "fragment", "be", "applying", "a", "directive", "to", "a", "grouping", "of", "field", "graphql", "fragment", "Foo", "on", "Type", "fieldA", "fieldB", "NUMBER", "include", "if", "wat", "fieldC", "fieldD", "Based", "on", "feedback", "from", "those", "use", "GraphQL", "and", "inspired", "by", "RelayQL", "s", "syntax", "this", "makes", "operation", "names", "optional", "NUMBER", "The", "primary", "value", "be", "the", "ability", "to", "express", "mutations", "or", "eventually", "subscriptions", "without", "be", "required", "to", "provide", "a", "name", "if", "the", "name", "add", "no", "value", "for", "your", "use", "case", "NUMBER", "Value", "typically", "be", "query", "disambiguation", "and", "logging", "NUMBER", "Systems", "which", "want", "to", "enforce", "a", "name", "for", "queries", "should", "have", "a", "separate", "linting", "validation", "rule", "such", "a", "rule", "would", "probably", "also", "want", "to", "ban", "query", "shorthand", "Thanks", "Thank", "you", "for", "this", "The", "issue", "be", "that", "GraphQL", "has", "no", "way", "of", "actually", "confirming", "that", "the", "data", "it", "encounters", "be", "not", "infinitely", "recursive", "NUMBER", "Without", "an", "ability", "to", "make", "this", "guarantee", "allowing", "for", "cyclic", "queries", "could", "in", "fact", "expose", "infinite", "execution", "queries", "which", "could", "be", "use", "as", "an", "attack", "vector", "NUMBER", "Also", "infinite", "isn", "t", "really", "the", "only", "issue", "here", "NUMBER", "The", "other", "issue", "be", "reasonable", "limits", "per", "your", "application", "NUMBER", "For", "the", "same", "reason", "that", "we", "suggest", "use", "pagination", "LINK", "to", "limit", "the", "amount", "of", "data", "fetched", "when", "accessing", "a", "list", "of", "unknown", "length", "we", "also", "should", "be", "cautious", "not", "to", "fetch", "at", "an", "unknown", "depth", "and", "result", "in", "accessing", "way", "more", "information", "than", "desired", "NUMBER", "Take", "Reddit", "as", "an", "example", "since", "it", "s", "close", "to", "this", "hypothetical", "nested", "comments", "example", "NUMBER", "They", "don", "t", "actually", "query", "to", "an", "unknown", "depth", "when", "fetching", "nested", "comments", "NUMBER", "Instead", "they", "eventually", "bottom", "out", "with", "a", "show", "more", "comments", "link", "which", "can", "trigger", "a", "new", "query", "fetch", "NUMBER", "The", "technique", "I", "illustrated", "in", "a", "prior", "comment", "allows", "for", "this", "_maximum_", "depth", "control", "NUMBER", "There", "s", "no", "magic", "number", "of", "NUMBER", "the", "technique", "can", "be", "expanded", "or", "shrunken", "for", "whatever", "_maximum_", "depth", "makes", "sense", "NUMBER", "For", "example", "here", "s", "the", "same", "example", "expanded", "to", "fetch", "up", "to", "NUMBER", "levels", "deep", "graphql", "message", "NUMBER", "CommentsRecursive", "fragment", "CommentsRecursive", "on", "Message", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "fragment", "CommentFields", "on", "Comment", "id", "content", "I", "agree", "with", "you", "NUMBER", "For", "now", "this", "limitation", "continues", "to", "exist", "for", "this", "balance", "of", "simplicity", "for", "the", "common", "case", "and", "protection", "from", "inadvertent", "infinite", "recursion", "NUMBER", "Perhaps", "we", "can", "revisit", "it", "in", "the", "future", "if", "a", "solid", "proposal", "to", "do", "what", "you", "suggest", "be", "compelling", "NUMBER", "This", "add", "the", "type", "definition", "syntax", "to", "the", "GraphQL", "specification", "NUMBER", "There", "be", "some", "remaining", "issue", "to", "solve", "x", "Include", "reference", "in", "Execution", "chapter", "about", "non", "executable", "GraphQL", "x", "Description", "be", "not", "yet", "represented", "x", "Deprecation", "be", "not", "yet", "represented", "x", "Directives", "be", "not", "yet", "represented", "x", "Top", "level", "Schema", "be", "not", "yet", "represented", "x", "Investigate", "impact", "on", "validation", "rules", "x", "Decide", "on", "_any_", "or", "_many_", "rules", "for", "type", "field", "enum", "values", "x", "Combine", "into", "type", "system", "chapter", "x", "Consider", "separating", "into", "two", "top", "level", "grammars", "x", "Solve", "ambiguity", "for", "extending", "interfaces", "LINK", "js", "pull", "NUMBER", "Proposal", "for", "schema", "schema", "query", "QueryType", "mutation", "MutationType", "SchemaDefinition", "schema", "OperationTypeDefinition", "OperationTypeDefinition", "OperationType", "NamedType", "exogen", "developer", "ergonomics", "be", "better", "specifically", "because", "descriptions", "be", "often", "multiple", "lines", "and", "include", "markdown", "syntax", "NUMBER", "Embedding", "that", "into", "a", "directive", "would", "make", "reading", "the", "schema", "language", "much", "more", "difficult", "and", "legibility", "be", "primarily", "important", "NUMBER", "For", "example", "the", "description", "appearing", "before", "the", "__TypeKind", "introspection", "type", "in", "graphql", "js", "graphql", "The", "fundamental", "unit", "of", "any", "GraphQL", "Schema", "be", "the", "type", "NUMBER", "There", "be", "many", "kinds", "of", "types", "in", "GraphQL", "as", "represented", "by", "the", "__TypeKind", "enum", "NUMBER", "Depending", "on", "the", "kind", "of", "a", "type", "certain", "field", "describe", "information", "about", "that", "type", "NUMBER", "Scalar", "types", "provide", "no", "information", "beyond", "a", "name", "and", "description", "while", "Enum", "types", "provide", "their", "values", "NUMBER", "Object", "and", "Interface", "types", "provide", "the", "field", "they", "describe", "NUMBER", "Abstract", "types", "Union", "and", "Interface", "provide", "the", "Object", "types", "possible", "at", "runtime", "NUMBER", "List", "and", "NonNull", "types", "compose", "other", "types", "NUMBER", "type", "__Type", "kind", "__TypeKind", "name", "String", "description", "String", "field", "includeDeprecated", "Boolean", "false", "__Field", "interfaces", "__Type", "possibleTypes", "__Type", "enumValues", "includeDeprecated", "Boolean", "false", "__EnumValue", "inputFields", "__InputValue", "ofType", "__Type", "Vs", "graphql", "type", "__Type", "description", "msg", "The", "fundamental", "unit", "of", "any", "GraphQL", "Schema", "be", "the", "type", "NUMBER", "There", "be", "many", "kinds", "of", "types", "in", "GraphQL", "as", "represented", "by", "the", "__TypeKind", "enum", "NUMBER", "n", "n", "Depending", "on", "the", "kind", "of", "a", "type", "certain", "field", "describe", "information", "about", "that", "type", "NUMBER", "Scalar", "types", "provide", "no", "information", "beyond", "a", "name", "and", "description", "while", "Enum", "types", "provide", "their", "values", "NUMBER", "Object", "and", "Interface", "types", "provide", "the", "field", "they", "describe", "NUMBER", "Abstract", "types", "Union", "and", "Interface", "provide", "the", "Object", "types", "possible", "at", "runtime", "NUMBER", "List", "and", "NonNull", "types", "compose", "other", "types", "NUMBER", "kind", "__TypeKind", "name", "String", "description", "String", "field", "includeDeprecated", "Boolean", "false", "__Field", "interfaces", "__Type", "possibleTypes", "__Type", "enumValues", "includeDeprecated", "Boolean", "false", "__EnumValue", "inputFields", "__InputValue", "ofType", "__Type", "It", "s", "also", "not", "too", "late", "to", "introduce", "a", "new", "kind", "of", "token", "for", "descriptions", "NUMBER", "There", "be", "certainly", "pros", "and", "cons", "to", "use", "comments", "for", "this", "NUMBER", "Pros", "It", "follows", "prior", "art", "NUMBER", "Comments", "in", "source", "code", "as", "descriptions", "for", "the", "following", "declaration", "be", "prevalent", "in", "almost", "every", "programming", "language", "NUMBER", "Nearly", "every", "popular", "language", "has", "some", "tool", "which", "consumes", "these", "comments", "to", "use", "as", "documentation", "NUMBER", "It", "s", "obvious", "make", "it", "easy", "to", "fall", "into", "the", "pit", "of", "success", "LINK", "pit", "of", "success", "essentially", "there", "be", "no", "other", "obvious", "way", "to", "add", "descriptions", "and", "the", "reasonable", "assumption", "of", "just", "putting", "them", "in", "comments", "just", "works", "NUMBER", "It", "minimizes", "additional", "syntax", "to", "the", "language", "NUMBER", "In", "fact", "no", "additional", "syntax", "be", "necessary", "NUMBER", "This", "be", "beneficial", "for", "interoperation", "with", "exist", "tool", "NUMBER", "For", "tool", "which", "don", "t", "care", "about", "descriptions", "they", "can", "be", "safely", "treated", "only", "as", "comments", "NUMBER", "Cons", "Parsers", "need", "to", "be", "more", "sophisticated", "and", "cannot", "simply", "skip", "over", "comments", "but", "instead", "need", "to", "track", "which", "comment", "lines", "appear", "before", "which", "definitions", "so", "they", "can", "be", "interpreted", "as", "descriptions", "NUMBER", "There", "be", "potential", "for", "ambiguity", "where", "commenting", "out", "lines", "could", "cause", "them", "to", "be", "misinterpreted", "as", "a", "description", "for", "the", "following", "line", "NUMBER", "Actual", "comments", "ignored", "need", "to", "be", "separated", "from", "descriptions", "currently", "propose", "via", "an", "empty", "line", "Other", "proposals", "suggest", "a", "different", "leading", "character", "similar", "to", "comments", "comment", "description", "use", "chars", "type", "SomeType", "field", "String", "Or", "comment", "description", "use", "char", "type", "SomeType", "field", "String", "Another", "option", "be", "to", "use", "something", "like", "a", "docstring", "LINK", "This", "be", "a", "python", "inspired", "doc", "string", "style", "description", "type", "SomeType", "field", "String", "Or", "Similar", "style", "perhaps", "interpreted", "as", "a", "multi", "line", "comment", "type", "SomeType", "field", "String", "I", "would", "vote", "for", "parser", "friendly", "solution", "NUMBER", "I", "disagree", "NUMBER", "We", "should", "be", "aiming", "for", "whatever", "will", "have", "the", "best", "developer", "experience", "NUMBER", "Parsers", "be", "write", "rarely", "and", "by", "people", "who", "be", "capable", "and", "can", "write", "test", "NUMBER", "Schema", "in", "the", "language", "will", "be", "write", "far", "more", "often", "and", "by", "a", "broader", "set", "of", "people", "NUMBER", "That", "s", "what", "we", "should", "be", "optimizing", "for", "and", "that", "s", "why", "most", "of", "the", "pros", "for", "use", "comments", "center", "around", "ergonomics", "and", "be", "the", "most", "obvious", "NUMBER", "Using", "comments", "for", "descriptions", "has", "a", "lot", "of", "advantages", "but", "we", "ll", "need", "to", "decide", "if", "it", "s", "worth", "these", "drawbacks", "There", "be", "potential", "for", "ambiguity", "where", "commenting", "out", "lines", "could", "cause", "them", "to", "be", "misinterpreted", "as", "a", "description", "for", "the", "following", "line", "NUMBER", "Actual", "comments", "ignored", "need", "to", "be", "separated", "from", "descriptions", "currently", "propose", "via", "an", "empty", "line", "Using", "some", "other", "mechanism", "for", "add", "descriptions", "can", "solve", "these", "but", "could", "reduce", "the", "benefits", "of", "use", "comment", "lines", "or", "add", "drawbacks", "of", "their", "own", "NUMBER", "The", "drawbacks", "for", "be", "that", "it", "s", "easy", "to", "get", "wrong", "and", "miss", "a", "for", "a", "and", "accidentally", "lose", "a", "documentation", "NUMBER", "It", "add", "some", "ambiguity", "with", "comments", "and", "I", "could", "careless", "commenting", "out", "of", "lines", "repeatedly", "converting", "a", "into", "a", "and", "falling", "into", "the", "same", "drawbacks", "NUMBER", "The", "drawbacks", "for", "be", "that", "it", "consumes", "a", "punctuator", "not", "in", "use", "those", "be", "fairly", "precious", "and", "it", "s", "not", "particularly", "easy", "to", "remember", "nor", "be", "there", "much", "precedence", "for", "such", "a", "documentation", "scheme", "in", "modern", "languages", "so", "it", "s", "more", "to", "learn", "for", "newcomers", "NUMBER", "Multi", "line", "comments", "and", "Doc", "strings", "be", "both", "interesting", "to", "me", "in", "that", "while", "they", "re", "maybe", "slightly", "less", "ergonomic", "they", "may", "add", "additional", "value", "elsewhere", "though", "not", "in", "a", "way", "that", "solves", "a", "real", "need", "at", "the", "moment", "Multi", "line", "comments", "This", "add", "two", "different", "comment", "form", "to", "GraphQL", "NUMBER", "I", "originally", "avoided", "this", "in", "the", "sake", "of", "simplicity", "NUMBER", "Any", "multi", "line", "comment", "can", "be", "easily", "represented", "as", "multiple", "single", "line", "comments", "NUMBER", "graphql", "Multi", "line", "description", "type", "Foo", "bar", "String", "Perhaps", "there", "s", "some", "value", "in", "including", "them", "even", "if", "only", "for", "this", "use", "case", "NUMBER", "Though", "I", "think", "they", "still", "suffer", "from", "the", "same", "drawbacks", "of", "single", "line", "comments", "just", "to", "a", "lesser", "degree", "NUMBER", "Doc", "strings", "would", "really", "be", "doing", "two", "things", "Adding", "a", "new", "kind", "of", "multi", "line", "string", "literal", "that", "presumably", "could", "be", "use", "anywhere", "string", "literals", "be", "use", "today", "NUMBER", "Optionally", "parsing", "String", "before", "parsing", "anything", "that", "may", "have", "a", "description", "NUMBER", "That", "s", "interesting", "in", "that", "very", "short", "descriptions", "could", "be", "inline", "with", "typical", "string", "literals", "graphql", "Multiline", "string", "description", "of", "Foo", "type", "Foo", "Short", "description", "of", "a", "bar", "field", "bar", "arg", "describe", "inline", "arg", "Int", "String", "Adding", "this", "multiline", "string", "literal", "probably", "otherwise", "had", "only", "minor", "value", "but", "one", "use", "case", "that", "comes", "to", "mind", "be", "deprecation", "warnings", "graphql", "type", "Foo", "bar", "deprecate", "reason", "There", "s", "a", "lengthy", "reason", "why", "bar", "be", "deprecate", "that", "takes", "multiple", "lines", "to", "fully", "describe", "and", "fitting", "into", "a", "single", "line", "string", "literal", "would", "be", "illegible", "I", "think", "that", "s", "a", "pretty", "interesting", "use", "for", "multi", "line", "strings", "and", "brings", "some", "parity", "between", "descriptions", "and", "deprecation", "reasons", "NUMBER", "The", "drawbacks", "of", "strings", "as", "descriptions", "I", "think", "be", "mostly", "ergonomic", "NUMBER", "Comments", "can", "include", "any", "characters", "while", "strings", "need", "to", "escape", "some", "characters", "it", "could", "definitely", "be", "the", "case", "that", "quote", "marks", "appear", "in", "some", "descriptions", "NUMBER", "It", "s", "also", "less", "obvious", "that", "you", "should", "use", "a", "string", "literal", "instead", "of", "a", "comment", "to", "describe", "something", "NUMBER", "Instead", "newcomers", "to", "the", "language", "may", "see", "that", "string", "and", "be", "curious", "how", "it", "s", "affecting", "the", "schema", "NUMBER", "This", "be", "a", "common", "drawback", "to", "docstrings", "in", "languages", "like", "Python", "and", "Clojure", "it", "s", "easy", "for", "those", "less", "familiar", "with", "the", "language", "to", "misinterpret", "the", "strings", "a", "important", "to", "runtime", "behavior", "and", "become", "confused", "NUMBER", "I", "like", "the", "docstring", "approach", "as", "well", "but", "I", "do", "think", "it", "s", "important", "to", "be", "sober", "about", "the", "drawbacks", "NUMBER", "Maybe", "I", "m", "misunderstanding", "what", "you", "mean", "by", "runtime", "behavior", "though", "NUMBER", "For", "example", "clojure", "defn", "myFn", "Some", "fn", "x", "doSomethingWith", "x", "If", "you", "weren", "t", "familiar", "with", "clojure", "you", "might", "encounter", "this", "and", "be", "curious", "how", "this", "argument", "to", "the", "defn", "function", "was", "be", "interpreted", "and", "use", "at", "runtime", "or", "perhaps", "how", "it", "might", "affect", "performance", "or", "API", "design", "NUMBER", "Only", "once", "you", "become", "more", "familiar", "would", "you", "realize", "that", "defn", "be", "a", "macro", "not", "a", "function", "and", "that", "none", "of", "those", "early", "concerns", "apply", "NUMBER", "It", "s", "mostly", "about", "matching", "exist", "mental", "models", "NUMBER", "I", "think", "if", "we", "ve", "be", "docstring", "documenting", "our", "stuff", "since", "the", "NUMBER", "s", "that", "this", "sort", "of", "thing", "would", "be", "obvious", "to", "all", "of", "us", "and", "confusion", "wouldn", "t", "be", "a", "drawback", "NUMBER", "For", "GraphQL", "I", "think", "the", "same", "thing", "applies", "graphql", "type", "Foo", "bar", "this", "be", "an", "argument", "arg", "String", "String", "Is", "that", "string", "literal", "another", "argument", "in", "some", "way", "Is", "it", "some", "hint", "to", "bar", "Is", "it", "the", "default", "value", "for", "arg", "If", "that", "string", "gets", "longer", "will", "it", "affect", "performance", "I", "think", "it", "s", "totally", "reasonable", "to", "expect", "some", "portion", "of", "people", "who", "encounter", "this", "for", "the", "first", "time", "to", "be", "confused", "with", "these", "sorts", "of", "question", "or", "probably", "others", "I", "haven", "t", "thought", "of", "NUMBER", "That", "kind", "of", "seems", "to", "ruin", "the", "idea", "of", "ignoring", "whitespace", "NUMBER", "Yeah", "it", "s", "definitely", "a", "drawback", "of", "the", "approach", "NUMBER", "vergenzt", "I", "think", "that", "s", "certainly", "a", "topic", "worth", "discussion", "NUMBER", "Currently", "it", "s", "not", "uncommon", "for", "client", "codebases", "to", "define", "both", "their", "schema", "extensions", "and", "set", "of", "definitions", "across", "the", "same", "documents", "NUMBER", "We", "would", "expect", "these", "definitions", "to", "be", "separated", "by", "tooling", "before", "validation", "and", "execution", "NUMBER", "Good", "feedback", "OlegIlyenko", "NUMBER", "I", "still", "had", "some", "reservations", "about", "the", "any", "many", "field", "in", "field", "sets", "NUMBER", "My", "previous", "understanding", "was", "that", "the", "use", "cause", "for", "empty", "field", "was", "for", "type", "extensions", "where", "an", "extension", "sought", "to", "add", "a", "directive", "or", "interface", "and", "no", "additional", "field", "NUMBER", "A", "minor", "concern", "be", "consistency", "with", "the", "rest", "of", "the", "grammar", "NUMBER", "For", "example", "SelectionSet", "LINK", "SelectionSet", "and", "Arguments", "LINK", "Arguments", "and", "VariableDefinitions", "LINK", "VariableDefinitions", "share", "this", "property", "of", "requiring", "the", "grammar", "to", "have", "non", "empty", "lists", "similarly", "these", "could", "be", "validation", "rules", "instead", "however", "requiring", "them", "in", "the", "grammar", "ensures", "unambiguous", "text", "NUMBER", "Another", "use", "case", "I", "ve", "come", "across", "and", "one", "I", "personally", "wouldn", "t", "advocate", "but", "people", "seem", "to", "find", "value", "in", "it", "be", "to", "define", "a", "type", "with", "no", "field", "followed", "by", "numerous", "extensions", "graphql", "type", "Example", "extend", "type", "Example", "foo", "String", "extend", "type", "Example", "bar", "Int", "This", "pattern", "seems", "to", "reduce", "the", "legibility", "of", "the", "document", "however", "it", "certainly", "still", "seems", "semantically", "valid", "and", "unambiguous", "in", "its", "entirety", "NUMBER", "While", "these", "use", "cases", "for", "empty", "field", "sets", "be", "not", "particularly", "compelling", "to", "me", "personally", "I", "think", "the", "strongest", "argument", "be", "simply", "that", "people", "be", "already", "use", "them", "and", "smoothing", "the", "migration", "path", "from", "the", "experimental", "SDL", "to", "the", "spec", "SDL", "be", "valuable", "in", "its", "own", "right", "and", "it", "s", "the", "cost", "we", "pay", "for", "experimenting", "in", "the", "open", "NUMBER", "I", "like", "that", "suggestion", "OlegIlyenko", "NUMBER", "That", "formulation", "almost", "makes", "it", "more", "immediately", "apparent", "that", "no", "field", "be", "defined", "rather", "than", "an", "empty", "set", "be", "defined", "NUMBER", "However", "one", "drawback", "be", "that", "it", "still", "presents", "a", "breaking", "change", "against", "the", "experimental", "SDL", "however", "at", "least", "it", "be", "very", "easy", "to", "fix", "by", "simply", "remove", "Thanks", "for", "the", "review", "vergenzt", "I", "ll", "go", "through", "and", "address", "the", "issue", "you", "spotted", "Thanks", "Closing", "this", "aging", "issue", "Just", "wanted", "to", "add", "that", "a", "blog", "post", "was", "write", "on", "this", "topic", "as", "well", "LINK", "in", "graphql", "and", "relay", "Subscriptions", "be", "one", "piece", "of", "a", "larger", "topic", "of", "live", "data", "and", "asynchronicity", "that", "we", "plan", "on", "covering", "in", "the", "future", "with", "GraphQL", "NUMBER", "There", "be", "already", "experiments", "underway", "to", "better", "understand", "what", "the", "right", "decisions", "will", "be", "NUMBER", "Can", "you", "share", "the", "introspection", "query", "in", "particular", "GraphQL", "do", "not", "have", "a", "concept", "of", "keyed", "sets", "or", "maps", "only", "lists", "so", "I", "m", "a", "little", "confused", "with", "the", "issue", "NUMBER", "inputFields", "and", "field", "have", "different", "names", "in", "introspection", "because", "they", "return", "different", "types", "NUMBER", "Since", "introspection", "uses", "one", "simplified", "and", "flattened", "__Type", "type", "that", "can", "represent", "all", "of", "the", "types", "in", "a", "type", "system", "it", "needs", "differently", "named", "field", "to", "refer", "to", "these", "two", "different", "concepts", "NUMBER", "No", "problem", "this", "has", "be", "good", "feedback", "Thanks", "for", "point", "this", "out", "I", "just", "re", "write", "this", "section", "to", "be", "more", "clear", "I", "hope", "it", "helps", "NUMBER", "This", "proposal", "add", "a", "null", "literal", "to", "the", "GraphQL", "language", "and", "allows", "it", "to", "be", "provide", "to", "nullable", "typed", "argument", "and", "input", "object", "field", "NUMBER", "This", "presents", "an", "opportunity", "for", "a", "GraphQL", "service", "to", "interpret", "the", "explicitly", "provide", "null", "differently", "from", "the", "implicitly", "not", "provide", "value", "which", "may", "be", "especially", "useful", "when", "performing", "mutations", "use", "a", "per", "field", "set", "API", "NUMBER", "For", "example", "this", "query", "may", "represent", "the", "removal", "clearing", "of", "the", "bar", "field", "from", "thing", "with", "id", "NUMBER", "mutation", "editThing", "editThing", "id", "NUMBER", "edits", "foo", "add", "bar", "null", "NUMBER", "In", "addition", "to", "allowing", "null", "as", "a", "literal", "value", "this", "also", "proposes", "interpretting", "the", "variables", "JSON", "to", "distinguish", "between", "explicit", "null", "and", "implicit", "not", "provide", "mutation", "editThing", "edits", "EditObj", "editThing", "id", "NUMBER", "edits", "edits", "NUMBER", "This", "variables", "results", "in", "the", "unsetting", "of", "bar", "edits", "foo", "add", "bar", "null", "Finally", "this", "proposes", "following", "the", "not", "provide", "ness", "of", "variables", "to", "their", "positions", "in", "argument", "and", "input", "obj", "field", "mutation", "editThing", "editBaz", "String", "editThing", "id", "NUMBER", "edits", "foo", "add", "bar", "null", "baz", "editBaz", "NUMBER", "Such", "that", "the", "three", "variables", "be", "semantically", "different", "The", "baz", "input", "field", "be", "not", "provide", "editBaz", "null", "The", "baz", "input", "field", "be", "null", "editBaz", "add", "The", "baz", "input", "field", "be", "add", "cc", "dschafer", "schrockn", "I", "think", "this", "behavior", "would", "surprise", "most", "people", "and", "in", "fact", "I", "don", "t", "even", "think", "most", "implementations", "behave", "like", "this", "NUMBER", "Thanks", "for", "this", "feedback", "I", "agree", "that", "it", "s", "easy", "to", "misinterpret", "the", "spec", "in", "this", "way", "the", "way", "implementations", "behave", "be", "spec", "compliant", "so", "your", "suggestion", "be", "really", "just", "to", "clarify", "how", "things", "be", "supposed", "to", "work", "rather", "than", "be", "a", "change", "NUMBER", "I", "ll", "make", "it", "happen", "NUMBER", "jbinto", "graphql", "js", "should", "be", "compliant", "and", "if", "not", "be", "a", "bug", "NUMBER", "Please", "feel", "free", "to", "file", "a", "bug", "there", "or", "open", "a", "PR", "with", "a", "fail", "test", "case", "if", "you", "ve", "find", "one", "Rebased", "this", "just", "now", "NUMBER", "For", "reviewer", "here", "s", "what", "this", "looks", "like", "LINK", "ykdwgdukwo", "NUMBER", "now", "NUMBER", "sh", "Just", "get", "a", "careful", "review", "from", "dschafer", "offline", "so", "merge", "this", "now", "NUMBER", "We", "re", "work", "on", "richer", "documentation", "which", "will", "definitely", "cover", "mutations", "further", "NUMBER", "Closing", "this", "individual", "task", "but", "the", "work", "there", "continues", "stay", "tuned", "Thanks", "next", "time", "feel", "free", "to", "submit", "a", "PR", "LINK", "slack", "NUMBER", "herokuapp", "NUMBER", "com", "This", "would", "be", "a", "great", "task", "to", "claim", "for", "an", "aspiring", "contributor", "NUMBER", "IntelliJ", "would", "be", "great", "CompleteValue", "be", "miss", "reference", "to", "abstract", "type", "resolution", "NUMBER", "Thanks", "to", "seanchas", "for", "the", "careful", "read", "and", "highlight", "this", "issue", "NUMBER", "I", "would", "prefer", "not", "to", "do", "this", "NUMBER", "While", "it", "helps", "clarity", "when", "viewed", "in", "Github", "it", "makes", "the", "text", "file", "themselves", "a", "bit", "harder", "to", "read", "NUMBER", "Thanks", "for", "the", "exploration", "though", "Thanks", "It", "wasn", "t", "include", "because", "it", "s", "not", "available", "across", "all", "platforms", "most", "importantly", "and", "practically", "in", "our", "case", "JavaScript", "NUMBER", "The", "GraphQL", "spec", "do", "not", "specify", "a", "maximum", "byte", "width", "or", "storage", "size", "for", "its", "Int", "and", "Float", "type", "but", "there", "be", "a", "note", "about", "the", "caveat", "of", "platform", "specific", "restrictions", "NUMBER", "The", "two", "types", "only", "represent", "the", "semantic", "difference", "between", "whole", "and", "part", "numbers", "NUMBER", "This", "means", "that", "you", "can", "use", "Int", "as", "a", "Long", "or", "Float", "as", "a", "Double", "as", "long", "as", "the", "platforms", "you", "re", "use", "support", "that", "size", "NUMBER", "GraphQL", "allows", "you", "to", "define", "custom", "scalars", "as", "well", "in", "the", "case", "that", "you", "want", "to", "distinguish", "between", "Long", "and", "Int", "or", "define", "a", "custom", "serialization", "for", "it", "NUMBER", "Custom", "scalars", "be", "how", "we", "expect", "these", "kinds", "of", "desired", "Scalars", "to", "be", "introduce", "in", "a", "way", "that", "doesn", "t", "burden", "spec", "following", "GraphQL", "core", "libraries", "NUMBER", "Sorry", "I", "may", "be", "quoting", "outdate", "information", "NUMBER", "It", "appears", "you", "be", "correct", "that", "we", "decided", "on", "stricter", "language", "for", "the", "spec", "out", "of", "concern", "for", "the", "exact", "reasons", "you", "brought", "up", "NUMBER", "I", "believe", "the", "JavaScript", "reference", "implementation", "be", "more", "lenient", "and", "allows", "up", "to", "NUMBER", "bit", "Int", "the", "max", "JS", "number", "type", "can", "represent", "This", "be", "intentional", "NUMBER", "Note", "that", "the", "same", "be", "true", "for", "many", "programming", "languages", "including", "JavaScript", "NUMBER", "You", "can", "type", "a", "number", "in", "syntax", "that", "s", "larger", "than", "what", "the", "underlying", "memory", "can", "represent", "NUMBER", "In", "GraphQL", "s", "case", "it", "s", "also", "useful", "for", "exactly", "what", "you", "mention", "be", "able", "to", "create", "custom", "scalars", "which", "represent", "large", "numbers", "NUMBER", "However", "the", "Int", "scalar", "type", "do", "enforce", "NUMBER", "bit", "both", "in", "spec", "and", "the", "reference", "implementation", "to", "be", "maximally", "compatible", "NUMBER", "Thanks", "for", "open", "this", "NUMBER", "I", "m", "renaming", "the", "task", "to", "use", "the", "terminology", "we", "have", "be", "use", "to", "talk", "about", "this", "NUMBER", "We", "agree", "that", "this", "be", "really", "important", "but", "be", "not", "yet", "actively", "work", "on", "it", "NUMBER", "do", "you", "already", "have", "an", "idea", "which", "form", "it", "will", "take", "Sort", "of", "NUMBER", "I", "think", "it", "will", "specify", "a", "schema", "to", "implement", "along", "with", "a", "data", "set", "to", "use", "NUMBER", "Ideally", "this", "schema", "be", "as", "small", "as", "possible", "while", "still", "illustrating", "every", "feature", "of", "GraphiQL", "and", "support", "all", "of", "the", "acceptance", "test", "NUMBER", "Ideally", "this", "schema", "be", "write", "in", "the", "GraphQL", "Type", "DSL", "so", "it", "be", "easy", "to", "understand", "NUMBER", "Then", "there", "should", "be", "a", "list", "of", "test", "where", "each", "test", "include", "the", "following", "Description", "what", "be", "this", "test", "test", "and", "why", "Query", "a", "document", "to", "submit", "to", "the", "GraphQL", "service", "Response", "The", "response", "expected", "from", "the", "GraphQL", "service", "Then", "optionally", "also", "include", "Variables", "and", "OperationName", "when", "those", "be", "relevant", "to", "a", "test", "NUMBER", "This", "form", "should", "allow", "us", "to", "test", "everything", "from", "parser", "corner", "cases", "and", "proper", "detection", "and", "report", "of", "syntax", "error", "to", "validation", "error", "for", "all", "the", "rules", "we", "specify", "to", "execution", "behavior", "NUMBER", "I", "guess", "implement", "something", "like", "this", "can", "be", "a", "challenging", "task", "considering", "that", "it", "suppose", "to", "test", "implementations", "write", "in", "different", "languages", "NUMBER", "Ideally", "the", "form", "I", "write", "above", "only", "needs", "to", "be", "write", "once", "and", "can", "leverage", "the", "fact", "that", "the", "GraphQL", "language", "be", "represented", "as", "a", "string", "independent", "of", "any", "one", "backend", "language", "and", "the", "output", "can", "be", "serialized", "to", "JSON", "NUMBER", "However", "the", "provide", "schema", "still", "needs", "to", "be", "implement", "by", "that", "backend", "NUMBER", "Either", "by", "interpreting", "the", "GraphQL", "Type", "DSL", "or", "by", "manually", "implement", "it", "NUMBER", "Hopefully", "that", "be", "not", "too", "much", "of", "a", "burden", "NUMBER", "However", "overall", "I", "would", "certainly", "rate", "this", "task", "as", "challenging", "D", "Thanks", "for", "the", "suggestion", "I", "ll", "forward", "this", "to", "someone", "on", "our", "team", "who", "knows", "more", "about", "licensing", "NUMBER", "Thanks", "for", "this", "feedback", "NUMBER", "This", "be", "a", "lot", "so", "let", "me", "try", "to", "address", "each", "point", "NUMBER", "For", "colons", "in", "the", "type", "definition", "field", "argument", "and", "variable", "definitions", "we", "re", "hoping", "to", "do", "two", "things", "NUMBER", "Create", "a", "visual", "mirroring", "between", "the", "definition", "of", "the", "field", "argument", "and", "the", "usage", "of", "them", "NUMBER", "NUMBER", "More", "importantly", "leverage", "exist", "knowledge", "of", "other", "languages", "where", "syntax", "works", "this", "way", "Flow", "TypeScript", "Swift", "amidst", "others", "NUMBER", "be", "the", "dollar", "sign", "really", "required", "Yes", "it", "syntactically", "avoids", "an", "ambiguity", "between", "a", "possible", "enum", "values", "and", "variables", "NUMBER", "enum", "Color", "red", "green", "blue", "query", "coloredThing", "color", "Color", "variableThing", "thing", "color", "color", "redThing", "thing", "color", "red", "Also", "variables", "have", "a", "different", "frequency", "and", "importance", "in", "a", "query", "language", "than", "they", "do", "in", "a", "programming", "language", "NUMBER", "When", "use", "a", "programming", "language", "variables", "be", "often", "the", "most", "common", "token", "you", "use", "so", "keep", "them", "unadorned", "be", "important", "for", "legibility", "NUMBER", "In", "query", "languages", "however", "variables", "be", "fairly", "rare", "relative", "to", "data", "description", "identifiers", "NUMBER", "When", "variables", "be", "use", "it", "s", "important", "to", "visually", "highlight", "them", "so", "that", "it", "s", "clear", "NUMBER", "We", "use", "the", "sigil", "as", "a", "way", "to", "visually", "identify", "variables", "NUMBER", "Moves", "the", "source", "file", "into", "their", "own", "directory", "to", "clarify", "to", "someone", "just", "looking", "at", "the", "top", "level", "directory", "that", "they", "be", "source", "file", "and", "not", "designed", "to", "be", "read", "NUMBER", "This", "was", "the", "subject", "of", "considerable", "internal", "debate", "prior", "to", "the", "release", "of", "the", "spec", "so", "it", "s", "definitely", "a", "discussion", "worth", "having", "thanks", "for", "raising", "it", "A", "few", "things", "came", "up", "when", "we", "were", "considering", "this", "that", "convinced", "us", "nullability", "by", "default", "was", "a", "reasonable", "call", "NUMBER", "Because", "the", "type", "system", "on", "a", "GraphQL", "server", "be", "application", "specific", "not", "feature", "specific", "it", "can", "be", "difficult", "to", "provide", "universally", "valid", "default", "values", "NUMBER", "For", "example", "what", "s", "the", "right", "behavior", "if", "someone", "s", "profile", "picture", "fail", "to", "load", "In", "some", "features", "it", "might", "be", "to", "replace", "it", "with", "a", "default", "silhouette", "in", "others", "it", "might", "be", "to", "omit", "the", "person", "from", "the", "list", "NUMBER", "The", "correct", "behavior", "in", "the", "presence", "of", "an", "error", "be", "dependent", "not", "on", "the", "field", "but", "on", "the", "feature", "and", "only", "the", "client", "knows", "about", "the", "feature", "NUMBER", "By", "make", "the", "field", "be", "nullable", "and", "provide", "an", "error", "indicating", "that", "we", "nulled", "this", "field", "out", "because", "of", "the", "error", "the", "feature", "can", "handle", "it", "as", "it", "sees", "fit", "NUMBER", "Especially", "as", "queries", "and", "type", "systems", "grow", "the", "probability", "that", "_something_", "will", "go", "wrong", "in", "the", "backend", "increases", "and", "we", "need", "some", "way", "of", "handle", "that", "and", "expressing", "that", "in", "the", "query", "NUMBER", "The", "entirety", "of", "news", "feed", "for", "Facebook", "be", "powered", "by", "one", "GraphQL", "query", "and", "there", "be", "a", "number", "of", "places", "where", "a", "backend", "system", "might", "for", "any", "number", "of", "reasons", "not", "be", "able", "to", "provide", "a", "result", "for", "a", "field", "NUMBER", "In", "a", "system", "where", "things", "be", "non", "null", "by", "default", "this", "could", "mean", "that", "a", "backend", "failure", "at", "a", "leaf", "node", "deep", "in", "the", "tree", "causes", "the", "entire", "query", "to", "fail", "NUMBER", "To", "be", "clear", "though", "while", "nullable", "field", "be", "a", "feature", "of", "GraphQL", "and", "one", "that", "we", "think", "be", "valuable", "it", "s", "_absolutely_", "not", "a", "requirement", "of", "it", "NUMBER", "Non", "null", "field", "and", "nullable", "field", "be", "both", "first", "class", "citizens", "of", "GraphQL", "NUMBER", "We", "had", "to", "choose", "one", "to", "be", "the", "default", "though", "and", "based", "on", "the", "above", "we", "chose", "nullable", "NUMBER", "Closing", "this", "task", "now", "NUMBER", "Updates", "the", "README", "with", "a", "more", "clear", "hero", "field", "that", "takes", "an", "argument", "NUMBER", "This", "matches", "the", "change", "in", "LINK", "js", "pull", "NUMBER", "Thanks", "Thanks", "Thanks", "Thanks", "Good", "find", "Based", "on", "LINK", "js", "blob", "master", "src", "validator", "test", "harness", "NUMBER", "js", "L", "NUMBER", "NUMBER", "I", "think", "we", "should", "probably", "remove", "nickname", "from", "Pet", "which", "will", "make", "this", "example", "invalid", "again", "and", "demonstrate", "the", "case", "it", "was", "trying", "to", "establish", "even", "if", "all", "of", "the", "implementations", "have", "a", "field", "it", "be", "still", "not", "valid", "to", "query", "it", "if", "the", "interface", "doesn", "t", "NUMBER", "Thanks", "For", "example", "what", "be", "the", "expected", "answer", "for", "this", "graphql", "query", "dumb", "query", "just", "for", "the", "example", "We", "d", "describe", "that", "as", "a", "Document", "at", "the", "parser", "layer", "that", "contains", "two", "Operation", "s", "LukeAndLeiaNames", "and", "LukeAndLeiaHomePlanet", "NUMBER", "When", "executing", "we", "need", "to", "know", "which", "Operation", "to", "run", "LINK", "sec", "Evaluating", "request", "covers", "this", "in", "the", "spec", "and", "LINK", "js", "blob", "master", "src", "executor", "executor", "NUMBER", "js", "L", "NUMBER", "NUMBER", "in", "the", "reference", "implementation", "NUMBER", "If", "you", "only", "have", "one", "operation", "in", "a", "Document", "the", "common", "case", "then", "it", "s", "implied", "to", "run", "that", "one", "NUMBER", "If", "you", "have", "more", "than", "one", "you", "specify", "which", "operation", "to", "run", "in", "a", "given", "execution", "NUMBER", "Hope", "this", "helps", "What", "do", "I", "get", "in", "response", "from", "the", "server", "An", "error", "NUMBER", "The", "Document", "contained", "multiple", "operations", "and", "the", "client", "didn", "t", "specify", "which", "one", "to", "run", "NUMBER", "If", "you", "wanted", "to", "send", "that", "document", "and", "run", "one", "specific", "query", "you", "could", "pass", "an", "operationName", "parameter", "NUMBER", "The", "spec", "To", "evaluate", "a", "request", "the", "executor", "must", "have", "a", "parsed", "Document", "as", "defined", "in", "the", "Query", "Language", "part", "of", "this", "spec", "and", "a", "selected", "operation", "name", "to", "run", "NUMBER", "The", "executor", "should", "find", "the", "Operation", "in", "the", "Document", "with", "the", "given", "operation", "name", "NUMBER", "If", "no", "such", "operation", "exists", "the", "executor", "should", "throw", "an", "error", "NUMBER", "If", "the", "operation", "be", "find", "then", "the", "result", "of", "evaluating", "the", "request", "should", "be", "the", "result", "of", "evaluating", "the", "operation", "according", "to", "the", "Evaluating", "operations", "section", "NUMBER", "In", "our", "reference", "implementation", "we", "implement", "a", "helper", "where", "if", "there", "s", "only", "one", "operation", "in", "the", "document", "it", "s", "implied", "that", "the", "operation", "name", "be", "the", "name", "of", "that", "operation", "since", "that", "simplifies", "the", "common", "case", "NUMBER", "But", "you", "can", "t", "run", "multiple", "queries", "in", "the", "same", "request", "if", "that", "s", "the", "desired", "behavior", "a", "single", "query", "that", "combines", "them", "can", "be", "run", "instead", "NUMBER", "With", "fragment", "that", "would", "become", "simple", "query", "LukeAndLeiaNames", "NUMBER", "LukeAndLeiaNamesFragment", "fragment", "LukeAndLeiaNamesFragment", "on", "Query", "luke", "human", "id", "NUMBER", "name", "leia", "human", "id", "NUMBER", "name", "query", "LukeAndLeiaHomePlanet", "NUMBER", "LukeAndLeiaHomePlanetFragment", "fragment", "LukeAndLeiaHomePlanetFragment", "on", "Query", "luke", "human", "id", "NUMBER", "homePlanet", "leia", "human", "id", "NUMBER", "homePlanet", "query", "LukeAndLeiaBoth", "NUMBER", "LukeAndLeiaHomePlanetFragment", "NUMBER", "LukeAndLeiaNamesFragment", "And", "to", "finish", "how", "the", "client", "be", "supposed", "to", "send", "which", "operation", "to", "run", "if", "there", "be", "many", "operations", "in", "the", "document", "Up", "to", "the", "server", "the", "reference", "implementation", "just", "has", "the", "operationName", "as", "another", "parameter", "so", "I", "could", "imagine", "having", "a", "HTTP", "Param", "for", "the", "operation", "name", "NUMBER", "Until", "now", "I", "imagined", "graphql", "as", "a", "simple", "GraphQLQuery", "Server", "Response", "behavior", "NUMBER", "The", "client", "sending", "its", "query", "in", "string", "at", "a", "server", "endpoint", "NUMBER", "So", "I", "m", "a", "bit", "disappointed", "by", "this", "many", "operations", "document", "This", "be", "definitely", "the", "right", "way", "to", "think", "about", "things", "a", "Document", "be", "just", "an", "additional", "concept", "that", "can", "contain", "many", "GraphQLQueries", "NUMBER", "If", "you", "send", "a", "document", "with", "only", "one", "query", "then", "graphql", "be", "just", "QueryInDocument", "Server", "Response", "NUMBER", "If", "the", "document", "has", "many", "queries", "then", "you", "specify", "a", "query", "so", "that", "we", "can", "go", "Document", "Query", "Server", "Response", "So", "now", "what", "wonder", "me", "be", "NUMBER", "what", "s", "the", "point", "of", "having", "a", "document", "that", "can", "contains", "many", "operations", "The", "use", "be", "threefold", "NUMBER", "It", "s", "often", "useful", "to", "store", "GraphQL", "documents", "in", "a", "client", "side", "file", "we", "use", "NUMBER", "graphql", "file", "on", "iOS", "and", "Android", "for", "this", "NUMBER", "We", "wanted", "the", "parser", "to", "work", "on", "these", "file", "as", "well", "so", "the", "parser", "be", "universal", "but", "you", "can", "and", "we", "often", "do", "include", "multiple", "queries", "in", "a", "single", "document", "NUMBER", "NUMBER", "One", "optimization", "that", "can", "be", "made", "and", "that", "we", "ll", "discuss", "in", "more", "detail", "in", "the", "future", "I", "m", "sure", "be", "persisting", "documents", "you", "send", "the", "document", "to", "the", "server", "who", "stores", "it", "for", "you", "and", "gives", "you", "an", "identifier", "for", "that", "that", "way", "you", "don", "t", "have", "to", "send", "the", "whole", "document", "string", "up", "every", "time", "NUMBER", "If", "you", "do", "that", "you", "can", "send", "a", "document", "up", "with", "all", "your", "queries", "and", "then", "pass", "the", "document", "ID", "operation", "name", "over", "the", "wire", "NUMBER", "This", "would", "optimize", "bytes", "be", "sent", "from", "the", "client", "to", "the", "server", "NUMBER", "NUMBER", "It", "s", "possible", "to", "write", "a", "batch", "API", "for", "GraphQL", "where", "you", "use", "the", "results", "from", "one", "query", "as", "the", "parameters", "to", "another", "NUMBER", "We", "re", "still", "work", "out", "the", "exact", "details", "there", "but", "if", "you", "do", "that", "it", "s", "useful", "to", "specify", "multiple", "queries", "in", "a", "single", "document", "you", "d", "specify", "which", "one", "you", "wanted", "to", "run", "at", "the", "start", "and", "the", "relationships", "between", "them", "NUMBER", "You", "re", "absolutely", "correct", "that", "in", "the", "model", "we", "describe", "pass", "a", "string", "to", "the", "server", "get", "a", "response", "back", "a", "Document", "with", "multiple", "operations", "isn", "t", "that", "useful", "we", "wanted", "to", "permit", "it", "for", "the", "reasons", "describe", "above", "NUMBER", "Thanks", "for", "the", "great", "question", "Thanks", "Good", "catch", "We", "ll", "make", "sure", "to", "fix", "this", "Thanks", "Thanks", "Thanks", "graue", "Yep", "we", "re", "definitely", "planning", "on", "doing", "so", "Closing", "this", "thread", "since", "this", "discussion", "should", "be", "driven", "from", "loopback", "and", "there", "s", "no", "action", "to", "be", "taken", "from", "this", "repo", "NUMBER", "See", "LINK"], "text_count": [0, 10984, 2551, 1148, 376, 282, 717, 1, 74, 1402, 1603, 2957, 1711, 1001, 1192, 436, 0, 0, 0, 0, 3173, 997, 574, 344, 652, 545, 0, 0, 0, 0, 6015, 3413, 2697, 137, 1838, 299, 0, 0, 0, 0, 7805, 41, 2872, 2653, 2076, 0, 0, 0, 0, 0, 2285, 1096, 1079, 576, 991, 462, 780, 0, 0, 0, 5256, 287, 4163, 485, 0, 0, 0, 0, 0, 0, 4113, 462, 2588, 1323, 603, 0, 0, 0, 0, 0, 7765, 3605, 596, 3315, 385, 234, 0, 0, 0, 0, 330, 2138, 230, 0, 0, 0, 0, 0, 0, 0, 5362, 1287, 3009, 1092, 0, 0, 0, 0, 0, 0, 12056, 21110, 278, 771, 244, 454, 0, 0, 0, 0, 28921, 175, 21249, 427, 5091, 6686]}, {"repo": "graphql-spec", "type": "nonelite", "title": "", "number of text": 982, "text": "  It looks like the specification is not clear if the client provides a request without variables, does the field \"variables\" should be assigned \"null\" or \"{}\" or both are valid?\r\n\r\nContext:\r\nIn the [altair](https://altair.sirmuel.design) tool, the default value is set to \"{}\" (without the double quotes) and in the graphql-java implementation, it's expecting a \"null\" value if not variables are needed.  The result is, the queries are rejected on the server side, so does the server side is too stick or is it the client side which is providing the wrong value? What do you mean be \r\n\r\n> So de jure even\r\n\r\n... but thanks, I think you answered my question:\r\n`Let coercedValues be an empty unordered Map.`\r\nI guess by empty, they mean `{}`, but I'm not understanding why they mention `empty unordered Map`,  since it's empty there's nothing to sort?!  Could we support some markdown in GraphQL comments? The benefit is not huge and is definitely the lowest priority issue on here but this proposal could make sense in some contexts. I could possibly want to put emphasis on a certain part of a comment so that other people who read the docs for my API don't overlook it. That's about as far as I got with thinking this through. I have an example below but it's pretty simple. I would imagine that this is a pretty easy job and I'd be willing to shoot a PR over to `graphql-js` if accepted.\r\n\r\nObviously, it probably wouldn't be a wise idea to have full support for Markdown. I was thinking of:\r\n\r\n- Italics\r\n- Bold\r\n- Strikethrough\r\n- Links (maybe)\r\n\r\nFor example:\r\n\r\n```graphql\r\nenum MessageStatus {\r\n  # If a message could not successfully be delivered.\r\n  Failed\r\n  # If a message was successfully delivered but _has not been_ read by the other user(s).\r\n  Delivered\r\n  # If a message was successfully delivered and _has been_ read by the other user(s).\r\n  Read\r\n}\r\n```\r\n\r\nCould possibly return the following in the docs:\r\n\r\nIf a message could not successfully be delivered.\r\nIf a message was successfully delivered but **has not been** read by the other user(s).\r\nIf a message was successfully delivered and **has been** read by the other user(s).\r\n  I would appreciate if you could describe the motivation behind this proposal. I remember raising similar issue in past in a context of an empty string (`\"\"`) `ID`s: https://github.com/facebook/graphql/issues/404\r\n\r\nATM I have some concerns about this constraint. It is a breaking change and I have a feeling that in might affect some of the API. Also, this limitation (as well as disallowing empty strings) might cause issues integrating with legacy systems (`-1` also comes in mind, I have seen API that use such IDs). But also in general, I think IDs should be opaque. I see constraints like this as part of the application domain, so I feel that we should not enforce them in the spec.  currently the name only supports `/[_A-Za-z][_0-9A-Za-z]*/` And to add more background information:\r\n\r\nThe - character tends to interfere with parsing of a name such as `x-y`. Is this now an identifier `x-y` or is it a subtraction: `SUB x y` in an AST node? In most languages, this is ambiguous and thus, the `-` character is often disallowed in identifier names. Even if GraphQL doesn't use `-`, languages in which it is embedded often do.\r\n\r\nAn important exception to the rule are Lisp-like languages (Common Lisp, Scheme, Racket, Clojure) where the notation is an s-expression `(- x y)` in the above case. Since everything is coded as a prefix it is clear one can use names with a dash in those languages, and it is seen quite often on those languages. E.g. `(string-append \"hello\" \"world\" \"!\")`.\r\n\r\nLikewise, catenative languages are likely to accept a `-` in other positions as well. @IvanGoncharov @jlouis Thanks very much for the explanation. \r\n\r\nI asked this questions because I am developing a GraphQL schema where there is something like \r\n```\r\naddress {\r\n  \"en-GB\": \"Address in English\",\r\n  \"zh-CN\": \"Address in Simplified Chinese\",\r\n  \"zh-HK\": \"Address in Traditional Chinese\"\r\n}\r\n```\r\n\r\nMaybe I have to change to another approach. @liweinan0423 we had exactly the same challenge for localized strings in out API. Since the set of available locales is dynamic and changes over time, we decided not to bake such fields as `en` or `en-GB` into the GraphQL schema (and in general I would advise not to do so).\r\n\r\nWe ended up providing 2 GraphQL fields for every localized property (for 2 different use-cases our clients have):\r\n\r\n```graphql\r\ntype LocalizedString {\r\n  locale: String!\r\n  value: String!\r\n}\r\n\r\ntype User {\r\n  address(locale: String!, fallbackLocales: [String!]): LocalizedString\r\n  addressAllLocales: [LocalizedString!]\r\n}\r\n```\r\n\r\n`address` field is designed for customer-facing apps that normally work with a single locale (user language). `addressAllLocales` is designed for admin-style applications that normally present localized strings in all locales and allow users to view and edit them.\r\n\r\nNot sure whether this approach will work for you, but I hope this helps :) @IvanGoncharov sure, thanks very much for your clarification.  \r\n**Proposal**\r\n\r\nThere should be three (3) GraphQL specs, for Queries, Mutations and Subscriptions.\r\n\r\nWhen I looked at [GraphQL-JS on Github](https://github.com/graphql/graphql-js) which is supposed to be the Reference Implementation of the GraphQL spec, it seems to include Queries, Mutations and Subscriptions. \r\n\r\nSometimes we just need the Queries capability or Queries and Mutations but not Subscriptions. \r\n\r\nBy splitting the GraphQL spec into the three aforementioned parts (this Proposal) it will encourage modular implementations. \r\n\r\nThanks,\r\n > This might also be a challenge since aspects of GraphQL like Introspection make reference to mutation and subscription root types - presumably any service, even if only supporting queries, would need to respond well to introspection queries that reference these\r\n\r\nHmm. I didn't think about that, but I'm not sure the service needs to respond to introspection queries referencing mutation and subscription root types with anything other than indicating lack of support for those queries. This way the spec is untangled.\r\n\r\nIdeally, I should be able to implement separate concepts (Queries, Mutations, Subscriptions) separately. Subscriptions can conform to the GraphQL-Subscriptions spec but be used with Non-GraphQL Mutations.  Why not? Same with Mutations, which can conform to the GraphQL-Mutations spec but be used with Non-GraphQL Subscriptions (like notifications streamed from the db's change log in some custom format using some streaming API with exactly-once processing, etc...) \r\n\r\n\r\n I know all of it can be done today if you don't mind having more code to maintain than you have to (why should I implement GraphQL Mutations if I only need GraphQL Queries? Imagine I have to combine GraphQL Queries with Non-GraphQL Mutations (e.g. writes coming over Kafka Streams API directly from clients that are outside my scope of responsibility)  \r\n\r\nThe question is why as implementor do I need to implement parts of the spec that I have no use for? Why are completely separate (or should be separate) concepts bundled together in one spec? What is special about the 'Queries, Subscriptions, Mutations' set that makes it immune to decomposition?\r\n\r\n At a point you can definitely build a process which follows Python's PEP (Python Enhancement Proposal), The Bittorrent BEP (Bittorrent enhancement proposal), or the scheme SRFI (Scheme Requests for Implementation).\r\n\r\nThe idea is that you have a base system which is the minimum requirement for compliance, and extensions are then numbered as BEP5, BEP17 and so on. Clients experimentally build those and they then become standardized later if enough clients de-facto implements them.\r\n\r\nBitTorrent had the Azureus/Vuze client which were built in Java and was adding features at a much faster pace than every other client, and their features were rarely the ones the rest of the community ended up using. So all the BEPs were written down, and people steered around those proposals and implemented the other proposals (which were then accepted into the standard eventually).\r\n\r\nSpecifications evolve. Support the evolution.\r\n\r\nI was afraid the Jun2018 specification would be bloated and mess up things, but luckily my worry was only that: a worry. The changes are mostly clarifications, and sensible extensions. It will take some time to adapt my GraphQL server code base, but we are slowly getting there :) @jlouis yes that is exactly what I was hinting at but did not want to get into the how ahead of agreeing on the what of the proposal. The reference you make to the BitTorrent Azureus/Vuze client reminds me of Apollo server/client. \r\n\r\nThank you for framing it in historical context. I agree 100% that we need this kind of thinking in order for GraphQL to evolve naturally.\r\n\r\nMaybe 3 years down the line someone will reference this and come out with the base spec and reference implementation that will support spec extensions in the way you described. \r\n\r\nBut for now I am getting massive resistance on Twitter (see discussions under my handle @marcfawzi)\r\n\r\n@stubailo compared the argument to someone not wanting to use Underscore because they only need a few functions from it. I had to state that it\u2019s about implementation cost  not usage cost\r\n\r\nI love your framing. Thank you. I think the case is pretty clear now.\r\n\r\nI look forward to this getting resurrected in a few years when the community realizes that they need to have that level of abstraction in the process. To be clear, the base case for me is Queries. \r\n\r\nEverything above that (Mutations, Live Queries, Cache, Subscriptions, etc) should be an extension, IMO.\r\n\r\nWhat is special about queries? Without them GraphQL is meaningless. I can\u2019t say the same about Mutations and Subscriptions, as well as all other non-standard features out there. Fair enough. The onus on us (the community) to come up with a compelling case. I believe I have one at the moment (on the roadmap) but will be better informed when we do the actual work. To clarify, the use case can be done with GraphQL as is today but it should demonstrate how a PEP-like process would allow us to contribute to the spec and partake in its evolution, as opposed to many folks in our position doing custom work in isolation.\r\n\r\nThat is the key point of this proposal.\r\n\r\nI'll leave this open for a few days then close it, in case other have any other input.  # The issue\r\nHere's a link to the specification for not-null: http://facebook.github.io/graphql/June2018/#sec-Input-Objects\r\n\r\nIt says:\r\n```\r\nOtherwise, if the field is not required, then no entry is added to the coerced unordered map.\r\n```\r\n\r\nThis means that we have an opportunity to behave differently in our application code based on whether the user explicitly posts null for a field, or simply omits the field. However, we have no way of restricting the options available to a user.\r\n\r\n## Consider the following schema:\r\n```graphql\r\ninput PersonInput {\r\n  id: ID!\r\n  name: String # Does not support partial updates - i.e. null or omission results in this field being set to null in the database\r\n  hobby: String # Supports partial updates - i.e. null means to unset this field, omission means to leave the existing value as-is\r\n}\r\n\r\ntype Person {\r\n  # ... omitted for brevity\r\n}\r\n\r\ntype Mutation {\r\n  updatePerson(input: PersonInput): Person\r\n}\r\n```\r\n\r\n## Consider the following scenarios:\r\n\r\n### Scenario 1 - User wants to blank out all values for a person\r\n#### Option 1 - Setting all fields to null\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"name\": null,\r\n  \"hobby\": null\r\n}\r\n```\r\nI think this is the most idiomatic approach a user would use. The server does exactly what the user wanted.\r\n#### Option 2 - Omitting all fields\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1\r\n}\r\n```\r\nThis doesn't feel like a natural thing to do. The server nulls out the name, but the hobby is left as-is. The user didn't achieve what they wanted, but they will be left wondering why. They will probably write a more specific query and maybe file a bug against the API saying the hobby field doesn't work as expected.\r\n\r\n### Scenario 2 - User wants to blank out the hobby for a person\r\n#### Option 1 - Providing the existing name, with the hobby set to null\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"name\": \"John\",\r\n  \"hobby\": null\r\n}\r\n```\r\nI think this is the most idiomatic approach a user would use. The server does exactly what the user wanted.\r\n#### Option 2 - Providing the existing name, with the hobby omitted\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"name\": \"John\"\r\n}\r\n```\r\nThis doesn't feel like a natural thing to do. The server does not blank out the hobby. The user would probably retry the query using option 1 at this point.\r\n#### Option 3 - Just setting the hobby to null\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"hobby\": null\r\n}\r\n```\r\nThis feels natural, especially in the \"GraphQL\" world where the API can constantly evolve and new fields can be added. The server nulls out the hobby as expected. However, it also nulls out the name, which the user did not expect.\r\n\r\n### Scenario 3 - User wants to blank out the name for a person\r\n#### Option 1 - Providing the existing hobby, with the name set to null\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"name\": null,\r\n  \"hobby\": \"Skydiving\"\r\n}\r\n```\r\nI think this is the most idiomatic approach a user would use. The server does exactly what the user wanted.\r\n#### Option 2 - Providing the existing hobby, with the name omitted\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"hobby\": \"Skydiving\"\r\n}\r\n```\r\nThis doesn't feel like a natural thing to do. However, the server does exactly what the user wanted.\r\n#### Option 3 - Just setting the name to null\r\nThe user posts the following object:\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"name\": null\r\n}\r\n```\r\nThis feels natural, especially in the \"GraphQL\" world where the API can constantly evolve. The server does exactly what the user wanted.\r\n\r\n**I have not illustrated examples of the scenarios regarding a field which is always mandatory but can be omitted from an update to retain its existing value.**\r\n\r\n## Description\r\nThe following cases illustrate that there are several points of ambiguity in our API:\r\n- Scenario 1 - Option 2 - quite painful\r\n- Scenario 2 - Option 2 - not that much of a pain point\r\n- Scenario 2 - Option 3 - quite painful\r\n\r\nIt's easy to turn around at this point based on these trivial examples and say \"Well why the hell would you do that for? Why not be consistent?\"\r\n\r\nThe reason we are facing this dilemma is because we have many mutations (none of which support partial updates, i.e. all fields are always required explicitly) and our consumers want some APIs to start supporting partial updates. At the moment, some fields are optional, so both null AND omission translate to \"blank it out\". However, we would need to start treating omission differently (i.e. \"leave as-is\"). Without excessive comments in our documentation and validation in our API, our API will be difficult to understand and seem \"inconsistent\" to end users. It would be great if we could define input types like the following:\r\n```graphql\r\ninput ExampleInput {\r\n  id: ID!\r\n  field1: String | null # Can be a string or null, but must always be provided (i.e. does not support partial updates). This would be a solution to the scenarios I listed above.\r\n  field2?: String! # Can be a string (to update the value) or omitted (to leave as-is), but can't be null. This would be a solution to the scenario I briefly mentioned above in bold but did not provide examples for.\r\n}\r\n```\r\n\r\n@trevorah @peterstarling @joaojeronimo @craigbilner @belema @jackharvey1 You guys might be interested in this  This proposal directly relates to a discussion in https://github.com/facebook/graphql/issues/429. As was discussed at the latest WG meeting, I'm creating several alternative proposals. This one implements [proposed solution](https://github.com/facebook/graphql/issues/429#issuecomment-392946579) `4. Limit the validation to only these directives that are explicitly marked as \"unique\". This implies that we need to introduce a new option in the directive definition`.\r\n\r\nIt limits the scope of \"Directives Are Unique Per Location\" to directives that are explicitly marked as `unique`.\r\n\r\nThis proposal is mutually exclusive with other alternative proposals:\r\n\r\n* [RFC] Limit uniqueness to `@skip`, `@include` and `@deprecated` directives (#471)\r\n* [RFC] Limit directive uniqueness to explicitly marked directives (#472, this one)\r\n\r\n@leebyron @IvanGoncharov @jjergus I would appreciate your reviews.\r\n\r\nCloses #429\r\nCloses #471 @OlegIlyenko I need a couple more days to think about #472 vs #471 vs keep everything as is.\r\nBut here are a couple points after quick review:\r\n1. I don't like `unique` in front of the directive: `unique directive @example on OBJECT | INTERFACE`\r\nHow about `directive @example uniquely on OBJECT | INTERFACE`?\r\n2. I think directives should be unique by default since it what make sense in most of the cases. If you want to support some advanced usage of your directive (chaining, accumulation, etc.) you should explicitly allow this. Can't come up with better English word so I will use `nonUniquely` as temporary keyword: `directive @example nonUniquely on OBJECT | INTERFACE`.\r\n\r\n @IvanGoncharov thanks a lot for your feedback and for taking your time to review the PR! \r\n\r\nThese are good points. I think the reason I used `unique directive ...` syntax is because it makes presence of an additional constraint on directives explicit. For me personally, it is more intuitive to assume that without any explicitly stated information, the entity is unconstrained. SQL DDL is one example of this approach. As well as the GraphQL itself, where you need to put an explicit `!` to add extra not-null constraint on the field.\r\n\r\nThat said, I also think that your suggestion has a good argument (default that represents the prevalent use-case). So I think I don't have a strong preference between these two alternatives. Maybe you have some good examples of non-standard directives that are widely used and either need to be unique or non-unique? (would be interesting to compare both cases). Also, you be interesting to hear opinions on this aspect from other reviewers.\r\n\r\nRegarding `unique directive @example` vs `directive @example uniquely`. The second variation look a bit odd to me, so I think I would prefer the first one, but it's more personal opinion. Although with the syntax of the second one it might be easier to add additional constraints in future. So I guess this is a thing to consider.\r\n\r\nAlso in my experience, directives are very rarely authored in the SDL. Most of the time I worked with and saw them used in the host language. From this perspective most of the time directive-definitions-in-sdl show up in the rendered output of actual schema (in this case I would prefer more explicit `unique directive ...`). But maybe it's just me, I'm not sure about this point. I think a near-ideal English word would be `repeatable`: basically, you are allowed to repeat the directive at the same location. I still don't think that's a perfect word, but I think it's better than `nonUnique`.\r\n\r\nI also wonder if, instead of adding a language keyword, we should instead allow directives on directive definitions. Then you'd have something like:\r\n```\r\ndirective @repeatable on DIRECTIVE\r\ndirective @my_skip(if: Boolean) @repeatable on FIELD\r\n```\r\n\r\nI agree with @IvanGoncharov that by default, most directives will be unique per location. A couple of potential directive examples:\r\n- `@ignore_validation`: basically, if validation on this fails, keep going. This one should probably not be repeatable.\r\n- `@ignore_validation_rules(rules_to_ignore: [ValidationRuleName])`: this could go either way, but I think most implementers of this would first make it non-repeatable/unique, as it's easier to implement if it's more rather than less strict. Then once the need for it to be repeatable is clear, it can be \"upgraded\".\r\n\r\nAs I think it'll be easier to implement unique directives, I suspect it's better if by default the implementer doesn't have to worry about merging them. I'm not totally sure we'll ever get to a set of 100% consistent directive-merging rules that work for all use cases. But if we did this, it would be easy if we decided, say, that `@skip`  @IvanGoncharov those arguments are pretty convincing to me. It does end up potentially opening up a class of \"things we want to add to directive definitions\", and this argument basically means this entire class cannot be experimentally added via directives first, but instead must be added to the language. I can't immediately think of another example that lives in this class though, so maybe this is indeed the only thing in the entire class of \"additions to directive definitions\" we would want to add.  @mjmahone I also like `repeatable`, it looks and sounds good in SDL. I also don't have a strong opinion on the default. If we have a strong consensus on non-repeatable default, then let's do it. Also, if most of that directives that people are using in practice are non-repeatable, then I think it is indeed a very good idea to represent it as the SDL default.\r\n\r\n> I also wonder if, instead of adding a language keyword, we should instead allow directives on directive definitions\r\n\r\nI thought about this as well, but I think I would agree with @IvanGoncharov's arguments. I feel that the syntax will get quite confusing in SDL. ATM I also can't think of other use-cases for directives-on-directives.  Fixed typo in spec: acknoledgment -> acknowledgement It\u2019s a great spec! Thanks for a great spec!  Re-applies #424, but as an RFC. This change is a major spec breaking change, and if it is desire-able, we should provide an upgrade path for existing schemas. Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fgraphql%20%23460). Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  This validation requirement was a really nasty breaking change for existing GraphQL type systems. Additionally, it is in my opinion actively harmful to an iterative development model, where you'd define an interface that a field returns, develop on the client against that interface, then days or weeks later, create one or more types that implement the interface, which old clients can start using immediately. >  develop on the client against that interface\r\n\r\nHow can you develop against an interface if it's not implemented?\r\nDo you use some mocking tool?\r\nWhat would be the value of `__typename` for a field that returns such interface? At least internally, we have a lot of tooling that generates client-side, language-specific models. So for Relay, we have flow types for fragments that you define. How we (frequently) do this:\r\n1. Create the interface definition with the fields you'll want to support on that interface.\r\n2. Add a field to another type which returns that interface. On the server, the implementation always returns `null`.\r\n3. Build your client using the generated flow types and potentially client-defined dummy data.\r\n4. Implement the interface with a specific object, have the field you defined in (2) return that object.\r\n\r\nBecause GraphQL schemas are meant to be forwards compatible, all of our clients have the concept of an \"unknown implementation of Interface Foo\" built into them, with the assumption that we'll get objects with `__typename` we don't know, but because we've built our fragments against the Interface and not a specific object, it's OK. It is interesting to see this PR, I also had mixed feelings about this validation. In my case ita breaking change as well. \r\n\r\nIn our case we provide a multi-tenant system where most of the schema is static, but small parts of the schema are specific to the tenant and generated dynamically for each project (it is a set of custom product attributes). All tenant-defined parts of the schema implement a common interface - it is advantageous to consider the interface as a part of the static schema and assume that it is always present for all tenants. On the other hand,  user-defined types (the implementations of this interface) might or might not be present. So it is possible that some tenants end up in a situation where they have a non-implemented interface. Though, it is still useful to have this interface in the schema for client-side tooling.\r\n\r\nFor the moment being, we disabled the validation in our project. I believe it would be possible to refactor the schema, but I think I would prefer to avoid it. In general, I don't mind this validation as log as it is not prescribed by the GraphQL spec. I see it more as helper that specific implementation might adopt to help users avoid common schema configuration issues. As long as there is an easy way to disable the validation and it is not part of the spec, I think it should be fine. As this validation will not be included in `graphql-js` v14.0.0, I'm going to merge this and put up a new PR for adding this validation back in. I do not want our spec and reference implementations getting out of date.\r\n\r\nI'm still very open to adding this validation. But because it's a major breaking change, we need more discussion on the value of this enforcement vs. allowing un-implemented interfaces. New PR with RFC: #460  @mjmahone It's a draft version of a specification so it's normal that it deviates from `graphql-js`. Plus it safe do any changes until a new release is published.\r\n\r\nI agree that it makes sense to prove that such validation doesn't cause more harm than good. And I 100% agree that it worth to exclude this validation from upcoming release if no good solution found for both your and @OlegIlyenko use cases. \r\n\r\nBut I don't understand what is a reason for such a quick merge. It was worth to wait at least a day to hear what others have to say especially the @mattkrick (the author of original PR) and @leebyron (the person who merged that PR).\r\n\r\nI'm totally against merging such non-trivial PRs without giving the community some time for feedback. As far as I remember previously all non-editorial changes were opened for discussion for more than 3 hours. @IvanGoncharov sorry about that. I was under the impression that `graphql-js` and `graphql` needed to stay in sync as quickly as possible. Which meant in my mind, as soon as it became obvious that `14.0.0` wasn't going to include this spec addition, we should get rid of it rather than letting the two drift.\r\n\r\nThis is my error: had I realized it was OK for the spec and reference implementation to be out of sync for a few days, I would have happily left this un-merged. I'm sorry, and will allow more time for comments from the community going forward. Of note: prior to merging this I had reached out to @leebyron already, and he OK'd the graphql-js strategy. I likely misunderstood what he wanted us to do for the spec, though. @mjmahone Thanks for the explanation \ud83d\udc4d \r\nNothing bad happened but I think it's a good idea to have some kind contribution guide that explains what to do in such situations.\r\nAlso if possible keep us in sync with Facebook internal discussions so we are all on the same page. good call. the important part (`getPossibleTypes` returning an empty array) was not rolled back in the reference implementation, so I'm cool with this. The multitenancy use case is a fun one! Certainly makes the case for favoring 0-to-many over 1-to-many. \r\n\r\nSo if it's not an error, is it a warning? info? Is there a utility function that I can use to find unused interfaces?  All other places reference it as \"type system definition language\". @leebyron Just to clarify \"schema definition language\" was renamed to \"type system definition language\", right?\r\nSo what abbreviation should be used instead of SDL?\r\nTSDL or TSD?  Reported by @OlegIlyenko in https://github.com/facebook/graphql/issues/429#issuecomment-392990065\r\nI think it should be added in upcomming release for consistency with other definition extensions.\r\n  When linking to the website, many places (either due to wanting to stay up-to-date or because they did so before the website moved to have multiple spec versions live) link directly to a position in the spec using the top-level path, rather than a specific version.\r\n\r\nFor example, they link to:\r\nhttps://facebook.github.io/graphql/#sec-Enums\r\nrather than:\r\nhttp://facebook.github.io/graphql/October2016/#sec-Enums\r\n\r\nThe problem is that the `<meta>`-refresh loses any query string or hash-fragment of the URL. So the above, instead of redirecting to the desired:\r\nhttp://facebook.github.io/graphql/October2016/#sec-Enums\r\ninstead just goes to the top of the page:\r\nhttp://facebook.github.io/graphql/October2016/\r\n\r\nThis change adds some JS that performs the redirect, additionally repeating the current URL's query string `?...` and fragment `#...` on the redirect, so that the browser jumps to the correct position on the resulting page.\r\nIt also alters the `<meta>`-refresh to wait 1 second, allowing the JS to get in but still offering progressive enhancement for cases where the JS is not executed.\r\n\r\nThe effect can be seen by comparing:\r\nhttps://facebook.github.io/graphql/#sec-Enums (before)\r\nwith:\r\nhttps://ind1go.github.io/graphql/#sec-Enums (after)\r\n @ind1go Thanks for PR \ud83d\udc4d\r\nBTW. `index.html` generated by [this script](https://github.com/facebook/graphql/blob/master/publish.sh) so you should edit it instead.\r\n\r\n> When linking to the website, many places (either due to wanting to stay up-to-date or because they did so before the website moved to have multiple spec versions live) link directly to a position in the spec using the top-level path, rather than a specific version.\r\n\r\nI think all such links preceded #364 and proposed redirection makes sense only for `October2016`. \r\nBut we plan to publish next release in a short while so after that release should we still redirect to `October2016` or to a new release?\r\n\r\nMoreover, a new version of spec allows you to reference things like examples and algorithms:\r\nhttp://facebook.github.io/graphql/draft/#example-65e7d\r\nhttp://facebook.github.io/graphql/draft/#CollectFields()\r\nAnd such links are very useful but are highly unstable so we can't maintain them between releases.\r\n\r\nAlso, there is a high risk that text surrounding a link will contradict with part of spec it references, because of specification changes.   @MSleepyPanda Thanks for quick PR \ud83d\udc4d \r\nWould be great if you also fix `Explanatory Text` in the same section, to keep it in sync. While i'm at it, re Example 114:\r\n`fragment scalarSelectionsNotAllowedOnBoolean on Dog`: Why Boolean? barkVolume is an Int. Also the intent is to convey that no further selections are allowed on primitives.\r\n\r\nI'd propose changing the name to `scalarSelectionsNotAllowed`. I'd expand the example by `enumSelectionsNotAllowed`. > While i'm at it, re Example 114:\r\nfragment scalarSelectionsNotAllowedOnBoolean on Dog: Why Boolean? barkVolume is an Int. Also the intent is to convey that no further selections are allowed on primitives.\r\n\r\n@MSleepyPanda Good catch \ud83d\udc4d \r\n\r\n> I'd propose changing the name to scalarSelectionsNotAllowed. I'd expand the example by enumSelectionsNotAllowed.\r\n\r\nMakes total sense to me, but I suggest keeping `onInt` part to prevent possible confusion. @MSleepyPanda This and #451 both look good \ud83d\udc4d \r\nNext step is the review by  @leebyron\r\n\r\nIf you find any other places where clarification needed to feel free to open PR or create an issue.  For motivation, see discussion in https://github.com/facebook/graphql/issues/450 To achieve full consistency I would also change:\r\n> {typeA} and {typeB} must both be Non-Null.\r\n\r\nto\r\n\r\n> If {typeA} or {typeB}  is not a Non-Null, return false.\r\n\r\nSame here:\r\n> {typeA} and {typeB} must both be List.\r\n\r\n Addressed review!  In the section 3.6.1 Field Arguments: http://facebook.github.io/graphql/draft/#sec-Field-Arguments\r\n\r\n>Object fields are conceptually functions which yield values. Occasionally object fields can accept arguments to further specify the return value. Object field arguments are defined as a list of all possible argument names and their expected input types.\r\n\r\n>All arguments defined within a field must not have a name which begins with \"__\" (two underscores), as this is used exclusively by GraphQL\u2019s introspection system.\r\n\r\n>For example, a Person type with a picture field could accept an argument to determine what size of an image to return.\r\n\r\nIt misses to mention that if a `Type` is a `NamedType` it can only refer to the name of an input object type. > It misses to mention that if a Type is a NamedType it can only refer to the name of an input object type.\r\n\r\n@tinganho Actually no, also you can use scalars both standard (String, Int, ...) and custom. That's why specification uses `input type` term for everything that can be used as an argument:\r\n\r\n> list of all possible argument names and their expected input types. OK, I might put too much restriction. But all types except Object types?\r\nhttp://facebook.github.io/graphql/draft/#sec-Objects\r\n\r\nBut if this sentence is clear enough, then I'm fine to close:\r\n>list of all possible argument names and their expected input types. > OK, I might put too much restriction. But all types except Object types?\r\n\r\nExcept for Object types, interfaces and unions and the same types wrapped in `List` and `NonNull`.\r\nThat's why `input type` term consistently used in specification text.\r\n\r\n> But if this sentence is clear enough, then I'm fine to close:\r\n\r\nI think `input type` sounds very similar to `input object` but I can't think of a better alternative.  I'm wondering if there is any plans to add an alternative binary protocol to GraphQL? I think it is good if it is optional and if one can just opt-in to it.\r\n\r\nAn example:\r\n\r\nWe manually byte encode all fields:\r\n\r\n```graphql\r\ntype RootQuery {\r\n  starship = 0\r\n}\r\n\r\ntype Starship {\r\n  id: ID! = 0\r\n  name: String! = 1\r\n  length(unit: LengthUnit = METER): Float = 2\r\n}\r\n```\r\nInstead of sending this query:\r\n```graphql\r\nquery {\r\n   startship {\r\n      id\r\n      name\r\n      length\r\n   }\r\n}\r\n```\r\nWe send this compact one instead:\r\n```graphql\r\n0 { # query\r\n   0 { # starhsip\r\n      0 # id\r\n      1 # name\r\n      2 # length\r\n   }\r\n}\r\n```\r\nAnd instead of receiving JSON\r\n```json\r\n{\r\n  \"data\" : {\r\n    \"starship\": {\r\n      \"id\": \"1\",\r\n      \"name\": \"Albert Einstein\",\r\n      \"length\": \"1\",\r\n    }\r\n  }\r\n}\r\n```\r\nWe receive a byte encoded response:\r\n```graphql\r\n0 { # starship\r\n    0 \"1\" # id\r\n    1 \"Albert Einstein\" # name\r\n    2 \"1\" # length\r\n  }\r\n}\r\n```\r\nThe binary protocol should not replace the textual one. I still think it is good with JSON. Though, I think there is a good use case to have both. I've seen many use-cases where one use gRPC for internal communication(microservice-to-microservice) and GraphQL for external API. And it would be practical if GraphQL just allowed one to use a binary protocol, so devs don't have to use both.  > JSON is preferred, but explicitly not required (http://facebook.github.io/graphql/October2016/#sec-Serialization-Format)\r\n\r\nI doubt there will be any implementation of an alternative to JSON, unless GraphQL supports(blesses) it. Though this is just for the response side. You are still missing the request side?\r\n\r\n> gRPC space that would work well alongside GraphQL\r\n\r\nI'm not sure what you mean here. To enable both, gRPC and GraphQL. You have to define your types(or messages) for both. Which requires a lot of work. GraphQL is just lacking the optimizations that gRPC has, why can't you just add it as an opt-in feature? I think it makes perfect sense, no?  I propose the possibility of serializing composite types (like Object) into scalar values. This functional will be useful in those cases when some object can be represented in a scalar value, but it provides (can) a functional (a set of fields).\r\n\r\nWe can use the name `__toScalar` field as the serializable value name. Double underline at the beginning is compatible with the standard adopted for system names.\r\n\r\nFor example:\r\n\r\n## Definition\r\n\r\n```graphql\r\ntype DateTimeObject {\r\n    year: Int!\r\n    month: Int!\r\n    # ...\r\n    ago: String!\r\n    format(format: String!): String!\r\n    __toScalar: DateTime!\r\n}\r\n```\r\n\r\n## Usage\r\n\r\n### As Object\r\n\r\n```graphql\r\n{\r\n    date {\r\n        year\r\n        month\r\n    }\r\n}\r\n```\r\n\r\n```json\r\n{\r\n    \"date\": {\r\n        \"year\": 2018,\r\n        \"month\": 04\r\n    }\r\n}\r\n```\r\n\r\n### As Scalar\r\n\r\n```graphql\r\n{\r\n    date # __toScalar field usage\r\n}\r\n```\r\n\r\n```json\r\n{\r\n    \"date\": \"2018-04-28T04:53:23+03:00\"\r\n}\r\n```  Right now there are only two directives in core: `@include` which ignores fields if true, and its exact opposite... `@skip`. But `@skip` is poorly named because it's not the parallel opposite word. It should really be named `@exclude` to make the API more consistent and intuitive.\r\n\r\nI realize this isn't giving us new functionality, and it's one of many small things, but it would just be nice from a design and consistency standpoint.  :+1: I also got the same feeling after working with other extensions for a while.\r\n\r\nOn a side note (but I think it is a bit related), I wanted to ask about another limitation that was added at some point:\r\n\r\n[[RFC] Add Validation rule for unique directives per location.](https://github.com/facebook/graphql/pull/229)\r\n\r\nFrom the moment this validation was introduced, I felt that it was quite limiting. Considering that now there is a good support for splitting the schema across multiple files, I think that it might be a good idea to reassess this validation. \r\n\r\nDo you think it makes sense to reconsider it? (I personally would vote in favor of removing it or, at least, limiting the validation to a subset of directives)\r\n\r\nJust to give a small example where it might be helpful. Considering the schema delegation case where multiple GraphQL schemas are merged into one. I can define the config like this:\r\n\r\nhttps://github.com/OlegIlyenko/graphql-gateway/blob/master/testSchema.graphql#L6-L16\r\n\r\nWith the new extension I can potentially split the schema in 2 files:\r\n\r\n```graphql\r\n# file 1\r\nschema\r\n  @includeGraphQL(\r\n    name: \"starWars\", \r\n    url: \"http://try.sangria-graphql.org/graphql\") {\r\n  query: Query\r\n}\r\n\r\n# file 2\r\nextend schema\r\n  @includeGraphQL(\r\n    name: \"universe\", \r\n    url: \"https://www.universe.com/graphql/beta\")\r\n```\r\n\r\nBut even if directives are not split across different extensions, I would still find it helpful to be able to use the same directive multiple times (with different arguments) at the same location. Sure thing, I'll create a new issue :+1:  I created a separate issue for this:\r\n\r\n[Limiting the scope of \"Directives Are Unique Per Location\" validation](https://github.com/facebook/graphql/issues/429)  Similarly to JS's shorthand object props/destructuring, I'd like to propose to write queries either like:\r\n\r\n```graphql\r\n{\r\n  posts($q, $limit) {\r\n    id\r\n    content\r\n  }\r\n}\r\n```\r\nor more simply:\r\n```graphql\r\n{\r\n  posts(q, limit) {\r\n    id\r\n    content\r\n  }\r\n}\r\n```\r\ninstead of the current\r\n```graphql\r\n{\r\n  posts(q: $q, limit: $limit) {\r\n    id\r\n    content\r\n  }\r\n}\r\n```\r\n\r\nThey require to fit the models arguments and have corresponding variables:\r\n```json\r\n{\r\n  \"q\": \"Foo bar ...\",\r\n  \"limit\": 10\r\n}\r\n``` Also I find it really verbose to do \r\n```graphql\r\nquery Foo($id: ID!) {\r\n  foo(id: $id) {\r\n    name\r\n    description\r\n  }\r\n}\r\n```\r\nthe shorthand argument wouldn't simplify it much, that's slightly better:\r\n```graphql\r\nquery Foo($id: ID!) {\r\n  foo($id) {\r\n    name\r\n    description\r\n  }\r\n}\r\n```\r\nMy problem is with the query (or mutation, or subscription) wrapper. I understand it's good to put the type constraint for a variable only once, I can't see a better way though  When we have a big API, with several functions. We have a gigantic documentation of Schema with queries, mutations and subscriptions. So, this gets complicated and confusing with time because of the order of things.\r\n\r\nA separator in sessions besides the own comments with something like \"Accordion\"  would be perfect.\r\n\r\n\r\nCheers. I wrote here because I thought it was your team who supported \"GraphiQL\". To have something like \"Accordion\" would need to create something in the graphql syntax to get such a feature. I'm wrong? @MichelDiz try posting an issue on the [GraphiQL repo](https://github.com/graphql/graphiql), this repo is for the GraphQL spec, GraphiQL (with the \"I\")  is the IDE. I know that, I think you didn't understand my point. The IDE will be irrelevant if there is no specification in the GraphQL syntax. Did you get it? \r\n\r\nPS: You would need to specify in Schema where and when to do \"Accordion\". IDE react to Schema...  Matches graphql-js PR: https://github.com/graphql/graphql-js/pull/1280\r\nFor background, see https://github.com/graphql/graphql-js/issues/1277 I think we should change the spec and revert this changes: there is no reason a schema should be required to have objects implementing each interface. A very common pattern is to create an interface first, start programming against that, then weeks later actually implement that interface. This is also a really nasty breaking change for large, existing schemas.  ![image](https://user-images.githubusercontent.com/8336157/37162258-7735a65c-22fd-11e8-9bec-65e2056f87cf.png)\r\nhttp://facebook.github.io/graphql/draft/#example-a4647   Thanks, I missed it in #407 \ud83d\udc4d\r\nCan you please sign CLA? Done  Subscription allows client to get messages when they appear, but in case of failures client do not have the option to ack / nack (to skip) messages. \r\n\r\nThis allows the replay of messages \r\nBetter transaction handling\r\n\r\nSimply Put : Exposing kakfa via graphql schema Exposing kakfa via graphql schema\n\nOn Mar 6, 2018 4:38 AM, \"Senthil Sivanath\" <notifications@github.com> wrote:\n\n> Subscription allows client to get messages when they appear, but in case\n> of failures client do not have the option to ack / nack (to skip) messages.\n>\n> This allows the replay of messages\n> Better transaction handling\n>\n> Simply Put : Exposing kakfa via graphql schema\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/facebook/graphql/issues/419>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AMjXZN2jTyzRpiZ1Wd0Be3I__OjLtn4Nks5tblkDgaJpZM4SeYh3>\n> .\n>\n  (Rendering Preview: https://out-nmocjoypvp.now.sh)\r\n\r\nThis is a *NON-BREAKING* **validation change** which allows some previously invalid queries. It is also a behavioral **execution change** which changes how values interact with variable and argument default values.\r\n\r\nThere is currently ambiguity and inconsistency in how `null` values are coerced and resolved as part of variable values, default values, and argument values. This inconsistency and ambiguity can allow for `null` values to appear at non-null arguments, which might result in unforseen null-pointer-errors.\r\n\r\nThe version of this proposal to be merged includes the following:\r\n\r\n* *NEW*: Non-null arguments and input object fields are no longer required to be provided a value/variable if that argument also supplies a default value.\r\n* *NEW*: Similarly, non-null input object fields can be omitted if they supply a default value. (Note that previously this validation clause was missing from the spec, however has long been included in reference implementations)\r\n* *NEW*: All variables can now have default values by way of removing a validation rule. Previously it was invalid to supply a default value with a non-null variable.\r\n* *BUG FIX*: Variables with a nullable type and a `null` default value cannot be provided to a non-null argument or input field.\r\n* *NEW*: Optional (nullable) variables can now be used for arguments or input object fields which supply default values.\r\n* *CLARITY*: Redefine `CoerceVariableValues()` to make it more clear how to treat a lack of runtime value vs the explicit value `null` with respect to default values and type coercion.\r\n* *NEW*: Redefine `CoerceArgumentValues()` to ensure providing a `null` variable value to a Non-Null argument type causes a field error, and to add clarity to how `null` values and default values should be treated.\r\n* *NEW*: Redefine Input object coercion rules to ensure providing a `null` value or runtime variable value to a non-null type causes a field error, and improve clarity for these coercion rules. This mirrors the changes to `CoerceArgumentValues()`.\r\n\r\n---\r\n\r\nPrevious version of this proposal:\r\n\r\n<strike>\r\n\r\nThis appears in three distinct but related issues:\r\n\r\n**Validation: All Variable Usages are Allowed**\r\n\r\nThe explicit value `null` may be used as a default value for a variable with a nullable type, however this rule asks to treat a variable's type as non-null if it has a default value. Instead this rule should specifically only treat the variable's type as non-null if the default value is not `null`.\r\n\r\nAdditionally, the `AreTypesCompatible` algorithm is underspecificied, which could lead to further misinterpretation of this validation rule.\r\n\r\n**Coercing Variable Values**\r\n\r\n`CoerceVariableValues()` allows the explicit `null` value to be used instead of a default value. This can result in a null value flowing to a non-null argument due to the validation rule mentioned above. Instead a default value must be used even when an explicit `null` value is provided. This is also more consistent with the explanation for validation rule \"Variable Default Value Is Allowed\"\r\n\r\nAlso, how to treat an explicit `null` value is currently underspecified. While an input object explains that a `null` value should result in an explicit `null` value at the input object field, there is no similar explaination for typical scalar input types. Instead, `CoerceVariableValues()` should explicitly handle the `null` value to make it clear a `null` is the resulting value in the `coercedValues` Map.\r\n\r\n**Coercing Argument Values**\r\n\r\nThe `CoerceArgumentValues()` algorithm is intentionally similar to `CoerceVariableValues()` and suffers from the same inconsistency. Explicit `null` values should not take precedence over default values, and should also be explicitly handled rather than left to underspecified input scalar coercion. Since this changes behavior, I'd love your feedback @IvanGoncharov, @OlegIlyenko, et al cc @bbakerman @leebyron I fully agree with the changes from `Validation: All Variable Usages are Allowed` \ud83d\udc4d\r\n\r\n> Coercing Variable Values\r\n> Coercing Argument Values\r\n\r\n> Explicit null values should not take precedence over default values.\r\n\r\nThis is very confusing at the first glance, especially for argument values. Here is the example from JS:\r\n```js\r\nfunction f(arg = 'foo') {\r\n  return arg;\r\n}\r\n\r\nf()      // 'foo'\r\nf(null)  // null\r\nf('bar') // 'bar'\r\n```\r\nAnd same in Python and probably all other langs so I would expect the same from GraphQL.\r\nBut I fully understand technical challenge here so I need to think more about it. Absolutely correct, @IvanGoncharov. There are two paths forward to solve for the ambiguity, each of which have some tradeoffs.\r\n\r\nThe path I'm proposing here preserves the ability to treat `$var: String = \"default\"` as non-nullable and usable in an argument expecting `String!`. The tradeoff is that a default value would take precedence over an explicit `null` value.\r\n\r\nThe alternative is to *no longer* treat `$var: String = \"default\"` as non-nullable while preserving explicit `null` over default values. This would mean queries which pass variables with default values to arguments expecting non-null types would no longer be valid.\r\n\r\nMy concern is that the change cost of this alternative is too high since passing a variable with a default value to a non-null argument is an existing pattern. However I'm less certain how common overriding a default value with an explicit `null` value is, though I certainly understand the incongruity with existing programming languages. I haven't found an example of it within queries at Facebook yet, so I would love to hear use cases to better understand change cost.\r\n\r\n It's an interesting change. I remember the time when I finally correctly implemented the support for the `null` in sangria. As far as I remember, my initial implementation was doing the same as was suggested in this PR: \"Explicit null values should not take precedence over default values.\". Later on I refactored it in order to comply with the reference implementation.\r\n\r\nAlong the way, I also faced these issues where null value can potentially appear in nullable the argument with a default value (which might be treated as not-null since it has a default). As a solution to this problem I introduced following 2 things:\r\n\r\n* I delay the value resolution to the last moment. This led to the introduction of a new [`Trinary`](https://github.com/sangria-graphql/sangria/blob/cb92d9b510690609de4f8fd65e9a4bfa1712dc93/src/main/scala/sangria/execution/ValueCoercionHelper.scala#L478-L494) container which able to preserve information about the default value (`NullWithDefault`).\r\n* By default nullable arguments with a default value are treated as non-null on a type level. But since I have a `Trinary` value around I can force the usage of a default value which might come from the variable definition (this one has precedence over other default values) or argument/input field default. I also provide an extra function to get a nullable variation of the value (`Option[Value]`) - this one behaves in the same way as reference implementation at the moment. \r\n\r\nI find this solution quite robust - by default, it behaves similarly to the proposal in this PR, but it also provides a way to propagate explicit `null` value (and ignore all of the defaults) when this information is significant.\r\n\r\nThough it is still possible to trick the system by setting the default value to `null`, like here:\r\n\r\n```graphql\r\ntype Query {\r\n  article(id: ID = null): Atricle\r\n}\r\n```\r\n\r\nDo you think it would make sense to disallow this? (for arguments, input fields, and variables)\r\n\r\nI personally don't have practical insights on API that takes advantage of the `null` value. I know that some people use it to explicitly \"unset\" fields in the database.  But in this scenario, I don't really see the need for a default value. So it's hard for me to assess the impact of this change, but I find the use case quite niche. @leebyron It's not an ideal solution since we are trying to fix validation issue by changing execution behavior. Ideally, we would allow defaults to be specified on nonull arguments:\r\n```graphql\r\nquery foo($arg: String! = \"foo\")\r\n\r\n{} => $arg === \"foo\"\r\n{ arg: null } => Exception\r\n\r\nquery bar($arg: String = \"bar\")\r\n\r\n{} => $arg === \"bar\"\r\n{ arg: null } => $arg === null\r\n```\r\nBut it's not a viable alternative since it will break huge number of existing queries \ud83d\ude22 \r\n\r\nSo practically speaking if there is no GraphQL APIs that distinguish between `null` and default value in field arguments then I don't see a point to fight for theoretical purity. \r\n\r\nThat said I think it's very important question so we need to be extremely careful and do some research beyond the Facebook use case.\r\nI volunteer to do research on a major public APIs(Shopify, Yelp, ...).\r\n\r\nGitHub was my first victim and tried to pass nulls in every field with a default argument. A few of them treat `null` the same way as absent value but in one case it actually broke query:\r\n![image](https://user-images.githubusercontent.com/8336157/37235185-600343e6-2405-11e8-8f36-5b1a4920744d.png)\r\nMoreover, in GitHub schema `repository` defined as nullable so absence of this field inside `data` suggests that it wasn't simple exception inside resolver. IIUC this is ~ the same issue as https://github.com/facebook/graphql/issues/359.\r\n\r\nI also find the \"explicit nulls don't take precedence over defaults\" confusing. Per the issue I originally filed, I think this can be solved by by allowing non-null variables/arguments/input-fields to have default values. This is I think what you mean by\r\n> The alternative is to no longer treat $var: String = \"default\" as non-nullable while preserving explicit null over default values. This would mean queries which pass variables with default values to arguments expecting non-null types would no longer be valid.\r\n\r\nThe change cost of that approach is real, but the migration is fairly trivial and I think important: anywhere that this ambiguity currently occurs the author is forced to resolve it by adding a `!` to the variable to make it clear that explicit nulls are forbidden. If they did intend to support nulls for that variable then their query is invalid no matter what and that's something they should be aware of. Excellent feedback everyone. I've made serious revisions which I hope both protect against allowing null values to non-null arguments while preserving existing behavior. The result is a bit broader in scope, however no longer breaks existing queries in either validation or execution.\r\n\r\nThe reference PR has also been updated in graphql/graphql-js#1274\r\n\r\nThis update better defines the difference between a \"required\" and \"non-null\" argument / input-field as a \"non-null\" type which includes a default value is no longer required. As such the validation rule which prohibited queries from using non-null variables and default values has been removed completely. This change also adds clarity to the input field validation - this rule has existed in the GraphQL.js reference implementation however was found missing within the spec. It essentially mirrors the change of the required argument rule.\r\n\r\nThis also updates the `CoerceVariableValues()` and `CoerceArgumentValues()` algorithms to retain the behavior of explicit null values overriding a default value (minimizing breaking changes), however critically adding additional protection to `CoerceArgumentValues()` to explicitly block null variable values from passing into a non-null argument. This retains the existing common pattern of passing a nullable variable with a default value into a non-null argument while removing the problematic case of an explicit null value at runtime.\r\n\r\nI'd love another look at this and the accompanying PR. I feel confident in this approach but would appreciate your feedback. I'm a bit torn - on the one hand I think this approach is probably the best we can do in terms of a clarification that is strictly non-breaking. On the other hand I'm not sure that strictly non-breaking is something we should be striving for in this case:\r\n- The last published spec is still marked as a draft, with no implicit or explicit compatibility guarantees.\r\n- Even Golang (whose [explicit compatibility guarantee](https://golang.org/doc/go1compat) is one I use as a good model) reserves the right to clarify undefined or inconsistent behaviour in a way that may break programs.\r\n- The \"from-scratch\" design (if we weren't concerned about compatibility at all) is I think fairly uncontroversially to decouple default values from the nullability of arguments entirely. For anyone new to the spec, that behaviour seems the least surprising, and much simpler than the behaviour proposed here.\r\n\r\nI realize that putting a breaking change like that in the spec causes its own huge set of pains for implementations that have to migrate, but I guess I'm not convinced that isn't still the best long-term solution.\r\n\r\nAll that said, I do believe this current approach is the best we can do while being non-breaking, so if that's the way that we want to go then I won't object further. > Change the \"Variable Usages are Allowed\" rule tweaking the rules for treating nullable variables as non-null for the sake of determining where they're allowed to be used. This is not what I would do in a from-scratch design. Instead I would propose removing the ability for nullable variables to flow into non-null arguments at all.\r\n\r\nYup, this is the one that is bugging me :)\r\n\r\n> I will look at editing this to both make it more clear where the caveat for existing systems is while making it possible (or even encouraged) for new systems not to adopt that caveat.\r\n\r\nAwesome. I was going to suggest that we include an RFC 2119 header in the spec so we can use SHOULD/MAY appropriately here, but I note that you already did that, it just hasn't made it into http://facebook.github.io/graphql/ yet. I think that servers `SHOULD` prevent nullable variables from flowing into non-null arguments, but they `MAY` permit it in accordance with old versions of the spec in order to maintain compatibility. Thoughts?\r\n\r\n> are there other differences from the current state of this PR that you would consider approaching differently in a from-scratch design?\r\n\r\nI'll go through again but I think that was the only one. > However, I don't think we should be terribly concerned with a bifurcation of tooling.\r\n\r\nI agree with @mike-marcacci I think most of the tooling doesn't need to be backward compatible. There is only one scenario we shouldn't break: existing queries compiled inside clients that were deployed in production should be still supported by GraphQL server.\r\n \r\nThat means that all client libraries, ESlint plugin, client code generation, GraphiQL and other libraries/tools that are used only in development or during build process can be easily updated.\r\n\r\nThe only part of the ecosystem that should be backward compatible are GraphQL servers and maybe some proxy servers (e.g. Apollo Engine).\r\n\r\nThat's why I think both specification and `graphql-js` should use \"from-scratch\" behavior by default. Compatibility section of the specification can provide an alternative version of `IsVariableUsageAllowed` function and `graphql-js` can have `VariablesInAllowedPositionCompatible` validation rule.\r\n\r\n> Because we're already altering the spec for query validation to expand the definition of validity, we're going to see a mismatch in the wild: some servers won't update their software, while new clients will expect looser queries to work. \r\n\r\nThis is not a problem since if a new client stops working with old servers it would be caught during development. So I think we should distinguish between changes that will break already deployed clients and changes that will result in temporary inconvenience during development.\r\nHowever, I fully agree that breaking changes are unavoidable in the future and we should prepare for them:\r\n\r\n> This is probably unavoidable, and makes me think that there should be a \"graphql version\" or programmatically readable \"feature set\" (as discussed in the WG meeting) supplied in the result of an introspection query.\r\n\r\nI think any mechanism involving introspection query is not a solution since the majority of GraphQL clients doesn't do any handshake; they just send queries to the server. So the only solution I see is for sever to detect what was the expected behavior during client development and fallback to it.\r\nSo I think having some kind of \"graphql version\" delivered together with GraphQL query is the right call.\r\n\r\n> After discussing this in depth with @dschafer at a whiteboard - we've talked ourselves out of any breaking change - I think that having a fork in the expected behavior of validation rules is just too easy to get wrong, liable to cause issues during deployment, and could create a bifurcation of tooling environments. We came up with mitigation strategies for Facebook's codebases and APIs, however also agreed that public APIs like Github would be much much more challenging to solve for.\r\n\r\n@leebyron I want to propose a solution. Currently, all GraphQL clients send GraphQL request document inside `query` field. But `ExecuteRequest` names the same parameter `document`:\r\n```\r\nExecuteRequest(schema, document, operationName, variableValues, initialValue)\r\n```\r\nSo it makes sense to rename this field to `document` inside GraphQL request.\r\nIn addition to that, we can make `version` a required field for all requests that use `document`. And both specification and reference implementation should provide the algorithm for converting request documents to a new version.\r\n\r\nSo a server can implement the following algorithm:\r\n* Request contains `document`:\r\n  * if the request also contains `query`, return a fatal error\r\n  * if the request doesn't contain `version`, return a fatal error\r\n  * use `version` from the request\r\n* Request contains `query` then assume `version` is equal to legacy one(e.g. `0`)\r\n* if `version` is newer than the last version supported by server return `fatal error`.\r\n\r\nPros:\r\n* Don't break any deployed client.\r\n* Add versioning to queries that allow bugfixes similar to this one.\r\n* Allows clear error messages\r\n* Rename `query` to `document` that makes sense on its own and solve a lot of terminology problems.\r\n\r\nCons:\r\n* One additional field in every request.\r\n* New clients stop working with old servers.\r\n\r\nI also think we should use an integer for `version` field and increment it only when breaking change is made. > I think these are interesting ideas, but I'd love to avoid expanding the surface area of this proposal since I believe it is in a final reviewable state.\r\n\r\nAgreed; apologies for nudging the discussion off-topic. To reiterate what I intended to be the core point of my review, the current proposal successfully avoids breaking things that are already deployed while adding very little mess. This ended up a much cleaner solution than initially seemed possible \ud83d\udc4d   I'm looking to create a GraphQL query that selectively adds/removes fields based on a variable \"type\", which is a string:\r\n\r\n`query ResultsPage($casetype: String!)`\r\n\r\nAccording to the reference on Directives, you can use a boolean value to either @include or @skip certain fields:\r\n\r\n```\r\nquery Hero($episode: Episode, $withFriends: Boolean!) {\r\n  hero(episode: $episode) {\r\n    name\r\n    friends @include(if: $withFriends) {\r\n      name\r\n    }\r\n  }\r\n}\r\n\r\n```\r\nHow could I do something similar with this string value? i.e. only include the friends field if $casetype = \"foo\". What is the best way to approach this problem using GraphQL?\r\n\r\nThanks! @romeboards GraphQL is designed to be as simple as possible so it doesn't support constructions from programming languages, e.g. comparations.\r\nSo you can include/exclude fields only based on the boolean query parameters.\r\nBut as I understand, you want to change query result based value of enum which is not possible according to GraphQL spec.\r\n\r\nSo can you please describe your use case in more details?\r\nMainly, how is your schema looks like and why your frontend needs different responses?\r\n\r\n  GraphQL is very powerful for query, but is weak for mutation in my opinion. Second, GraphQL is based on resolvers, there is no resources concept which makes create, update and destroy actions complex.\r\n\r\nFor example, there is `User` type, we can CRUD it like RESETful API\r\n```graphql\r\nquery {\r\n  allUsers: [User]\r\n  user(id: ID): User\r\n}\r\n\r\nmutation {\r\n  createUser(input: UserInput): User\r\n  updateUser(id: ID, input: UserInput): User\r\n  destroyUser(id: ID): User\r\n}\r\n```\r\nIf we have 5 or more types like `User`, GraphQL schema will become hard to manage.\r\n\r\nMy proposal is add `class`, things will like\r\n```graphql\r\nclass User {\r\n  init(id: ID)\r\n  mutate init(params: User.Lets)\r\n  static all: [User]\r\n  var name: String\r\n  let username: String\r\n  followingCount: Int\r\n  createdAt: Date\r\n  mutate update!(params: User.Vars): Boolean\r\n  mutate destroy(): Boolean\r\n  mutate follow(userID: ID): Boolean\r\n  articles(state: ArticleState): [Article]\r\n}\r\n```\r\nAnd you can use it like\r\n```graphql\r\nquery($createParams: User.Lets, $userID: ID, $updateParams: User.Vars, $followUserID: ID) {\r\n  User.all { # Get list\r\n    id\r\n    name\r\n  }\r\n  User(params: $createParams) { # Create\r\n    id\r\n    name\r\n  }\r\n  User(id: $userID) {  # Read\r\n    update!(params: $updateParams) # Update\r\n    name\r\n    username\r\n    follow(userID: $followUserID)\r\n    followingCount\r\n  }\r\n  User(id: $userID) {\r\n    destroy # Destroy\r\n  }\r\n}\r\n```\r\n\r\nField types are\r\n* `var`: e.g. `var name: String`\r\n* `let`: e.g. `let username: String`\r\n* `default`: e.g. `followCount: Int`\r\n* `mutate`: e.g. `mutate update!(params: User.Vars)`\r\n\r\nFor `var` and `let`, it will automatically generate inputs `User.Vars` and `User.Lets`.\r\n```graphql\r\ninput User.Vars {\r\n  name: String\r\n}\r\ninput User.Lets {\r\n  name: String\r\n  username: String\r\n}\r\n```\r\n`User.Vars` only includes `var` fields and `User.Lets` includes `var` and `let` fields.\r\n\r\nFor `mutate`, it means the query is a mutation.\r\nFor `default`, it just normal fields.\r\n\r\nThe reason we have `var` and `let` is that `let` fields should only be used on creating and `var` can be used on creating and updating.\r\n\r\nLet's take a closer look at\r\n```graphql\r\n  User(id: $userID) {\r\n    update!(params: $updateParams)\r\n    name\r\n    username\r\n    follow(userID: $followUserID)\r\n    followingCount\r\n  }\r\n```\r\nThis query has two mutations `update` and `follow`. Although `follow` is below `username`, GraphQL will still execute all mutations serially first and then resolve other fields e.g `name`, `username` and `followingCount` parallelly.\r\n\r\nWhat does `!` mean?\r\nIt means the resolvers will return both parent and result, and returning parent will replace the original one.\r\n```js\r\nconst userType = {\r\n  update: (parent, args, ctx) => {\r\n    // ...\r\n    return { parent: obj, result: result }\r\n  }\r\n}\r\n```\r\n  Wait, sorry -- `subscription` can only take one root field per request document? > Wait, sorry -- subscription can only take one root field per request document?\r\n\r\nThat's correct. Is that a limitation that will cause problems for you? @robzhu & @leebyron I see. I haven't yet started implementing subscriptions. We're looking to potentially migrate to them to implement what's essentially a live query (hence my discussions on other tickets) from an existing system that uses an ad hoc Web Socket protocol. But since this is still in the early stages, I can't say for sure whether this is an issue. It's probably fine. It seems like the issue could be skirted by having a field represent a whole bunch of different events and return a union of event payloads.\r\n\r\nI was just surprised, since Sangria's [pre-spec subscription implementation](http://sangria-graphql.org/learn/#stream-based-subscriptions) doesn't have this restriction, so just wanted to make sure I understood. It seems like they solve the problem by largely treating the document as independent subscriptions, and the event stream simply only contain one of the root fields per payload.  For now, GraphQL lets developers decide errors' format, which makes developer bewildered.\r\nFor example,\r\n```graphql\r\ntype Mutation {\r\n  register(input: RegisterInput!): User!\r\n  verifyPhone(pin: String!): Phone!\r\n}\r\n```\r\n`register` may have errors like email format is wrong, email already used, password is too easy. So its error is like\r\n```json\r\n{\r\n  \"errors\": [\r\n    {\r\n      \"message\": \"Email not found\",\r\n      \"fields\": [\r\n        { \"field\": \"Email\", \"message\": \"Email format is wrong\" },\r\n        { \"field\": \"Password\", \"message\": \"Password is too easy\" },\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n`verifyPhone` may have two types of error\r\n```json\r\n{\r\n  \"errors\": [\r\n    { \"message\": \"Pin is wrong\", \"type\": \"wrong\" }\r\n  ]\r\n}\r\n```\r\nor \r\n```json\r\n{\r\n  \"errors\": [\r\n    { \"message\": \"Pin is expired\", \"type\": \"expired\" }\r\n  ]\r\n}\r\n```\r\nThese errors are so different, so I can't just use the same formatting implementation of `formatError`.\r\n\r\nOne way to solve it is\r\n```graphql\r\ntype RegisterValidateError {\r\n  message: String\r\n  fields: [ValidationField]\r\n}\r\ntype RegisterPayload {\r\n  user: User\r\n  error: RegisterValidateError\r\n}\r\nenum VerifyPhoneErrorType {\r\n  wrong\r\n  expired\r\n}\r\ntype VerifyPhoneError {\r\n  message: String\r\n  type: VerifyPhoneErrorType\r\n}\r\ntype VerifyPhonePayload {\r\n  phone: Phone\r\n  error: VerifyPhoneError\r\n}\r\ntype Mutation {\r\n  register(input: RegisterInput!): RegisterPayload!\r\n  verifyPhone(pin: String!): VerifyPhonePayload!\r\n}\r\n```\r\n\r\nBut I think it'll be good if GraphQL supports native typed errors and add `throws` keyword to hint clients which errors might throw in the query.\r\nSo it'll be like the following\r\n```graphql\r\nerror RegisterValidateError {\r\n  message: String\r\n  fields: [ValidationField]\r\n}\r\nenum VerifyPhoneErrorType {\r\n  wrong\r\n  expired\r\n}\r\nerror VerifyPhoneError {\r\n  message: String\r\n  type: VerifyPhoneErrorType\r\n}\r\n\r\ntype Mutation {\r\n  register(input: RegisterInput!): User! throws RegisterValidateError, RegisterTooManyTimesError\r\n  verifyPhone(pin: String!): Phone! throws VerifyPhoneError\r\n}\r\n```\r\nAnd the response's errors have the type\r\n```json\r\n{\r\n  \"errors\": [\r\n    {\r\n      \"type\": \"RegisterValidateError\",\r\n      \"message\": \"Email not found\",\r\n      \"fields\": [ ... ]\r\n    }\r\n  ]\r\n}\r\n``` Is there any update here?  The idea is similar to how you can prepare variables in relay before using them.\r\nSo, the proposal is to add a layer before using the arguments in the resolve field.\r\n\r\nExample in javascript:\r\n```\r\nexport const userMutation = {\r\n  type: userType,\r\n  args: {\r\n    id: {\r\n      type: GraphQLID,\r\n      prepare: (arg) => {\r\n        return arg + 1;\r\n      },\r\n    },\r\n  },\r\n  resolve: (obj, args) => {\r\n    // here args.id is incremented by 1\r\n  },\r\n};\r\n```\r\nThis could be useful when IDs are in base64, so that it's easier to use e.g. `fromGlobalId` with relay.\r\n\r\nAnother use case is for pagination. So I set up a basic \"connection type\" with `limit` and `offset` argument. Then to see if there's a next page, I query for `limit + 1` in my db. Instead of incrementing in my resolve, it would be much easier to do this:\r\n```\r\nargs: {\r\n  limit: {\r\n    type: GraphQLInt,\r\n    prepare: (arg) => {\r\n      return arg + 1;\r\n    },\r\n  },\r\n},\r\nresolve: (obj, args) => {\r\n  // args.limit is incremented by 1\r\n}\r\n```\r\nas I reuse the connection type.\r\nThough, maybe I'm just missing something or just using GraphQL wrong?\r\nWould love to know if someone else has this issue.\r\n\r\nEdit: Btw, am I posting this in the wrong repo? Maybe this should be in the graphql-js repo rather than this one?  I noticed that all the errors mentioned in the specification could be divided into the following categories:\r\n- syntax error\r\n- validation error\r\n- query error\r\n- field error\r\n\r\nI reviewed existing `error` mentions in the spec text and clarified their type.\r\nIn future, it would be great to add separate `Errors types` section to list all possible error types and describe them. I think to start, we could just group into:\r\n\r\n1. Syntax\r\n2. Validation\r\n3. Execution\r\n\r\nIn your text you separate \"query\" from \"field\", but it seems like a lot of the examples are actually validation errors, right? Hmm - I'm a bit worried about further overloading the word \"query\" - it's already hard to tell the difference between documents, operations, query operations, etc. > In that sense there are really 2 behaviorally different errors - those that result in no data key, and those that are local to one field in the response.\r\n\r\n@stubailo @leebyron  I think it very important to make it more explicit in the spec. For example, I was very surprised to find out that error during coercion of query variables is \"fatal\" error.\r\n\r\nSo I think error names should describe the expected result of errors instead of a place where they were originated.\r\nWhat do you think about using `partial error` and `fatal error`?  Currently, the spec requires `data` to be the first field in a response.\r\nBut after [my PR](https://github.com/graphql/graphql-js/pull/838) was merged into `graphql-js`, `errors` always precede `data`:\r\n![image](https://user-images.githubusercontent.com/8336157/33083372-e26a2dea-cee7-11e7-9361-a1b4a2686665.png)\r\n\r\nI still think that having `errors` as the first property is a big DX improvement so I updated the spec to reflect the change in `graphql-js`. Why should the order matter? I like having `errors` first, but it seems arbitrary. And what of JSON libraries that leave order undefined? I've always found the ordering requirements odd.\r\n\r\nAt most, the specification can put a *should* on them, because JSON encoders are free to do whatever they want. If the internal representation of a JSON dict is a large hash table, then the rendering order is going to be arbitrary. Furthermore, some languages (Go is one example) randomizes the order in which you visit a hash table in order to make it explicit to the programmer that they cannot rely on the ordering.\r\n\r\nIn short, requiring order here is rather brittle and is bound to create problems down the line.  @acjay @jlouis GraphQL spec only recommends order of properties, for more details see \r\nhttps://github.com/facebook/graphql/commit/b22c73c875807e0cbb2c1d51804311e42cba0a36\r\n\r\nThis PR just makes `graphql-js` (reference implementation) in line with spec recommendation :) I think order requirements in the spec are for parsers which rely on the order to more efficiently parse the result. IMO that makes errors at the front even more valuable, since it is super useful to know about errors first in the case of a huge result. If it's framed as a recommendation it shouldn't be an issue since things are still valid GraphQL even if they return data first. > If it's framed as a recommendation it shouldn't be an issue since things are still valid GraphQL even if they return data first.\r\n\r\nYou right. But I think the spec should recommend only best practices and error first approach provide better UX. Moreover spec recommendation should be implemented at least in the reference implementation. Yep, I just think there's a big difference between \"recommend\" vs. \"require\" in a spec! I totally agree errors first is the best approach. @leebyron Great improvment \ud83d\udc4d \r\nHope it will be merged soon.   I've recently run into a use-case where versioning specific resources would be incredibly helpful with my GraphQL API. I have probably only spent ~2 months with GraphQL so I potentially could have missed something where this is concerned. Anyway, let's take the following example and go from there:\r\n\r\n---\r\n\r\n**Post 1.0**\r\n\r\n\"I went to the beach today.\"\r\n\r\n**Post 1.1**\r\n\r\n\"I went to the beach today **and I got really sunburned.**\"\r\n\r\n---\r\n\r\nCurrently, achieving something similar to this is really involved and no solution feels right. It more-or-less just feels like I'm hacking together a temporary solution. I think the use-case for adding versioning capabilities to the spec would eliminate both confusion and complexity. \r\n\r\nI know that GraphQL is versionless but from my understanding, that is both intentional and for the API as a whole. Would something to this extent even be possible? Do you think that this use-case is actually helpful to others? I'm open to discussing this in greater detail. (If something like this exists, can you point me to the right direction? All of my search queries have returned everything about GraphQL as a whole being versionless. I couldn't find anything for my use case.) Here's an implementation of how I think this would look. Also, I may have gotten something wrong here but you get the idea.\r\n\r\n```graphql\r\ntype Post {\r\n  id: ID!\r\n  title: String!\r\n  body: String!\r\n  version: Version! # using the new Type\r\n}\r\n\r\nquery Post($id: id, $version: version) {\r\n  Post(id: $id, filter: { version: $version }) {\r\n    id\r\n    title\r\n    body\r\n  }\r\n}\r\n``` It seems as if these issues are not looked at too often... Is there a better place to hold discussions?  This is the right place, it just takes a bit of time.\r\n\r\nSomething like these would be easily implemented into your Object, rather than a new Versioning Type.\r\nWhy not just put your Post type in an Array ?   I'm unaware of the ability to put a Type into an array. But even if it were possible, that opens the door for a lot of problems. The first I can think of is querying a single Post. I'm not sure how well it would work with Mutations either. Anyway, I do think this feature is completely valid and worth a discussion \ud83d\ude04  I too think this is worth a discussion.\r\n\r\nWhy not put a list of postHistorys in your Post ?\r\n\r\n```graphql\r\ntype Post {\r\n  id: ID!\r\n  title: String!\r\n  postHistory: [PostHistory!]\r\n}\r\n```\r\nand then just query with a Version? see here: https://launchpad.graphql.com/n7nl337n7\r\nmutations will be a bit tricky, and there are surely even better ways to do this.\r\n\r\nI just doesnt feel right to let graphQL handle your business logic of keeping track of data\r\n\r\n\r\n\r\n\r\n\r\n Out of the box, that wouldn't work. I'd have to write a bit of logic to implement that. However, if it were part of the spec, this feature could be written in existing implementations. (Both by the community and by graphql/graphql-js).\r\n\r\nI'm really not sure how the implementation details would look. I've been pondering this since I wrote this issue. > if it were part of the spec, this feature could be written in existing implementations\r\n\r\nYou wouldn't want us _implementors_ to take all the fun now, would you? \ud83d\ude09 \r\n\r\nFor real though, the most successful new features have followed the _reverse_ process. Instead of going into the spec first, then into a real-world application, they _start_ in an application and then become part of the spec. (Subscriptions stand out -- FB built subscriptions _on top_ of the spec first, then opened an RFC to update the spec.)\r\n\r\nSo, if you think this idea is valuable, how about demonstrating its value first, and showing how it may be implemented? With a good demonstration, more of us may be convinced that it's a good addition to GraphQL at the language/runtime level. That sounds like a good plan. I'll go ahead and fork graphql-js to get started. Thanks for the advice \ud83d\ude04   i am using gatsby with graphql and when i try to query using graphiql it is showing this error message \r\n'' ----------------Cannot query field \\\"childMarkdownRemark\\\"------------\"  The proposal come from the needs of a better organization of tools around GraphQL. Many people/companies have to swap the order of the naming of mutations because they want the related mutations to be as close as possible in the tools.\r\n\r\nFor example\r\n\r\n```\r\ncreateOrder\r\nupdateOrder\r\n\r\nvs\r\n\r\norderCreate\r\norderUpdate\r\n```\r\n\r\nAs you can notice the second example seems a little weird to read because it breaks English language, but people need to do this because they want those mutations to be close like I said. In my personal opinion that looks a little bit ugly and I don't like that my GraphQL design is driven by the lack of organization support of the tools.\r\n\r\nThe proposal is to add another introspection (at least for the mutations), where tools can use it for group mutations or whatever they will be using it.\r\n\r\nFrom my point of view, this is strictly use for that propose and no for anything outside that, I wouldn't want people to do any crazy thing with that value.\r\n\r\nSome example code would be like\r\n\r\n```js\r\nvar root = {\r\n  @group('message')\r\n  getMessage: function ({id}) {\r\n     ....\r\n  },\r\n \r\n  @group('message')\r\n  createMessage: function ({input}) {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\nI am using decorator for the sack of a clean example \ud83d\ude07 but I am pretty much there is an alternatives.\r\n\r\nI am not sure how the introspection will look like because I didn't understand how it looks like for mutations but I am expecting something like\r\n\r\n```graphql\r\ntype __Schema {\r\n  types: [__Type!]!\r\n  queryType: __Type!\r\n  mutationType: __Type\r\n  group: String // <- I am guessing?!\r\n  directives: [__Directive!]!\r\n}\r\n```\r\n\r\nI hope we can debate about finding a solution for this problem that is not changing API designs. @yordis IMHO it doesn't make sense to add new fields to introspection each time you need to expose the value of directive. I think this issue is a good example how GraphQL will benefit from exposing directive values through introspection as described in #300  @IvanGoncharov my knowledge in the full spec is limited so now knowing about that it definitely is the right place.\r\n\r\nNow, who should implement that directive? or support rather (I dont quite understand this is the first time I saw it)\r\n\r\nThe use case described come from the use of `graphiql` so should they support that directive?\r\n\r\nSorry for my lack of understanding @yordis No problem. You have very valid use cases in mind \ud83d\udc4d \r\nActually, it's my fault that I didn't provide enough context in my comment.\r\n\r\nProblem is that there many very similar use-cases requiring exposing values of directive, e.g. \r\n* Authorisation: `@role`, `@scope`\r\n* Rate limiting: ` @rateLimit`\r\n* Value constraints: `@min`, `@max`, ...\r\n* ...\r\nSo I think adding special fields for every possible directive is a bad decision in the long run.\r\nThere is an ongoing discussion about the generic mechanism for exposing directive values in #300 and I wanted to use your use case as an argument in this discussion. @IvanGoncharov got you! Thanks a lot for explain me.\r\n\r\nShould I comment in that thread? Probably the `graphiql` contributors should be on this thread and that one so they `could` add what I asked.  ## Introduction\r\n\r\nWhen using GraphQL, I find myself often writing duplicate code in field definition maps (i.e. the field definitions in interface definitions, Object definitions, and Input Object definitions), especially when implementing interfaces. I think that the inclusion of mixins would aid in schematic maintenance by allowing for a reduction in such duplicate code, especially in large schemata. Though a mixin can technically be defined as an interface and be included in a field definition map via a directive without any major changes to the GraphQL grammar itself, I think that a dedicated syntax would aid in readability because mixins are not conceptually identical to interfaces (among other reasons).\r\n\r\nConsider the following example:\r\n\r\nMy company wants to store and serve various metadata on each Object. I could create an interface that describes the schema of this metadata as follows:\r\n\r\n    interface Metadata {\r\n        createdAt: Int!\r\n        createdBy: User!\r\n        updatedAt: Int\r\n        updatedBy: User\r\n        deletedAt: Int\r\n        deletedBy: User\r\n    }\r\n\r\nBut then, I would must verbosely implement the `Metadata` interface in each Object that claims to implement it, and I would be unable to implement other, more relevant interfaces in those Objects. Should I find myself wanting to change one of the field definitions, I'd have to change it in several places throughout the schema.\r\n\r\nA workaround is to implement a new `@mixin(name: \"InterfaceName\")` directive which would be used in place of the field definitions in the implementing Objects. This would allow for the reduction of duplicate code as the following snippet demonstrates:\r\n\r\n    type Entity1 {\r\n        id: ID!\r\n        name: String!\r\n        @mixin(name: \"Metadata\")\r\n    }\r\n\r\nHowever, the aforementioned technique is inconsistent with the current GraphQL grammar, because it wouldn't convey that mixins are conceptually very similar to fragments, which already have a dedicated syntax.\r\n\r\n## Proposal\r\n\r\nTherefore, I propose the following new syntax:\r\n\r\n### Mixin Definition\r\n\r\n    mixin Metadata {\r\n        createdAt: Int!\r\n        createdBy: User!\r\n        updatedAt: Int\r\n        updatedBy: User\r\n        deletedAt: Int\r\n        deletedBy: User\r\n    }\r\n\r\nThis mixin definition syntax is straightforward, self-explanatory, and very readable.\r\n\r\n### Mixin Inclusion\r\n\r\n    type Entity {\r\n        id: ID!\r\n        name: String!\r\n        ...Metadata\r\n    }\r\n\r\nThis mixin spread syntax borrows the spread operator from the fragment spread syntax because it's readable, it's familiar, and it's analogous to fragment spreads. Because fragment spreads are invalid in field definition maps, and mixin spreads are invalid in selection sets, this syntax won't introduce any conflicts in the grammar.\r\n\r\n## Implications\r\n\r\nI believe that these proposed changes to the GraphQL grammar will be relatively easy to implement, will allow more concise code, and will provide a better development experience. I'll close by demonstrating the utility of these proposed changes via the following example schema:\r\n\r\n    mixin Timestamps {\r\n        createdAt: Int!\r\n        updatedAt: Int\r\n        deletedAt: Int\r\n    }\r\n\r\n    mixin Mutators {\r\n        createdBy: User!\r\n        updatedBy: User\r\n        deletedBy: User\r\n    }\r\n\r\n    mixin Metadata {\r\n        ...Timestamps\r\n        ...Mutators\r\n    }\r\n\r\n    mixin Sluggable {\r\n        slug: String!\r\n    }\r\n\r\n    interface Submission {\r\n        id: ID!\r\n        body: String!\r\n        ...Metadata\r\n    }\r\n\r\n    type User {\r\n        id: ID!\r\n        username: String!\r\n        ...Timestamps\r\n    }\r\n\r\n    type Post implements Submission {\r\n        id: ID!\r\n        title: String!\r\n        body: String!\r\n        ...Sluggable\r\n        tags: [Tag!]\r\n        ...Metadata\r\n    }\r\n\r\n    type Comment implements Submission {\r\n        id: ID!\r\n        body: String!\r\n        post: Post!\r\n        ...Metadata\r\n    }\r\n\r\n    type Tag {\r\n        id: ID!\r\n        title: String!\r\n        description: String\r\n        ...Sluggable\r\n        ...Metadata\r\n    } been 9 days. what are the community norms for discussing these proposals?  @sw-yx I wrote a proposal for the [implementation of LSP and the hierarchy of types](https://github.com/facebook/graphql/issues/369) a month ago, for this month no one even asked \"wtf, what it is!11??\". It seems to me that GraphQL as a standard is more likely to be dead than alive. In any case, it's easier to:\r\n1) Make the implementation of the interface simply not necessary\r\n2) And the inheritance of interfaces\r\n\r\n```graphql\r\ninterface Timestamps { ... }\r\ninterface Mutators { ... }\r\n\r\ninterface Metadata extends Timestamps, Mutators {}\r\n\r\n# ...\r\ntype Comment implements Metadata {\r\n    id: ID!\r\n    body: String!\r\n    post: Post!\r\n}\r\n```\r\n\r\nThus, we get the same result, but at the same time we use existing constructions (`interface` instead `mixin`) I've also desired this and in practice pretty much needed it \u2013 so I made myself a transpiler/polyfill for it, using a slightlty different syntax: https://github.com/sydsvenskan/node-graphql-partials (I took more inspiration from how eg. [traits works in PHP](http://php.net/manual/en/language.oop5.traits.php) than from how eg. mixins work in Sass as the proposal here)\r\n\r\nI posted a bit more about my transpiler/polyfill in this thread, which also discusses this kind of behavior: https://github.com/graphql/graphql-js/issues/703#issuecomment-341128954\r\n\r\nThis is also slightly related to https://github.com/facebook/graphql/issues/295, where this has been brought up before @SerafimArts, I like the idea but my only aversion to that is that I don't think `implements` would quite be the right keyword for such behavior. Your proposal is an argument for abstract types in addition to inheritance, so though it aims to solve a similar problem, it's conceptually quite different, so if this is something that you'd like to discuss, I think that a new ticket would be fitting. \ud83d\ude0a @tylercrompton It seems to me that this is just a solution to the same problem, but a little more complex/global, at the level of the entire architecture of the SDL language. In the case of \"mixins\", this is another additional construction that serves only one - simply supplement the body with other inserts. > The expectation is that SDL will be read far more often than it is written\r\n\r\nThat is a very fair statement. However, can the same not be said about GraphQL operations (i.e. queries, mutations, and subscriptions)? Those of course can have fragments which are synonymous to mixins. What differentiates fragments from mixins in regard to readability and maintainability? Operations themselves are typically written more often than types and interfaces, but I would bet that given any one type or interface and any one operation of comparable complexity, one would be read or changed just as frequently or rarely as the other on average.\r\n\r\n> If adding mixin support is important to you, I would recommend you build it!\r\n\r\nI am by no means against doing this and would be glad to report my findings. I actually created a ticket for it in my project's issue tracker immediately after opening this issue. However, beyond writing a formal specification, I'm not sure how to best proceed, considering that my implementation would be dependent on the library on which it builds. Thus, the potential audience who could try it out in their projects would be limited. I'd hate to build it and be the only one to report their findings. I'm obviously already biased to supporting them. Do you have any suggestions as to how to proceed in this regard? > If adding mixin support is important to you, I would recommend you build it!\r\n\r\nI've already done it: https://github.com/sydsvenskan/node-graphql-partials As I mentioned in https://github.com/facebook/graphql/issues/370#issuecomment-341184506\r\n\r\n@tylercrompton Please try my piece of code out and we can maybe get some common findings  Thanks for the great work and the really good news. :+1: \r\n Finally <3  Public APIs often contain fields whose values are naturally integers, but which exceed 32 bits. For example:\r\n\r\n- `fileSizeBytes`\r\n- `millisecondsSinceEpoch`\r\n- `secondsSinceEpoch` (values after 2038)\r\n- `freeMemoryBytes`\r\n- `monetaryAmount` (in ISO 4217 meaning integer and fixed exponent)\r\n- `databaseRowId`\r\n- `youtubeViewCount`\r\n- `facebookActiveUsersCount`\r\n- `uniquePageVisitorCount`\r\n\r\nThese numbers are sometimes larger than 32 bits, but almost universally smaller than 53 bits. These numbers are also almost everywhere, and most users will have to figure out how to represent them - or how to work around the problem instead. A real world example is GitHub GraphQL API, where repository `diskUsage` is given in kilobytes instead of bytes, and with the `Int` datatype, meaning that the API needs to be changed when the first repository larger than 2 terabytes appears.\r\n\r\nSo, what is the recommended universal default way to represent such numbers in GraphQL:\r\n\r\n- `Float` (which works, but does not convey that the number is an integer, so requires additional validation)\r\n- Custom `Int53` type (works, but not in standard)\r\n- Custom `Int64` type (works, but not in standard, also would map to BigNum in JavaScript unnecessarily)\r\n- `String` (requires conversion client side and server side, additional error handling)\r\n\r\nBecause these cases are so common, I would like to get a definitive answer on what is the default way to handle them, and I would also hope this would be added (as an informative note) to the documentation, so people would actually know about it.\r\n\r\nOr alternatively, the best solution in my opinion: update the specification to actually contain an integer datatype >32 bits, since it is still a working draft instead of a standard. But, it may be way too late for that, I don't know.\r\n\r\nI am willing to do the legwork for any such change, but without a decision I don't think there's much I can do about this. @leebyron @wincent Sorry to bother, but this issue has just sat here for a month. How and where should I open a discussion about this? What is the proper place for graphql spec feedback? > What is the proper place for graphql spec feedback?\r\n\r\nThe issue tracker here is a reasonable place to start. If you want to go beyond an initial exploratory conversation about a topic then see [CONTRIBUTING.md](https://github.com/facebook/graphql/blob/master/CONTRIBUTING.md) in the root of the repo for a description of the basic stages that a proposal to change the spec should generally go through (the process itself is evolving, but that document captures some current thinking about it).\r\n\r\n> I would like to get a definitive answer on what is the default way to handle them\r\n\r\nThat is going to be tricky as there may not be a \"definitive\" answer as such. The 32-bit int size was very intentionally chosen for maximum interoperability, knowing that pretty much all significant, current systems that one might wish to use GraphQL with will be capable of representing numbers in this way. Once you want to go beyond that, you are pretty much inevitably in the territory of the implementation-specific, which means that it is going to be difficult to get it into the spec. Even if just in a supplemental, advisory addendum; part of the value of the spec is that it can reasonably be implemented in its totality *everywhere*, and once you start adding additional layers of guidelines it is no longer necessarily clear where the \"core\" spec ends and the \"optional\" part begins. What does it means to say a library \"implements the spec\"? I could go on, but you can probably see where the logical conclusions lie. I wonder if a document in the spirit of the `Relay Modern Conventions` could be beneficial. GraphQL doesn't define eg pagination, but in `Relay Modern` there is a convention for doing just that on top of GraphQL. It might be useful to have a document which defines an \"extended type Zoo of commonly used types\" which a server can adhere to.\r\n\r\nSome of the trickery that is going on here is that different languages treat integer values differently:\r\n\r\n* Erlang, Common Lisp, and Haskell defines arbitrarily sized integers by default. Hence, they have no problem dumping you a 160bit integer as a result.\r\n* OCaml uses one bit for tagging in its integer scheme. Thus integers are 63 bit by default and the 64 bit integers have a considerable performance degradation if you use them.\r\n* Perl, and Javascript doesn't define an integer type at all and are thus only precise up to 53bit\r\n* SQL has a DECIMAL type for fixed point arithmetic.\r\n\r\nIf a spec tries to cater to a specific language, you exclude some languages from the implementation. So it makes sense to start with a lowest common denominator. Other considerations:\r\n\r\n* JSON might not be the transport. Other transports define different integer types. Expect coercions.\r\n* Were I to define some of the above types, I'd probably define them as user-defined scalar types and build proper resolvers in the languages I intend to work with. Poly-language systems tend to need some special handling when traversing the language barrier anyway.\r\n\r\n I'm going to respect the decision to leave this out of the spec. However, for posterity, I will express my disagreement with the issue here.\r\n\r\nI fear that not recommending an universal default does not result in people choosing the best type based on the type of data. I fear that they will instead stick with 32-bit integers, hoping that they will be enough, until they are not. Github using integer for repository size is already an example of this - it will break with the first 2 terabyte repository. I am betting that if YouTube adds a GraphQL API for their service, the person implementing that will decide that `viewCount` property for a video should be of type `Int`, because it is the most natural type for such a value, completely forgetting that YouTube has almost 20 videos with more than 2 billion views. When the general migration from 32-bit OS to 64-bit OS happened, we saw this sort of thing en masse, and it was a very painful transition - and currently the integer size is no longer an issue as the *default* selected integer in programming languages can be larger than 32-bit. It feels like a renaissaince back to those days, getting all these 32-bit problems again.\r\n\r\nBut even when people select a datatype larger than 32-bits for the GraphQL API, the end result is not going to be terribly nice since everyone will select differently. This means conversions between the different types across the board. This is similar to Java, where half of the APIs decide they want `long` and half of them want `int`. The result is typecasts all around, warnings about possible loss of precision, and hard to diagnose bugs because people don't want to use conversion helpers that will error out if the value exceeds the new range.\r\n\r\nThe only solution to both of these problems is that the *default* type people pick for an integer is large enough for most uses. If this default integer type would be 53-bit integer, it would be represented by the following types in programming languages:\r\n\r\n| Language | Type |\r\n| --- | --- |\r\n| JavaScript | Number |\r\n| Python | int (or automatically long for 32-bit Python 2) |\r\n| C/C++ | int64_t |\r\n| Go | int64 |\r\n| C# | long |\r\n| Java | long |\r\n| PHP | integer (or automatically float for 32-bit) |\r\n| VB.NET | Long |\r\n| OCaml | int (or, unfortunately Int64 for 32-bit, but see below) |\r\n\r\nNote: OCaml has 31-bit integers on 32-bit platforms, so even the current GraphQL default for \"maximum\" compatibility cannot be represented by them, forcing the use of Int64 for 32-bit platforms. So this does not \r\n\r\nI don't know, maybe my viewpoint is limited, but I fail to see in what kind of environments this would actually pose a problem. Sure, some embedded controllers for IoT are mostly 32-bit, and might have slow 64-bit numbers, and might access GraphQL APIs - but I doubt the integer size problem would be a major obstacle there. In case somebody stumbles upon this from a search, I created a custom scalar for this and published the library: https://github.com/nakedible/graphql-scalar-int53 In the spirit established in Relay of making specs outside of the GraphQL spec for auxiliary ideas, maybe that's what's needed here, so that libraries can adopt a uniform approach.  https://www.facebook.com/api/graphql/ return error 500 This repository is for discussing the graphql specification, not for issues with specific implementations.  hi, how i can set same index for listOf type?\r\n\r\nme need next structure for response JSON\r\n\r\n```\r\n{\r\n  \"data\": {\r\n    \"operative_control\": {\r\n      \"que\": [\r\n        \"1\" : {\r\n          \"R\": \"4\",\r\n           ...\r\n        },\r\n        \"26\" : {\r\n          \"R\": \"6\",\r\n           ...\r\n        }\r\n        ...\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI understant that its no good, but me need only this structure. or how can return custom data (raw not encode)? for example \"que\" => Type::string() and set custom json data **return json_encode($que);**\r\nresponse\r\n```\r\n{\r\n  \"data\": {\r\n    \"operative_control\": {\r\n      \"que\": \"{\\\"91\\\":{\\\"R\\\":4},\\\"22\\\":{\\\"R\\\":6}}\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```\r\nclass OperativeControlType extends ObjectType\r\n{\r\n    public function __construct()\r\n    {\r\n        $config = [\r\n            'fields' => function() {\r\n                return [\r\n                    'que' => [\r\n                        'type' => Type::listOf(Types::OperativeControlValue()),\r\n                        'resolve' => function($que) {\r\n                            return $que;\r\n                        },\r\n                    ]\r\n                ];\r\n            }\r\n        ];\r\n\r\n        parent::__construct($config);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nclass OperativeControlValueType extends ObjectType\r\n{\r\n    public function __construct()\r\n    {\r\n        $config = [\r\n            'fields' => function() {\r\n                return [\r\n                    'R' => Type::string(),\r\n                ];\r\n            }\r\n        ];\r\n\r\n        parent::__construct($config);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nclass QueryType extends ObjectType\r\n{\r\n    public function __construct()\r\n    {\r\n        $config = [\r\n            'fields' => function() {\r\n                return [\r\n                    'operative_control' => [\r\n                        'type' => Types::operativeControl(),\r\n                        'resolve' => function($root, $args) {\r\n                            return \r\n                                [\r\n                                    91 => [\r\n                                        'R' => 4\r\n                                    ],\r\n                                    '22' => [\r\n                                        'R' => 6\r\n                                    ],\r\n                                ]\r\n                            ;\r\n                        }\r\n                    ]\r\n                ];\r\n            }\r\n        ];\r\n\r\n        parent::__construct($config);\r\n    }\r\n}\r\n```\r\n  Hi Guys,\r\n\r\nFirst, thank you for your incredibly hard work and brilliant design.  You've helped me and many others.\r\n\r\nI believe that there's an IP issue over GraphQL that needs to be brought to Facebook's attention.  GraphQL patents are issuing and there are no patent grants in the specification.  I read these patents to cover core functionality and difficult (thought not impossible) to design around.  However, the current spec leads most implementations to be infringers.\r\n\r\nFor more, here are my full thoughts.\r\n\r\nhttps://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9\r\n\r\nI've been a Facebook licensing defender for other OSS like React, but I think this is a completely different issue and hope this can start a dialogue up the chain.\r\n\r\nThank you! \ud83c\udf7f  Hi @LawJolla, thanks for highlighting this and for the well researched blog post.\r\n\r\nI'll bring this to the attention of our legal council for their suggestion on how to resolve this issue. We definitely want to ensure the community has all necessary rights to be able to use GraphQL! I'll make sure we get a speedy resolution. @leebyron - in general the patent appendage to FB's BSD + patent license is at best, just a paper tiger, as @LawJolla contests. Or at worst, it is a poor message, like FB is just another large enterprise that only thinks about its greedy self. I'm paraphrasing the overall perspective of comments I've read, when I say that. \r\n\r\nI guess the question is, is the value of the protection expected from the added patent conditions higher than the negativity and uncertainty it causes. I'd think not and it is not really true to OSS community values, if FB were honest about it.\r\n\r\nScott Hi @smolinari, I understand this is a contentious issue and that the legal portion of open source can be frustrating since decisions they are not always in the hands of the engineers building the software, and their implications are not always clearly understood.\r\n\r\nI'm discussing this issue with our legal council and will try to find a solution that provides the necessary legal rights for the community to continue to use and contribute to GraphQL. I'll share updates as soon as I can. @leebyron sorry if I ask something that is already answer but between English and my ignorance I am really lost.\r\n\r\nDoes the Patent affects the Specification itself?\r\n\r\nI am kind of fine if you put some patent `on the implementation` of such of specification, but I wouldn't expect to be affected even using the specification.\r\n\r\nI can't even imagine that @leebyron thanks for your help and quick attention!\r\n\r\nAs someone who's patented many inventions for large companies, I know how the machinery works.  Facebook counsel farms the IP to an external firm that handles the application independently.  Then three years later, FB decides that open source a the better route, but the outside firm continues to chew the application.\r\n\r\nBut GraphQL is a different open source monster from other FB projects because it's a spec (without a patent grant) and not software.\r\n\r\nAnd thank you again for your hard work and advocacy!  Your time and brilliance greatly benefits my life and makes my business goals possible. I just ran into this article. \r\n\r\nhttps://medium.com/@reverdev/why-we-moved-from-angular-2-to-vue-js-and-why-we-didnt-choose-react-ef807d9f4163\r\n\r\nNotice the part about FB's license and how it helped sway the decision away from React.\r\n\r\nand this note in the comments:\r\n\r\n> and the licensing on React is just ridiculous, but we\u2019ve known about that for more than a year; we\u2019re just paying attention, now\r\n\r\nI ask again, is the expected protection of the BSD + patent license worth such negative vibes, which seem to be getting worse? Is FB's OSS really the place to leverage the fight against patent trolling (if that is the intended purpose)? \r\n\r\nScott It would be helpful to link to the patent related to this: https://www.google.com/patents/US9646028\r\n\r\nIt looks like that patent covers GraphQL, how does this affect companies who are relying on GraphQL is the big question here. Perhaps this is why the reference implementation for JavaScript includes the PATENTS grant: https://github.com/graphql/graphql-js/blob/master/PATENTS\r\n\r\nMy personal opinion is we should #EndSoftwarePatents very disappointed that anyone would put their name on that patent filing especially when patents do not encourage innovation at all. @leebyron thank you for the reply and the link to that blog post! @leebyron I could understand any Patent/Law against any law sue because of the usage or any spec , lib and frameworks made by Facebook but I can't not understand anything add it outside that, specially on open source projects.\r\n There is a lot of fuss about FB OSS patents and the way they're granted but the whole issue is moot until and unless those patents hold up in court, which knowing the prior art for both GraphQL and Reacf I heavily doubt they they could. so if company A uses GQL and sues FB then FB sues back and tries to force them to not use GQL I think we will have a laugh then. Can't see how it would work. Seems better off for FB to change the license to remove that non-sense.\r\n\r\nA fan and advocate for both GQL and React, and FB OSS in general. I realize the issue being raised is about infringing for simply developing a GQL server. Same comment applies here: moot until GQL patent is proven valid in a legal case. Till then it's pure legal posturing.  As @LawJolla commented,  I think there is a big difference between React and GraphQL, specially regarding patents. While one is a *framework*, the other is a *specification*.\r\n\r\nSo we can't really look at both with the same eyes, neither accept the [React license explanation](https://code.facebook.com/posts/112130496157735/explaining-react-s-license/) in the GraphQL topic.\r\n\r\nFocusing on GraphQL, here are some of my worries, whose answers might help to understand what are the real implications of the Patent:\r\n* How this affects the different frameworks and ecosystems?\r\n   - GraphQL server implementations (both open-source and closed-source, SaaS, ...).\r\n   - GraphQL server tooling\r\n   - GraphQL clients (it seems this case will be the less vulnerable to the Patent, as analyzed by the article)\r\n* How this **affects to new specifications** highly inspired by the GraphQL spec? (Let's say [GraphQL+](https://docs.dgraph.io/master/query-language/)) Could Facebook demand them?\r\n\r\nCompared to GraphQL, SQL it's been a specification/standard that's been around for some years now and have zero patents associated to the standard itself. So, should we accept the Patent argument for the GraphQL case?\r\n\r\nPerhaps including a patent grant in the GraphQL spec will help to alleviate this concerns. We're grateful for GraphQL and believe it is the future of inter application API's (with GRPC being the future of intra application API's). I wanted to mention that at GitLab we decided to put our GraphQL implementation on hold, in https://gitlab.com/gitlab-org/gitlab-ce/issues/34754#note_40144735 our Senior Director of Legal Affairs mentions: \"If we were to allow this license, it could lead to potential future conflicts with software licensed under Apache.  Also, we could be impairing the future rights of our customers.  Essentially, this is not really an open source product based on the implications of the license.  While there is no payment of cash, payment is in the form of giving up future rights.\" @syrusakbary dead on and well said.\r\n\r\nThe longer that this drags out, the more I wonder what's going on.  I have faith in Facebook and still do.  But the answer is obvious, and the fact we're so far into this without any legal uttering is disturbing.\r\n\r\nSoftware patents are rarely commercially valuable because most claim arbitrary elements.  That is, if you were independently designing a similar system, odds are high your implementation, just by sheer implementation chance, would zig instead of zag.  That zag would miss the claimed, patented arbitrary implementation.\r\n\r\nBut a way to make sure your arbitrary implementations are followed is to create an open spec.  Then the arbitrary claimed elements (and GraphQLs patents have a few) are followed and infringed.  Was GraphQL open sourced as a tech poisoned pill?  I don't think so.  But as previously expressed, this delay is worrisome.\r\n\r\nSince Facebook legal may read this post, I think the developer community is in enough of an uproar to mount a crowdsourced / crowdfunded USPTO request for reexamination of Facebook's patents to invalidate them.   I think the real issue here is that the patent is patentable at all!  Reading the linked article says the examiner requested they limit to social networks but that sounds non-intuitive - what kind of social network isn't based on a graph?\r\n\r\nAnd querying graphs is not 'new' or 'innovative' - I've worked with XML databases many years ago where you could issue XPath-style requests over a network connection and they would traverse and return results.  GraphQL is hardly different from that - it's just a nicer application of it since we now live in a mostly XPath/XSLT/XML-free world. Since the language of the patent is too broad, does it mean that anyone implementing any such hierarchical querying system is violating this patent? Such query languages have been around for a long time before GraphQL came into the picture. Netflix\u2019s Falcor comes to mind. \r\n\r\nHow will such query languages be affected by this patent? Will someone be liable to get sued for building and distributing another hierarchical query language system, which was implemented independently of GraphQL ? And will the users of that system also become liable? \r\n\r\nIf so, that is really bad and it won't be solved by just including a license grant along with GraphQL. If I am liable to get sued because I am building/using a completely independent hierarchical querying system - that sounds very unfair.\r\n\r\nPlease clarify this point as well. Based on my reading of the patent and the comments in the Medium article by @LawJolla, I don't see the GraphQL patent passing the obvious test. \r\n\r\nThe question would be whether or not a social-network system is an obvious limitation to someone skilled in the art. Given the volume of prior art filed with the USPTO using that terminology, it seems hard to believe any arguments claiming non-obviousness are credible. \r\n\r\nA method of organizing and communicating abstract information, which the Examiner stated the patent amounted to before adding the social-networking system limitation in the claim, still fails to qualify for a patent if an obvious limitation is applied to the claim. I agree with @emrul on this.\r\n\r\nEdit: To put it another way, to invalidate the patent, you just need to prove someone queried data over a graph before Facebook filed, and that data was part of a social-network system. @bsbechtel When was the filing date? I did this back in 2015: https://github.com/cloutiertyler/RibbonGraph. It's a similar concept but with a declarative permissions system. since a few people mentioned prior art, there's also the [SPARQL](https://en.wikipedia.org/wiki/SPARQL) specification from 2008 and finalized in 2013, you can see an example in the [Wikidata Query Service](https://query.wikidata.org/), here's an example query to try:\r\n\r\n```\r\nSELECT ?computer ?computerLabel ?location ?locationLabel WHERE {\r\n  SERVICE wikibase:label { bd:serviceParam wikibase:language \"[AUTO_LANGUAGE],en\". }\r\n  \r\n  OPTIONAL {  }\r\n  ?computer wdt:P31 wd:Q68.\r\n  OPTIONAL { ?computer wdt:P495 ?location. }\r\n}\r\nLIMIT 100\r\n```\r\n\r\nMay not look like GraphQL but it is using one schema to query multiple other schemas which is basically what GraphQL is for.\r\n\r\ncc @LawJolla  I can't believe we are talking about patenting an specification like this one, I refused to even think about it.\r\n\r\nWith all the respect to all the engineering department of Facebook, but I would crash the legal department for this, my ethic as an engineer worth more than whatever Facebook could pay me. \r\n\r\nHow it's possible to accept this, I would prefer Facebook to be like Microsoft 1990 and close source everything, it's way better than put this out there open source and **many of us that have no clue about legal details** go to the hell because of this practices from Facebook.\r\n\r\nI know that is not 100% the engineering department of Facebook faults but if you can't win this battle who will?!, either you really work harder on this or the whole industry will becomes this nightmare, I bet a lot of companies will start copying this practices and there is no going back. @omouse pretty much, just put some `JSON` at front and it's the same. So basically patent JSON structures?! This doesn't even makes sense.\r\n\r\nI wouldn't care about the implementation on NodeJS and those code, but patent in this specification, really!? Last time I commented I stated that the discussion is moot until the patent is tested in court and given the prior art no one should assume that the patent is valid. I was wrong. People are worried about the lawsuit and cost of fighting it, not about whether they'd prevail or not.\r\n\r\nHere is some of the better known prior art:\r\n\r\nhttps://www.slideshare.net/mobile/SumitSarkar10/rest-api-debate-odata-vs-graphql-vs-ords\r\n @idibidiart I understand the concern, but I think both discussions are worth having, and also closely related. It only takes one case to invalidate the patent, unlike a copyrighting license. Yes, the legal fight would be expensive and time consuming for that individual team, but it would also be a case where a win for that team would be a win for the entire open source community. Hopefully the community would realize this, and find various ways to express their support. \r\n\r\nI should mention that, at the end of the day, a solution that works for Facebook, the open source community, and the US Patent System is the optimal outcome, whatever that solution may be. @idibidiart I would be fine if the Patent is **ONLY** for prevent any lawsuit from anyone because they were using the specification and/or any tool from Facebook. 100% agree on that because it's money for Facebook at the end of the day and it's not fair for them to open source and help the community, and then have to pay shit lot of money dealing with lawsuit from opportunists\r\n\r\nBut that is one thing,\r\n\r\nthe other side of the coin is to constraint the business from using it specially when you are open sourcing under BSD @bsbechtel @yordis \r\n\r\nAgree on all points. This is a serious issue. \r\n\r\nI know @leebyron is a serious guy and is 1000% behind open source and doing the right thing. He's a pillar in the community. \r\n\r\nI also know corporate legal departments are full of people trying to justify their existence. \r\n\r\nIt would not be fun for those at FB Legal if this lack of foresight cost them a useless legal battle with other patent holders whose patents are infringed upon by the FB patent. Just because one company has a patent on something it does not mean that it doesn't infringe on other patents.\r\n\r\nReference:\r\nhttps://www.google.com/search?q=can+a+patent+infringe+another+patent&rlz=1C5CHFA_enUS734US734&oq=can+a+patent+infringe+&aqs=chrome.0.0j69i57j0l3.5200j0j9&sourceid=chrome&ie=UTF-8\r\n\r\nThere is a potential material risk to FB themselves from their patents coming under scrutiny. \r\n\r\nNormally, companies acquire patents to use in bargaining in case of lawsuits and not in preemptive fashion as FB has done. \r\n\r\nThere is definitely a risk to FB here.\r\n\r\nIf they're smart, they'll put a lid on this whole thing, undo the stupid license, and regain trust of the OSS community, before things get out of control for them and the companies who have invested in GraphQL. \r\n\r\n\r\n\r\n\r\n\r\n\r\n   @idibidiart I hope they don't because they I screwed badly my own company, all my businesses are running on top of GraphQL endpoints so  FWIW, I have built and used a library which implements hierarchical querying abilities on top of a REST API built using Flask and SQLAlchemy. Have been working on it since late 2014 - https://github.com/inkmonk/flask-sqlalchemy-booster\r\n\r\nIt would allow you to declaratively build API endpoints which can be queried like\r\n`/resources/(id)?_ds={'f':{'id': {'op': '>', 'v': 5} }, 'attrs': ['id', 'name'], 'rels':{'rel1':{'attrs':['id','date']}}}` etc. \r\nBut I am not sure if small projects like mine can prove that they were in prior use before GraphQL came into picture. In my case I am the sole user of my library.\r\n\r\nBut surely, libraries like Falcor and specifications like SPARQL pointed out above - should be able to make an use case  for prior art. It is sad that this is even being debated. I would like to think of this as something as abstract as REST itself - and hence should be out of bounds for any patent application.  A specification in this context is an API, right? The graphQL query/mutation and schema spec is the API for GraphQL. If that's incorrect, please explain how else it would need to be framed.\r\n\r\nIf it is correct, the Google vs Oracle Android battle proved that you cannot patent an API.\r\n\r\nhttps://www.publicknowledge.org/news-blog/blogs/why-you-cant-copyright-an-api\r\n\r\n```\r\nIt\u2019s a basic fact of copyright law that you can\u2019t copyright methods or procedures for doing things.\r\n You might be able to copyright particular expressions for things\u2014like an evocative description of \r\nhow to combine and prepare ingredients in a recipe\u2014but you can\u2019t copyright the basic facts behind \r\nit\u2014the ingredients, their amounts, and the order in which you combine them.\r\n\r\nThe same is true of blank accounting forms, the rules of games, or any other situation where you \r\nneed a set of structures in order to interface with an underlying system. What you\u2019re doing is \r\ncreating a set of ideas of how to interact with a system, and ideas in themselves aren\u2019t \r\ncopyrightable. You might copyright the book on accounting that contains your blank forms and \r\nexplains them; you might copyright the booklet that contains your particular description of the rules \r\nof your new board game. But the underlying ideas that those things describe\u2014the forms and the \r\nrules\u2014can be used by others without your permission.\r\n\r\nThe same thing should be true for APIs. An API, or \u201capplication programming interface,\u201d is a \r\nframework used to communicate with a given computer system. If I want an application to perform a \r\nparticular calculation on a couple of variables and send me the result, I need a way to structure that \r\nrequest. Just as with the rules of the game, the particular name of that request, and the order in \r\nwhich it takes its inputs, and how it spits back its result, are all parts of a process and method\u2014an \r\nidea. But a case decided by the Federal Circuit this past May threw that into confusion.\r\n```\r\n\r\n\r\n  > the Google vs Oracle Android battle proved that you cannot patent an API.\r\n\r\nPatents and copyrights are entirely different things with very different rules, and anyway the Federal Circuit upheld Oracle's copyright claim in that case.\r\n\r\n---\r\n\r\nAs a more general note for this thread: it's pretty obvious that Lee is aware of the concerns, and working with the Facebook legal team to come to a solution. I look forward to putting this to rest.\r\n\r\nIn the meantime, there's not a lot that anybody can do, and speculating about complicated legal topics is resulting in a lot of misinformation and confusion here. If you're not a lawyer practicing American IP law (i.e. @LawJolla) please kindly stop.\r\n\r\n@leebyron you may want to consider locking this thread until Facebook legal has something concrete to share. I thougjt the issue is they patented the specification not merely copyright it?\r\n\r\nLocking the thread is a panic driven move. I would do the same if I was FB, but c'mon guys, if you shutdown one avenue for releasing frustration and sharing (mis)information people will find otheravenurs like Hacker News et al amd then it will really get out of hand I believe the patent covers software that does the stuff that GraphQL does, such that GraphQL itself is just one embodiment. If you created your own implementation of GraphQL, you'd be infringing. If you created your own implementation of something sufficiently similar, you'd be infringing. You can only copyright a specification. Right! So if they can't patent the specification but they have patented how GraphQL does stuff then chances are their patent infringes IBM's patents for OData and other patents held by major players in this field. That's just my naive brain can work out. Whether the discussion amongst us developers is generating misinformation or not, the answer is definitely yes, but that's just a byproduct of FB's confusing license. Folks need to focus on the cause not the symptom.\r\n\r\nI've sold a $2B consulting firm (3rd largest in US) on GraphQL and I was almost going to have major US retailers adopt it. This won't derail my plans until the plot goes wrong. What I expect is for FB to immediately change the license and sort stuff out.... as opposed to let it linger and affect so many companies and themselves in the process.\r\n\r\nIn other words, lock the tread or whatever but do take immediate action. This is not a small issue.\r\n\r\nFingers crossed. Disclaimer: not a lawyer, not affiliated with FB, just a user of FB OSS.\r\n\r\nI think FB wants to see this litigated. Some very popular licenses (I'm looking at you GPL) don't seem to be grounded by/in legal precedent. FB wants BSD+ to be legally tested so that OSS licenses carry more legal weight. Many people assumed that the BSD license was tantamount to a patent license that couldn't be selectively revoked based on litigation, and while that is a reasonable assumption IMO, there isn't much in the way of precedent to back it up. FB and other large companies would rather trust the mutually assured destruction of patent trolling than the mutual benevolence of companies using OSS.\r\n\r\nOSS licenses exist in parallel to the patent system, and while the intuition of devs (myself included) is that permissions granted by the OSS license overrule restrictions imposed by the patent, the fact that there is far more case law surrounding patent enforcement makes the opposite the likelier scenario, namely that the patent overrides the OSS license.\r\n\r\nTyped on my phone, sorry for errors or rambling. As someone subscribed to this issue to keep updated about the issue: Can I second the request to keep speculation (legal and otherwise) to a minimum? There are lots of forums to discuss this or speculate about it (HN, reddit,\u2026). I at least am here waiting for updates from FB and/or actual experts. Speculation doesn't really help and just takes up attention. Facebook announced they will relicense React under MIT Expat https://code.facebook.com/posts/300798627056246 Awesome! I encourage FB to consider transferring GraphQL to a formal standards body, or at least laying out a roadmap to doing so @dosire - That's great. But what about their patent on GraphQL \"technologies\"? \r\n\r\nThat's what got this thread started. As I see it, FB either needs to grant a patent license for anyone doing GraphQL and add the patent clause \"only\" for those suing them due to GraphQL technology patent infringements, or they could drop the GraphQL patent and add a clause that GraphQL technology cannot be patented by anyone else. \r\n\r\nIf you ask me, a clause avoiding patents is actually missing in the MIT license. Something like, \"No patents may be made from this software or its concepts or any derivative software using this software.\". That maybe not the proper legal way to formulate it, but you get the drift. OSS needs to fight against software patenting, because they (and those trying to take advantage of them in unethical ways) are the evil in this game. FB is only trying to protect themselves from these people in the end and I can understand that. But, it derails their projects from the OSS community spirit, unfortunately. And as you can see from the React announcement, Facebook gets it, which is totally cool! \r\n\r\nNow to solve GraphQL's OSS community and patent issues! \ud83d\ude04 \r\n\r\nScott @grahamegrieve @leebyron I completely agree. GraphQL is being hailed by many developers as a replacement for REST. Please allow it to become this and not limit its potential impact with licensing issues. GraphQL needs a formal standards body. That's great! Thank you Facebook for pushing the web towards open and accessible standards!  Incredible work @leebyron .  I've read the OWF v1.0 and think it's entirely appropriate for GraphQL and should put the legal issues to bed.\r\n\r\nI sent up another Medium post that Facebook needs to go on record stating there are no patents protecting their MIT licensed software.\r\n\r\nBut as far as GraphQL, let's close this issue and move on to bigger and better things!  \ud83c\udf89 Thank you contributors for enriching my life... and allowing me to never write another forsaken REST endpoint.  \ud83d\ude02 Thanks so much @leebyron. This is big from a higher standpoint to me, because it shows that even big corporations can show true heart, community spirit and do what is best for everyone in the end.\r\n\r\nWay to go!!!! \ud83d\udc4d \r\n\r\nScott @leebyron this is great news, well done on advocating for this internally.\r\n\r\nI have an implementation question that perhaps you can pass back to your legal team: how should we ensure that a 3rd party implementation such as https://github.com/webonyx/graphql-php \"links back\" to the OWFa-licensed specification to clarify that it is covered by its patent grants.\r\n\r\nFor example, should there be some kind of reference sentence in the LICENSE of graphql-php? Are you planning on making some relevant reference in graphql-js as a guide?\r\n\r\nI understand, of course, that anyone who is particularly nervous about such things should seek their own legal advice, but I thought it would be better to start with a Facebook-recommended model to apply in such situations, rather than every project getting something draft by their own lawyer.\r\n\r\nThanks again for your work on this,\r\nSam @leebyron are you able to comment on the above?  Please add `@scope` directive to be possible to mark what permissions/roles should have user in order to be able to fetch data.\r\nExample\r\n```\r\ntype Post {\r\n    id: ID\r\n    comments: [Comment] @scope(authenticated)\r\n}\r\n``` Yeah, it can be enabled without a change to GraphQL, but is it a very common one, so will be better to be in core I think.\r\nThanks. this should be in user land\r\n\r\npermissions are very specific for an application context  Currently the GraphQL spec at https://facebook.github.io/graphql/#sec-Field-Selection-Merging only mention conditions that have to apply in order for fields in a selection to merge. While discussing a fix to an issue ( Youshido/GraphQL#138 ) the specification was brought up.\r\n\r\nIt is pretty confusing to infer how to actually merge fields in a selection just from the specs alone, because they only seem to be talking about how to know when multiple fields can merge, and not about how to actually do the merging.\r\n\r\nCan we get some more specific documentation on how to merge fields? Can we get some examples of how to merge fields of object types and array types?  fix copy paste error in the same way as https://github.com/facebook/graphql/pull/345 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fgraphql%20%23346). Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  https://github.com/facebook/graphql/pull/344 was against the wrong branch Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fgraphql%20%23345). Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! @wincent nice spec, glad to help  Hi GraphQLers,\r\n\r\nI'd like feedback on an idea to spec the `.graphql` file format and, within that, to spec a syntax for \"importing\" fragments from other files (inspired by https://github.com/apollographql/graphql-tag/pull/33 by @Poincare and @stubailo).\r\n\r\nI would like to see this specced so developers can store their application's queries in files, co-located with the associated application code, that can be consumed by tooling in multiple languages & platforms.\r\n\r\n---\r\n\r\n<details>\r\n<summary>A little aside...</summary>\r\nIt's particularly useful for us because our migration strategy (from REST to GraphQL) is to replace existing network requests with GraphQL queries, and we use a stored operation/persisted query system, so the queries have to be built and submitted before reaching prod. The queries should be stored with the code, in a way that can be statically built and uploaded with a standalone tool.\r\n</details>\r\n\r\n---\r\n\r\nSpecifically, I want to avoid:\r\n\r\n- requiring developers to maintain massive files that contain single queries\r\n- duplication of identical fragments within those queries (for standard objects that never change across the API)\r\n\r\nIn my mind, the file format spec is relatively simple, requiring:\r\n\r\n- extension (`.graphql`?)\r\n- character encoding (Unicode? I'm not a specialist here; unsure of nuance)\r\n- MIME type? (`text/graphql`?)\r\n\r\nTo avoid fragment duplication, I would also like to spec the _import_ syntax for fragments. The goals of this syntax are that:\r\n\r\n- large query files can be split into fragments and the composite query\r\n- `.graphql` files are transferable between platforms (eg. written for Android but parsed by Scala)\r\n- be completely opt-in and not break existing GraphQL files\r\n\r\nFeature-wise, imports would:\r\n\r\n- support direct import: fragments can be imported from another file\r\n- support transitive import: dependencies of a dependency are imported too\r\n- not support circular imports\r\n- only support relative-path imports (no URLs or absolute paths)\r\n\r\nFragments would be imported in their entirety \u2014 you _cannot_ import by name and you _cannot_ alias. This is to simplify implementation and to dodge the namespacing problem (YAGNI). Put another way, avoiding fragment name clashes is a user-land problem.\r\n\r\nRegarding circular imports, they should be considered invalid: if fragment file \"a\" imports fragment file \"b\", which imports \"a\"  \u2014 the latter \"a\" would be invalid and should cause an error in the implementation.\r\n\r\nIn terms of syntax, there are some more goals:\r\n\r\n- look GraphQL-ish\r\n- support future extension if named imports proves useful & achievable\r\n\r\nI suggest, inspired by JavaScript and [@poincare's work](https://github.com/apollographql/graphql-tag/pull/33):\r\n\r\n```graphql\r\n# file: my_user.graphql\r\n\r\nimport \"./basic_user.graphql\"\r\n\r\nquery ($id: ID) {\r\n  user(id: $id) {\r\n     ... BasicUser\r\n     my_field\r\n  }\r\n}\r\n```\r\n\r\n```graphql\r\n# file: basic_user.graphql\r\n\r\nfragment BasicUser on User {\r\n  id\r\n  name\r\n}\r\n```\r\n\r\n---\r\n\r\nThoughts?\r\n\r\nInitially, please give me a sense of:\r\n\r\n- something you need: yes/no?\r\n- something you can forsee needing? yes/no?\r\n- is there a viable alternative to this given the goals above? (YAGNI!)\r\n- is there more prior art here? I have also see it mentioned [here][intellij-plugin].\r\n\r\n_Please_ let's avoid bikeshedding on the import syntax; that can come later. \ud83d\udeb2\r\n\r\n[intellij-plugin]: https://github.com/jimkyndemeyer/js-graphql-intellij-plugin/issues/43#issuecomment-288216815 Unless I am reading this wrong we are saying we will need to design all the queries we wish the client to use prior to releasing? This is Imo the opposite of flexibility. Its a view that cannot be extended in RDBMs land?\r\nThis would not work for me as I particularly fell for QueryQL because my users generate their query on the fly through and interface (its a management tool for their data). I think its a nice add on for queries often used just as Views are a nice add-on\u2026 (if you can extend? :P)\r\n\r\nIf I mis-read please let me know if now I better fork now! @brokenpeace Don't worry, this idea is opt in (as are persisted queries). You can keep using GraphQL the way you are! \u263a\ufe0f How about ability as second part mentioned utilizing both? If it does provide benefit for a lot of use cases just my few particular ones. I do like the concept.\r\n\r\nActually looking at the esparse library we can just add optionals in this case perhaps we use the template name+hash of the fields in a cached persisted folder? \ud83d\udd28 \r\n\r\nI dig the idea completely but I am just trying to figure out how to keep it simple yet flexible (which is what I love about it) It would be great to see some form of this incorporated within `relay-compiler`. Seems like a great way avoid issues with more than one file containing fragments with the same name, e.g. `a/Foo.js` and `b/Foo.js` both contain a `Foo_viewer` fragment). See https://github.com/facebook/relay/pull/2020 Yep - one reason we didn't go with the Relay Modern approach for fragments in Apollo is to avoid having a global namespace where you could run into naming conflicts. It would be nice to have a module-like approach.\r\n\r\nOne cute thing suggested by @calebmer once was:\r\n\r\n```graphql\r\nquery {\r\n  me {\r\n    firstName\r\n    ...userDetails @import(from: \"../UserDetails\")\r\n  }\r\n}\r\n```\r\n\r\nI think all tooling should be built to work equally well with queries in JS code and queries in standalone files. For example, both Apollo and Relay persisted queries work fine with queries written as part of JS code (but require unique fragment names). @stubailo Do you have specific feedback on the proposal? It seems you're saying that you _don't_ like that fragments would exist in a global namespace?\r\n\r\nAvoiding the global import adds a lot of complexity to the spec & tooling that we might not want to incur:\r\n\r\n- how are fragments namespaced \u2014 do you import them by name? can you alias?\r\n- if you import a fragment by name, what happens to _its_ dependencies?\r\n- what if a transitive dependency has a name clash? do you auto-namespace transitive dependencies?\r\n\r\nI'm keen to get a _simple_ version specced soon, as the community is already running into this problem and solving it ad-hoc. We can leave the door open to improvements like namespacing in the future.\r\n\r\nThe way Apollo does persisted queries (which I haven't used, so my understanding is based on [this][persisted]) seems to be compatible with this proposal.\r\n\r\n[persisted]: https://dev-blog.apollodata.com/persisted-graphql-queries-with-apollo-client-119fd7e6bba5\r\n Here's my current set of opinions:\r\n\r\n1. Having imports is valuable\r\n2. I really like the ES2015 module system - stuff like circular dependencies and being able to import just one fragment from a document is really useful (like having a `fragments.graphql` and importing individual fragments from there seems like a pretty good pattern)\r\n3. We should definitely follow dependencies, this should be simple because GraphQL as a language is quite simple\r\n4. Things that break the GraphQL parser/AST are harder to test out quickly, so a short-term solution based on directives or comments is desirable\r\n\r\n> Regarding circular imports, they should be considered invalid\r\n\r\nI don't think this should be the case since in GraphQL it should be pretty easy to resolve any dependencies like that.\r\n\r\nSo basically:\r\n\r\n```graphql\r\n# PersonFragments.graphql\r\nfragment PersonBasicInfo on Person {\r\n  firstName\r\n  lastName\r\n  avatar { small }\r\n}\r\n\r\nfragment PersonDetails on Person {\r\n  ...PersonBasicInfo\r\n  address { street, state, zipCode }\r\n}\r\n```\r\n\r\nThen you can import:\r\n\r\n```graphql\r\nimport { PersonDetails } from \"./PersonFragments\";\r\n\r\nquery CurrentUserDetails {\r\n  currentUser {\r\n    ...PersonDetails\r\n  }\r\n}\r\n```\r\n\r\nMaybe you can rename to avoid name collisions:\r\n\r\n```graphql\r\nimport { PersonDetails } from \"./PersonFragments\";\r\nimport { PersonDetails as AvatarPersonDetails } from \"./AvatarFragments\";\r\n\r\nquery CurrentUserDetails {\r\n  currentUser {\r\n    ...PersonDetails\r\n    ...AvatarPersonDetails\r\n  }\r\n}\r\n```\r\n\r\nSo the name collision thing is interesting. One situation I'm worried about is where you have two parts of your app you used to use separately, but then you want to use a fragment across that boundary. You might have a whole world of duplicate fragment names and renaming them all is not feasible. That seems to imply that it would be valuable to have some way to import two fragments with the same name and have it still work.\r\n\r\nHowever, there's no scoping in GraphQL - all fragment names are totally global. So either we need to assign that fragment a unique name as part of the import evaluation (not ideal) or convert it to an inline fragment (also not ideal).\r\n\r\n> I'm keen to get a simple version specced soon, as the community is already running into this problem and solving it ad-hoc. We can leave the door open to improvements like namespacing in the future.\r\n\r\nIs there a disadvantage to using the current experimental approach with comments until a good spec is finalized? Something like a module system probably shouldn't be added lightly. > I don't think this should be the case since in GraphQL it should be pretty easy to resolve any dependencies like that.\r\n\r\nMaybe. I don't think circular dependencies are that simple. It's certainly more simple than in an imperative language, but you still have to worry about ordering (do you hoist the import statements? if not, what are the implications?). I need to think more about edge cases of circular imports.\r\n\r\n> So either we need to assign that fragment a unique name as part of the import evaluation (not ideal) or convert it to an inline fragment (also not ideal).\r\n\r\nThis is the transitive problem I mentioned. As soon as imports become more advanced than a literal file-contents copy, it become an issue that needs *specification*. That makes the spec more complex, which is generally undesirable.\r\n\r\nIt's preferable in this case to see how developers solve that problem (automatic renaming? failing the build?) and, perhaps, later encode it in the spec.\r\n\r\n> Is there a disadvantage to using the current experimental approach with comments until a good spec is finalized? Something like a module system probably shouldn't be added lightly.\r\n\r\nNo, it's fine, but implementations will diverge and may become incompatible. It will be painful to walk back from that for everyone.\r\n\r\nA little bit of experimentation in the community is great, and is what inspired filing this issue! > but you still have to worry about ordering\r\n\r\nThat's one nice thing - ordering doesn't matter in GraphQL, so I think the issue becomes much simpler.\r\n\r\n> As soon as imports become more advanced than a literal file-contents copy\r\n\r\nSo the current comment-based approach, as you've seen, is a straight copy. I think if we decide that approach is fine, it doesn't need to be in the language spec IMO. Then it's more like a preprocessor?\r\n\r\nI guess I'm not clear on how preprocessor stuff works in C, for example - is it part of the language spec? Just wanted to say :+1: on experimentation for the time being. I just recently learned graphql-tag's approach which is great, also, github/graphql-client uses Ruby constants to import GraphQL fragments. Kind of crazy, but just thought I'd share another example \ud83d\ude06  > I think if we decide that approach is fine, it doesn't need to be in the language spec IMO.\r\n\r\nI think it's worth having something specced so you can be reasonably sure you have compatible implementations. Perhaps if not in this spec, it would be worth writing down the rules somewhere.\r\n\r\n---\r\n\r\nI thought in more depth about a more complex import syntax, supporting import-by-name and aliasing, and I think you're right: it's useful enough that it might be worth talking through in detail.\r\n\r\nIf the features were:\r\n\r\n* support direct import: fragments are imported from another file *by name*\r\n* support aliasing: fragments can be renamed during import\r\n* support transitive import: dependencies of a dependency are imported too\r\n* circular imports allowed, with cycle detection\r\n* only support relative-path imports (no URLs or absolute paths)\r\n\r\nThen we could look at the syntax you describe (taken from JS):\r\n\r\n```graphql\r\nimport { User as MyUser } from \"./user\"\r\n```\r\n\r\n---\r\n\r\nHowever, before we get there I want to discuss: is there a way to achieve the goals stated above without introducing new syntax? If we can then it's the preferable option, I think.\r\n I think a directive-based approach would work to satisfy all of the above cases, without new syntax:\r\n\r\n```graphql\r\nquery {\r\n  me {\r\n    firstName\r\n    ...userDetails @import(name: \"specificUserDetails\", from: \"../UserDetails\")\r\n  }\r\n}\r\n``` Without getting too much into syntax, I'm really keen to address the question at the bottom of my comment:\r\n\r\n> is there a way to achieve the goals stated above without introducing new syntax?\r\n\r\nAre there *any* alternatives? I do think this is one case though where the existence of a system where imports weren't used doesn't mean they are never going to be valuable. Sure it's possible to get by without them, but it's also possible to use programming languages without any module system.\r\n\r\nI think imports are valuable to:\r\n\r\n1. Integrate with module-based systems like JavaScript frontends\r\n2. Avoid the necessity for globally unique fragment names, which can become a hassle if you develop two code bases in isolation and then need to combine them into one app\r\n3. Identify where fragments are coming from in a large codebase without specialized tooling > I certainly didn't make that claim. Where did you see me make it?\r\n\r\nI didn't say you made it, sorry if it seemed that way! I can understand how it's easy to get by without imports when the following restrictions are in place (which to the best of my understanding is the case at Facebook).\r\n* [Unique file names](https://facebook.github.io/react/contributing/codebase-overview.html#custom-module-system)\r\n* monorepo\r\n* Fragment naming convention based on file names\r\n\r\nIt's much more awkward when you try to adopt it to an existing code base with a nested directory structure, non-unique file names, and fragments in modules that are shared via a packaging system like npm. I've been working on a proof of concept of @stubailo's directive based proposal in relay-compiler: https://github.com/facebook/relay/pull/2064 @wincent Thanks for your input here. I have some follow-up questions...\r\n\r\nHow are full queries constructed at Facebook? From what I gather you have a collection of (named?) queries and fragments. Looking at Relay, they're written in code directly (not files) \u2014 is this also true for your native clients?\r\n\r\nDo you have equivalents to the Relay compiler for Android and iOS queries?\r\n\r\n  This PR is a follow-up WG discussion about defining stages for changes to GraphQL specification. \r\n\r\nI copied stage descriptions from [my slides](https://docs.google.com/presentation/d/1y7OLdMv4sL583vUGePcXMMvmYRGz7JlBowaYDMcHWCU/edit?usp=sharing) as an early draft to keep momentum and continue the conversation. @wincent Thank you for proofreading \ud83d\udc4d\r\n\r\n> I think the one thing that is missing here is a framing statement at the top to provide a little more context\r\n\r\nI've added an one based on the text from your commit. What do you think?\r\n\r\n> What do you have in mind for the checklist?\r\n\r\nI think [Lee's list](https://youtu.be/mePT9MNTM98?t=20m32s) from GraphQL Europe talk can serve as a basis. So in theory, it will stimulate PR author to answer basic questions before making PR and thus save reviewers time and improve quality of PRs.\r\n\r\nBut before adding something concrete I want to make small research and see how it's done in other WG, committee, etc. I added `TBD` not to block discussion of stages since I think we can define checklist afterward. @wincent Great idea \ud83d\udca1 \r\n\u2705 Done > My inclination is to merge this as-is (but add a \"Draft\" label) and iterate from there.\r\n\r\n@wincent I suggest we proceed toward `Candidate` stage by:\r\n+ Notify all members of [GraphQL WG](https://github.com/graphql/graphql-wg)\r\n+ Community consent on the proposed change. If it\u2019s hard to achieve, add it to\r\nagenda of the next WG meeting.\r\n+ No changes to the graphql PR for at least last 7 days\r\n\r\nWhat do you think?\r\n @wincent Make sense \ud83d\udc4d \r\nShould I add something to the document itself? For example:\r\n`**Draft document**:  discussion [here](https://github.com/facebook/graphql/pull/342).`  @wincent \u2705 Done  ```\r\ntype Person {\r\n    firstName: String!,\r\n    lastName: String!,\r\n    age: Int!\r\n}\r\n```\r\n\r\nHow to query all people what are older than 18? That's not part of the graphql specification - you need to add arguments to your fields for all of the filters you would like to support. To clarify the answer, you would pass the arguments to yoir resolvers and deal with it at the API or db query level, wherever you're getting your data from.  Is there a specification about error responses, what status should be, what fields it should contains?\r\n\r\ngraphql-js respond with status 400 on invalid query\r\nGithub https://developer.github.com/v4/explorer/ respond with status 200 on invalid query  Is it possible to mark/show that some collections can be accessed only by user which has same permissions/roles? This would be done in the Access Control Layer of your application. In this context (the modeling of your data) it would not know what roles should have access not to mention that would add a real burden to maintain. I do not know your setup but I would highly recommend looking into ACL middleware to restrict this. I thought on this more and watched GitHub release of Graphql implementing\nhidden fields for roles.. Itypically she ick by my initial thought but it\ndid make sense if it's. Ring locked down record level to hold that meta on\nthe model. I still think the enforcement would need a special middle layer\nto ensure the users request is acceptable before ever querying.... just my\nthight.\nOn Wed, Aug 9, 2017 at 4:28 PM Greg Hurrell <notifications@github.com>\nwrote:\n\n> Closed #339 <https://github.com/facebook/graphql/issues/339>.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/facebook/graphql/issues/339#event-1199811735>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AAnOx7LLNG_WJBhsaNcULqbxzsuK8Skpks5sWhZXgaJpZM4OyHkZ>\n> .\n>\n  At the begining we have schema\r\n```\r\ntype User {\r\n  id: ID!\r\n  name: String!\r\n  birthday: String!\r\n}\r\n```\r\nAfter some time it was decided that birthday is not mandatory for new users, so the schema should change to\r\n```\r\ntype User {\r\n  id: ID!\r\n  name: String!\r\n  birthday: String\r\n}\r\n```\r\nThis is breaking change. Old clients can crash, they know that this field is not nullable, but we will send null, because we don't have birthday of all users.\r\n\r\nHow to versioning case like this in GraphQL? Thanks.  Verbal number must agree with subject.  Just to be clear, this is for translating the _specification_, right? Not for adding a i18n strategy _to_ GraphQL? hi, @wincent , sorry if bothered,\r\nI've already translated one version of the spec into Chinese, and am looking for the translation team where I am in to proofread.\r\n\r\nis there any guide to contribute to the spec translation?  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! done Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! i  am keenly  looking for others contributing to translation and disseminate graphQL  Because someone has to Good point! Regarding the practice of setting the end of the range to \"present\", is this something that Facebook lawyers have okayed, or was that something developers came up with? IMO it's unfortunate for a project to be using \"present\" because it makes it more difficult to determine in the future what years apply to a full or partial snapshot of some project, e.g. if a file from one project is copied into another project in accordance with the terms of the license of the originating project.   Thanks, @marktani!  Moved the PR onto this branch \r\n#320  @robzhu @IvanGoncharov I update the PR here. Can you please post a screenshot of the rendered spec document? Also, please don't forget to update the language grammar appendix <img width=\"921\" alt=\"screen shot 2017-06-14 at 20 36 44\" src=\"https://user-images.githubusercontent.com/6065744/27148686-727d072e-5141-11e7-9c0c-a68c8e007018.png\">\r\n Thanks! As I expected it's not rendering correctly. Notice other optional tokens have an <sub>opt</sub> subtext after them. This appears to require the literal character `?`. Do you think this form is weird or challenging to read? (open to advice)\r\n\r\n```\r\nUnionMembers :\r\n  - LeadingPipe? NamedType\r\n  - UnionMembers | NamedType\r\n\r\nLeadingPipe : |\r\n```\r\n\r\nOtherwise a change to spec-md will be required to allow for optional terminals @leebyron I'm already working on a PR on `spec-md`I think it will be a lot more readable to have <sub>opt</sub>  As it stands, the spec is unclear on what to do when an Non-Null element of a list resolves to null. These changes clarify that the entire list should resolve to null, and to propagate the error upwards Thank you for this clarification. I agree this is a helpful addition!  Minor typo fix. Thanks @iamaldi. FWIW I think the original wording was intentional and not a typo (it's grammatically valid) but your wording is nicer so let's go with it! @wincent That's my first pull request so I'm happy with that :+1:  !!!  Per #288  Superb! Thanks a lot @gtod.  Based on https://github.com/graphql/graphql-js/issues/797. Thanks, @xpepermint. With pleasure :).  Updated two Star Wars sentences that ended in a preposition and capitalized Episode V. Thanks. :-)  This proposal expands upon the ideas described in #294 (which ended up already being implemented).\r\n\r\nI'd like to suggest that GraphQL be expanded to allow an `interface` to `implement` another interface. This would allow for higher order interfaces and open the door for frameworks and tooling to describe their requirements in GraphQL, which would be implemented in userland interfaces and types.\r\n\r\nHere's a (very contrived) example borrowed from #294 and expanded upon to show how hierarchies would exist:\r\n\r\n\r\n```graphql\r\ninterface Pet {\r\n\tid: !ID\r\n\tsex: Sex\r\n\tname: String\r\n\tmother: Pet\r\n\tfather: Pet\r\n}\r\n\r\ninterface Equine implements Pet {\r\n\tid: !ID\r\n\tsex: Sex\r\n\tname: String\r\n\tmother: Pet\r\n\tfather: Pet\r\n\thands: Float\r\n}\r\n\r\ntype Horse implements Equine {\r\n\tid: !ID\r\n\tsex: Sex\r\n\tname: String\r\n\tmother: Horse\r\n\tfather: Horse\r\n\thands: Float\r\n}\r\n\r\ntype Donkey implements Equine {\r\n\tid: !ID\r\n\tsex: Sex\r\n\tname: String\r\n\tmother: Donkey\r\n\tfather: Donkey\r\n\thands: Float\r\n}\r\n\r\ntype Mule implements Equine {\r\n\tid: !ID\r\n\tsex: Sex\r\n\tname: String\r\n\tmother: Equine\r\n\tfather: Equine\r\n\thands: Float\r\n}\r\n```\r\n\r\nWhat's important here is that in a context where we generically have `Pet`s, each pet's `father` is only guaranteed to be a `Pet`. When we know we have a `Mule`, though, we know that its father is an `Equine`.\r\n\r\nWith these two features, tools which currently depend on schema *conventions* (like the Relay specs) could codify their requirements with GraphQL.\r\n\r\n### A Real-World Case\r\n\r\nI have been working on a system which allows offline, concurrent modifications to versioned documents. The problem and solution are very generic, but the current state of the GraphQL type system doesn't allow me to describe these general-purpose shapes. Much like the Relay team had to define a convention for any type ending in `Connection`, I have an internal spec describing any type with a name ending in `Object`, `Entity`, and `Change`. So, for example, I have a `HikeObject`, `HikeEntity`, and `HikeChange`; I also have a `ClimbObject`, `ClimbEntity`, and `ClimbChange`.\r\n\r\nI've found myself wishing I could use the GraphQL type system to describe these requirements, and because the current spec is *so close*, I find myself thinking of the schema in these terms.\r\n\r\nThis would make that possible, and bring GraphQL's type safety to tools that solve generic problems with GraphQL. As I've continued the think about this, I wanted to clarify a point:\r\n\r\nIf an interface implements another interface, it MUST specify compatible fields in its own `fields` list.\r\n\r\nThis keeps all the simplicity of the current system (with the total absence of inheritance, and a flat interface implementation strategy) while adding the functionality of chained interfaces.\r\n\r\n I also have a \"real world\" use case for this and would love to see this added to the spec. What are the concerns? @mike-marcacci, only a suggestion: would it be possible to consider using `extends` instead of `implements`?\r\nI am relatively new to graphql, but I find that most devs coming from any language or environment think of interfaces extending other interfaces, while types and classes implement interfaces. I think this would apply even in the scenario above where you mention that interfaces down the chain MUST specify all fields in their own fields list. Hi @stanishev! Thanks for the comment \u2013 I definitely thought about using this terminology, and considered how it might be interpreted by programmers of various languages. When writing this issue, I decided against `extends` to avoid the misconception that I was advocating for inheritance.\r\n\r\nIn fact, it's quite possible that there is a use-case for true inheritance (by which I mean applying the field definitions of one or more parents), while my use case simply needs the ability to *describe* a hierarchy. I would argue that `extend` is a *different* potentially-useful feature, in which a concrete type might define its fields by reference to other concrete types. I wanted to avoid misappropriating this word to describe a concept that's already fully contained by the `implements` keyword in GraphQL (albeit currently only for concrete types).\r\n\r\nAlso, I wanted to avoid bringing into the discussion the complexities of inference in general: In what order of precedence might a multi-parent inheritance effected? What happens when parents have non-identical (but potentially compatible) field types (type variance)? Can I \"sub-class\" a parent to have a non-compatible field type? etc...\r\n\r\nAll that said, if the GraphQL team chose to add this to the spec under the keyword `extends`, I would be more than happy to have it. I do think, though, that reusing `implements` here is a bit smaller of a request :) Not sure how mixins/inheritance got involved, but could that discussion happen in a new thread if you'd like to advocate for it? Either of those concepts would be more complicated than what this issue proposes, and I'm very interesting in seeing this proposal added so would rather not see the discussion veer off.\r\n\r\n(Mixins sound interesting, but the GraphQL team seems acutely interested in keeping the spec as simple as it can possibly be, and IMHO mixins are not simple.)\r\n\r\n---\r\n\r\nAny thoughts from the core team on this? Would you be open to a PR? I'd love to help @mike-marcacci out with this but wouldn't want to waste the effort if you think it's unlikely to be accepted. While this is being discussed, does anyone have a clean workaround that they are using? I would also make use of this at Zillow, where our type system includes a hierarchy of property records, in which the most basic type is a PublicRecord, which is extended by a PropertyRecord (includes attributes added by Zillow systems), which in turn is extended by a PropertyListing (includes attributes added by an agent or owner).\r\n\r\nIs anyone already working on a PR to incorporate this proposal into the spec? @MatthewHerbst @jwb While I don't want to reintroduce mixins/partials as a solution to this issue, I do wanted to point you to https://github.com/graphql/graphql-js/issues/703#issuecomment-341128954 and the solution I outlined there and the transpiler/polyfill I created to solve my need for making my schema more DRY by adding mixins/partials: https://github.com/Sydsvenskan/node-graphql-partials\r\n\r\n(It's a solution that would also help in making heavy usage of interfaces manageable \u2013 ensuring all implementations are in sync with the fields defined)\r\n\r\n@tylercrompton Did you create another issue for the mixin case? Would be good to link https://github.com/graphql/graphql-js/issues/703 to that one if so If mixin support were added, I would make use of it. I feel that enabling inheritance of interfaces is a basic feature of a type system and I need it more than I need mixins, since I can accomplish what I would use from mixins (minus inheritance) with code generation. For anybody following along, I went ahead and made a PR to add this to the spec: #373\r\n\r\nIf I can get some kind of indication from the GraphQL WG that this would be considered, I'll go ahead and implement it in [graphql-js](https://github.com/graphql/graphql-js). @leebyron thanks so much for the very thoughtful response! I'll definitely join the next WG meeting if that would be helpful (I just subscribed to the wg repo so I can add myself once the agenda is up).\r\n\r\n<br />\r\n\r\n> It's just much simpler to have Object types describe all the interfaces they implement directly rather than having to walk a hierarchy.\r\n\r\nI thought about requiring implementing types to re-declare indirectly-implemented interfaces. In the toy example above, then, `Horse`, `Donkey`, and `Mule` would all need to specify: `implements Equine, Pet`. I decided against this, though, since there is an ergonomic cost when writing/maintaining a schema, and wouldn't make improvements on the change cost.\r\n\r\n<br />\r\n\r\n> So we should just ensure the value it provides would be worth that cost.\r\n\r\nI definitely understand the resulting change cost here. I skimmed through the WG notes and CONTRIBUTING.md but didn't see any formal policy on how/when breaking changes are applied to the spec.\r\n\r\nI'll work on a companion PR to graphql-js and dive into relay to get a better understanding of what kind of changes this would require. This is implemented in graphql/graphql-js#1218 Per discussion at this week's WG meeting, I set out to better describe my real-world case here as a *justification* for this feature, as opposed to the highly contrived example from this issue.\r\n\r\nHere's the essence of my use-case, but using [Connection](https://facebook.github.io/relay/graphql/connections.htm) terminology to avoid having to explain the intricacies of my system:\r\n\r\n```graphql\r\ninterface Node {\r\n  id: ID!\r\n}\r\n\r\ninterface Edge {\r\n  cursor: String\r\n  node: Node\r\n}\r\n\r\ninterface Connection {\r\n  pageInfo: PageInfo!\r\n  edges: [Edge]\r\n}\r\n\r\ntype PageInfo {\r\n  hasPreviousPage: Boolean\r\n  hasNextPage: Boolean\r\n  startCursor: String\r\n  endCursor: String\r\n}\r\n\r\ninterface NamedNode {\r\n  id: ID!\r\n  name: String\r\n}\r\n\r\ntype NamedEdge implements Edge {\r\n  cursor: String\r\n  node: NamedNode\r\n}\r\n\r\ntype NamedConnection implements Connection {\r\n  pageInfo: PageInfo!\r\n  edges: [NamedEdge]\r\n}\r\n\r\ntype SomeNamedThing implements NamedNode & Node {\r\n  id: ID!\r\n  name: String\r\n}\r\n\r\ntype Query {\r\n  someQuery: NamedConnection\r\n}\r\n```\r\n\r\nNote that this schema fails validation with:\r\n\r\n```js\r\n[\r\n  {\r\n    \"locations\": [\r\n      {\r\n        \"column\": 9\r\n        \"line\": 7\r\n      }\r\n      {\r\n        \"column\": 9\r\n        \"line\": 29\r\n      }\r\n    ]\r\n    \"message\": \"Interface field Edge.node expects type Node but NamedEdge.node is type NamedNode.\"\r\n    \"path\": [undefined]\r\n  }\r\n]\r\n```\r\n\r\nthe solution is simply to allow `NamedNode` to declare that it implements `Node`:\r\n\r\n```graphql\r\ninterface NamedNode implements Node {\r\n  id: ID!\r\n  name: String\r\n}\r\n```\r\n\r\nUsing this updated schema in the [proposal's branch of graphql-js](https://github.com/graphql/graphql-js/pull/1218) works exactly as expected and is able to simultaneously communicate that:\r\n\r\n1. `NamedConnection` is intended to be used as a `Connection` by the generic pagination code\r\n2. Any `NamedConnection` will only have `NamedNode` results, and can be queried without having to use fragment type conditions:\r\n  ```graphql\r\n  query {\r\n    someQuery {\r\n      edges {\r\n        node {\r\n          name\r\n        }\r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\n---\r\n\r\n<del>Now for the twist.</del>\r\n\r\n<del>After the WG meeting, I set out to show how my problem could not be solved with the current spec; but instead, I found another way to accomplish my goals. Armed with a much better understanding of introspection (thanks, ironically, to implementing this feature in graphql-js) I realized that it is quite trivial to determine all the possible types of a field, and inject the appropriate type-conditional fragments (which was essentially my use case). Given the allegory above, I essentially decided that I didn't really need the `Connection` or `Edge` interfaces at all.</del>\r\n\r\n<del>The one remaining itch for me is that there is currently no way to indicate within the schema that a type is intended to be used in a generic capacity apart from naming conventions. This however, could be solved by exposing type-level metadata, which is a feature that appears to enjoy wide support from the WG.</del>\r\n\r\n**EDIT: I've circled back to this proposal. While queries *can* be generated without this, you lose out on the expressiveness and type guarantees that graphql provides natively. Hierarchal interfaces would cause compile-time validation errors for invalid schemas, which are far preferable to runtime bugs.**\r\n\r\nSo while I do believe this proposal generally improves the expressiveness of GraphQL and I think the example above clearly demonstrates a limitation of the current spec, I am going to ease off my campaign for it.\r\n\r\nI'd like to leave these issues/PRs open until the next WG meeting to allow anybody else with a real-world use case to chime in. I'd also really be interested in any estimations of change cost, particularly from the perspective of tooling maintainers.\r\n\r\nIf we don't have a compelling case for this change at the next meeting, I'll happily close these issues :-)\r\n @mike-marcacci Great post. Can you please show any of the code you used to achieve the workaround? Hey @MatthewHerbst, I\u2019m not actually using this for connections (I let relay handle that) but instead custom wrapper types for revision control & offline support, so none of my code is going to make sense without a lot of explaining. However, I can tell you that I essentially keep a list of `Entity` types (analogous to `Connection` implementations above) that should support offline behavior. I then traverse the introspection looking at all the `possibleTypes` for instances of these. Then, when proxying queries, I inject type-conditional fragments where applicable. This has several drawbacks: I might have to inject several type-specific fragments instead of 1 interface-specific fragment (which would be fixed by this issue); but I also run the risk of causing field merge issues (see #399). I\u2019m not particularly happy with my solution anymore, to be honest, so when I have time to revisit it I\u2019m going to look at doing things at compile-time (a la Relay). Another use, also tied with pagination is when different interfaces need to be paginated.\r\n\r\nSuppose we have an interface Profile, and two implementations: UserProfile and TeamProfile\r\n\r\nWithin the current featureset, I cannot see a solution to be able to deduct that UserProfilePagnated and TeamProfilePaginated can be supplied where we are expecting PaginedProfiles.\r\n\r\nMy first thought was generics and covariance:\r\n\r\nWith generics - although not trivial, one can make a complex analyzer that understands the notion of co and contravariance, and can deduct that PaginatedProfiles is an interface of UserPaginatedProfiles, although one might need to signal this somehow.\r\n\r\nBut @mike-marcacci's interface extensions could also be a solution, if the interfaces redefined the pagination fields Github GraphQL API uses interfaces https://developer.github.com/v4/interface I'm sorry that I can't point at code, but I really want to my schema to express the relationship:\r\n\r\n    location <|- property <|- listing  As #292 I believe it will be beneficial to clarify that\nspecifying the operation name when handling multiple operations\nis up to the implementation, not the query language.  Just update the Markdown to make the sub-classes clearer. Thanks @h3h. Good catch.  Hi! I want to create different GraphQLObjectType mutation\\queries for each separate model.\r\n\r\nIn present time in GraphQL server we have one schema with two parameters: queries and mutations. \r\nEach of which accepts GraphQLObjectType and includes differents fields. In library we have some think like this on the example of mutations:\r\n\r\n**Mutations:**\r\nUserAdd\r\nUserRemove\r\nArcicleAdd\r\nMapAddPin\r\n..etc\r\n\r\nRoot mutations include list of all fields, - yes because we import all fields in one GraphQLObjectType. I want to use for each separate model GraphQLObjectType, that i can get in my library next option:\r\n\r\n**Mutations:**\r\n- User\r\nUserAdd\r\nUserRemove\r\n- Arcticle\r\nArcicleAdd\r\n- Map\r\nMapAddPin\r\n\r\nThanks.  @robzhu exactly This is a duplicate of #252  @stubailo: Is it? I thought #252 was about implanting mutation/serial-execution semantics at arbitrary points within query operations, whereas this one seems to be about organization within mutation operations. > I want to use for each separate model GraphQLObjectType\r\n\r\nMy understanding is that @nikitamarcius wants to have separate mutation GraphQL Object Types for each kind of data. To me that sounds the same as being able to mark arbitrary GraphQL Object Types as a \"mutation type\", which is what #252 is about.\r\n\r\n(Note that AFAIK the mutation type can already appear anywhere, if you just return it from a field: `type Query { mutation: Mutation }`)  I think in many cases, developers use subscriptions to approximate live queries, but subscriptions are more powerful and easier to implement.\r\n\r\nFor example, in my case, where I have many microservices on my backend, where some nested fields go to other services, it's not really straightforward to define how live queries would work, and I've chosen explicitly to model things as event streams.\r\n\r\nLive queries would be a nice abstraction on top, but it's only that \u2013 it's not, in the general case, a great backend building block. I don't think this discussion should be judging about whether or not live queries are better than subscriptions, just whether they are different enough that they should be considered independently.\r\n\r\nI think \"building block\" is a great way to look at it though - subscriptions are a great well-specified unit of realtime data push that can be used to build a lot of other cool stuff. The fact that it's very easy to implement a spec-compliant subscription on the server side is pretty awesome, even if it's not always the thing you want as a client-side developer. I'd like to know first what people consider live queries to be. What is the definition? I ask, because I think there are different perspectives or ideas in play here, and thus the discussion can run in unnecessary tangents. \r\n\r\nSo, what is a live query? \ud83d\ude04 \r\n\r\nScott Here's my impression of a live query in one sentence:\r\n\r\n\"A live query is a query where some or all of the parts can be marked as 'live', and the client expects to receive updates whenever any of those parts would have ended up with a different result if refetched again.\"\r\n\r\nIn short, they should be a drop-in replacement for polling. Here is my definition.\r\n\r\nA live query is a query, which is designated by the client as \"live\". This designation is passed on to the GraphQL server (one could say it is a subscription). The server then observes for triggers or data input from the underlying data sources needed to fulfill any part of the query. This in turn means any updates from the underlying data sources will be passed to the client automatically via bi-directional communication.\r\n\r\nScott If you want a demo of a live query, complete with a GraphiQL editor, see http://rgraphql.org\r\n\r\nLive queries are infinitely more powerful than subscriptions because you can model live, reactive data in a way that efficiently encodes changes all the way from the data source to the browser, into something like react and angular. And it's not true that they cannot be done at scale - is definitely possible with a good enough scheduler / balancer.  > Live queries are infinitely more powerful than subscriptions\r\n\r\nI agree with this.\r\n\r\n> And it's not true that they cannot be done at scale - is definitely possible with a good enough scheduler / balancer.\r\n\r\nI also agree with this.\r\n\r\nHowever, I think they are significantly different from subscriptions nonetheless, and both have their place in the GraphQL ecosystem. > However, I think they are significantly different from subscriptions nonetheless, and both have their place in the GraphQL ecosystem.\r\n\r\nAgreed. I don't think live queries are necessarily difficult to do, though, either - the argument I'm arguing against is - \"live queries at scale isn't a solved science, so we're going to ignore the concept entirely.\"  Yeah I think it's important that the spec proposal doesn't say \"this is the only thing we will ever do for realtime data\" or even \"this is the best way to do realtime data\" - it should just say \"this is the way of doing realtime data that is understood clearly enough to specify\" That is a great question, but it blows my definition of live queries out of the water. Doesn't it? Hehehe... LOL! \ud83d\ude04 \r\n\r\nIf I may answer too. I think with Christian's  (@paralin) rqraphql system, live queries are a server-side and domain specific decision. From what I understand from the rgraphql docs, if you want a live query, the ability to observe for updates is \"baked\" into one or more resolvers for that query. And, I believe this is where this concept has a general concern (and something still missing in the spec too). It requires a front-end dev to have intimate knowledge of the back-end decisions, as the type of query (live or not) cannot be directly \"seen\" through introspection, whereas, it should be. Sure, one could add some type of comment, but is that really a good solution for flagging queries as \"potentially live\" with introspection? \r\n\r\nThe other question that burns in my mind is, how does the server know who to broadcast these updates to? The docs mention killing long running processes. That is only scratching the scaling issue. \r\n\r\nI guess I am the stupid guy on the fence between these two solutions. I don't think GraphQL should be working with events internally. They aren't needed, as Christians's rgraphql system proves. Yet, I don't think pure live queries, without some sort of subscription system, are also the right solution either. \r\n\r\nOh. And just because a live query has a subscription system tagged to it, doesn't mean it can't be called a live query. \ud83d\ude09 \r\n\r\nScott @robzhu \r\n\r\nI do think of them as semantically different. It would be awkward to do a toast notification with a live query rather than an event-based subscription stream, for example.\r\n\r\nThat said, I am mostly using subscriptions as a poor man's live query system, with easier-to-understand semantics on the backend. If I had a reactive backend that supported live queries, I would mostly move to using live queries \u2013 but I don't, and I decided it wasn't worth the architectural trade-offs required to do so.\r\n\r\nAdditionally, I expect the majority of users of GraphQL subscriptions as-is to use them to do something somewhat similar to my use case of emulating live queries in an easier-to-implement manner for complex back end systems. @smolinari don't you mean my system? :)  @paralin - Sorry about that. You are right. *Me goes correcting*\r\n\r\nScott So are we saying that the difference between a \"Live Query\" and a \"Subscription\" is essentially how the updates are pushed? A LQ will send you any updates automatically that effects the original query, whether it be an add/remove/update, a Subscription needs a \"manual\" push of new data, allowing the programmer to be selective about _what_ updates are sent? @siyfion in rgraphql at least the developer still has fine control over what gets sent to the client, the system just manages getting those changes to the client and applying them properly. \r\n\r\nThe only difference I can see really is that subscriptions are limited to the root level of the query only, and cannot be updated after they have begun. These properties are probably good for when you're subscribing to general streams of events. I wouldn't use it for live data though. \r\n\r\nImagine you're trying to build a news feed with comments. What happens if someone edits a comment? Do you just push a event saying it was edited via a subscription? But then all of the logic to apply the updates has to be hand built separately for each of the types of things you might want to update. That seems wrong to me. \r\n\r\nInstead you can just subscribe to the same streams of data on the server, interpret them correctly, and then send back updates to the client tailored to the data they already have.  @paralin - How does your system know when to send the news feed updates or rather, to which clients?\r\n\r\nScott @smolinari that's up to the developer to decide. In Go we have strong concurrency patterns around streams of data, and Magellan supports all of those patterns when resolving fields. When a user subscribes to some live query the server decides how it will fill that query, and the developers code can return many different permutations of result representations, including ones that change over time. >  When a user subscribes to some live query\r\n\r\nI missed how this can be done with rgraphql. Can you point me to the docs (or code), where this is explained (done)? \r\n\r\nScott @smolinari http://github.com/rgraphql/soyuz\r\n\r\nNot much in the way of docs yet, mostly focusing on optimizing and getting in mutations right now. But the interface is the same as in Apollo. Call query, returns an observable, subscribing to the observable triggers the query to actually be applied. The system merges together the entire tree of active queries into one query object and keeps that in sync with the server. \r\n\r\nThere is a lot of information on how it works in the protocol.md doc under I think Magellan (I'm on my phone right now, apologies for the lack of a link) > What happens if someone edits a comment? Do you just push a event saying it was edited via a subscription? \r\n\r\nYup, that's how we would do it.\r\n\r\n> But then all of the logic to apply the updates has to be hand built separately for each of the types of things you might want to update. That seems wrong to me.\r\n\r\nFor us, the subscription payload that gets pushed to the client is the same type as a comment_edit mutation payload, and the client already has logic for updating the comments UI in response to a comment_edit mutation response. In general, on our native clients and in Relay, we have client-side infra that is smart about taking GraphQL responses, sticking them into a GraphQL cache, and updating the UIs accordingly, so it's not actually as bad as you make it sound to add logic to handle a subscription response. And yet you have to base every change on mutations.\r\n\r\nI'm building a app right now that is extremely reliant on outside data - that is, sensor data, position data, connectivity, etc from a large number of sources. To make a mutation to affect every little change to this data would be impossible. This type of live data is something well suited to GraphQL, because the client can subscribe to only what it needs. It's also something that cannot be done with subscriptions in any tractable way.\r\n\r\nThis example I believe reveals that there are actually two types of live data that a GraphQL user might want to have: streams of updates to individual fields, along with batch updates as a result of measurable transactions. \r\n\r\nI believe this is the best argument yet for building two different live mechanisms into GraphQL.  Just catching up on everything in this thread. I'm seeing two general questions being discussed here: \r\n(1) How hard is it to implement live queries?\r\n(2) Are GraphQL subscriptions useful in their own right, even in a world with working live queries?\r\n\r\nRe: (1), we believe based on experience at Facebook and discussions with other folks that the *general* problem of implementing live queries at scale is not easy. This doesn't mean that it is always hard; with an efficient reactive backend, implementing live queries becomes fairly straightforward. As @taion mentioned, though, some folks might have \"many microservices on [the] backend.\" Some might have tens or even hundreds of different DBs and services backing the data in their GraphQL schema. The general problem of moving all of the backing data for a GraphQL schema to a reactive backend is quite challenging. \r\n\r\nHowever, I think we're getting off-topic by focusing on question (1). The more relevant question for this RFC is (2). Based on my experience working with a bunch of Facebook product teams building real-time features and rolling out GraphQL Subscriptions at scale over the past two years, I believe that the answer to question (2) is yes. We've seen cases where product folks explicitly design their real-time experience around events. They need control over things like which specific events get priority when the rate is too high to deliver all updates. @paralin said previously that \"Live queries are infinitely more powerful than subscriptions.\" I'm not sure if I agree with this, and I'm also not sure that it's useful to debate the meaning of \"powerful\" (super relevant talk: https://www.youtube.com/watch?v=mVVNJKv9esE) but one thing I will say about subscriptions is that they put more *control* into the hands of the product developers over which updates they'll receive.\r\n\r\nWe have also seen examples that lend themselves nicely to live queries, and some people in this thread have mentioned examples of that sort. Internally, we are still experimenting and working with product teams to arrive at a general understanding of which use cases are better served by subscriptions and which are better served by live queries, but we are confident that the former is not an empty set. @laneyk Agreed in full. I don't dispute that I've been overstating the worth of live queries a bit, primarily because I'm passionate about seeing them considered due to their value in my particular niche applications. I don't believe that live queries are the *only* way to do it, just that they are an effective mechanism in a lot of small to mid scale applications.\r\n\r\nIt makes sense that live data and events would have very different mechanisms. > One thing I will say about subscriptions is that they put more *control* into the hands of the product developers over which updates they'll receive.\r\n\r\nThis is one thing that I see consistently in the design of GraphQL. Besides the debate between live queries vs. subscriptions it may be worth thinking about this client-developer-control as a key design point of GraphQL.\r\n\r\nIf you think about mutations, they require a lot of work on the client developer\u2019s side to update the cache. This is a problem that Apollo Client, Relay, and any future GraphQL clients will struggle with. A lot of GraphQL beginners really want mutations to be \u201cmagical.\u201d They want to send a mutation to submit a comment and have that comment be automagically inserted into their pre-existing list with zero boilerplate, but GraphQL wasn\u2019t designed to be magical it was designed to be practical.\r\n\r\nIn its practicality GraphQL tries to enable both the server and the client developer as much freedom and flexibility to work in and around the query language without over-prescribing. The server developer may require a token in an HTTP header, or return a JSON blob as a scalar field. The client developer may implement super custom updates to their data based on a mutation or subscription which takes into account variables only the client knows, like a local priority based on what screen the user is on. However, this practicality comes at the cost of some higher-level \u201cmagic\u201d features that would make development much faster such as live queries or zero boilerplate mutations on the client.\r\n\r\nI like that GraphQL has chosen to be practical. It\u2019s the same choice React has made whereas Angular has chosen the \u201cmagic\u201d route. If you want magic in the data API space I heavily encourage you to check out [Falcor](http://netflix.github.io/falcor/). Unlike GraphQL, Falcor\u2019s design is optimized for some of these magic features like live queries and simple mutations that people would like to see (Albeit you probably won\u2019t get any magic from Falcor in its current form, but I think the design is there. Also forget about the fact that Falcor doesn\u2019t have a schema! You could easily write a version of Falcor with static types and get the same GraphiQL experience).\r\n\r\nWhat do you think? Do you see the same consistent choice in design decisions? Do you agree that live queries are a \u201cmagical\u201d feature?\r\n\r\nMy point isn\u2019t so much to argue for-or-against live queries (or even for-or-against magic!), I just wanted to make an observation about the design of GraphQL that I\u2019ve noticed from time to time \ud83d\ude0a\r\n\r\n(since it was mentioned this talk **is** amazing https://youtu.be/mVVNJKv9esE and its concepts apply to this observation as well) @calebmer You don't need to have a feature in the spec to build it. Projects like mine that add real-time to GraphQL operate with GraphQL in its current form, and declare their own rules as to how data is handled. Therefore they are derivative of GraphQL and perhaps compatible while not GraphQL in their own sense.\r\n\r\nGraphQL definitely can support these types of things, and I believe it's productive to at least discuss inside the bounds of GraphQL without deferring to other products entirely.\r\n\r\nYour point absolutely holds - GraphQL's spec doesn't really need to have real-time built in. It would be nice, but it would always be labeled as an optional feature anyway. Maybe it's best to leave these features to derivative projects to define, with loose guidelines in the spec? I believe subscriptions should be in the spec for sure, but real-time maybe not. [That talk](https://www.youtube.com/watch?v=mVVNJKv9esE)'s really good and definitely applies here, thanks for the link! It seems like a lot of the discussion has been about things outside of\ngraphql (how upstream implements events as per @laneyk, but also the\nsemantics encoded within events, eg update vs new state). Is there any\ndifference in the (external) behavior between what has been proposed and\nlive queries beyond how the request is interpreted?\n\nAs best I can tell subscriptions (with a bit of hand waving)  represent a\nsubset of one or more possible live query specs in that subscription is\nbased solely on the arguments passed to the root, whereas a live query will\nuse the whole query.[1] Everything else is either transport level stuff\n(subscription, errors, etc) and so common between the two, or event\nsemantics (new state, update etc) and opaque to graphql.\n\n[1] I'm cheating by ignoring any details how to design a specific live\nquery syntax, complexity of implementation, etc, since it's moot to my\npoint, as well as anything about the client updating their query\n > As best I can tell subscriptions (with a bit of hand waving)  represent a\r\n> subset of one or more possible live query specs in that subscription is\r\n> based solely on the arguments passed to the root, whereas a live query will\r\n> use the whole query.[1] Everything else is either transport level stuff\r\n> (subscription, errors, etc) and so common between the two, or event\r\n> semantics (new state, update etc) and opaque to graphql.\r\n\r\nThis is incorrect. A subscription doesn't have to correspond to anything in your query proper. It can be a pure event-only stream. > A subscription doesn't have to correspond to anything in your query proper. It can be a pure event-only stream.\r\n\r\nNot sure I follow this. I am under the impression that to subscribe you have to make a query. The root of this may contain zero or more arguments that the subscription resolver would use to determine what to send and when. The query object below the root would then be used to filter the response. @jamesgorman2 Yeah, but the data returned from the subscription doesn't necessarily conform to the selections in the query, is what he's saying I think. Although that wouldn't make much sense. Why have a query body if you're not going to respect it?\r\n\r\nEdit: see @taion clarification below, makes sense. I'm saying that the data in the subscription doesn't have to be something that can be grabbed from a normal query. Imagine something correspondingly purely to a transient event stream. Ah, looks like we're talking at cross purposes then. I'm using query in the sense of the message that is sent by the client to the graphql server during subscription, eg\r\n\r\n```\r\nsubscription {\r\n  foo(bar: 'baz') {\r\n    # stuff here\r\n  }\r\n}\r\n```\r\n\r\nThere is a subscription mechanism and transport protocol from client to server over which this is sent. There is also an event generating mechanism between the server and upstream that is opaque to a graphql server framework. The graphql server framework's job is to render the subscription query readable to the subscription resolver, then convert the events returned from upstream and emitted by the resolver into the correct graphql response object. @jamesgorman2 I had considered wrapping my \"live queries\" in the subscription tag but I find it's more flexible to blend regular and live data together side by side. As someone browses through an app, the app will constantly be subscribing and unsubscribing from just the fields it needs. This is the powerful part of live data - my frontend can pull literally exactly what it needs at any given time, nothing more, nothing less.\r\n\r\nIn terms of limiting what is live from a developer's perspective. I will probably add a `@live` directive that \"turns on\" live fields for all subfields. In rgraphql at least, `@defer` and `@stream` are implicit - results are streamed back as they are resolved, and because of this every field is deferred and every array is streamed. However, @live could be used to turn on and off live updates for a query tree and/or its sub-trees. @paralin - you have me sold now. Live queries with the `@live` directive to subscribe to them for the win! \ud83d\ude04 \r\n\r\nHowever, I am still not clear on how you'd turn off the query/ subscription. How would that work? \r\n\r\nAnd how does the server know who to send the updated data from a live query to? There could be 100 clients waiting and listening, yet let's say only 2 subscribed to get the updated data, not all 100. How can that be controlled? I can't imagine we'd want to simply broadcast any and all updates. \r\n\r\nI guess I am wondering if GraphQL should even be considered a gateway in this fashion (using live queries). It seems to me, there needs to be a subscription system in front of GraphQL (no matter what). The subscription system would control who gets what, when and to whom and GraphQL would only concerns itself with the feeding the subscription system with the \"what\". \r\n\r\nThis also might be showing my lack of knowledge in terms of a websocket kind of communication and exchange of messages. So, go easy on me. \ud83d\ude04 \r\n\r\nEdit: also thanks for that link to the talk. Very interesting take on abstraction.\r\n\r\nScott The `client.query<T>(options)` function returns an `Observable`. The system subscribes to the query fields when at least 1 subscriber is viewing them. It keeps a refcount, so if your app requests the same thing 10 places, it will only actually send a single field subscription.\r\n\r\nEvery client running a query gets its own resolver function call for each field. The Go server does these in parallel, so they're extremely fast in general. You could return an existing Go channel from these functions for example, to direct the system to subscribe to a stream of values coming from elsewhere, and send them to the client until the client unsubscribes. Or, you could manage the stream of data more tightly, using a \"live function\" that terminates the field when it returns. The system adapts to your code AST dynamically at runtime. I suppose the general answer to this thread is - **no** - the two are NOT the same thing.\r\n\r\nA good follow-up would be, \"Live Queries: do they belong in the spec?\"\r\n Well, if you add subscriptions as a necessary part of live queries (which I think we can all agree on, they are), then we are still talking about a subscription system in general, which would be the same thing. \r\n\r\nHowever, if we are talking about how to resolve those subscriptions, either with active pushing of updates in live queries or with an elaborate pub/sub event system, then we are talking about two different things. \ud83d\ude04  \r\n\r\nSo, I think the better question is, what is the best solution for subscribing to changes in data and getting the results of those subscriptions? \ud83d\ude04 \r\n\r\nScott Subscriptions as they are defined in GraphQL are not necessary for live queries. Furthermore, resolving subscriptions is going to be part of the spec, and is designed around a very different use case from live queries.\r\n\r\nMy previous suggestion still stands.  > Subscriptions as they are defined in GraphQL are not necessary for live queries.\r\n\r\nI thought subscriptions in general are necessary for live queries, in order for them to scale well. I realize the subscription system defined here doesn't match a live query subscription system. That is beside the point. (Edit: or maybe it is the point?)\r\n\r\nActually, my main concern is the definition of an event system out of the domain layer to trigger the GraphQL subscription system. I just don't think that should be necessary, or rather, an event system should be a domain responsibility and not part of the spec. Your live query system proves this is possible @paralin Christian). \r\n\r\nI see GraphQL subscriptions as a live query system with subscriptions. How the data is force-fed into GraphQL \"live\" from the backend data sources is then a domain specific concern. Right now, as I understand the current RFC, we are going from a bi-directional data flow to the client to a request/ response data flow from the backend data sources, plus some sort of events. But, what if I can connect to a data-source bi-directionally (I am also thinking about bi-directional microservice communication like gRPC too)? With events, I'm locked into working with or around a prescribed triggering methodology. With live queries, I am not. \r\n\r\nOne might argue that most backend data sources are request/response systems anyway and why we need events. But, that is due to past technologies. For truly reactive systems, live queries are the future and it is why newer databases and data storage/ persistence technologies are adding live query technology in their systems. Live queries makes the system a good bit more efficient.\r\n\r\nI can understand why Facebook might want it this way. It probably fits their systems better. I just think that is a bit closed minded. Sorry, if I step on toes by saying that. I actually think this might be something that could be effectively big in savings for Facebook in the end, if my assumptions are correct and they step out of their own box. I certainly appreciate the chance to try and make that happen. \ud83d\ude04 \r\n\r\nI'll bow out of the conversation now, unless someone mentions me. I've said what I wanted to. \r\n\r\nScott You are correct in that the concept of subscriptions is important for live queries - for example, you would subscribe to the result of a query on the client to inform the system that you're interested in knowing about it. I agree with all of your other points as well - particularly around the \"domain level\" implementation of reactivity. \r\n\r\nRecapping/summarizing now:\r\n\r\nGraphQL subscriptions refer to the \"subscription\" operation as opposed to the \"query\" or \"mutate\" operations. They are tightly bound by the spec, and designed more for event streams than live updates. \r\n\r\nIt's become clear now that live queries are still a \"query\" operation with some parameters or directives applied. The actual handling of those queries is done at a framework level, like in Relay or Magellan or Soyuz or Apollo, etc. As of now, the spec has everything necessary to handle these queries - directives (which are server defined), and the \"query\" operation. In the context of the language, we have everything we need, as far as I can see. Although this is closed, I'd like to put in my last input to this daunting question. It's probably too late to make any difference, but here goes anyway. \r\n\r\nI reread [this part of the blog post about the subscription system in GraphQL and Relay](http://graphql.org/blog/subscriptions-in-graphql-and-relay/#why-not-live-queries), and it dawned on me what the difference is between a subscription system and a live query system. A subscription system is business logic centric. A live query system is data centric. \r\n\r\nIf you read that article (please do, if not again), it's reasoning for not using live queries is, because, with a live query, you can't make heads or tails of which business logic should be covered to evoke the update to the client.\r\n\r\nSo, I ask two questions. \r\n\r\n1. Who care's what the business logic reasons are to update the client?\r\n2. With a pub/sub event based solution, are you possibly actually forcing these business logic decisions to be made, in order to update the client properly? \r\n\r\nProvocative questions for sure. And, I'd love to hear the answers of Dan or Lany or anyone else who thinks live queries offer the stumbling block of not knowing why an update should happen. \r\n\r\nUntil, and if, anyone answers, let me explain why I think the reasoning in that article is a bit flawed and that this stumbling block isn't one. Let's look at the example fragment used in the article to argue against live queries again. \r\n\r\n```\r\nfragment StoryLikeData on Story {\r\n  story {\r\n    likers { count }\r\n    likeSentence { text }\r\n  }\r\n}\r\n```\r\n\r\nInstead of worrying about why the client should be updated for changes in likes or the likeSentence, the client only wants to know about changes in the like _count_ and the likeSentence _text_. Right? The query or request itself is very _data-centric_. In other words, the client doesn't really give a hoot about why these things change, from a business logic perspective, because the client only wants to update the \"view\" of that data, whenever it changes. \r\n\r\nOh, and by the way, aren't all those business logic questions presented in the blog post about why a like count should be changed already made in the business logic? We don't need to ask them again (answering the questions above). At one point, the like count or the text will change. All the client cares about are those changes.\r\n\r\nAlso, if the client is going to request that some data be updated automatically (with a subscription), the query / request should be very specific. It shouldn't cover a fragment with multiple unrelated data items. It should only cover one specific piece of information (or very much related information for the scenario, where there is an insertion of data). \r\n\r\nWhy? \r\n\r\nA whole section of the RFC for subscriptions is dedicated to under- and over-_pushing_. If the like count above changes, why would I want the likeSentence text with it? In an update scenario, that would be over-pushing. Right? Of course, it depends on what is being presented, but I don't see any correlation. \r\n\r\nThe better solution for that example is two separate subscriptions: One on the likes count and one for the text updates of the likeSentence. \r\n\r\nSo now, the only need to make this happen is to watch these two data sources. When they get changed (for whatever reasons), then an update is pushed to the client. This might be a watcher, which following the aggregation system used for aggregating likes and also the \"update channel\" to the likeSentence text. \r\n\r\nThat is live querying. \r\n\r\nI wonder if we weren't talking in circles here. That in the end, Facebook actually has built a live query system, but is using an event based pub/sub system to make it happen and thus, feels this client real-time updating system can't be called \"live queries\". If so. Great! But, let's do call it a live query subscription system, based on a pub/sub event system. That way, everyone can understand and should that the events getting triggered should be data centric and not business logic centric. \ud83d\ude04 \r\n\r\nScott\r\n\r\n  \r\n\r\n > Who care's what the business logic reasons are to update the client?\r\n\r\nHave you watched https://www.youtube.com/watch?v=ViXL0YQnioU, particularly the part starting from 19:55? Because our backends at FB are not reactive (which is also the case for many other folks at other companies using GraphQL), we had the idea that we could instead implement live queries by using data dependencies to \"fake\" a reactive backend--which would require knowing what you call \"the business logic reasons\" that can cause a given field to change. The blog post and the talk both explain why this was ultimately not possible for us. \r\n\r\n> With a pub/sub event based solution, are you possibly actually forcing these business logic decisions to be made, in order to update the client properly?\r\n\r\nIf I understand this question correctly, then yes--we're putting the control into the hands of the client developer to decide which events to subscribe to and what information to query for each subscription. One of the main principles of GraphQL is that the client should have control over decisions about precisely what data it wants (as opposed to something like REST where the client hits an endpoint on the server which decides what data to return). This principle also holds true for GraphQL Subscriptions: the client developer has full control over which events they care about and what query should be executed when those events happen. @calebmer's comment above has some good insight into this issue of developer control versus magic.\r\n\r\n> And, I'd love to hear the answers of Dan or Lany or anyone else who thinks live queries offer the stumbling block of not knowing why an update should happen.\r\n\r\nIt's Laney \ud83d\ude42 To be clear, that \"stumbling block\" existed for us because we don't have a reactive backend. From my previous comment: \"we believe based on experience at Facebook and discussions with other folks that the general problem of implementing live queries at scale is not easy. This doesn't mean that it is always hard; with an efficient reactive backend, implementing live queries becomes fairly straightforward.\" You previously commented that \"I can understand why Facebook might want it this way. It probably fits their systems better. I just think that is a bit closed minded.\" Perhaps @stubailo can chime  in here with examples of other non-Facebook users of GraphQL who reached the same conclusion about live queries and GraphQL Subscriptions.\r\n\r\n> So now, the only need to make this happen is to watch these two data sources.\r\n\r\nYour whole chain of reasoning rests on the ability to \"watch these two data sources\" which is equivalent to having a reactive backend. I also noticed that you previously wrote that \"I don't think GraphQL should be working with events internally. They aren't needed, as Christians's rgraphql system proves.\" Again, the confusion here seems to center around the assumption that a reactive backend is always available. A live query demo using a reactive backend certainly does not prove that everyone using GraphQL has an efficient reactive backend. You previously wrote that \"For truly reactive systems, live queries are the future and it is why newer databases and data storage/ persistence technologies are adding live query technology in their systems. Live queries makes the system a good bit more efficient.\" If you have a reactive backend that's efficient for your particular application or use case, that's great. If you implement live queries using a directive, we'd love to hear what you learn. But it's incorrect to assume that everyone who uses GraphQL either started with such a backend or has the resources/desire to convert their existing backends to reactive ones. \r\n\r\n> in the end, Facebook actually has built a live query system, but is using an event based pub/sub system to make it happen and thus, feels this client real-time updating system can't be called \"live queries\". If so. Great! But, let's do call it a live query subscription system, based on a pub/sub event system. That way, everyone can understand and should that the events getting triggered should be data centric and not business logic centric.\r\n\r\nI don't fully follow this reasoning. What we've built (i.e. GraphQL Subscriptions) is described quite clearly in the spec from @robzhu (and in the blog post and talk I linked earlier). I certainly would not call this a \"live query system.\" (To be more concrete, you commented on March 6 with your definition of live queries; what we built and what we describe in the spec is definitely not that.) Finally, regarding your last sentence, the events being triggered in GraphQL Subscriptions are *not* data centric. They are tied to conceptual events such as a post being liked or a comment being written. @smolinari: Thanks a bunch for the thoughtful comment. Your post is quite long so forgive me if I am over-simplifying it if I try to summarize it. I get the sense that you think:\r\n\r\n> - Live queries and subscriptions may be isomorphic, but live queries are intrinsically superior to live queries because they more naturally capture the desired outcome of \"up-to-date-ness\".\r\n> - Subscriptions may be a mere implementation detail \u2014 only really chosen because they are easier to implement and scale \u2014 that you could use to construct a reactive (or apparently reactive) system, so you may as well put the public focus on reactivity and keep the implementation details private.\r\n> - Business logic is, in a way, an implementation detail, so why would clients care about it when what they actually want is having and keeping data up-to-date.\r\n> - If live queries are strictly better and more powerful than subscriptions, it's better to have only them in the spec.\r\n\r\nAgain, please forgive me if I've misread you on any of those points. Based on that reading I have a couple of comments:\r\n\r\n- Your example of `likers` count and `likeSentence` probably is a fine use-case for live queries, in the sense that it's the sort of thing that I can keep always-live and continuously update the UI, without any real risk of disrupting a user interaction (for example, a user is mostly only going to look at the count/sentence and not interact with it directly, and certainly not attempt to mutate any part of it).\r\n- Additionally, I evidently don't care about *why* the count or sentence changed. I already know that it is almost invariably because somebody liked the content (and less frequently, that somebody unliked it). Either way, it isn't going to change how I present the data to the user.\r\n- There may not be a huge up-side to keeping it very up-to-date. For example, a very popular post from a public figure doesn't really need to have its like count updated every second; updating every 5 or 10 or 15 or 30 or even 60 seconds or more, might be perfectly acceptable. As such, getting a periodic up-to-date view of the data is going to be just fine; I don't need to know about any of the individual events, or even the aggregation of multiple events, that led to the updated state.\r\n- On the flip side, there very definitely are use cases where the *reason why something changed* is just as useful and important to me as what the data looks like after the change. An example of this might be a list of chat threads divided into online and offline contacts: when somebody comes online, I might want to animate them to a new place in the list. For this use case, subscriptions may be exactly what I want: instead of comparing the old and new lists and trying to infer what happened in order to present it to the user, I can just rely on the server to tell me that a specific event occurred.\r\n- Note here that the event is driven by the business logic, but the logic is not an implementation detail: it actually has valuable *semantic* content. So, despite the isomorphism, I'm actually going to prefer subscriptions whenever the reason for the change is relevant to my product.\r\n- Another use case where I'll prefer subscriptions is when updating data that the user may wish to mutate. Go back to our contact list example: say my mouse is hovering over one of the items or I have right-clicked on it to show a menu, and I'm about to perform an operation on it (either re-ordering it within the list or assigning it to a category etc). In this case, too, I don't want the data to be continuously live and updated with the UI because that's going to be a very unpleasant UX for somebody who's actively trying to manipulate the data at the same time. For these use cases, it will be better for me to enqueue subscription updates that arrive during interaction, and then apply them once the interaction is finished.\r\n\r\nSo the tl;dr is:\r\n\r\n- Live queries and subscriptions are isomorphic, but differently suited to meet product-specific circumstances.\r\n- Any time you care about *why* something changed, subscriptions are a natural fit.\r\n- Any time you need to present the change in progress (eg. via animation) rather than just the final result of the change, subscriptions are a natural fit.\r\n- Any time you want to buffer/defer changes until after using interaction/mutation is complete, subscriptions are a natural fit.\r\n- Any time that none of the above apply, live queries will likely be a natural fit (caveat: full reactivity is hard).\r\n- Given the different use cases, there is room in the spec for both live queries and event-based subscriptions. I hope people don't feel like adding subscriptions is closing the door on live queries - in fact, I think once people get used to subscriptions getting live queries started will be much easier because a lot of transport-related questions will already be validated. Wow! This is sooo cool. I do not take it for granted that I am getting this attention and I appreciate it enormously. So, before I even begin, let me say thank you so much for your time and effort! \ud83d\ude04 \r\n\r\nPuh...where to begin.\r\n\r\nHmm.....Ok.\r\n\r\n@laneyk Thanks for your very clear and understood response and the link to the video. That sets a great basis to this continued discussion.\r\n\r\n>Your whole chain of reasoning rests on the ability to \"watch these two data sources\" which is equivalent to having a reactive backend. I also noticed that you previously wrote that \"I don't think GraphQL should be working with events internally.\"\r\n\r\nLet me clarify the events point first and thanks for bringing it up. I was mistaken in my wording or rather, I think I might have said something different at some point somewhere else (maybe not even in this discussion, but elsewhere). I am not against an events system. My thoughts on the event based / pub-sub solution are, as you even say in the video....it is an implementation detail. The whole time the FB team has fought against adding implementation details into the spec and I believe this is also one. I'll leave it at that, because the rest of my argumentation (and questions) will hopefully clarify the reasoning to why I say that. \r\n\r\nLet's put it another way. Adding the event based pub/ sub solution makes the FB GraphQL system reactive. \ud83d\ude04 \r\n\r\n@wincent made a point, which might be the core to our sort of tangential discussion.  \r\n\r\n> Any time you care about why something changed, subscriptions are a natural fit.\r\n\r\nMy question to that is, how can client devs using GraphQL care about why something changes? I don't see how they can. They have pieces of data or certain activities, which they want \"news\" about. They are simply asking the questions: \r\n\r\nAre there newly created data? \r\nOr are there new updates to changes of that data? \r\nOr are there activities going on, which I want to be aware of? \r\nIf the answer is yes, let me know about them, without me asking again. \r\n\r\nNone of that has anything to do with \"why\" the requested data changed, but rather \"did\" something change. This is the big difference and to me, it is the definition of a live query. \r\n\r\n@laneyk - also wrote.\r\n\r\n> If I understand this question correctly, then yes--we're putting the control into the hands of the client developer to decide which events to subscribe to and what information to query for each subscription.\r\n\r\nHow does a client define the event? She is working with GraphQL and data. There are no event definitions available. Are there? This is the open question in my mind, which isn't making the \"click\". To me, there is only a flow of data. So, when you say, \"it's in the hands of the client developer to decide what events he or she should be subscribing to\", I don't see it. I see the client developer asking for updates on single or multiple pieces of data or certain activities which yes, might be events, but they aren't defined as events. At least I have yet to see a good example of this. The only thing that comes to mind is the \"Someone is typing a reply\" display in FB comments. That is an event based subscription. How is that set up? It is a rare example of something that isn't a live query, because nothing is persisted. Well, not unless FB is logging our \"typing prowess\". LOL! ;smile:\r\n\r\nBtw, Laney, you said there were \"data dependencies\" that cause a lot of reasons for the like count to change the video. I call them business decisions. All the reasons you noted as to why a like count might grow or drop in number are decisions or processes made by the business. And again, the client dev is not at all interested in these decisions (or the events that cause a like count to increase or decrease) and cannot be bothered by them. Can we agree on that? The client dev only cares about the change happening. Her reasons for subscribing to the like count changes are purely data centric.\r\n\r\nSo again, I feel Facebook has built a pub/sub/ event based live query system for the client developer, because it is 99.9% data centric. It has to be, because the client dev really _can't_ be involved in all of the business decisions or events made available as to why a piece or multiple pieces of data change. They only want to display the change. All the logic as to why the data changed is hidden in the server and is business logic, which the client dev has no clue about, nor wants to know about. She or he just gets the \"live\" updates. Or maybe it could be called \"Reactive Subscriptions\"? \ud83d\ude04 \r\n\r\nIn other words, because there is the pub/sub/ event based system behind Facebook's GraphQL subscription system, it doesn't mean it is not a live query system. And, as @stubailo mentioned, how others get those updates through to the client can be pub/sub/event based, or could also be done with a purely reactive systems (which was also noted FB is also working towards, right?). The one solution for getting reactivity in the data doesn't exclude the other. The way the updates are pushed to the GraphQL API is an implementation detail and doesn't matter to the client or even the person responsible for the API. The response is always the same. The client (and the API itself) gets a response to a data centric, and not business decision/event based, request for updates. They are live queries, at least from the client's and API perspective.\r\n\r\nI hope that all makes sense. It's all just a matter of semantics I guess. I feel the query subscription that is being created by the client is a live query. I am certain, the client dev has (should have) no clue as to why he or she gets the updates and in the end, really doesn't care. Any subscription request is purely data centric in nature, as is the response. It's just that now the query is reactive. It is live. How that \"reactiveness\" happens in the backend is unimportant for the API, or at least it should be.\r\n\r\nMaybe that is the issue for this whole discussion from the beginning? I've been thinking in terms of the client and everyone else was thinking in terms of the implementation in the server? Hmmmm....... \r\n\r\nAt any rate. Thanks again for everyone's time and also efforts and making all this possible to begin with. I see huge potential with GraphQL and this discussion really is peanuts in comparison. I am honored to even have the chance to be the small thorn in everyone's side here. \ud83d\ude04 I certainly don't want to waste anyone's time, so I hope, at least, I could offer a different perspective and we could agree on it and maybe Facebook can now sell the subscription system as \"Live Query Subscriptions\". \ud83d\ude1c\r\n\r\nScott\r\n\r\n  Hey Scott, \r\n\r\n> They have pieces of data or certain activities, which they want \"news\" about.\r\n\r\n> None of that has anything to do with \"why\" the requested data changed, but rather \"did\" something change. This is the big difference and to me, it is the definition of a live query.\r\n\r\n> How does a client define the event? She is working with GraphQL and data. There are no event definitions available. Are there? This is the open question in my mind, which isn't making the \"click\". \r\n\r\nYes, the \"event\" corresponds to the GraphQL Subscription that the developer chooses to subscribe to. She may subscribe to comment creations or likes on a post or event RSVPs or someone starting to type, for example. These are all events that happen in the world of FB. She is *not* asking for any arbitrary updates about some piece of data; rather, by choosing a subscription to conceptual event X, she is saying that she wants to get updates pushed to her when and only when event X happens. In our system, we trigger publishes to each subscription event stream when the conceptual event happens (i.e. when someone starts typing or when someone creates a comment.)\r\n\r\n> I don't see it. I see the client developer asking for updates on single or multiple pieces of data or certain activities which yes, might be events, but they aren't defined as events.\r\n\r\nThey are events and they are defined as events. We have about 100 subscriptions in Facebook which correspond to conceptual events. The typing subscription, which you mentioned, is one example. To give another example, when someone subscribe to comment creations, they are not asking for any updates to the relevant data (the list of comments). If the list of comments changes because someone who had previously written a comment un-blocks the subscriber (so the comment suddenly appears in the list), the subscriber will not get an update. The data has changed, but the subscribed event has not happened. The subscriber will only get an update when the subscribed event happens--that is, when someone comments the post. I think that @wincent explained this really well. (\"Note here that the event is driven by the business logic, but the logic is not an implementation detail: it actually has valuable semantic content.\")\r\n\r\n> And again, the client dev is not at all interested in these decisions (or the events that cause a like count to increase or decrease) and cannot be bothered by them. Can we agree on that? The client dev only cares about the change happening. Her reasons for subscribing to the like count changes are purely data centric.\r\n\r\nNo, I don't agree on that, and I think this is the central point of misunderstanding. In the subscriptions system that we've built, the client developer thinks in terms of actions or events. There's no way in our subscription system to say \"tell me when any of this data has changed for any reason.\" There's only a way to say \"tell me when this conceptual event has occurred, and return the result of this subscription query to me when that happens.\"\r\n\r\n> All the logic as to why the data changed is hidden in the server and is business logic, which the client dev has no clue about, nor wants to know about. She or he just gets the \"live\" updates.\r\n\r\nWhat you're describing is not what we've built and not what we are describing in this GraphQL Subscriptions spec. The system you've described is much more in line with what we call \"live queries\" which is in a significantly earlier stage of investigation at Facebook with a lot of unanswered questions. I'm not sure that I can put it any better/differently than @wincent did above, but my one-sentence summary is that live queries let you say \"when any of the data in this query has changed for any reason, tell me the new result of the query\" whereas GraphQL Subscriptions let you say \"when this particular event has happened, tell me the result of my subscription query.\" I hope that makes the distinction more clear.\r\n\r\nI recommend checking out the reference implementation when it's ready and playing around with that; it may help make some of these questions more concrete. Ok. I guess I'll have to. \r\n\r\nBut, I must ask these last questions. \r\n\r\nFrom the video you linked to, what delivers the \"pub\" signal that triggers the updates on subscriptions to a like count? Where does the event come from and what is it called? Is there an aggregation system (business logic) which sends that pub event? If yes, is it the same logic that updates the persistence layer to store the new like value too?\r\n\r\nScott First, I would recommend thinking about the \"likes\" example as a subscription to likes (events) rather than a subscription to the like count (data).\r\n\r\nIn our system, when someone adds a new GraphQL subscription, they also add logic to publish to that subscription. These publish events live in the same codebase as the business logic. They are manually added for each new subscription. The events are called whatever the developer named them, like \"comment_create\" or \"story_like.\" (For a system that uses GraphQL mutations for its writes, you could imagine the subscription publish would happen in the mutation execution code.)\r\n\r\nFor the example of the like subscription, there's a common codepath that gets executed every time anyone likes or unlikes a post. This is where the subscription publish happens. This is also where we update our database to indicate that person X has liked (or no longer likes) post Y. \r\n\r\nThe reason that subscribing to *likes* is not equivalent to subscribing to *like count data* is that there are ways that the like count can change that will not trigger publishes to the like subscription. For instance, if Alice had previously liked the post but then she deletes her FB account, the like count will go down by one. This action does not go through the \"like/unlike post\" codepath so it does not trigger the like subscription, although the \"like count\" data has changed. Ahhhhh. Very interesting. \r\n\r\nThe logic to show a different value than what is persisted sort of eludes me. I guess I can't question FB's business decisions in the end. So, I won't. \ud83d\ude04 \r\n\r\nI also still say the event based solution is an implementation detail on how to make data change events reactive. But, I digress on that too. \r\n\r\nThank you so much for your patience. I'll be very much looking forward to the reference implementation and learning and hopefully also helping a whole lot more in the future.  \r\n\r\nScott  Maybe another way to think about it is that event-based subscriptions are one option for live query implementation, but in that context they're a _transport_-level concern. By contrast, for an event stream, the subscriptions actually do map to what's logically happening.\r\n\r\nThe \"like count\" thing is an interesting example, because visually it resembles live queries, so I'd argue that it's closer to a workaround over real reactivity there being really, really hard \u2013 but having tried to build conceptually similar things on our end with subscriptions, it's a very defensible one. @taion: I agree that likes is not the best example to talk about subscriptions in this particular discussion since it's something that is probably a better fit for a live query (assuming both options exist). One example where product requirements might specifically dictate events over live queries is something like Twitter's timeline, which shows a badge for new updates rather than immediately displaying new updates \u2013 if the user's about to interact with a timeline entry, you don't want to bump the timeline down in an unsolicited manner and make the poor user retweet the wrong thing, or something like that. @taion live queries still apply there, you would just restrict the query to never add new entries without an explicit argument change.  What's funny is that the same argument plays out over and over again.\r\n\r\nFor example, Redux, at its core, is event driven, although they call them actions. It gives you a structure for producing a live view of your state in the form of its reducers and selectors. MobX has you mutate your live model directly, and to the extent that events need to trigger processes, you need to handle that in your mutation logic.\r\n\r\nThere are strong reasons to build systems around the changing data itself. You don't have to worry about accounting for all the causes. \r\n\r\nThere are strong reasons to build systems around  events. Sometimes, user experience _does_ care about the causes.\r\n\r\nEvents can be depicted in a live query model by having field that will be the most recent event or `null`. After all, the schema need not restrict itself to depicting only things that are literally persisted. Clients then would be responsible for queuing up any events that happen to appear. It would be awkward, but possible. \r\n\r\nLikewise, subscriptions can support live queries by pushing the full state (or changes thereof) in every event. The event becomes \"your data has changed\". Also awkward to set up, use, and optimize. \r\n\r\nI think it's probably a good idea to have first-class approaches to both paradigms, even in the same application.  @acjay \r\n\r\nI think we're in general agreement there, and most of us are targeting live queries. The core issue is just that live queries, even at a schema level, require making more decisions \u2013 e.g. do you use something like JSON patch to communicate the updates? Or if not what do you use?\r\n\r\nRight now a number of implementations mock live queries with polling, but I think a general solution requires the kind of general consensus on how to push live query updates that does not yet exist. What events can happen that aren't persisted? If they aren't persisted, can they be? If they can be, and I know they can be, then those events can be \"triggered\" over live queries. Right?\r\n\r\nCan every live query be modeled into an event system? Sure they can. But, then you'd be building another separate system. I've seen this done for MongoDB in many ways for example. So it is clear the want for live querying is relatively large. Why is that? \r\n\r\nObviously too, only databases that can send live query messages can be used in a proper live query system. Otherwise, you are back again to needing a messaging/ queuing events system/ bus, etc. \r\n\r\nI can understand why FB went with events. AFAIK, they don't have databases that support live queries. But, maybe they should? If they did, I bet this whole discussion and any solutions would get a whole lot easier. \ud83d\ude09 \r\n\r\nScott \r\n\r\n  \r\n\r\n Any sort of stream data \u2013 trades, clickstream, &c. aren't nicely modeled by live queries and would have to be emulated there. @smolinari If you have a 15 minutes, check out the other issue I made above your comment. I'm increasingly convinced that all the pieces needed for a live query system more or less already exist in today's subscriptions. Although, since it's so far just been a big thought experiment, some details might be missing. There was a recent talk on Live Queries at GraphQL Summit by @rodmk, one of the engineers who works on the Live Query system at Facebook. I think it addresses several of the recurring questions in this thread. https://www.youtube.com/watch?v=BSw05rJaCpA.  @acjay - Absolutely. I never doubted GraphQL's capabilities to accommodate Live Queries. My whole argumentation here was to say that the added event driven system to make subscriptions work is basically unnecessary for (proper) GraphQL, because it can and should support live queries and that is the better answer to subscriptions and state management. Maybe my thinking was a bit ahead of its time???? \ud83d\ude04 \r\n\r\n@robzhu - Hah! Wow! Excellent video! Rodrigo demonstrates everything I've been trying to get across here. I'm all giddy now. \ud83d\ude1b And no, I don't mean to say, \"I told you so.\". \ud83d\ude04 I do still get FB's need to not go straight away with a live query solution, because of FB's legacy systems, which Rodrigo also mentions. (i.e. you can't rewrite all of the PHP code.) It demonstrates how FB's own internal issues drive directions in its open source projects and that is all fine and dandy, as a lot of dev shops out there will have those same kinds of issues. But there are also those, who are starting anew and want the best they can get too and Live Queries are the better/ simpler solution, granted only with a true reactive data store. \r\n\r\nI've enjoyed this whole discussion and I'd like to thank you all again for the opportunity.\r\n\r\nScott @taion I just re-read https://github.com/facebook/graphql/issues/284#issuecomment-346492667, and now I think I get exactly what you mean. And from my side thread, my conclusion to the title question, \"Are Subscriptions and Live Queries the same thing?\" is now \"yes\", qualified only by the need to answer the question of how to send updates. \r\n\r\nIn the best case scenario, those semantics can be defined at the spec level, leaving very little to be decided by library and application developers.\r\n\r\nBut, what if there's no natural _one size fits all_ solution to describing updates? Much as `scalar` leaves basically every aspect of implementation to the client and server, could something similar be done for the concept of updates? If so, I think there's one major advantage to implementing live queries within `subscription`: you can subscribe to _both_ new events and the changing state.\r\n\r\n@robzhu, since you closed this ticket with the opposite conclusion, namely that live queries should be something _separate_ from subscriptions, I'm curious whether this would address your concerns.  The spec thing sort of _is_ the thing, though. We were more or less able to ship subscriptions as of v0.4.8 that added support at a parsing level. The v0.10.0 release that changed the API to add first-class support \u2013 that was very, very nice from an API perspective, but ultimately didn't amount to much more than a minor API refactor: https://github.com/edvinerikson/relay-subscriptions/pull/39/files\r\n\r\nBy contrast, contra @rodmk, I can't see how to nicely implement live queries in a way that lets me handle lists efficiently, without pushing down the entire list every time the query updates, without some additional spec-level support. A subscription is so similar to a mutation from the schema perspective. A mutation isn't.\r\n\r\nThere is another distinction, too. Ultimately it's not _that_ awkward to subscribe to add, delete, and change events. Doing something like Twitter's \"new tweets\" alert (instead of reactively showing new tweets) with subscriptions is... possible, but extremely annoying. And there are cases where you either want to or have to ship updates in that manner (e.g. we're doing HIPAA-related stuff, we may want to only indicate the availability of new data, rather than pushing down new private-ish data to the client... ). > I can't see how to nicely implement live queries in a way that lets me handle lists efficiently, without pushing down the entire list every time the query updates, without some additional spec-level support.\r\n\r\nI'm not sure if my point isn't clear, or if I'm missing something you're saying. I think we agree that lists would seem to be the trickiest data type for coming up with a globally accpetable scheme of representing updates.\r\n\r\nBut do you get my point in analogizing that with the scalar situation? The handling of custom scalars is one of the more interesting (and initially confusing) parts of GraphQL to me. The spec basically completely punts on anything having to do with how they're represented. They're just dumb leaf data. It's up to the client and server to determine the convention for their representation. This is _great_, because it avoids clogging up the spec with arbitrary choices for things like dates and times.\r\n\r\nCan't the same approach be used for the representation of updates, since there are several reasonable approaches? On a really simplified level, the server needs to implement some function `(lastState, newState) => changeRepresentation` for each type, and the client needs a corresponding set of functions `(lastState, changeRepresentation) => newState`. For argument's sake, let's just say the reference server implementation provides a default for all types could just be just send `newState` directly, ignoring `lastState`. Presumably, the reference server implementation would allow this default to be overriden by something more optimized.\r\n\r\n> There is another distinction, too. Ultimately it's not that awkward to subscribe to add, delete, and change events. \r\n\r\nYeah, I get that, but for reasons I think everyone agrees with, the event approach just isn't a great fit for every application. I'm just trying to say, I don't think it's actually that much more complex to do live queries using the exact same mechanism as has been built for events, with really just one additional concept of what I might call \"modular update representation\".\r\n\r\nI hope this makes my point clearer, and sorry if I've misunderstood what you're trying to say. @acjay \r\n\r\nWhat you're saying makes sense. The distinction I was drawing was that, with subscriptions, there was an \"obvious\" choice of the semantic GraphQL payload to send back to the client that exactly matches what things look like with a mutation.\r\n\r\nThe issue with live queries (esp. lists) is exactly as you say \u2013 the specific implementation needs to define its _own_ format to use for encoding deltas, which is a problem that didn't arise with event subscriptions. It's just more stuff to decide for the app developer. Just to throw in what I've been understanding as a live query, which seems to be different to the discussion here and even a bit to what Rodrigo explained too, but I believe live queries shouldn't return whole datasets or deltas of the changed data, but rather only send a trigger to the client to re-request its \"affected\" query again. That way, the back-end can stay fairly dumb, because the client is the one asking for the new data through the particular query and only the updated data gets \"pulled\" back into the client. \r\n\r\nDoes that make any sense?\r\n\r\nScott That sucks because the server has to look everything up again and can't keep any context in memory. \r\n\r\nYou're getting caught up in the implementation details. There are a lot of ways of accomplishing this. Two way socket, pub-sub change notification channel, long polling, merkle tree data hash comparison and state sync, server-side in-memory meekle tree result caches.... > @taion I just re-read #284 (comment), and now I think I get exactly what you mean. And from my side thread, my conclusion to the title question, \"Are Subscriptions and Live Queries the same thing?\" is now \"yes\", qualified only by the need to answer the question of how to send updates.\r\n\r\n> since you closed this ticket with the opposite conclusion, namely that live queries should be something separate from subscriptions, I'm curious whether this would address your concerns.\r\n\r\nRe-reading the thread now, I have not found compelling arguments for why the answer to this question is \"yes\". To quote from Rodrigo's presentation at GraphQL Summit, **\"Live Queries observe data, subscriptions observe events\"**\r\n\r\nFor example, suppose you had a server-side clock that tracks the current time. The current time has two interesting properties: the value itself, and when it \"ticks\". \r\n\r\nIf you want to observe the current time, use a Live Query.\r\nIf you want to observe the \"tick\" event, use a Subscription. \r\n\r\nThese are (awkwardly) isomorphic because you can always record the set of events in a list and observe that list. For example, you can use a CQRS-style log, but it seems silly to have a CQRS log for seconds in the day. \r\n\r\nAnother angle: a Live Query is essentially a Query. You can poll any Query to simulate its behavior as a Live Query. By contrast, polling a Subscription (where the subscription does not have a stateful channel between polls) doesn't make sense. \r\n\r\nHope that communicates my current thinking. I'm not seeing the recent arguments cover new ground, so I'm inclined to keep the issue closed, but please let me know if I'm missing some context. \r\n @robzhu summarizes it nicely. It's easily possible to add an events (subscriptions) implementation on top of whatever live query system, and it's also probably possible to make a live query system using subscriptions as some kind of awkward transport. \r\n\r\nAt the end of the day data is data and the way you transfer it depends on what you want to do with it and how often it changes.  @paralin But the point I'm trying to make is that if we can \"forget\" for a minute that `subscription` was created with an event paradigm in mind, it's actually _very_ close to being suitable for live queries, as well. What seems to be missing is simply a concept of a difference between the intial response and the stream of updates and a (modular?) scheme for representing those updates. Not to minimize those issues, but it feels like a manageable hump. Which is also why I'm thrilled the answer has been revised to \"yes\" :D @acjay Those two things that you just described - including \"modular scheme for representing those updates\" - is a live queries system. There's no reason to use a subscription channel as your transport for a live queries system. It adds nothing over just a websocket transport. Therefore a subscription channel is not suitable for live queries, as well. It's suitable for the event-based paradigm, which was what it was designed for.\r\n\r\nI built a prototype of an efficient live-queries system with [magellan](https://github.com/rgraphql/magellan) and it doesn't look anything similar to the subscriptions system - for performance I binary encode and batch changes to different parts of the result tree, which wouldn't be possible via a subscriptions channel anyway. @paralin Maybe I'm missing something, but if the assumption is that a web socket server _could_ simply choose to interpret a vanilla `query` as being a subscription for live query updates, why wouldn't the exact same thing work for events? It's just a single query that's responded to multiple times, when the server deems it appropriate. @acjay I think that's exactly right. A minimum (not especially efficient) implementation could just hold onto the full query and re-run the entire thing and push the results down to the client every time it gets an update. That's in fact how I read the \"call to make a prototype\" bit at the end of @rodmk's talk. @taion @acjay I would struggle to call that a live query system at all. As we're discussing what a real implementation of something like that would look like, or in essence trying to figure out what the \"best approach\" would be, I'm not really considering hacks like sending the entire state over a subscription channel as a \"live query system.\" \r\n\r\nYou can do the exact same thing with just a websocket and a server-side polling [run query, check if changes happened, wait 3 seconds] loop, and remove the entire graphql stack. In that way it's not useful to have the subscriptions stack in the mix at all for something like this. It is for this reason that I would say that the two things are entirely separate and should be treated as such.\r\n\r\nI went and watched [Rodrigo's talk](https://www.youtube.com/watch?v=BSw05rJaCpA) and while I would argue that saying Subscriptions and Live Queries are interchangeable is misleading, he is right in that you can build almost any application with either approach. One approach will just be better for certain types of things than the other. @paralin Let's move this discussion to #386 instead of continuing to comment on a closed issue. > Live Queries observe data, subscriptions observe events\r\n\r\nLive Queries observe \"data store events\", i.e. record creations, updates and deletes. Also, those data store events could be due to other events. \r\n\r\nScott  From my response on #267:\r\n\r\nI think this is an application-level thing. \"State\" is not a concept that is inherent to GraphQL. Subscribing to e.g. streams of newly created items also doesn't necessarily admit an easy representation of current state. Imagine subscription updates that don't reflect idempotent operations \u2013 in such cases there isn't really a coherent initial state. Agreed, there should be no concept of \"initial state\". If the backend implementation wants to send something back right away then it's free to do so, though. I also agree with others, an initial state may or may not be present. I can imagine that some implementations may client decide what data to emit based on root field arguments (like `lastSeenEventId` or something along these lines) Oh, now I see how I could get an atomic subscription request:\r\n\r\n```graphql \r\nsubscription {\r\n  commentCreated(postId: 4) {\r\n    # `null` on first request, but present in later updates:\r\n    comment { \r\n      body \r\n    }\r\n    # present on first request, but `null` in later updates:\r\n    initialPost {\r\n      title,\r\n      comments {\r\n        body \r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nDoes that sound like it'd be within spec? The server _may_ respond to a `subscription` operation with a response?\r\n\r\n @rmosolgo Exactly Ooh! I really like that idea. Could be a clever way for the server to handle this kind of guarantee. I'm not sure there's a need to merge those. Thinking about Relay for the moment, I might want the \"subscription active\" thing to be entirely delegated to my transport layer (really just a Socket.IO ack on my \"subscribe\" request), while the initial message should be exposed to e.g. the Relay network layer.\r\n\r\nMaybe it's a bit of an implementation detail at that point.\r\n\r\nYou can imagine with something SSE-based that the \"subscription active\" bit could just be implicit, anyway. > This response can be useful for returning initial data or indicating whether the operation was successful.\r\n\r\nas per @taion , (assuming 'operation was successful' refers to subscription active) you want to keep these on different layers. Any ACK messages could go in the graphql bytestream (ie bytes handed to graphql from the underlying transport layer) but not be part of the message stream. Extending what Jimmy said, this should be delegated to the transport layer until a reason to bring it into the graphql layer since most sane transport layers will give us enough for core subscribe and unsubscribe semantics.[1]\r\n\r\n[1] it may be desirable to propagate error messages differently when they are graphql errors, eg bad upstream data. @rmosolgo I'd imagine you would want to use a union to make this type safe and since you're muxing state and updates but only want one of each type per message.\r\n\r\n```\r\ntype Comment {\r\n  author: Person\r\n  body: String\r\n}\r\ntype Post {\r\n  author: Person\r\n  title: String\r\n  body: String\r\n  comments: Comment[]\r\n}\r\nsubscription {\r\n  postWithComments(postId: Int): Post | Comment\r\n}\r\n```\r\nThis now says 'I will always send you either a post or a comment'.\r\n\r\n```\r\nsubscription {\r\n  commentCreated(postId: 4) {\r\n    # later responses\r\n    ... on Comment { \r\n      body \r\n    }\r\n    # the on first response\r\n    ... on Post {\r\n      title,\r\n      comments {\r\n        body \r\n      }\r\n    }\r\n  }\r\n}\r\n``` Yeah I definitely think the ACK should just be on the level of checking whether the connection is successful or not.  Depending on the resulution of #284 (subscriptions vs. live queries), I think only allowing the event stream to be derived from the root field parameters would be an important way to make the distinction.\r\n\r\nKnowing that you are going to get the same set of events regardless of the query passed in allows you to have more understanding of the system you're calling into, and means you can refactor your client code at will, for example by moving some of the fields into a follow-up query.\r\n\r\nMost arguments for including information about the whole query/selection set I've seen so far involve building a live-query like system on top of subscriptions - people are suggesting that you might want to receive updates based on the fields you asked for, which seems to break my understanding of the fundamentals of the system. IMO the nicest way to write the spec has things just work out this way. I take back what I said about live queries. A worthwhile detail from dshafer's comment:\r\n\r\n> root subscription field __(and its arguments)__\r\n\r\n(emphasis mine) In light of that, these two subscriptions may receive _different_ events:\r\n\r\n```graphql \r\n# Pushed only when a new comment is left on Post #4\r\nsubscription {\r\n  commentCreated(postId: 4) { \r\n    # ...\r\n  }\r\n}\r\n```\r\n\r\n```graphql \r\n# Pushed only when a new comment is left on Post #5\r\nsubscription {\r\n  commentCreated(postId: 5) {\r\n    # ...\r\n  }\r\n}\r\n``` I this is quite an import aspect, as dshafer pointed in in his comment.\r\n\r\nGiven this schema: \r\n\r\n```graphql\r\ntype Subscription {\r\n  a: A\r\n  b: B!\r\n  c(d: D): Int!\r\n}\r\n```\r\n\r\nand following query\r\n\r\n```graphql\r\n  subscription {\r\n    a {a1, a2}\r\n    b {b1, b2}\r\n    c(d: {foo: BAR})\r\n  }\r\n```\r\n\r\nHere are several questions I was struggling with:\r\n\r\n1. Do `a`, `b` and `c` relate to each other in some ways or represent something special just like mutation fields represent mutations/effects thus must be executed sequentially?\r\n1. Should `c` allowed to be a scalar type?\r\n1. Are there other restrictions on an output type of a root field?\r\n    1. Can it be not-null. What is semantic difference between nullable and not-null fields?\r\n    1. Can it be an abstract type (union or interface)? Previously I experimented with 2 ways of representing events in subscriptions and both work quite well: \r\n    \r\n       as hierarchies \r\n       \r\n       ```graphql\r\n       interface A {\r\n         eventId: ID!\r\n       }\r\n       \r\n       type UserCreated implements A {\r\n         eventId: ID!\r\n         userId: ID!\r\n         userName: String\r\n         email: String \r\n       }\r\n       type UserNameChanged implements A {\r\n         eventId: ID!\r\n         userId: ID\r\n         userName: String                 \r\n       }\r\n       ``` \r\n       \r\n       and a concrete types (every root field represents individual event)\r\n                   \r\n       ```graphql\r\n       type A {\r\n         eventId: ID!\r\n         userId: ID!\r\n         userName: String\r\n         email: String\r\n       }\r\n       \r\n       type B {\r\n         eventId: ID!\r\n         userId: ID\r\n         userName: String                 \r\n       }\r\n       ```       \r\n                    \r\n       should both approaches be allowed. Should we prefer one approach over the other                    \r\n1. Does execution of types `A`, `B` and `C` follow normal parallel query execution rules (should `a1` and `a2` be allowed to execute in parallel)?\r\n1. If I have 1 incoming event of type \"A\", what is the right result format?\r\n    1. all fields are always present\r\n       \r\n       ```json\r\n       {\r\n         \"data\": {\r\n           \"a\": {\"a1\": \"foo\", \"a2\": \"bar\"},\r\n           \"b\": null,\r\n           \"c\": // ???\r\n         }\r\n       } \r\n       ```\r\n    1. only relevant field is returned\r\n       \r\n       ```json\r\n       {\r\n         \"data\": {\r\n           \"a\": {\"a1\": \"foo\", \"a2\": \"bar\"}\r\n         }\r\n       } \r\n       ```\r\n1. If I have 2 incoming events or pieces of information of type `A` and `B`, what is the right result format?\r\n    1. all fields are emitted as a single result \r\n       \r\n       ```json\r\n       {\r\n         \"data\": {\r\n           \"a\": {\"a1\": \"foo\", \"a2\": \"bar\"},\r\n           \"b\": {\"b1\": \"baz\", \"b2\": null}\r\n         }\r\n       } \r\n       ```\r\n    1. every field are emitted as a single result\r\n       \r\n       ```json\r\n       {\r\n         \"data\": {\r\n           \"a\": {\"a1\": \"foo\", \"a2\": \"bar\"}\r\n         }\r\n       }\r\n       \r\n       // ...\r\n       \r\n       {\r\n         \"data\": {\r\n           \"b\": {\"b1\": \"baz\", \"b2\": null}\r\n         }\r\n       } \r\n       ```\r\n1. Should it be allowed to have 2 root fields simultaneously in a single emitted result? \r\n1. Can emitted result contain `null` values in root fields? e.g. \r\n\r\n    ```json\r\n     {\r\n       \"data\": {\r\n         \"a\": null\r\n       }\r\n     } \r\n     ``` My personal take on it :)\r\n\r\n1. `a`, `b` and `c` conceptually represents an event/message/fact. It can as well represent a chunk of information that is delivered in several emitted results\r\n2. yes, scalar types should be allowed\r\n3. I would allow abstract types, but I would disallow not-null types. It is not yet clear for me how it should mechanically work. I think both approaches from `3.ii` are valid without any particular preference.\r\n4. yes, all execution below root field should inherit normal query execution semantics\r\n5. I think `5.ii` makes the most sense. Though, if not-null result types are not allowed then both variations would be valid (but I still prefer `5.ii`)\r\n6. I think `6.ii` makes the most sense. \r\n7. I would not allow this\r\n8. I would allow it only in case of an error. E.g. \r\n\r\n    ```json\r\n     {\r\n       \"data\": {\r\n         \"a\": null\r\n       },\r\n       \"errors\": [\r\n         {\"message\": \"something went terribly wrong\", \"path\": [\"a\"]}\r\n       ]\r\n     } \r\n     ``` \r\n\r\nWhat do you think? Might be useful to generate some marble diagrams for some of these (or in the short term repurpose existing ones). \r\n\r\nRe 4/6 the choice can be rendered as the distinction between [`merge`](http://rxmarbles.com/#merge) and [`combineLatest`](http://rxmarbles.com/#combineLatest).\r\n\r\nIs subscription muxing and demuxing (cf queries in relay and apollo) important at this layer? I imagine it should be an overlay to the base subscription mechanism.\r\n\r\n\r\n @OlegIlyenko I differ on some of these points. Mainly the null/not null stuff.\r\n\r\n1. No. They represent different event types a user wants to receive.\r\n2. Yes. Nullable values (scalar or object) should also be allowed which gets brought up in 8 \ud83d\ude0a\r\n3. Abstract and not-null types should be allowed. I don\u2019t think there should be any restriction on what gets returned. What a not-null type means is that whenever an event is received for a given root field there _must_ also be a value. The only concession the spec may want to make is that a null is allowed for a not-null subscription field type only if there was an error. This differs from queries where if a not-null root field is null the null propagates up to the root level. In the subscription case nulls should only propagate to root level subscription fields.\r\n4. Yes.\r\n5. This is an implementation detail that shouldn\u2019t need to be specified. I do prefer `5.ii` as well for what it\u2019s worth \ud83d\ude0a\r\n6. This is also an implementation detail which may differ between servers. I think `6.i` is fine and clients should probably support that format. Servers may then choose between which format it actually wants to send.\r\n7. I think this is an implementation detail? The spec should, perhaps, only care about the fact that each root field has an event stream. The timing of event emits is determined by the server. My position on how this should be implemented is reflected in by answer to 6.\r\n8. Yes. Saying no to null values is not a restriction I think we need. Although I am curious, your position in 3 is that we should not allow root non-null types, but your position in 8 is that we should not allow root nulls. > No. They represent different event types a user wants to receive.\r\n\r\nSo I guess it's actually \"yes\" since they share a common property: they represent event types :) Do I understand it correctly? The question was more about semantic similarities rather than a relation between values during the runtime.\r\n\r\n> Although I am curious, your position in 3 is that we should not allow root non-null types, but your position in 8 is that we should not allow root nulls.\r\n\r\na very good point! I guess I got a bit confused along the way :) I added 8 in an edit mostly because I thought that `{\"data\": {\"a\": null}}` does not hold much of a useful information.\r\n\r\nRegarding nullable vs not-null. I don't hold a strong opinion on this one per se. I just wonder how it will interact with the fact that we now have 2 sources of field omission/`null` value:\r\n\r\n* event stream emitted `null` for particular event\r\n* other fields (assuming that they represent different event types) have not emitted any value\r\n\r\nI think I'm also ok with defining it like this:\r\n\r\n* both nullable and not-null fields are allowed at the root level \r\n* `undefined` means that event is not emitted\r\n* `null` means that event type is emitted but an event value is `null`\r\n\r\nThough it would look a bit strange when `a` is emitted, but `c` (which is defined as not-null) has `undefined`/`null` value.\r\n\r\n> 6/7. I think this is an implementation detail?\r\n\r\nI'm not sure about this one. I feel that this aspect has deeper implications on subscription semantics. I think this conversation about multiple root fields and null should happen on a separate issue IMO @OlegIlyenko \r\n\r\n> > 1. No. They represent different event types a user wants to receive.\r\n>\r\n> So I guess it's actually \"yes\" since they share a common property: they represent event types :) Do I understand it correctly? The question was more about semantic similarities rather than a relation between values during the runtime.\r\n\r\nThe \u201cno\u201d was mostly directed at the serial execution bit at the end of point 1 \ud83d\ude0a\r\n\r\n> - both nullable and not-null fields are allowed at the root level\r\n> - `undefined` means that event is not emitted\r\n> - `null` means that event type is emitted by the event value is `null`\r\n\r\nI like this as well \ud83d\udc4d\r\n\r\n> > 6/7. I think this is an implementation detail?\r\n>\r\n> I'm not sure about this one. I feel that this aspect has deeper implications on subscription semantics.\r\n\r\nYeah, you\u2019re right. I saw JSON and immediately jumped to the conclusion that it is a serialization concern \ud83d\ude0a\r\n\r\nI think it\u2019s limiting to think about subscription responses purely in the context of the current response format. Let\u2019s see if we can think of something else that better fits the subscription case.\r\n\r\nI\u2019m not sure that I like `6.ii` when `data` continues to be a map that conforms to the shape of the selection set. The restriction to a single key/value pair in the data map feels arbitrary. What if instead the event response was:\r\n\r\n```json\r\n{\r\n  \"event\": \"a\",\r\n  \"data\": { \"a1\": \"foo\", \"a2\": \"bar\" }\r\n}\r\n```\r\n\r\n```json\r\n{\r\n  \"event\": \"b\",\r\n  \"data\": { \"b1\": \"baz\", \"b2\": null }\r\n} \r\n```\r\n\r\nThis enforces only one event per message. Another thought is that the subscriptions grammar should be customized to _only_ allow fields and not other selections like inline fragments or fragment spreads. For example:\r\n\r\n```\r\nSubscriptionSelectionSet :\r\n  { Field[list] }\r\n``` @caabernathy \r\n\r\n> The \u201cno\u201d was mostly directed at the serial execution bit at the end of point 1 \ud83d\ude0a\r\n\r\nAh, I see. Sorry, I was more focused on meaning of the field rather them execution characteristics :) \r\n\r\n`{\"event\": \"...\"}` approach sounds quite interesting! I need to think about it. \r\n\r\n> Another thought is that the subscriptions grammar should be customized to only allow fields and not other selections like inline fragments or fragment spreads.\r\n\r\nI haven't thought about it. It's definitely something worth considering. What is your reasoning for disallowing inline fragments and fragment spreads?\r\n\r\n@stubailo Indeed, I agree. It looks like these two points are relatively independent and can be discussed separately.  > What is your reasoning for disallowing inline fragments and fragment spreads?\r\n\r\nIt would enforce a few properties about subscriptions:\r\n\r\n1. The subscription event types will always be present in the subscription definition. Any tooling may then easily know what to expect without resolving fragments.\r\n2. The user could not create a fragment with any special behavior like they may now for mutations. A fragment on the mutation root type may sometimes execute serially (if spread on a mutation), or in parallel in the rare case that a user recursively references the mutation type somewhere in their tree.\r\n3. The main use for inline fragments is type checking. On a root mutation or subscription type this is unnecessary most of the time. Unless the root mutation or subscription implements an interface, but is there a convincing reason to do this?\r\n\r\nIt may even be worth extending this argument for mutations as well.\r\n\r\nA more thorough approach then only allowing `Field`s in a subscription\u2019s `SelectionSet` would be to only allow fields on root mutations and subscriptions instead of object types. This provides more guarantees to the ecosystem and provides more flexibility to specification authors instead of retrofitting a current concept.\r\n\r\n* * *\r\n\r\nWhat do you think? I haven\u2019t thought much about this idea either so I\u2019m developing it on the fly \ud83d\ude0a That's a good point as well that it might be worth specifying that no field can return the Subscription type. @calebmer Thanks a lot for detailed explanation! And I'm sorry for the late reply.\r\n\r\nI definitely don't want to discard this idea, but I have some concerns:\r\n\r\n* Introducing a special rules, or exception from general rule has it's own price. I think one of the nice things about GraphQL is that it does have many rules to begin with. The only exception from a general rule i could find is an execution order of mutation fields. In this case I think it's kind of essential, so it definitely worth of inclusion. I guess something similar would be introduced for subscriptions as well. Disallowing fragments in subscription queries can add complexity in the language and and make it less uniform (which may be a disadvantageous for people who are just started to learn GraphQL or tools that relay on specific uniform structure and features), so I wonder whether gained benefits would be worth it.\r\n* Fragments also serve as a unit of decomposition. Event though query and mutation types are also object types (so there is no polymorphism involved), still libraries like relay take advantage of them to compose queries provided by different components. E.g.:\r\n\r\n  ```graphql\r\n  query Foo {\r\n    ...ComponentA\r\n    ...ComponentB\r\n  }\r\n  ```\r\n\r\n  I wonder whether this property of fragments can be beneficial for subscriptions as well. I feel that it can be quite beneficial.\r\n\r\n> That's a good point as well that it might be worth specifying that no field can return the Subscription type.\r\n\r\n@stubailo @calebmer Indeed, It's good point. I feel that may be even necessary for subscription type since it's semantics is quite different from anything else. Maybe it would be an option to introduce it for mutations as well, though I wonder whether it can be just a linting/optional validation rule in case of mutations. I wonder what are the use-cases for mutation/query/subscription type as a return type of a field @OlegIlyenko I don\u2019t feel super strong on the mutation and subscriptions are not root objects point, and it kind of derails from the original discussion. We may want to separate into another own issue if the idea is worth exploring. At a high level I do agree though that the simplicity of the language is incredibly important, but it may actually be simpler to add special semantics for root mutations and subscriptions instead of adding special cases to object types which people may want to extend to other object types that are not root mutations or subscriptions (see https://github.com/facebook/graphql/issues/252). Instead of changing GraphQL syntax we should just be able to do this with a validation rule.\r\n\r\nAs for the original question, I don\u2019t think there is any disagreement that the specification should require subscription events to be exclusively derived from the root field. Correct @robzhu? Updated the RFC text to describe this more clearly: https://github.com/facebook/graphql/pull/304  I think it might be nice to make the title a bit more generic - I think it might be better to structure it as a \"callback\" that can be fired in response to anything, including events. In terms of a JavaScript API, it would basically be like:\r\n\r\n(pending the resolution of https://github.com/facebook/graphql/issues/282 the arguments can be different)\r\n\r\n```\r\nfunction subscriptionSetup(rootFieldName, rootFieldArgs, callback) {\r\n  // hook up to pubsub system\r\n  const subscription = pubsub.subscribe('my_event_name');\r\n\r\n  subscription.on('data', (data) => {\r\n    callback({ data: formatData(data) });\r\n  }\r\n\r\n  subscription.on('error', (error) => {\r\n    callback({ error });\r\n  }\r\n}\r\n```\r\n\r\nThis could be located in the \"subscriptions system\", or perhaps next to the subscription field resolver. Modeling subscription payloads as a form of iterator\u2014or in the case of future ES features, an AsyncIterators\u2014is another viable alternative to pubsub. I think this most closely fits the definition of \"event stream\" you describe?\r\n\r\nSpecifying that subscription, payload receipt, and (most likely) unsubscription operations are required allows a client to model data flow using either paradigm. If this meets the criteria @leebyron was exploring in #267, we should reword the specification to be generic enough to accommodate both the type of API @stubailo describes above as well as a generic push model (like SSE, asynchronous iteration, etc.).  The RFC text has been updated to describe a generic \"event stream\" as opposed to specific events: https://github.com/facebook/graphql/pull/304  So, here are some options:\r\n\r\n1. As parent/root object\r\n2. As an extra fake argument in the same place as query args\r\n3. Attached to `context`\r\n4. As a new argument to the resolver signature\r\n\r\n-----\r\n\r\nI think 3 wouldn't be great, because I don't think non-root resolvers should have access to the payload.\r\n\r\n2 also seems weird, although it's the least \"breaking\" of these options.\r\n\r\n-----\r\n\r\nThat seems to leave us with:\r\n\r\n- (1) Pass the payload as the root object, which might conflict with some other ways people are using this object today, and\r\n- (4) Introduce a new argument to the resolver signature, and make it `resolve(parent, args, context, payload, [info])` which is a big change\r\n\r\nFor passing as the root object, the extra information we want to gather is how people are using this parameter today. For myself personally, I put everything on the `context`, but I've heard some people have opinions about how some common data should go on `rootValue` instead. So in my world passing as `rootValue` is just fine, but if people are already using that for something important then it might not be great.\r\n\r\nPassing as an extra parameter also comes with some questions. Does every resolver get this extra argument, or do subscription resolvers get a different number of arguments than others? Also, this could end up being a pretty big breaking change for the GraphQL execution libraries, since the arguments will end up moving around.\r\n\r\nI suppose there is another option - the spec says it's an \"extra parameter\", but the actual implementations put it somewhere implementation-specific, for example as a property on `info` in `graphql.js`. Then we could avoid the breaking aspects of changing rootValue, but at the expense of making the spec a little less descriptive and opening up to differences in language implementations.\r\n I'd prefer `rootValue`, because I think for modern GraphQL.js, using `rootValue` instead of `context` for context seems like an anti-pattern.\r\n\r\nBut I think this is entirely an implementation-level question. The GraphQL spec doesn't talk about things like `context`, for example. I see the tradeoff similar to how @taion describes it. While [#267](https://github.com/facebook/graphql/pull/267#issuecomment-280740586) appropriately calls out that this can be confusing if resolvers are relying on `rootValue` to be consistent, in my experience so far working with subscriptions this isn't an issue that you make once or more than once. Let's ensure the RFC doesn't conflict with implementations which chose to do this.  I don't think this matters for the spec. Implementation-wise I think it'd be neater to have the state live outside GraphQL.js though. :+1: Agreed that it should be basically excluded from the spec. \r\n\r\nIn the same way that storage and transport are \"application-specific\", subscription management should also be application-specific. \r\n\r\nFor example, one application may push updates over a websocket connection and consider a client unsubscribed when the connection is closed, while another application may respond to subscriptions by creating webhooks and push updates by hitting a client-supplied URL. Ideally, the spec would be flexible enough to accommodate either case without prescribing one or the other.\r\n\r\n(Personally, if I set up GraphQL subscriptions, it would probably be based on Pusher, which is neither here nor there!)  Copying over my response from #267:\r\n\r\nThe use of SSE v WS is an application-level implementation detail. All that's needed is the server being able to push messages to the client somehow, which distinguishes this from request/response.\r\n\r\nThe communication isn't really bi-di anyway; it's a request to make a subscription, then a stream from the server for subscription updates. SSE is perfectly fine for this, assuming other technical concerns permit its use. You could picture an SSE-only approach where each new subscription is a request to an HTTP endpoint with SSE.\r\n\r\nThis wouldn't necessarily be a great way to implement things, but there's nothing that would prevent it from working. The question here is - do subscriptions require a concept of \"unsubscribing\"? If so, then that implies that there is some state that tells the server whether or not there is a client to send events to. That's my mental model of what \"bidirectional communication\" means - the server is aware of whether someone is listening. We're probably getting into hermeneutics a bit, then. From @OlegIlyenko's initial post, there's no reason GraphQL subscriptions can't work over SSE instead of over WebSockets. If that's the only question, then I think we're on the same page here. I think \"bi-directional\" is a quite broad term. For instance, I consider UDP to be uni-directional. My server can make a broadcast of data based on a subscription query. But as soon as client somehow tells a server the subscription query (which may also be a human communication), the overall communication flow can be considered bi-directional, IMO.\r\n\r\nIn my opinion, this is a transport concern, so it would not be right to overspecify it in GraphQL spec. \r\n\r\nI would suggest to introduce an abstract notion of \"infinite result stream\" or \"result observable\" with following properties:\r\n\r\n* This \"result observable\" is the result of execution of subscription query in contrast to a single result of normal and mutation queries\r\n* Observable results are non-deterministically distributed in time. This means that they may not necessarily be emitted at the same time.\r\n* Result stream is infinite, so it may never naturally \"complete\".\r\n* Stream may become exhausted. In this case, it is considered \"completed\" and it will not emit further results\r\n* GraphQL execution engine may experience an unrecoverable error. This will \"complete\" stream as well.\r\n* Consumer of the stream must be able to perform 2 operations on it: \r\n  * subscribe to results emitted by the stream. Results will come one at a time.\r\n  * Prematurely \"complete\" the stream\r\n\r\nIt's just some basic properties of observables as seen in ReactiveX, reactive-streams, etc. I think this can be the right abstraction level that describes a semantics of interaction with GraphQL execution engine but does not imply any particular transport or client-server interaction mechanism.\r\n\r\nIf we would like to capture the semantics and protocol of subscriptions-transport-ws or similar implementations, I feel it would be better to tackle it as a separate specification (just like [relay](https://facebook.github.io/relay/docs/graphql-relay-specification.html#content)). I think it's a higher level abstraction and it should be possible to express it on top of the primitives I described above.\r\n\r\nWhat do you think about it? None from me; I think the point is that the communication system should in some manner enable the server to push messages to the clients. Whether we call that \"bidirectional\" is unimportant. I like @OlegIlyenko 's break down, though I think\r\n\r\n> * Result stream is infinite, so it may never naturally \"complete\".\r\n> * Stream may become exhausted. In this case, it is considered \"completed\" and it will not emit further results\r\n> * GraphQL execution engine may experience an unrecoverable error. This will \"complete\" stream as well.\r\n\r\nis a little unclear. My preference would be for upstream to be able signal no more data so we can close redundant connections if possible (and for downstream to do the same). (It seems like that this the intent here so maybe just a language use issue). Cognate events from Rx are `complete`, `error` and `unsubscribe` which is a nice symmetry. @jamesgorman2 yes, I generally mean the same thing. The completion of a stream is propagated to both the producer and consumer (depending on who initiated it). So that they can do proper cleanup if necessary  Hello,\r\n\r\nIn section [All Variables Used](http://facebook.github.io/graphql/#sec-All-Variables-Used)...\r\n\r\nCurrent example:\r\n```graphql\r\nquery variableNotUsedWithinFragment($atOtherHomes: Boolean) {\r\n  ...isHousetrainedWithoutVariableFragment\r\n}\r\n\r\nfragment isHousetrainedWithoutVariableFragment on Dog {\r\n  isHousetrained\r\n}\r\n```\r\n\r\nI believe it should query on Dog first... so it should be updated to:\r\n```graphql\r\nquery variableNotUsedWithinFragment($atOtherHomes: Boolean) {\r\n  dog {\r\n    ...isHousetrainedWithoutVariableFragment\r\n  }\r\n}\r\n\r\nfragment isHousetrainedWithoutVariableFragment on Dog {\r\n  isHousetrained\r\n}\r\n```\r\n\r\nThank you for all the test examples in the document! It makes my life much easier\r\n\r\n- Barret  Let's add GraphQL Subscriptions to the Spec! This is really great! It was awesome that this took into account feedback from a variety of sources.\r\n\r\nI think this sketch of the subscriptions lifecycle is compatible with the one currently implemented in our `graphql-subscriptions` package here, which can be a nice way to test-drive some of the concepts: https://github.com/apollographql/graphql-subscriptions/\r\n\r\nWe've designed it in such a way that anyone currently using GraphQL.js can just drop it in and start using subscriptions right away, and we have some adapters for Redis, MQTT, etc.\r\n\r\nWe'll make sure that implementation is always up to date as new conclusions are reached in the discussion. After all, this RFC is just the beginning, not something set in stone.\r\n\r\nThere's also a transport protocol over websockets (something that shouldn't be covered in a spec, but you need a transport to use it) which we are currently using in production. It isn't coupled to any particular client or web server package, and implements all of the important lifecycle events necessary: https://github.com/apollographql/subscriptions-transport-ws\r\n\r\nI encourage people interested in this proposal to try out those packages with their existing server and experiment with GraphQL subscriptions today! I think that's going to be a great way to collect more feedback about this design. Awesome! Here's a rough schedule of what happens next:\r\n\r\nThis is a really well written RFC, but this should not deter anyone from asking questions - both getting into the weeds and challenging core assumptions and aspects of the proposal. An RFC is the *beginning* of a discussion. Let's leave this PR open as a place for discussion for the time being. Really happy to see progress on subscriptions! Good job, it looks great so far! \ud83c\udfc6 \r\n\r\n> the input query and variables are mapped to a set of events\r\n\r\nIt would be interesting to see the semantics of this mapping. In particular, do the root subscription fields have any special semantics or the interpretation of the root field semantics can be defined by a GraphQL server (for example, does every root field represents specific type of event like `commentCreated` or topic `comments` or something else)?\r\n\r\nAlso another remark. The RFC assumes and emphasizes that subscription communication is bi-directional. I wonder whether this restriction is necessary or required. I definitely see appeal of having bi-directional communication. For instance, it can multiplex several subscriptions in a single WebSocket connection and provide extended life-cycle phases for further optimizations. \r\n\r\nBut in the most basic form, uni-directional communication (server \u2192 client) can be sufficient to implement semantics described in the RFC. A while back I implemented [an example GraphQL subscription service that is based on SSE, which is uni-directional](https://github.com/sangria-graphql/sangria-subscriptions-example). As far as I can tell, it satisfies the semantics described in this RFC, but simplifies life-cycle a bit:\r\n\r\n* `Subscribe` (client \u2192 server) - represented by server receiving a client request with subscription query\r\n* `Subscription active` (server \u2192 client) - absent/implicit\r\n* `Unsubscribe` (client \u2192 server) - client just closes the connection\r\n\r\nWould love to hear your thoughts on this aspect of the RFC :)\r\n\r\nAlso regarding bi-directional communication. As far as I can tell, it defines a small protocol - something similar to [apollo WS transport protocol](https://github.com/apollographql/subscriptions-transport-ws#client-server-communication). Does this mean that in future we will have additional specification, alongside of GraphQL, that will define and standardize this bi-directional communication protocol (life-cycle phases, data format, command types like `SUBSCRIPTION_START`, `SUBSCRIPTION_FAIL`, `UNSUBSCRIBE`, etc.)? @OlegIlyenko my interpretation is that \"bidirectional\" means that in your description there are arrows that go from client -> server and also server -> client. Aren't any client -> server legs just mutations?\r\n\r\nThis looks consistent with what's implemented between [relay-subscriptions](https://github.com/edvinerikson/relay-subscriptions) and [graphql-relay-subscription](https://github.com/taion/graphql-relay-subscription) as well.\r\n\r\nA few comments:\r\n- An explicit \"subscription active\" message may not be necessary. I don't use one, anyway.\r\n- https://github.com/robzhu/graphql/blob/80f17faac4838a3afcff3213c785ebaa533d53c8/rfcs/subscriptions_01.png might be clearer if there were a box for \"other backend components\" that \"domain layer\" and \"event B\" connect to We started our implementation without a \"subscription active\" notification, but later had to add it. Because the first result from your subscription could arrive a long time after the initial request, you don't know if you're actually receiving those updates. In some cases, you want to be able to look at the state of the subscription to decide if you should be polling for data or simply waiting for events to arrive, especially if you don't want to miss some crucial updates to the information you're looking for.\r\n\r\nEssentially, it can be very hard to know what happened if you subscribe and get back total silence - did the subscription somehow fail or stall, or did it successfully start and you should expect to get results in the future? @taion I think you're using socket.io right? Maybe they have a system that checks if the subscription is successful under the hood? @stubailo \r\n\r\nTo clarify, I'm saying that \"subscription active\" notifications aren't required in all cases.\r\n\r\nIt really depends on the app. If it's something like chat, then \"subscriptions are down\" is a big deal and you want to show some user feedback. For something like, say, showing \"new comment\" prompts on a GitHub issue page, you don't really care.\r\n\r\nA general purpose subscription layer probably wants to expose something like those \"subscription active\" notifications to handle all uses cases, but they're not always necessary in more specialized cases. Good call - I agree that it is not necessary in cases where the subscription is not providing critical functionality. I think one other factor to consider is that returning an error about the initial subscription definitely is necessary - for example, if the query is not valid at all you want to receive some validation error in response to your initial subscription. Without a message that there was a successful subscription (essentially it just tells you the query validated etc) there's this time when you're not sure if there will be an initial error or not. Yup \u2013 error handling is necessary in general. I guess it depends how in-detail this spec wants to go on what the network layer should do. Questions like whether a subscription can do events singly or must be multiple, as asked in the blog post, point to the possbible usefulness of an abstraction like Observable, which is not inherently tied to multiplicity of responses. Also, that it is moving through standardization in the language would be helpful too.\r\n\r\nI'm also a fan of the DDP 'ready' event that announces the change from serving up existing old data to serving up new responses. While not strictly necessary, it lets you do things like remove loading graphics as you already know quite well @stubailo :)\r\n\r\nMy 2c on unsubscribe is it should be a message as well (as in DDP), but obviously the server should do the right thing if a connection goes stale and no unsubscribe was received.\r\n\r\nPS I'm in the category of someone whose org may adopt GraphQL if it had subscriptions. Right now we're rolling something on Meteor DDP until we see if Apollo could give us a compatible-enough experience. Observable is really a JS-level implementation detail, no? I don't think it's pertinent at the level of this spec. Thanks for writing this up, I'm looking forward to seeing how it evolves! I had a couple questions:\r\n\r\n- Somehow, I was previously under the impression that subscription requests _also_ returned an immediate result, as if they were queries. That's not mentioned here, right? So I was mistaken about that? \r\n- Would it make sense to add one more arrow to this diagram? I thought there might be one like this: \r\n  \r\n  ![image](https://cloud.githubusercontent.com/assets/2231765/23043248/ab4c5ba2-f469-11e6-8eaf-d2f252c2592f.png)\r\n\r\n  After the subscription system is notified of an event, it tells the GraphQL server to re-evaluate the query, and the GraphQL server gives a new response (in magenta) to the subscription system. (Then, the subscription system sends it to the client over the particular transport layer.) Did I understand correctly? That's how I made sense of this arrow in the later diagram:\r\n\r\n  ![image](https://cloud.githubusercontent.com/assets/2231765/23043368/0b5299d0-f46a-11e6-87b7-4f6c6f518df1.png)\r\n I don't think in general subscription queries should return an immediate result. If I have a subscription on e.g. items being added, what would that result be? @taion - The point of it wasn't to prescribe an implementation, but to convey semantics by referring to an existing spec to broaden the discussion. The contract covers issues like you mentioned above such as whether you get a result upon subscribe. http://reactivex.io/documentation/contract.html Whatever the solution may be. I \ud83d\udc4d the addition to the spec, because without a subscription system, GraphQL can hardly be considered as \"state of the art\", when if fact, it really should be. \r\n\r\nEdit: [Had to also link to Sashko's great blog post. ](https://dev-blog.apollodata.com/the-next-step-for-realtime-data-in-graphql-b564b72eb07b#.4yrfdrlel)\r\n\r\nScott One thing that's not necessarily clear to me (and to be honest, I haven't been down in the trenches with subscriptions, unlike others commenting here) is this:\r\n\r\nWhen the client wants to create a subscription, is it just executing a GraphQL query with a special operation? Or is it sending a package of \"something\" (_including_ a GraphQL query, variables, etc) to something else, and then that something else is interacting with GraphQL?\r\n\r\nI was previously under the impression that if I sent this query to my GraphQL server, using the exact same transport/etc mechanics as any other query, that it was creating a subscription:\r\n```graphql\r\nsubscription {\r\n  someField {\r\n    # sub-selections\r\n  }\r\n}\r\n``` \r\n\r\nIn this scenario, the GraphQL library ([graphql-ruby](github.com/rmosolgo/graphql-ruby) in my case) is handling the \"book-keeping\" of the subscription, and somehow I'm plugging in:\r\n- Events\r\n- A special network layer\r\n\r\nBut after reading this spec, it sounds like I'm instead directing this to something _other_ than my GraphQL library, handling the book-keeping myself, and periodically running a not-so-special query and sending the (black box) payload to the client.\r\n\r\nEssentially, what I'm getting at, is should we expect authors of GraphQL frameworks to be providing the book-keeping for subscriptions, etc and then exposing some fancy integration points (events and networking)? Or should we expect a new eco-system of subscription frameworks to grow up alongside existing GraphQL frameworks? I imagine implementation-wise there's not much actual change, right? As set up right now, GraphQL.js can execute a `subscription` query, but the actual semantics of the full request live outside. It's like the split between `graphql` and `express-graphql` for the standard query/mutation side. > Or is it sending a package of \"something\" (including a GraphQL query, variables, etc) to something else, and then that something else is interacting with GraphQL?\r\n\r\nYes, the idea is that you can add subscriptions on top of the existing GraphQL execution libraries by adding a subscription manager or subscription gateway. And that thing's job is to re-execute the subscription query against the GraphQL server in response to the event.\r\n\r\n> I imagine implementation-wise there's not much actual change, right? As set up right now, GraphQL.js can execute a subscription query, but the actual semantics of the full request live outside.\r\n\r\nI think that's about right - in terms of a library like GraphQL.js I think the one thing that could be added is a way to map the subscriptions fields to events. I think there would be a lot of value in putting that right next to the resolver code.\r\n\r\nOh, and one more thing - the resolver for a subscription field has one more parameter now, which is the \"payload\", so now that resolver takes in `rootValue`, `args`, `context`, and `payload`.\r\n\r\nThat could come in three different places:\r\n\r\n1. The payload could be passed as the root value, that would be consistent with looking at the subscription as a continuation of the mutation - so the mutation can push its result over the message system, and the subscription field picks up where it left off. But that could be confusing given that root values are used for other stuff as well.\r\n2. The payload is attached to context, but that feels like a bit of a hack to me especially since it means _all_ fields will be able to access it.\r\n3. There's a new parameter that only subscriptions field resolvers get access to.\r\n\r\nI think I'm in favor of (3), which requires a change to GraphQL.js to have the execution function take an extra `subscriptionPayload` parameter or similar. It'd be great if running a subscription could return some description of the relevant event set as a first-order concern, though the current workarounds aren't too bad.\r\n\r\nI'd prefer subscription payload come through as `rootValue` for consistency. > I'd prefer subscription payload come through as rootValue for consistency.\r\n\r\nThat's what the `graphql-subscriptions` npm package does right now, and it's not too bad. But we don't really use `rootValue` for anything else since we basically put everything on `context`. Yeah, I think that's the right thing, no? Now that `context` exists, `rootValue` is exactly just for injecting payload in that manner, I think. I've read through everything once more and I think I might be missing something (probably general understanding). But, how does or should the subscription system fit in with Introspection?\r\n\r\nCould someone also run through the subscription lifecycle with a use case? I am understanding two things here and I am not sure which one is right. Either the the event  on the server triggers a requerying of a specific GraphQL query from the client, or the event on the server pushes the new results of a specific query automatically to the client. I'd like to understand which one it is through a use case. Or can both happen?\r\n\r\nAnd a general comment. To me, the argumentation against a live query system referenced in the RFC is assuming that any standard GraphQL query should be subscribable as a live query. I'd suggest this is an incorrect assumption. Instead of any query being subscribable, there should only be specific (extra) queries that are subscribable. This should allow for a much finer control over what needs to be updated. It also simplifies the GraphQL subscription system enormously. You must admit, the event based system in this proposal is quite complex. The RFC even says it is the most complex way to go. To me, live queries are all GraphQL should be worried about. An events system, or a database that allows for live queries itself or whatever else userland can come up with to feed the live queries should be business domain specifics IMHO.\r\n\r\nScott Great to see this added to the spec!\r\n\r\nWe have been using relay-subscriptions for the last few months at Mainframe, and I wonder how much of this spec differs from relay-subscriptions\u2019 implementation?\r\nIn our case, with the only exception of handling notifications, all our subscriptions are linked to queries, so they notably use the same fragments, as in [relay-subscriptions\u2019 example](https://github.com/edvinerikson/relay-subscriptions/blob/b66edefeb9dff6ba1dea3fe19a42d0611540c419/examples/todo/js/subscriptions/AddTodoSubscription.js#L22).\r\n\r\nOne issue we needed to address was the possibility to miss relevant events between the time a query is resolved and the subscription is created on the server, as the current flow using relay-subscriptions is client queries -> server responds -> client creates subscription using response payload -> server receives subscription request -> server publishes subscription events when receiving internal events.\r\nOur current workaround is to have the server provide a \u201cversion\u201d (opaque string for the client) when responding to any query, that the client sends along with the subscription requests related to the query, allowing the server to look back at the events log and publish the needed subscription events to the client so it can catch-up on any change.\r\nWe implemented this logic in our custom network layer, but considering it is affected by the relations between queries and subscriptions, I wonder if it is something that could be part of this spec? Again, I think that's the sort of thing that really depends. In many cases I think that's just not required, and would instead just be extra overhead. That's interesting, it's actually a case where my _misunderstanding_ of subscriptions would come in handy. \r\n\r\nIn that scenario, a subscription request also returned an immediate response, so you could get the current server state _and_ make a subscription in a single operation. \r\n\r\nHowever, I'm not sure how you'd sort it out in a case like this:\r\n\r\n```graphql \r\nsubscription getNewComment($postId: $ID!) {\r\n  commentAdded(postId: $postId) {\r\n    newComment { \r\n      author { name }\r\n      message\r\n    }\r\n    post { \r\n      title \r\n      comments { message } \r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIn that case, the first response comes with `newComment: null` but `post: { ... }` is present, so you can initialize the UI with that state. \r\n\r\nThe problem is, on later requests, you'd _still_ get `post: { ... }`, which is overfetching. \r\n\r\nSo, I don't think it's much of an answer, but I thought I'd share anyways \ud83d\ude06  Presumably at the implementation level, you can put something on `context` indicating whether this is the initial subscription request, then do whatever is appropriate in the resolver.\r\n\r\nThere's nothing that _prevents_ an implementation from immediately firing an update corresponding to the current state \u2013 I just don't think it's required in the general case. I'm going to just drop a link to my Real-Time GraphQL Project here - http://github.com/rgraphql/magellan - where I define a protocol and proof of concept implementation for two-way communication between a GraphQL client and server, including real-time updates to results **and queries**.\r\n\r\nSubscriptions seem like an inelegant solution to me. They are extremely limited, one-way, one-time subscribe, unable to update query parameters after the subscription has started, etc. As you're finding now in this thread, these limitations make using and implementing subscriptions a muddy deal.\r\n\r\nIf something's not simple, it's probably wrong. And subscriptions to me seem to have a lot of cludginess as a result of jerry-rigging them in to an existing one-way one-off GraphQL spec. With the assumption that we have a two-way communication path with the server, a lot of optimizations and improvements can be made. I've written a proof of concept of this at the rgraphql repo I linked above. A demo is also available here: http://rgraphql.org\r\n\r\nCurious to hear your opinions on this. Liking the looks of the RFC so far!\r\n\r\nOne thing that's not in the RFC right now but that might be valuable: do we want to require that the sequence of payloads sent to the subscriber is determined only by the root subscription field (and its arguments), and that in particular the *fieldset* of that subscription field does not affect the sequence of payloads?\r\n\r\n----\r\n\r\nI think a concrete example probably demonstrates the value of this best; I imagine a developer on the client writing\r\n\r\n```graphql\r\nsubscription DeveloperSubscription {\r\n  commentCreate(postId: 1234) {\r\n    comment {\r\n      text\r\n      timeCreated\r\n      author {\r\n        ...CommentAuthorFragment\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis is a pretty basic subscription; every time there's a new comment, push a payload that includes the text of the comment, time created, and the author information (where that's delegated to another fragment, one that presumably defined by `CommentAuthorView` or something).\r\n\r\nNow I imagine using a client-side GraphQL framework to issue that subscription; if that framework has a normalized cache, it might want to augment the subscription to fetch IDs for some of the objects so that it can update the cache. So rather than issuing `DeveloperSubscription`, it would instead issue:\r\n\r\n```graphql\r\nsubscription FrameworkAugmentedSubscription {\r\n  commentCreate(postId: 1234) {\r\n    comment {\r\n      id # Added by framework\r\n      text\r\n      timeCreated\r\n      author {\r\n        id # Added by framework\r\n        ...CommentAuthorFragment\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nMeanwhile, our developer wants to debug this, and opens up Graphiql. The whole author fragment might be big and unwieldy and all the developer wants to do is verify that the subscription is working as expected, so the developer might issue the following in Graphiql:\r\n\r\n```graphql\r\nsubscription DebuggingSubscription {\r\n  commentCreate(postId: 1234) {\r\n    comment {\r\n      text\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n----\r\n\r\nOf course, the *payloads* received by these three subscriptions will be different between the three, since the field sets are different. But because the root subscription field on all three was the same, `commentCreate(postId: 1234)`, it feels like we should be able to guarantee the sequence is the same: if one subscription receives a payload, the other two should as well. It seems like without the guarantee, we might have three potential issues.\r\n\r\n - A client-side framework can't safely modify the field set without risking changing the functionality of the subscription.\r\n - A debugging developer can't reduce the size of the field set in Graphiql while guaranteeing that they are still seeing the same sequence as the client they are debugging.\r\n - We kinda break encapsulation: in the `DeveloperSubscription` example, the developer's intention is to subscribe to all comments created... but if the field set can alter the sequence, then changes to `CommentAuthorFragment` can alter the sequence. This feels kind of weird, the developer only spread in `CommentAuthorFragment` to ensure it fetched the right fields in the payload to render the comment author; the idea that a change to `CommentAuthorFragment` could alter the functionality of `DeveloperSubscription` feels odd.\r\n\r\nThoughts? @dschafer The spec contains special rules for root fields on a `Mutation` type. It sounds like you're suggesting that the root fields of `Subscription` type have a special property also: _only_ the root fields determine how a client is subscribed, so if two queries have the same root fields, they result in the same subscribed state (regardless of any child selections).\r\n\r\nIs that correct? If so, big :+1: from me. I somehow had that assumption, but I didn't notice it was missing from this RFC! I wonder if that might not be better as a best-practice type thing for typical use cases rather than a part of the spec?\r\n\r\nImagine a subscription like:\r\n\r\n```graphql\r\nsubscription {\r\n  commentUpdate(commentId: 3) {\r\n    author {\r\n      karma\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nWith my current implementation, if I care about author karma changes here, I would just create a new subscription, but it seems like it'd be odd to prohibit this subscription from firing on e.g. author karma changes, or else force something like:\r\n\r\n```graphql\r\nsubscription {\r\n  commentUpdate(commentId: 3) {\r\n    score\r\n  }\r\n}\r\n```\r\n\r\nto also fire when this sort of thing happens.\r\n\r\nAnd what about optimizations, e.g. for a partial update if none of the fields on a given subscription have changed in that partial update? @dschafer This sounds great \ud83d\udc4d. This is precisely what I mean in my question:\r\n\r\n> It would be interesting to see the semantics of this mapping. In particular, do the root subscription fields have any special semantics or the interpretation of the root field semantics can be defined by a GraphQL server (for example, does every root field represents specific type of event like `commentCreated` or topic `comments` or something else)?\r\n\r\nThis definitely helps to make the subscription semantics a bit more clear (as you mentioned, it has a big advantage for generic tools). In my experiments, I also found that this semantics for root subscription fields makes it quite easy to use `Observable`s instead of `Promise`s for root query fields.  > @dschafer The spec contains special rules for root fields on a Mutation type. It sounds like you're suggesting that the root fields of Subscription type have a special property also: only the root fields determine how a client is subscribed, so if two queries have the same root fields, they result in the same subscribed state (regardless of any child selections).\r\n\r\nSo subscription root fields will end up being special no matter what, since they both end up \"resolving\" to a value and identifying a \"sequence of payload events\" (which query/mutation root fields don't do). I guess my claim is that the \"sequencer\" should obey similar constraints to the resolver; in particular, in the spec the field resolver looks like:\r\n\r\n```\r\nResolveFieldValue(objectType, objectValue, fieldName, argumentValues)\r\n```\r\n\r\nNotably, `fieldSet` is *not* a parameter there; it's provided in `graphql-js` and other implementations to allow for reasonable optimizations (so you can do `SELECT name FROM users WHERE id=1` if they only asked for `{name}`), but the field value itself shouldn't change based on the field set. It would be very strange if `user(id:1){name}` returned `{name: \"Dan Schafer\"}` but `user(id:1){name, firstName}` returned `{name:\"Lee Byron\", firstName:\"Lee\"}`, and I'd argue that would be spec non-compliant.\r\n\r\nI'd envision the \"sequencer\" acting the same way; the \"sequence of payload events\" that it identifies should only vary depending on those four values (objectType, objectValue, fieldName, argumentValues) and not on the field set. So in some ways, I think this makes subscription fields *less* special, since it increases the parallelism between how they sequence and how all other fields resolve.\r\n\r\n----\r\n\r\n> I wonder if that might not be better as a best-practice type thing for typical use cases rather than a part of the spec?\r\n\r\nI think the primary benefit to having it be in the spec is for client tooling. If this guarantee isn't in the spec, then a client can't safely add a field to any subscription (and by extension, it can't really add a field to any *fragment*, because the fragment could be used in the subscription).\r\n\r\nI guess it feels like there's a pretty important guarantee that exists today in GraphQL: you can always safely add a field, and know the only thing that will change about the response is that there will be a corresponding key-value pair in the response for your field; the rest of the response will be the same. So while adding this guarantee in the subscriptions spec adds a restriction on subscriptions, it more importantly maintains an existing guarantee about field sets.\r\n\r\n----\r\n\r\n> With my current implementation, if I care about author karma changes here, I would just create a new subscription, but it seems like it'd be odd to prohibit this subscription from firing on e.g. author karma changes\r\n> And what about optimizations, e.g. for a partial update if none of the fields on a given subscription have changed in that partial update?\r\n\r\nSo because there's a lot of freedom in how we define the subscription root type, it feels like all of these possibilities/optimizations would still be available; they would just have to be more explicit. The intent would be that this change would just prevent the field set from being used as the trigger for a behavior change; instead, the behavior change would have to be made by calling a different subscription field, providing a different set of arguments to the subscription field, or using a directive, which feels like a reasonable tradeoff to me. The downside is that the field set cannot change the behavior, so we have to be explicit if we want to change behavior; but the upside is that the field set **cannot** change the behavior, so users/tools can safely manipulate the field set without worrying that we've changed something. Thinking a bit more on something like the \"empty partial update\" case \u2013 even if the GraphQL subscription itself uniquely identifies a sequence of events, would the network layer be required to not apply optimizations like not sending empty updates?\r\n\r\nContra request/response semantics on typical GraphQL operations, it seems like there's more scope for the network layer (on the server side) to do particular things here, such that spec guarantees aren't the final word for behavior in practice with an actual server. I think it would be very useful to recommend that the subscriptions system doesn't even know about anything other than the root subscription field, because it would be pretty unfortunate to have the server return different events based on the selection set. That would be like a mutation making a different change to the server based on the fields fetched afterwards.\r\n\r\nHowever, I think it's accurate that some subscriptions implementations would want to do throttling or batching of some kind, which means you don't get exactly one result for one event fired. So I'm not sure how the specification could have an opinion on how many messages are delivered, even though it would be very nice to have the re-running be independent of the selection set. For your case @taion I think `commentAuthorKarmaUpdated` would be good to be a separate subscription from `commentScoreUpdated`. Or, even something like `commentUpdated(events: [SCORE, AUTHOR_KARMA])`. To be clear, I'm just trying to work through hypotheticals here.\r\n\r\n@stubailo: you'd have a better answer for this than me \u2013 what would it look like to build something like a live query on top of GraphQL subscriptions? Naively I'd have imagined that it would require subscriptions with events that are payload-dependent. @stubailo - my argumentation exactly! Live queries would need to be specialized queries and contrary to the Facebook argumentation, not the standard read queries set to live. That would be very problematic. Live queries should be specific to the data needing updating and it will be that way 80-90% of the time. It seems like the live query idea was only half way thought through....\r\n\r\n@taion - My words! However, let's have GraphQL subscriptions BE a live query system. How userland gets the data to be live should be up to them. It is a userland concern, whether it be events, databases that do live queries themselves, polling some other API (which defeats the purpose of live queries, but sometimes it just isn't possible otherwise). There are a myriad of possibilities and now GraphQL is forcing something on its users with this (self-admitted) difficult events system. KISS \ud83d\ude04  \r\n\r\nScott @smolinari @taion this is exactly what I have built in rGraphQL - http://rgraphql.org - live data. Users decide how to feed data into the resolver system. It adjusts automatically to your code via reflection. Then query changes and result changes are streamed over a two way connection.  It would not be appropriate for GraphQL subscriptions to mandate live queries. In general doing live queries in a scalable manner is an unsolved problem, and it's not in general the correct solution for all use cases anyway. @taion - It would be just as appropriate as the event system being (possibly) mandated, except considerably simpler. I also don't understand your comment about live queries being an unsolved problem in terms of scaling. What problem is there?\r\n\r\nScott > It would not be appropriate for GraphQL subscriptions to mandate live queries. \r\n\r\nI cannot agree with this enough, we're talking about two vastly different things here @smolinari, live queries trigger on *any* update. Subscriptions are fine-grained and specific. Also live queries involve a lot of backend logic in order to support them, something GraphQL has managed to stay away from as yet. @Siyfion - maybe my definition of a live query is different then, because in my book, a live query is a particular query that is \"deemed\" live. In other words, you call certain queries as live through a different subscription method. You could say it is like a subscription system, but without all the event stuff. How updates are fed back to the GraphQL server is domain specific and yes, it could get hairy, as we can see from the solution offered here. \r\n\r\nThis is an example of something similar to what I have in mind: http://blog.parse.com/announcements/parse-server-goes-realtime-with-live-queries/\r\n\r\n> To use live queries, you just construct a Query like you normally would and call subscribe() instead of find().\r\n\r\nScott Awesome conversation around this so far.\r\n\r\nOne concern I wanted to throw in which I've discussed with @dschafer and @robzhu offline about is what the right abstraction should be for the source of triggering the execution of payloads. Right now the RFC suggests:\r\n\r\n> When the Subscription is created, the input query and variables are mapped to a set of events to which the Subscription listens.\r\n\r\nI think this actually exposes too much about the implementation details of a subscription and makes too strong of an assumption that a Pub Sub system is the *only* way rather than the *primary* way to implement subscriptions. The wording is actually pretty close to what I would recommend, but how we read it is importantly different.\r\n\r\nI think the appropriate abstraction requires two things:\r\n\r\n1. A relationship between a client and service must be *bidirectional*. That is, in addition to a client being able to initiate connection with a service, the service must also be able to communicate directly to the client. This differs from a request/response model where a service can only \"speak when spoken to\".\r\n2. Each subscription instance corresponds to a single sequence of notifications emitted over time, e.g. a single *Observable*. Each emit from the Observable must result in a GraphQL Subscription payload.\r\n\r\nA PubSub system can pretty clearly satisfy both of these, \"Pub\" is the reverse direction of \"Sub\" fulfilling bidirectional, and if more than one \"events\" or \"topics\" are relevant, this can still be modeled from GraphQL's point of view as a single merged Observable.\r\n\r\nImportantly, service statefulness is not required. Webhook APIs can also satisfy these statelessly. Webhooks include a URL to POST payloads to fulfilling bidirection, and the \"Observable\" exists only abstractly via some other part of the service that's run repeatedly over time as a result of some other incoming request (i.e. GitHub `post-receive` git hook). Following up on that, this different framing of the base abstraction still captures @dschafer's concerns above: May a change in selected fields result in a different sequence of payloads? @leebyron I agree that it might be better to avoid mentioning events explicitly. In the proposal I shared with you guys before I had framed it as a \"callback\" provided to the application code by the subscriptions system, where the callback can be called as many times as desired with payload objects. Perhaps \"observable\" could be used as a term, but I find that term pretty heavily overloaded by specific implementations like RxJS that bring a lot of baggage.\r\n\r\n> the input query and variables are mapped\r\n\r\nI'd also propose this wording could be changed to \"root subscription field and arguments\" to suggest that implementations should avoid depending on parts of the query other than the root field.\r\n\r\n@smolinari Subscriptions as proposed here, IMO, should almost never be used as a live query because they don't provide some relevant guarantees, and I think it might be good to ensure that there's a very clear distinction. Live queries would be a great feature to have in GraphQL, but I don't think this proposal should be expanded to also include that separate concept. @leebyron / @stubailo:\r\n\r\nTo what extent is it actually necessary to codify the behavior of the subscription system? At a minimum, GraphQL itself only needs to deal with two cases, no?\r\n\r\n- On a subscription being received, given the subscription query, produce some sort of `NewSubscriptionResult`, e.g. for the subscription to use to identify a set of events\r\n- At future points in time, given the same subscription query, produce some sort of `SubscriptionUpdateResult`, e.g. to send on to the subscriber\r\n\r\nDoes the GraphQL spec need to outline what the subscription system does? For example, the guarantee mentioned above can just be stated as the `NewSubscriptionResult` being only a function of the root query; further semantics don't concern the GraphQL engine directly.\r\n\r\n@stubailo \r\n\r\nI think the best scenario would be that the subscription support is event-based, but that it would be possible to use it as a lower-level building block for a live query system. Do you think this is impractical? > To what extent is it actually necessary to codify the behavior of the subscription system?\r\n\r\nI think the value of specifying some part of GraphQL is to make it predictable. You want to know what the life cycle of a subscription looks like, how it might change when requesting different fields, etc.\r\n\r\n> Do you think this is impractical?\r\n\r\nLive query systems can easily be built as extensions to GraphQL completely independent of subscriptions. Do you think some part of the current proposal makes live queries harder to implement than they were before? Hi!\r\n\r\nI implemented a naive and **simple** GQL Subscription implementation using `EventSource` and @rmosolgo's [`graphql-ruby`](https://github.com/rmosolgo/graphql-ruby).\r\n\r\n```js\r\nvar source = new EventSource(`/graphql?query=\r\n  subscription ($id: ID!) {\r\n    todoAdded(id: $id) {\r\n      id\r\n      text\r\n    }\r\n    todoUpdated(id: $id) {\r\n      id\r\n      isCompleted\r\n    }\r\n    todoRemoved(id: $id) {\r\n      id\r\n    }\r\n  }`)\r\nsource.addEventListener('graphql.todoAdded', function (message) {\r\n  // \"todoAdded\" field resolved.\r\n})\r\nsource.addEventListener('graphql.todoRemoved', function (message) {\r\n  // \"todoRemoved\" field resolved.\r\n})\r\nsource.addEventListener('graphql.todoUpdated', function (message) {\r\n  // \"todoUpdated\" field resolved.\r\n})\r\n```\r\n\r\nThe problem here (which is not a problem for implementation but the RFC) is it's executing queries lazily with back-end generated variables (publisher at back-end sets the variables).\r\n\r\nSince this approach works on this example, I have no experiment on a more complex application.\r\n\r\nThis is the working demo:\r\n\r\n![Gif](https://github.com/f/graphql.js-demo/raw/master/demo.gif)\r\n\r\nI know this approach has some pitfalls. E.g. I cannot subscribe to an individual field at back-end since I'm listening to back-end publisher to take the variables and execute the query comes from client. And it's not very intuitive. But works exactly how I need.\r\n\r\nHere is the link you can try out [https://github.com/f/graphql.js-demo](https://github.com/f/graphql.js-demo) I've read the RFC (excellent job @robzhu!) and all of the (insightful) comments. I want to understand if GraphQL Subscriptions can be used for implementing hot + cold observables, where a user first gets the initial state (cold observable) and then receives subsequent changes (hot observable)? In such a system, the hot observable (subscription payload) must be combine-able with the current client state. \r\n\r\n1. Should the RFC include details about behavior regarding the first payload vs all subsequent payloads. For example, the initial state (cold observable) must be sent as the first payload, if the value is present and the context makes sense?\r\n\r\n2. Should the RFC include details about the order of subscription payloads as they relate to the firing order of the underlying events. \r\n\r\n3. Should the RFC propose a special metadata field in a subscription payload to serve as place for data like: eventIds that triggered the subscription payload, a sequential payload id to serve as a data anchor to detect payload loss when using non-reliable transport libraries like socket.io (where loss can occur when protocol switching)? @stubailo On live queries, that makes sense, thanks.\r\n\r\n@romandvoskin To me, (1) seems application-specific, while (2) and (3) seem transport-specific. To e.g. the points earlier, these don't seem like things that should be specified at the level of the query language, as they relate to properties that you may or may not want in a specific implementation, in an application-specific manner. I wrote some feedback to @robzhu privately, which he asked me to share here. I will.\r\n\r\nI think this proposal will enable a useful subset of realtime/reactive use cases.\r\n\r\nI see the subset as event-triggered schema projection. Whenever one of a specified set of underlying events happens, run a user specified projection of the GraphQL schema.\r\n\r\nImagine we have event sources `IObservable<X> xs`, `IObservable<Y> ys`, `IObservable<Z> zs`, ..., a GraphQL schema, plus a function that maps from `TSchema` (the GraphQL schema) to `TPayload` (the user specified subset of the schema). We could model the proposal as an Rx Observable query.\r\n\r\n```\r\npublic IObservable<TPayload> GraphQLObservable<X, Y, Z, ..., TSchema, TPayload>(IObservable<X> xs, IObservable<Y> ys, IObservable<Z> zs, ..., TSchema schema, Func<TSchema, TPayload> query) {\r\n  var xSignals = xs.Select(_ => Unit.Default);\r\n  var ySignals = ys.Select(_ => Unit.Default);\r\n  var zSignals = zs.Select(_ => Unit.Default);\r\n  return Observable.Merge(xSignals, ySignals, zSignals)\r\n    .Select(_ => query(schema));\r\n}\r\n```\r\n\r\nThis Observable query is quite general, as the user may specify whatever query he wants, and we can select any list of underlying events as triggers.\r\n\r\nHowever, for some use cases, this approach may not be significantly more efficient than polling.\r\n\r\nConsider the following case.\r\n\r\nLet's say I want to produce a trending topics live dashboard. This dashboard will show me a top 10 list of the most popular Twitter hashtags in the last 6 hours.\r\n\r\nThere is one underlying event stream: Tweets.\r\n\r\nOne approach, which could be implemented with GraphQL subscriptions, would be to trigger a re-query across all the tweets for the past 6 hours every time a new tweet occurred.\r\n\r\nA more efficient approach would be to set up a stream processing pipeline, say with Apache Storm, that processed the tweet stream through a directed graph of computation.\r\n\r\n* Spout: Tweet stream\r\n* Edge: Random partitioning (load balancing)\r\n* Bolt Type 1: Parse hashtags from tweets (stateless)\r\n* Edge: Partition by hashtag\r\n* Bolt Type 2: Perform 6 hour rolling counts of hashtags (maintain intermediate state)\r\n* Edge: Partition by count object\r\n* Bolt Type 3: Intermediate rankings of counts (maintain intermediate state)\r\n* Edge: Global grouping\r\n* Bolt Type 4 (singleton): Total rankings of counts (maintain intermediate state)\r\n* Edge: Random partitioning\r\n* Bolt Type 5: Publish (stateless)\r\n\r\nHere's a post that details how to implement this stream processing pipeline in Storm.\r\nhttp://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/\r\n\r\nHere, we set up the processing pipeline once, at the dawn of time, or when a user expresses interest. Once we set up the processing pipeline, there's no querying required when an event happens. We take an underlying event stream and transform it into a more interesting stream, which pushes data at the user. It's all reactive.\r\n\r\nI guess the distinction is push versus pull. Querying is a pull activity. In the proposed (RFC) model, we pull at sources, not on a fixed interval trigger like polling, but on an event-based trigger. That's a possible and useful approach to solving realtime use cases, but it may not be practical (efficient) for some applications.\r\n\r\nAll that said, I still think the proposed spec covers a useful subset of cases. It will be wonderful to avoid under-pushing/over-pushing in those cases. @rzachariah This is an interesting observation. I wonder if the feature you're getting with Storm is possible here by creating an event (becoming an event source) as a consumer of a subscription. To use your use case, an initial subscription to tweets is consumed by an aggregator (which as an event source) publishes an event whenever the result (top x tweets) changes. What do you think?  @romandvoskin I think that's right. I could create a GraphQL Subscription server that offered both a Tweets subscription based on raw tweet events, and a Trends subscription based on manufactured top-x rankings events. There is a relationship between these event streams, but perhaps those are implementation details of the server. Perhaps the GraphQL Subscription spec should be ignorant of any distinction between raw and manufactured events. @rzachariah  - Correct me if I am wrong, but your example is one where a polling type push of data (the event to GraphQL) is going to be the result of the aggregation of top tweets. In other words, you wouldn't want to push data for each tweet, but rather only every minute or 10 seconds or whatever is smart for your users and your system. It is a great example of how diverse the events could be, which trigger publishing data to subscribers.\r\n\r\nOn a side note: The more I read and learn, the more I see that the pub-sub system, which is put forward in this RFC, is actually what I consider a live query system. So, I apologize for my ramblings. \r\n\r\nI've also noticed that \"live query\" has been defined in different ways for different technologies, from databases to jQuery to Meteor. So, seeing as there is no one clear standard for what a live query is, I'd like to also suggest we call this system \"GraphQL Live Query\", simply because that name is a lot sexier than \"pub-sub\" or \"GraphQL Subscriptions\". \ud83d\ude04 \r\n\r\nOr is there a clear definition of what a live query is? Let's forget what was put forward as a live query in this RFC, as it also isn't a standard either. \ud83d\ude09 How about it?\r\n\r\nScott\r\n\r\n Hi @smolinari. Yes, in my example, the top trends event stream is a streaming aggregation of the tweet stream. The throughput (events/second) of this derived event stream would be much lower than the raw event stream that produced it. There's some natural filtering as a result of the top-x operation. In addition, yes, it would be reasonable to introduce additional delays/batching to reduce the computational load. A top 10 trends dashboard that's live as of a few seconds ago, or even a minute ago, seems reasonable.\r\n\r\nI was also trying to suggest a more efficient alternative to simply iterating over the last 6 hours of tweet data every time you're interested in updating the trends dashboard. I proposed a storm topology as an approach that maintains intermediate state about the computation (sliding window counts by topic, current rankings), so there's very little work to do whenever it's time to process a new tweet. It's an event processing pipeline made up of a chain of subscriptions. An Rx query would be another example of an event processing pipeline made up of a chain of subscriptions, and it's possible to write one for this example (though the Rx version would not be as scalable).\r\n\r\nOne could think of a storm topology or an Rx query as a live query. It's a query that, once deployed or subscribed to, is always running and automatically pushes updates in reaction to new input events. Some thoughts on this I've had reading the RFC and this thread (in no particular order):\r\n\r\n* the case for subscriptions _inside_ graphql needs to be made more strongly. 'Ah well, you can just implement that in your transport layer' seems to have come up a few times. \r\n* in `img_01`, why does the subscription layer talk directly to graphql? This feels like a break in the abstraction.\r\n* there feels like there is a gap between Data-transform pipelines and Live Queries for entity-state updates. The main problem with live queries is not business logic decisions[1] but computation and dependency complexity. If I have an _n_ depth query I am subscribed and an object at depth _n_ changes, propagating this back down to the root subscriptions is difficult (not impossible, but I'd rather not have to think about how to get it to wire up!). Comments by @leebyron, @rmosolgo and @stubailo about restricting subscription semantics to the root parameters all speak to this. \r\n  * I think restricting subscription semantics to the root parameters is generally a good restriction to make, but it needs to be made clearly and with reasons given if it is to be more than a recommendation\r\n  * talking about live queries is unclear (and has already caused some confusion). This seems to be a DB-land phrase originally, but it does appear to be causing confusion. It would be better to frame everything in terms of the construction of graphql queries and their result sets.\r\n  * distinguishing between events (state mutation events), actions/commands (not in here yet, but closely related in the eventing world) and whole state objects is immaterial given the above, particularly since they are all types of event and the distinction is unenforceable.\r\n* in `img_01` most the green subscription layer seems unnecessary. A graphql subscription would work without any bi-directional traffic from downstream. Leaving this in may reduce the clarity of the message (it could perhaps go in an addendum to describe a more complex system).\r\n* there is definitely room for best practice stuff around designing events, but this should be demarcated as best practice since it's stuff that is contingently true.\r\n\r\n[1] here I disagree with Dan Schafer and Laney Kuenzel's assessment of Live Queries in Relay (though not their decision). I think their domain problem (ie, when do I update?) is technically solved (eg using some sort of buffer/aggregation or debouncing, ignoring the computational cost aspect) but requires a product decision as to what should updates be seen when. Their second point about computational complexity speaks only to that specific use case, not all use cases. FWIW, I'd strongly recommend taking a look at [graphql-subscriptions](https://github.com/apollographql/graphql-subscriptions) and [graphql-relay-subscription](https://github.com/taion/graphql-relay-subscription) (with [relay-subscriptions](https://github.com/edvinerikson/relay-subscriptions)), if you haven't already.\r\n\r\nI think there already _are_ implementations that hew quite closely to what's in the proposal. Some of these are even already live.\r\n\r\nThose systems, their relevant API warts, and the current GraphQL reference implementation (which has already moved ahead of the spec here) are in some sense existence proofs for what makes sense engineering-wise to split between core and transport layers. Thanks Jimmy. While I've read around them I haven't looked at them in\ndetail yet. My main goal wasn't to dispute that subscription is useful, or\neven that this is heading in the right direction,[1] but to improve the\nclarity of the whys. Once this is tighter, it is easier to debate 'is this\nthe problem we want to solve' and 'is this a solution to the problem'\nseparately.\n\n\n[1] except maybe the definition of events\n @rzachariah\r\n\r\n> It's a query that, once deployed or subscribed to, is always running and automatically pushes updates in reaction to new input events.\r\n\r\nThat sounds like exactly what the one-sentence-definition of GraphQL Subscriptions or ehem.... Live Query \ud83d\ude04  should be. \ud83d\ude09 \r\n\r\nScott @smolinari I hate to keep mentioning it, but I have actually proven in rgraphql that \"live\" Graphql queries with arbitrary data sources (no DB related logic) and mixes of static and dynamic data is easily possible without changing the current spec at all. What these guys are working on is a extension to the spec that works around the cludge of typical one-way data sources like Pub/Sub or long polling on requests. Otherwise there's no advantage to the flat limited subscription model when compared to a streaming system.   Ok. @paralin Still, I am a bit confused. Are you making that point for me, because I am misunderstanding something or are you making that point to everyone else, to say all this isn't really necessary to make a live query system within the spec? Or maybe even both? LOL! \ud83d\ude04 \r\n\r\nScott The spec already covers everything for live queries, other than I suppose directives to control the execution. But that's more of a server specific thing anyway. \r\n\r\nWhat's the difference of a live query to the spec? You're still specifying what data is required in the same syntax.  Hey all, amazing feedback and discussion so far, but it\u2019s clear the github PR single-comment-thread feedback format is not suited for hosting multiple conversations at once. \r\n\r\nI\u2019m going to go through the feedback and organize everything into **open** and **closed** topics. **Closed** topics are either obvious or have clear consensus and will be merged into the proposal in the next edit. **Open** topics are still being discussed (I will try to tag everyone who\u2019s been involved/interested on each topic). Once I\u2019ve organized this list, I\u2019ll need everyone\u2019s help:\r\n\r\n* Make sure the list is complete and the categorization of open/closed topics is accurate\r\n* Make sure your name is tagged on the topics you care about.\r\n\r\nAfter that, I\u2019ll merge this PR (clearly marked as \"WIP\") and open issues for each of the open topics so that we can have a more focused conversation. As each open topic is resolved, we will make the appropriate edits as part of a new PR. My main goals are to make sure all the great conversations here are captured without competing for attention and that we can make incremental progress on getting this into the Spec.  @paralin \r\n\r\n> What's the difference of a live query to the spec? You're still specifying what data is required in the same syntax.\r\n\r\nSomehow a query needs to be designated as \"live\" by the client. Or, as you said, and I think we are on the same wavelength on this, the queries that can be called as \"live\" need to be defined on the server in some way and be obvious/ findable through introspection.   \r\n\r\nScott >Do we need a \"bi-directional\" channel between client and server?\r\n\r\nThe use of SSE v WS is an application-level implementation detail. All that's needed is the server being able to push messages to the client somehow, which distinguishes this from request/response.\r\n\r\n>Where should subscription state be stored? (inside GraphQL-js or as a separate component?)\r\n\r\nI'd prefer to have this state be stored outside of GraphQL.js. I want to e.g. manage my own Redis subscriptions backing my GraphQL subscriptions, and I feel like the control logic is more straightforward if I have something I can call when my subscription fires, rather than passing e.g. an observable into GraphQL.js.\r\n\r\n>How should we pass event payloads/data into the subscription resolvers?\r\n\r\nThis is a framework-level implementation question. I'd prefer GraphQL.js use the existing `rootValue` field here.\r\n\r\n>The \"event stream\" should be derived purely from the subscription root field (and ignore selection set).\r\n\r\nI agree with this. It's the \"natural\" way to write the spec.\r\n\r\n>Fetching initial state when subscribing.\r\n\r\nI think this is an application-level thing. \"State\" is not a concept that is inherent to GraphQL. Subscribing to e.g. streams of newly created items also doesn't necessarily admit an easy representation of current state. Imagine subscription updates that don't reflect idempotent operations \u2013 in such cases there isn't really a coherent initial state.\r\n\r\n>Re-define Live Queries? Can Live Queries make Subscriptions unnecessary?\r\n\r\n@stubailo's point is exactly right here. Live queries should be thought of separately from event-based subscriptions. They can be used to solve similar problems. However, scaling event-stream-based subscription systems is relatively well-understood; the same does not apply for live queries, and for anyone looking to ship something scalable now, live queries aren't really an option.\r\n\r\n>Intermediate Subscription event processing\r\n\r\nThis is an application-level detail. If someone wants to subscribe to e.g. a \"top X\" stream but not re-process that stream, then there's nothing at the framework level that prevents e.g. the \"trending tweets\" subscription from using different events than the \"new tweet\" subscription. @taion Live queries certainly could be scalable, especially with GraphQL's emphasis on separating logic for each field. I'm looking at implementing a scheduler for [Magellan](http://github.com/rgraphql/magellan) that could do that.\r\n\r\nBut, you're right. Subscriptions are a different topic from live queries. And IMO, live queries don't need a change to the spec to be implemented. Directives are server-specific with introspection, and that should be all you need. Just to clarify, when I say \"live queries\", I mean something like the `@live` directive mentioned in talks, where the interface presented to the client is one where the client can request a particular query be live, rather than one where the client explicitly requests specific streams.\r\n\r\nFor an example of a subscription-based API, see https://github.com/edvinerikson/relay-subscriptions/blob/v1.0.0/examples/todo/js/components/Todo.js#L124-L148.\r\n\r\nIf this were using live queries, then perhaps it would just look like:\r\n\r\n```graphql\r\nfragment on Todo @live {\r\n  id\r\n  complete\r\n  text\r\n  # ...\r\n}\r\n```\r\n\r\nHowever, if you're doing various things such as using microservices and splitting up GraphQL objects across multiple backend services, &c., how to efficiently implement live queries can be much less than obvious, while event-based systems are much more straightforward. Since there's excitement and support for the direction of this RFC, I'm going to commit it as an official tracked RFC. @robzhu just opened up issues for all of the various topics still under discussion - so this is still very much an open design! So excited! Me too! \ud83d\udc4d \r\n\r\nScott AHHHHHHHHHHHHH!!!!!!!  `type` => `input` Good catch. Thanks a lot @firede.  Follow-up to #260\r\n\r\nImproved the note on input coercion for null value via runtime variable value for a list type.\r\n\r\nThe previous form was a little bit hard to read. Hopefully the changes improve its readability.\r\n\r\nThanks!  Minor typo correction, from 'interpretted' to 'interpret'.\r\n\r\nFor further consideration: would it possible to re-consider the entire sentence? Currently, it is not easy to read.\r\n\r\nCurrent (with typo change)\r\n> Note that when a {null} value is provided via a runtime variable value for a\r\nlist type that it is interpreted as no list being provided, and not a list of\r\nsize one with the value {null}.\r\n\r\nPossible change:\r\n> Note that when a {null} value is provided via a runtime variable value for a\r\nlist type, the value is interpreted as no list being provided, and not a list of\r\nsize one with the value {null}.\r\n\r\nOpen to discussion.\r\n\r\nCheers!  Does this exclude the possibility of using `__id` for IDs, which are not strictly introspection, or will that involve changing this language?  Over at [graphql-java](https://github.com/graphql-java/graphql-java/pull/238#issuecomment-259005359) we've run into some confusion regarding 2.9.2 (Float Value). The JS implementation lets you have an empty FractonalPart, even though it's not marked \"opt\" in the spec. What is correct? @okorz001 @pcarrier\n https://github.com/graphql-java/graphql-java/pull/238 with reference to graphql-js implementation.\n  I\u2019m only semi-serious with this proposal, and I\u2019m more interested to hear a defense of union types (because I currently can\u2019t think of one) then to see this proposal proceed.\r\n\r\n* * *\r\n\r\nIn the specification, it is currently written that [\u201cAn Interface type must define one or more fields.\u201d](http://facebook.github.io/graphql/#sec-Interface-type-validation). From a precursory glance at the specification it seems like that limitation is arbitrary. In addition, if we remove that validation requirement (and perhaps change some other spec wordings) an interface could behave the exact same as a union, and perhaps be strictly better. An interface with no fields would be better than a union because the interface gives the schema designer the flexibility to add common fields in the future. Because interfaces are nominal and not structural this could be allowed.\r\n\r\nA major benefit of unions in functional programming languages is that pattern matching statements with unions can be exhaustive. Whenever a programmer adds a new variant to the union, the type system breaks and requires all exhaustive pattern matches to be update appropriately. In GraphQL such a benefit is not realistic given that the code (mobile apps) which executes against a GraphQL schema can not always easily be updated when adding a new variant to a union. It would seem that the spec makes the argument that unions are good because:\r\n\r\n> [Unions] also differ from interfaces in that Object types declare what interfaces they implement, but are not aware of what unions contain them. [(source)](They also differ from interfaces in that Object types declare what interfaces they implement, but are not aware of what unions contain them.)\r\n\r\nHowever, it seems to me that the only case where the property of objects not declaring union membership is useful is in a pattern matching scenario which I think we can agree is a scenario that doesn\u2019t always work well with the design goals of GraphQL.\r\n\r\nFurthermore, if we make this change removing unions from the specification and allowing interface types with no fields, it wouldn\u2019t be a breaking change. The access patterns from a GraphQL client that assumes unions exist would be the same for an interface with no fields.\r\n\r\nSo I think it\u2019s plausible that we can remove unions from the spec and maintain backwards compatibility (I\u2019d love to be proven wrong! That\u2019s what this issue is for :wink:), and I also think it would have the following benefits:\r\n\r\n- Simplifies the specification without breaking it, making it easier to learn for beginners and easier to build off of for implementors both on the client and server side. I\u2019ve run into my fair share of Relay 1 union type bugs and gotchas. (https://github.com/facebook/relay/issues/1203, https://github.com/facebook/relay/issues/1230)\r\n- No more union type related proposals which may or may not actually be useful/plausible, such as union input types and union scalar types. (https://github.com/facebook/graphql/issues/215, https://github.com/graphql/graphql-js/issues/207, https://github.com/graphql/graphql-js/issues/291, https://github.com/facebook/graphql/issues/202)\r\n\r\n* * *\r\n\r\nAgain, I\u2019m only semi-serious about this. I mostly just want to hear when you would ever need a union type. I also want to hear future plans for how the union type will evolve because in its current form I don\u2019t see much utility (asides from interfaces with no shared fields).\r\n\r\nAt a minimum can we remove the requirement for a single field on interfaces? At that point I can remove union types from my projects altogether :wink: > First Let's look at client's pattern matching on return types for a Union, in my client code (pseudo code):\n> \n> ```\n> switch (oneOf) {\n>   case A:\n>   case B:\n>   case C:\n>   case Unknown:\n> } \n> ```\n> \n> Because of how unions must be queried, the unknown type is the empty object type.\n\nIf you replace the word \u201cunion\u201d with \u201cinterface\u201d here, nothing else changes. Unions and interfaces even match against the same `__typename` field. Calling it a union instead of an interface presents a communication challenge, API developers must make sure all consumers know that a union may have more/less variants at any point in time. This communication must be made because in other languages unions have great utility by being exhaustive. By calling it an interface and not a union, the assumption that the type is not fixed is encoded in the dialog.\n\n> A Union is a way to say \"I may return one of a few things at this location\" - it should be defined locally to the field. For example, a `Video` type doesn't need to describe that it might appear alongside `Photo` for some specific fields, though a specific fields needs to describe that it might return `Video | Photo`.\n> \n> An Interface is a way to say \"I conform to this contract\" - it should be defined locally to the thing which conforms, the Object type. For example, a User type should be able to say that it fulfills the contract of Profile such that any type current known or unknown can be used knowing that it fulfills the contract.\n\nThis is a good point, and you\u2019re right the ergonomics of unions are better in this case. However, should ergonomics alone define whether something should be in the spec? Also, your argument here revolves around type definition which is not even part of the spec. GraphQL implementations may choose to allow users to define an interface just as one may define a union. Also, what if an implementation decided to make types open ended? (like in TypeScript)\n\n``` graphql\ntype A { a: Int }\ntype B { b: Int }\ntype C { c: Int }\n\nunion U = A | B | C\n```\n\nDesugars to the following in an open ended system:\n\n``` graphql\ntype A { a: Int }\ntype B { b: Int }\ntype C { c: Int }\n\ninterface U {}\ntype A implements U {}\ntype B implements U {}\ntype C implements U {}\n```\n\nHere you get the same benefits of local definition with interfaces. Let\u2019s not argue about whether or not defining GraphQL in an open ended manner like this is good or bad, the point of the demonstration is to show that it is up to the GraphQL schema implementor to solve the \u201cI may return one of a few things at this location\u201d case and not the specification. Consumption of the union doesn\u2019t change for the client whether it is a \u201cmarker interface\u201d or a union.\n\nI see ergonomics in type definition (which is not even specified!) as the only argument for unions. If we let ergonomics alone define whether unions should be in the spec, that sets a slippery slope precedent.\n\nAnother quick note in the case of `union SearchResult = Person | Post`. I think such a union is an anti-pattern. I personally think the better schema design would be types like so:\n\n``` graphql\ninterface SearchResult {}\n\ntype PersonSearchResult implements SearchResult { person: Person }\ntype PostSearchResult implements SearchResult { post: Post }\n```\n\nAs in the future this allows schema designers to add new fields without making breaking changes at the cost of one inexpensive level of indirection.  An example field to be added may be `relevance`. If this is the best pattern then these pseudo-unions are for all intents and purposes defined locally anyway as most of the time `PersonSearchResult` and `PostSearchResult` will generally be defined locally, or at least near, `SearchResult`.\n\n> This concept of contract-less interfaces is often called \"marker interfaces.\" They're typically used either as a backfill for languages like Java that don't have a good concept of Union, or are used as metadata annotations for languages that don't have metadata annotations. I don't think either should apply to GraphQL for modeling data domains.\n\nI think the tradeoff between the bad taste of marker interfaces and simplifying the spec for beginners and tooling is a fine one to make :blush:\n\n---\n\nAnyway, I think I\u2019ve said all I have to say on the matter. I might never use unions, but ultimately I don\u2019t feel too strongly removing them for everyone else. In my opinion over time, unions are only going to make the spec (and subsequently ecosystem) more complicated. So if we can remove them now without breaking a lot of things, why not?\n\nIf you haven\u2019t been convinced by any of the arguments above, feel free to close this issue \ud83d\udc4d \n Closing this aging issue @calebmer this is an interesting idea and I've come across it as well recently. I found that allowing `interface` to have no fields can be useful, but `union` would also be needed in some scenarios. For instance, `union` is more flexible when re-use types. Here's my two cents.\r\n```gql\r\ntype ObjA {}\r\ntype ObjB {}\r\ntype ObjC {}\r\n\r\nunion U1 = ObjA | ObjB\r\nunion U2 = ObjB | ObjC\r\n```\r\nWithout `union`, you'll have to declare more types because each type will be strictly coupled with only one interface.\r\n```gql\r\ninterface U1 {}\r\ninterface U2 {}\r\n\r\ntype ObjA implements U1 {}\r\ntype ObjB implements U1 {}\r\n\r\ntype ObjB' implements U2 {}\r\ntype ObjC implements U2 {}\r\n``` Another use case is when you need to deal with existing types, `interface` can't help. Say, I need to define a field in a type that could be String, Int or Float. With `union` I can easily make it like this:\r\n```gql\r\nunion CustomData = String | Int | Float\r\n\r\ntype Obj {\r\n   cData: CustomData\r\n}\r\n``` @IvanGoncharov thanks for pointing them out!\r\nIt's good to know that it supports implementing multiple interfaces and it doesn't support scalar union (which surprises me, I think that's probably why this issue #215 is still open).\r\n  Hmm, let me see if I understand correctly: \n\n> Validation should still insist on not allowing unknown fields to an input object.\n\nThis means, if the value of an input object is provided as a _literal_, it should only contain input fields defined for that input object, right? \n\nThis suggestion is to change the behavior when the value is provided as a _variable_, previously extra fields (should have) resulted in an error, but now they'd just be ignored?\n\nIf I've got it right, :+1: from me. I don't _remember_ putting that validation in graphql-ruby in the first place \ud83d\ude2c \n Just to be clear, suppose we have an input object Contact that has a `value` and `type` field.\n\n```\nquery UserByContact {\n  user(contact: {value: \"foo@bar.com\", type: EMAIL, extraField: false}) { name}\n}\n```\n\nis invalid but\n\n```\nquery UserByContact($contact: ContactInput) {\n  user(contact: $contact) { name }\n}\nvariables: {\"contact\":{\"value\": \"foo@bar.com\", \"type\": \"EMAIL\", \"extraField\": false}}\n```\n\nis not invalid?\n Reviving this again because not sure what happened to this, but why not just do a strict input validation on \"non-null\" object types, and allow extra unspecified fields? I know the reasoning behind typos, but I don't see why we can't have a property like \"allow-unknows\" = true on a specific object input type. Accepting unknown fields allows clients to create constraints on the evolution of the schema.  For example, if a client sends an extra field and the server ignores it, then the server later adds that field, it can retroactively break the clients that over-sent.  If the client is important enough, then that field name is burned and cannot be added.  This type of break is hard to detect ahead of time and the names most logical for over-sending (artifacts of client implementation) are the ones most logical to be added to the schema later.  This happened to me maintaining a public api over the course of many years.  I'm reading through the spec on GitHub at the moment.\r\nSo I see some discrepancy in GitHub render output.\r\nSo here are small changes to make markdown more GFM-friendly.\r\n\r\n\\+ I fixed some inconsistency in how tokens are defined. Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n\n**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions.\n @leebyron Thank you, for incorporating formatting changes into spec.\nI opened #238 issue with a suggestion on how to prevent confusion about lexical grammar in future.\n  This brings together many of the considerations about a `__id` unique identifier field into one document. There is still a lot of work to do before this becomes a merge-able diff on the spec:\n- [ ] Agree on field semantics specified in this PR\n- [ ] Restructure the spec so that the description for `__id` can live next to `__typename`\n- [ ] Write the change to the spec\n @calebmer @leebyron any initial thoughts?\n I recall seeing that the `__` prefix was reserved for introspection and based on the current precedence, introspection is really around the type system. So therefore it feels odd that the value of `__id` would change for different instances of the same type. Which means, would this not be instance specific and better off served by having common conventions and practices of a meaningful `id` field?\n > Another piece of feedback is just at a high level - why should we be including this in the spec with additional behavior rather than simply making an `id: ID!` field a best practice for cacheable types? The spec should be as small as possible and no smaller, so we should ensure we have a strong argument for moving this from best practice to spec.\n> \n> Specifically I think the argument \"client caches would like to rely on this\" is a little faulty as we already have client caches that rely on different forms of pagination and connection models with those as best practices and no impact on the spec.\n\nIn my opinion the specification of `__id` is perhaps the most important addition to the spec for GraphQL\u2019s future. Cacheability is a side benefit of what an `__id` field gives us, the `__id` field gives us identity. Vanilla GraphQL is incredibly powerful for the first data query but after that first query reconciling data from mutations, subscriptions, and other queries is an incredibly hard problem. Falcor got the identity story right with paths (at the cost of good pagination), and resource identity was a fundamental principle of REST for good reasons.\n\nBeing able to identify data is important, so then the next question is how we identify that data. Whichever approach we choose, it must be consistent. There are problems with `id: ID!` which has become best practice thanks to Relay 1, chiefly that the name `id` conflicts with SQL field names. So then we need an alternative, which exists in renaming the field to `__id`. However, using a name like `__id` is useless unless the tooling agrees. In my opinion, fragmentation is not worth keeping this out of the spec.\n\n---\n\nSo in summary, this issue (in my opinion) is the most important issue to resolve for the long term success of GraphQL, and since there are problems with the community solution (Relay `id` name choice) to avoid fragmentation we should standardize data identity with a solution which is both agreeable by the community and will help to build much better developer tooling.\n Also, just a thought, if instead of having `__id`s be null if they don\u2019t exist on the type then they are a base64 encoding of a path to the data from the last `__id`?\n\n``` graphql\n{\n  __id # Encoded value of an empty path or array: `[]`.\n  a {\n    __id # User defined to be the value `unique-id`.\n    b {\n      __id # Encoded path `[\"unique-id\", \"b\"]`.\n      c(x: true) {\n        __id # Encoded path `[\"unique-id\", \"b\", \"c\"]`\n        alias: d {\n          __id # Encoded path `[\"unique-id\", \"b\", \"c\", \"alias\"]`\n        }\n      }\n    }\n  }\n}\n```\n\nI don\u2019t particularly like this idea, but @leebyron mentioned requiring non-nullable ids by default :wink:. Ultimately I don\u2019t think missing an `__id` on a user would be a huge deal in practice, it just wouldn\u2019t be normalized by the client.\n @calebmer coincidentally this is very similar to how the Apollo Client cache deals with missing IDs.\n\n> In a final decision where this should be a common practice, then id: ID! would be the recommendation.\n\nThis is pretty inconvenient if GraphQL is meant as a thin API layer, since people often have underlying model objects that already have an `id` field. `__id`, even if it's not built into GraphQL, seems like a reasonable recommendation because it's something everyone can follow, even if they already have a pre-defined `id` field.\n\n> Another piece of feedback is just at a high level - why should we be including this in the spec with additional behavior rather than simply making an id: ID! field a best practice for cacheable types? The spec should be as small as possible and no smaller, so we should ensure we have a strong argument for moving this from best practice to spec.\n\nThere's one big argument for this being in the spec, which is similar to @calebmer's - this gives GraphQL tools, services, and libraries the ability to reliably cache data coming from any GraphQL server. I'd argue that is a much more fundamental requirement than pagination.\n\nGiven that, having the `__id` field be queryable on every single object, even if the server doesn't want to present an ID for that field, is important for tools that want to be able to cache data but not run introspection ahead of time. Specifically, for Apollo Client it's incredibly advantageous that we don't need to require schema knowledge to do many useful GraphQL things. Even if the ultimate best solution to some problems requires introspection, caching is so useful that it's good to include in the \"getting started\" experience.\n\nIn the current situation:\n1. `id` can't be turned on by default because some servers expose a field called `id` that isn't unique, and\n2. Requesting the `id` from the client requires either manually typing that field in the query or doing introspection, so it requires extra setup and work\n\nThis means that people getting started with GraphQL can't get the benefits of caching without a lot of effort, and makes GraphQL seem less powerful out of the box. If this proposal or similar could be included in the spec, then every single GraphQL tool could have caching built in by default.\n It's important to separate aspects of `__id` that would be convenient from those that are necessary to achieve certain ends. \n\nIt's already possible to write a GraphQL client that correctly caches data coming from any server. This can be achieved with product-specific configuration (e.g. a mapping of type names to the identifying field(s) to use) or with convention (as in Relay's \"Object Identification\" spec). Given that, `__id` is primarily a convenience for cache identification.\n\nAs @leebyron pointed out, though, other proposals may require something like `__id`:\n- A `@defer` directive that caused the server to return the data for a query in several stages. Clients would need some way to interpret subsequent responses. This may or may not be feasible without a way to easily identify the root object.\n- Pre-normalized responses. There is a tradeoff between response size and response processing time. For clients that normalize a response, it _may_ be preferable to receive an already normalized response. This would require the server to know how to identify records, either via `__id` or some other mechanism.\n- Delta payloads for live queries and/or subscriptions. Informing a client about how the results of a previously executed query has changed could take several forms: returning an updated complete query result, or returning a partial result. A \"delta\" payload could rely on `__id`.\n\nOn the one hand, I do see a lot of value in `__id` from a client caching perspective. However, it seems more relevant in the context of future proposals. Would it make sense to flush out these more advanced use-cases first? I'm concerned that nuances of how `__id` would work could make these features more challenging. As an example, should `@defer` be allowed anywhere or only on types that have an `__id`? If it's allowed anywhere, how should a client interpret a deferred response that doesn't have a cacheable root id? It's even possible that `__id` isn't required for some of these features. \n That's not the main reason I'm interested in this proposal. I mostly just think it's unfortunate that such a core feature of pretty much all GraphQL servers and clients is unspecified and requires extra configuration, which makes it harder to build generic tools. But let's take a look:\n\n### defer\n\nI think this can easily be implemented without caching IDs. The new results can simply have a JSON path, in the same format as the error path in #230, which will allow the client to put the new result in the right place. Of course, that requires maintaining the original query result until the rest of the query results arrive, but I think that's preferable to _requiring_ caching IDs for any deferred fields.\n\n### Normalized responses\n\nFrom my understanding of how Relay and Apollo work, a normalized transport wouldn't help either one. Both clients have different opinions about how the normalization should be done, and so neither would use the graphql spec normalization directly. Perhaps a normalized transport would make the response size more efficient, but in that case it might be able to use something like JSON paths? Although I agree it would be more compelling to have it use a standard ID, especially since it would only make sense to normalize repeated objects which would need to be identified.\n\n### Delta payloads for livequeries\n\nI think these and `@defer` should ideally be the same, since `@defer` seems like just a special case of sending a result patch where the path doesn't intersect with already received data.\n\n---\n\nIn my mind, this is a case of taking something that is very clearly a \"best practice\" in GraphQL, that almost any serious tool needs to take advantage of, and making it \"standard\".\n\nI think almost anything can be done without a standardized `__id`, so my feeling is that it will never be more than a convenience. But a lot of things in GraphQL are a convenience so I feel like that shouldn't disqualify this proposal.\n Just wanted to add my 5 cents into this discussion. In general, I don't have anything against a built-in concept of `id` in GraphQL spec. But I would strongly agree with @leebyron: not all objects in the schema have an ID. Some of them do, in this case the `id` field must be not-null.\n\nI also thinking about implications on the end-users who are writing a GraphQL server and possible complexity of GraphQL server implementation itself. For instance, it would be very inconvenient if I need to explicitly define an ID for every single GraphQL object type in the schema (especially if they should be globally unique). I doubt that it would be even possible in most cases.\n\nI also not very optimistic about generically inferring constructed IDs based on some real object IDs. For instance, give this schema:\n\n``` graphql\ntype User {\n  id: String\n  profilePicture(size: Int!): Image\n}\n\ntype Image {\n  width: Int!\n  height: Int!\n  url: String!\n  labels: [ImageLabel!]\n}\n\ntype ImageLabel {\n  name: String!\n  description: String\n}\n```\n\nand this query:\n\n``` graphql\nquery AwesomePictures {\n  user(id: \"123\") {\n    id\n    awesomePicture: profilePicture(size: 300) {\n      awesomeLabels: labels {\n        description\n      }\n    }\n  }\n}\n```\n\nAccording to the semantics of my data, only `User` has a semantic ID which is not globally unique (in my experience, many applications model data in this way), everything else may or may not have an ID which is unique within particular user (if you like DDD, then the Aggregate and Aggregate Root would be a good analogy).\n\nWhat  would be the ID of the labels in this case? Something like: `\"user:123:awesomePicture_size_300:awesomeLabels[0]\"`, `\"user:123:awesomePicture_size_300:awesomeLabels[1]\"`, etc.?\n\nMaybe instead of defining an `__id` field in the spec, we can define an interface that has an `id` field, just like relay does:\n\n``` graphql\ninterface __Identifiable {\n  id: ID!\n}\n```\n\nWith this interface user can very precisely identify which objects do have an identifier and which don't. I think this will have a huge advantage not only for client-side caching, but also for normalized data transfer. I'm thinking about [JSON Graph](https://netflix.github.io/falcor/documentation/jsongraph.html) here. The problem is that we can't really unify particular object within different parts of the query because the same field name may have very different semantic value or even type (if alias is used).\n\nBut we have the similar situation with fragment unification. It is solved with `OverlappingFieldsCanBeMerged` validation rule, which ensures that fragments can be unified. If we have standard `__Identifiable` interface, then maybe we can write similar validation (thus introducing additional constraint) for identifiable types that must be \"merge-able\". Just a brainstorming idea (haven't put too much though into it yet).\n It looks there's a consensus that having an `__id` field that is guaranteed to be queryable on every type, but is sometimes null, isn't something people want. I think it would allow great improvements for GraphQL clients that don't require special build tooling, but perhaps that isn't part of people's desires for how GraphQL should be used.\n\nIn my mind the biggest benefit would come from allowing `__id` to be queried on every selection set just like `__typename`, without knowing whether the underlying type actually has an ID or not.\n\nWithout that property, I think this is mostly indistinguishable from a client-specific convention to use a special interface like `Node`, which could be discovered through introspection as usual.\n\nSo there could be a different proposal that would:\n1. Add a special interface like `Node` to the specification, and\n2. Specify the semantics and name of the ID field, like `__id` and global uniqueness.\n\n> I also not very optimistic about generically inferring constructed IDs based on some real object IDs.\n\nIn my original proposal they would simply be returned as `null` when the server doesn't have a semantic ID to offer. I agree that generating non-semantic IDs on the server is not a good idea.\n Now that I think about it, given this built-in `Node` interface, it should be straightforward to transparently define an `__id: ID` (nullable) meta-field in terms of it, which is available on all object types.\n The availability of `__id` on all types is a powerful property for simpler schemaless GraphQL clients, so I stand by it. However, I would rather see that split into another RFC and just define the global identity semantics of an `__id` field in this RFC if we could more easily get this RFC through.\n\nAt a minimum we should standardize the semantics of an `__id` field to avoid fragmentation as we have determined object identification is something all reasonably powerful GraphQL clients need.\n Per @stubailo and @calebmer's comments above, I'd propose that we separate this into two proposals: defining the semantics of the `__id` field and a separate discussion about if/how GraphQL should make tradeoffs to allow \"schema-less\" clients.\n\n## `__id` Semantics\n\nI would argue that the schema is one of the strengths of GraphQL, as it enables building client tooling. As such, the introspection results should accurately indicate the full list of fields that is selectable on any given type. This suggests that either `__id` should be selectable everywhere and nullable, or that it should be non-nullable and only selectable on types that implement it. \n\nFor clients it is very helpful to know _statically_ which types (and therefore which fields in a query) are identifiable. We have used this knowledge to polyfill `@defer` and connection edge streaming in Relay, for example. If the introspection query were to indicate that all types had a nullable `__id`, then these types of polyfills would be much harder as the client would not have enough information to know how to split up a query. \n\nGiven this, I'd _strongly_ prefer that we make `__id` non-nullable, required to have globally unique values, and only appear in the schema/introspection query where defined by the user for a given type.\n\n## Querying `__id` Everywhere & \"Schema-less\" Clients\n\nThis leaves open the question of whether it should be allowed to send a query that asks for `__id` everywhere,, even on fields whose type does not implement the field (the server could theoretically return `null` or omit the field for those types that don't implement it). I think it's useful to separate this discussion from this `__id` RFC: the two are only tangentially related. \n\nStepping back, this aspect of the proposal is really about whether the specification should allow clients to send _un_validated (and therefore possibly _invalid_) queries:\n- Selecting fields like `id` or `__id` that may not exist\n- Adding fragment spreads of an invalid type\n- Sending input objects with additional fields not defined in the schema\n\nOur experience with Relay and our native GraphQL clients has shown the benefits of _embracing_ the schema; any degree to which it may be inconvenient to load the schema in advance has been offset by all the possibilities that affords. That said, this is definitely something we should discuss more generally in a separate RFC.\n\n# Next Steps\n\n@stubailo Thanks again for kicking off this RFC and discussion. What do you think about updating the text to reflect the above?\n Does the shortened proposal basically come down to:\n1. If your schema defines globally unique IDs for some or all objects, they should be in a field named `__id`\n2. The `__id` field shouldn't be used for anything else\n3. `__id` is in the introspection result like any other field\n\nOr is there anything else?\n\nAnd yes, I think there could be a general discussion to be had about the benefits of schema-less GraphQL client libraries and tools, and some simple changes that could make them much more convenient to build and use. The benefit here is simplifying adoption of GraphQL as the next standard for APIs - such tools will inherently be easier to adopt than those which require special tooling or schema access, the same way that untyped languages are easier to get started with than typed ones, and generally require less tooling. Where would be the best place to have that discussion?\n > Or is there anything else?\n\n@stubailo That's a good summary, yup! \n\n> And yes, I think there could be a general discussion to be had about the benefits of schema-less GraphQL client libraries and tools [...] Where would be the best place to have that discussion?\n\nHow about opening another issue for this topic in order to start the discussion and get more input? It would be good to clearly define the goal first in order to ground the discussion, and _then_ list out any technical challenges that make that goal harder to achieve under the current spec. I think we're one or two steps away from a RFC, as there may be better alternatives than just allowing `__id` to be selectable anywhere. Looking forward to discussing in more detail!\n > Easy to auto-add to queries for schemaless clients.\r\n\r\nI'm not sure this is a factor for `id` as compared to `__id`.\r\n\r\nI think taking up the name `id` can be a pretty big disadvantage because then you have to start having fields like `sqlId` or something. > I could also argue that the \"pit of success\" would have us make the id field which corresponds to caching (and occasionally refetching) as easy to guess and use as possible.\r\n\r\nDeciding the GraphQL specification is going to favor one path or \u201cput of success\u201d over another, the specification begins to assume a certain use case which can be dangerous. Naming the field `__id` (to avoid collisions) is not just about preserving space for SQL id fields, but preserving space for new innovative GraphQL designs. The field name `id` for two ridiculous examples could stand for Indonesian (the language code of which is [`id`](https://en.wikipedia.org/wiki/Indonesian_language)), or Freud\u2019s [Id](https://en.wikipedia.org/wiki/Id,_ego_and_super-ego) part of his psychic apparatus. More realistically by constraining the `id` field, applications like [GatsbyJS](https://github.com/gatsbyjs/gatsby), [`gdom`](https://github.com/syrusakbary/gdom), and [PostGraphQL](https://github.com/calebmer/postgraphql) which generate a schema from the file-system, XML, and database respectively must design workarounds to avoid collisions.\r\n\r\nAll of these applications may be able to make use of identifying the data in their responses, but not all may appreciate the naming collision.\r\n\r\n* * *\r\n\r\n## Alternative proposal:\r\nAfter better understanding some of the hesitations around the `__` prefix, and gaining some inspiration from @leebyron\u2019s mention of an `@identifiable` directive here is a rough alternative direction we could go for the same benefits.\r\n\r\nIt seems as if the name of the unique cache-key field should really be a schema designer\u2019s decision. We can (hopefully) agree that by specifying `id` we may limit creativity, and by specifying the name `__id` we introduce confusion and make the semantics of `__` fields less clear. Since we can\u2019t agree on a name, let us give the naming power to schema designers with a `@identifier` directive. It may look as follows:\r\n\r\n```graphql\r\ntype Person {\r\n  _id: ID! @identifier\r\n  name: String!\r\n}\r\n\r\ninterface Node {\r\n  id: ID! @identifier\r\n}\r\n\r\ntype Post implements Node {\r\n  id: ID! @identifier\r\n  title: String!\r\n}\r\n```\r\n\r\nOr:\r\n\r\n```graphql\r\ntype Person @identifiable(field: \"_id\") {\r\n  _id: ID!\r\n  name: String!\r\n}\r\n\r\ninterface Node @identifiable(field: \"id\") {\r\n  id: ID!\r\n}\r\n\r\ntype Post implements Node @identifiable(interface: \"Node\") {\r\n  id: ID!\r\n  title: String!\r\n}\r\n```\r\n\r\nA field on a type or interface may be marked as the type\u2019s identifier field. That field must have a type of `ID!` and must take no arguments. A type must only have one field marked as an identifier. If a type inherits from an interface where one of the fields is marked as an identifier, the field on the type with the same name must also be marked as an identifier.\r\n\r\nWhat the `@identifier` directive means semantically is that the value of the field is unique for all values *of that type*. Note that it does not mean the field is globally unique, just locally unique for that type. So an `@identifier` directive on the `id` field of the Relay `Node` interface would mean the same thing as it does now. The `id` must be unique across all other `Node` values.\r\n\r\nIn clients, the cache key would become the `__typename` combined with the identifier. So in the above example `Person-${value1}` or `Node-${value2}` would be the key.\r\n\r\nIn the introspection query if we wanted to get real meta, the `__Type` type\u2019s `name` field could be marked as an identifier.\r\n\r\n### Pros:\r\n- No naming collisions. Gives schema designer total control over their types.\r\n- Backwards compatible with Relay 1 schemas. Just mark `id` as an identifier everywhere.\r\n- Users can have non-globally unique identifiers. They could use SQL serial ids or plain UUIDs and mark them with `@identifier` as long as they don\u2019t inherit from an interface which marks the same field.\r\n\r\n### Cons:\r\n- No room for schemaless clients, may actually make the schemaless client use case much harder to implement. Unless we also wanted to add an `__id` or `__identifierValue` field which was always queryable and returned the identifier value. But then we are back to bikeshedding over `__id`.\r\n- More API configuration.\r\n- Requires a change to introspection queries.\r\n- Interaction between interface identifiers and type identifiers may be confusing. @stubailo - could you please explain this a bit more in detail? \r\n\r\n> And yes, I think there could be a general discussion to be had about the benefits of schema-less GraphQL client libraries and tools, and some simple changes that could make them much more convenient to build and use.\r\n\r\nI don't mean to derail this conversation, but I'd really like to understand where you were heading with this, because if it is what I think it is, you get a \ud83d\udc4d from me. However, this is my confusion. If it is what I think you were getting at, then any definition of a fixed field type, even an ID, which is so common, basically kills my understanding, thus my asking for a bit of an explanation. \ud83d\ude04 I guess this is my question.\r\n\r\nIsn't the notion of \"variable schema\" (I don't like the term schema-less, as it is inappropriate) and the necessity of an ID field contradictory? \ud83d\ude04 \r\n\r\nScott I'm going to close this PR since there doesn't seem to be a clear consensus about the design of such an addition to the spec, or whether it's necessary at all.\r\n\r\nI am partial to Lee's idea in https://github.com/facebook/graphql/pull/232#issuecomment-262392032 about constraining any fields named `id` to be unique and of type `ID!`, however also mindful that this might break a significant number of non-Relay apps who have previously not been constrained to such a requirement.\r\n\r\nI still deeply believe that standardizing the concept of an identifier for objects will make GraphQL more useful overall and reduce the amount of boilerplate and configuration most developers need to write, so if there is an agreement on how that can happen I'd be happy to write a PR for the spec. Thanks for your work so far on this. I'm still interested in a solution for broad identifiability. Hopefully we can find consensus on this in a future RFC   Reopening from https://github.com/facebook/graphql/pull/187 with a real branch.\r\n\r\nThis is helpful for clients to identify why there is a `null` in the response, because that could be due to an error or an actual `null` result. @leebyron should I also change \"should\" to \"must\" in the passage above?\n\n> If an error can be associated to a particular point in the requested GraphQL\n> document, it **should** contain an entry with the key `locations` with a list of\n> locations, where each location is a map with the keys `line` and `column`, both\n> positive numbers starting from `1` which describe the beginning of an\n> associated syntax element.\n @leebyron ping about the question above.\n @leebyron anything blocking this PR? Let me know if I can make any more improvements. \\+ 1 for this.\r\n\r\nWe already depend on `path` in our [proxy tool](https://github.com/APIs-guru/graphql-faker).\r\n\r\nIt is critical for us since we modify queries (inject `__typename`, remove mocked fields, ...) before sending them to a GraphQL server. Because of that we have to recalculate `line` and `column` properties of `locations` array based on `path` value. Super excited about adding this into the next spec release. We've been using it in graphql-js experimentally for a while and it's quite helpful This does not explain how to represent the path for a selection that uses a fragment.  @hlship `path` represent:\r\n> path of the response field\r\n\r\nSo `path` is not affected by fragments at all since fragments doesn't change response. Fair enough; I was focusing too much on what our implementation currently\ndoes.\n\nOn Tue, Jun 12, 2018 at 1:48 PM Ivan Goncharov <notifications@github.com>\nwrote:\n\n> @hlship <https://github.com/hlship> path represent:\n>\n> path of the response field\n>\n> So path is not affected by fragments at all since fragments doesn't\n> change response.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/facebook/graphql/pull/230#issuecomment-396728662>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AADNtGMtzlYYRjIAAUcpgmX2F8sccKt1ks5t8CksgaJpZM4Kj4rl>\n> .\n>\n\n\n-- \nHoward M. Lewis Ship\n\nSenior Mobile Developer at Walmart Labs\n\nCreator of Apache Tapestry\n\n(971) 678-5210\nhttp://howardlewisship.com\n@hlship\n @hlship I think spec will benefit from clarification.\r\nThis example can be rewritten as:\r\nhttp://facebook.github.io/graphql/June2018/#example-bc485\r\n```graphql\r\n{\r\n  hero(episode: $episode) {\r\n    name\r\n    heroFriends: friends {\r\n      ...characterInfo\r\n    }\r\n  }\r\n}\r\n\r\nfragment characterInfo on Character {\r\n  id\r\n  name\r\n}\r\n```\r\nWill it make the spec more clear?  I guess this means that certain directives will need to include array arguments, rather than having one argument and using the directive multiple times, eg:\n\n```\n{\n  comments @refetchOn(channels: [\"newComment\", \"removedComment\"])\n}\n```\n\nRather than:\n\n```\n{\n  comments @refetchOn(channel: \"newComment\") @refetchOn(channel: \"removedComment\")\n}\n```\n\nSeems reasonable, to require the directive to decide if it wants to accept multiple inputs.\n  Hi!\n## Setup\n\nWe're in the process of implementing a GraphQL server for the programming language Erlang, and we're trying to get by with only reading the specification and looking relatively little at code, in the hope this will uncover some inconsistencies in the spec. In general, I'm really happy with the specification, but I need some clarification on the combination of _non-null_ when it is combined with the _list_ type.\n\nI feel this combination is part of the dynamic semantics of GraphQL, which is execution semantics. Yet, the only section in the draft spec which covers this is section 4.2.2.9, http://facebook.github.io/graphql/#sec-Combining-List-and-Non-Null which is part of the introspection system. I'm not sure why it is there, and not in the execution semantics of the spec, where I would have expected to find this. Is there another place where this is written down, and am I reading the spec with too much skimming?\n\nAlso, I'm not sure how to read the 4.2.2.9 section with respect to evaluation semantics. In order to be able to ask the question, here is my example, taken from an internal test schema where we are building a dungeon containing rooms, monsters, and so on:\n\n```\ntype Stats {\n    shellScripting: Int! # How good a monster is at shell scripting\n    yell: String\n}\n\ntype Monster {\n    id: Id!\n    name: String!\n    statsV1: [Stats]\n    statsV2: [Stats]!\n    statsV3: [Stats!]\n    statsV4: [Stats!]!\n    ...\n}\n```\n\nAs you can see, we have monsters, and monsters have stats, possibly many in a list. We can represent a monster internally as a record:\n\n```\n#monster {\n    id = \"1\",\n    name = \"Two-Headed Ogre\"\n    stats = [\n        #stats { shell_scripting = null, yell = \"I'm Ready!\" },\n        #stats { shell_scripting = 5, yell = \"I'm NOT Ready!!!\" }\n    ]\n}\n```\n\nAnd we can resolve the fields of `statsV1, ..., statsV4` by using the `stats` field of that record. The question is how it would resolve.\n## Expectation\n\nThe two-headed ogre we just defined has a bug: when rendering stats for the two heads, the first head has a shell scripting value of `null` which will produce an error for the `Stats` object of a non-nullable `shellScripting` field. This means an error will be raised for the first head, while the second head will render okay.\n\nLets set up a query document:\n\n```\nquery Q1 { monster(id: \"1\") { statsV1 { shellScripting, yell }}}\nquery Q2 { monster(id: \"1\") { statsV2 { shellScripting, yell }}}\nquery Q3 { monster(id: \"1\") { statsV3 { shellScripting, yell }}}\nquery Q4 { monster(id: \"1\") { statsV4 { shellScripting, yell }}}\n```\n#### Q1\n\nIn this case, I think the output would be\n\n```\n{ data:\n    monster: {\n        statsV1: [null, { shellScripting: 5, yell: \"I'm NOT Ready!!!\"}]\n    }\n}\n```\n\nThe resolver for `Stats` will return `null` for the `shellScripting` field which is _non-null_ and thus the whole object becomes `null`. It is reflected in the list.\n#### Q2\n\nI think the output would be\n\n```\n{ data:\n    monster: null\n    }\n}\n```\n\nSince the `[null, ...]` output for `statsV2` means there is a `null` value in the context of `[Stats]!` and this is not allowed. Thus the whole monster becomes null.\n#### Q3\n\nI think the output would be\n\n```\n{ data:\n    monster: {\n        statsV3: [{ shellScripting: 5, yell: \"I'm NOT Ready!!!\"}]\n    }\n}\n```\n\nSince the rule is that `null` entries are removed from the list (at least that is how I read 4.2.2.9 in this case).\n#### Q4\n\nEither disallowed by the static semantics, or it essentially behaves as Q2.\n## Current implementation I have\n\nI run this by a recursion over the list entry. Resolution of the underlying objects in the list returns a value that is either \"ok\" or an \"error\"\n\n```\n{ok, Object} | {error, Reason}\n```\n\nThis means we have the following list resolved in the execution engine:\n\n```\n[{error, {null_field, \"shellScripting\"}}, {ok, SecondHeadObject}]\n```\n\nWhere the binding of `SecondHeadObject` is `#{ <<\"shellScripting\">> => 5, <<\"yell\">> => <<\"I'm NOT Ready!!!\">> }`, an Erlang `map()` type we can turn into a JSON object later. We can now scrutinize the modifiers. There are 4 cases:\n- Q1: Turn `{error, _}` into null values, and `{ok, _}` into normal values. Easy.\n- Q2: The case is a `[...]!`, i.e., a list wrapped in a non-null modifier. Check the list for `{error, _}` terms. If one is found, return `{error, ...}` for this field. Otherwise, turn `{ok, _}` into normal values and return those.\n- Q3: The case is `[...!]`, i.e., a non-null modifier wrapped in a list. Filter the list and pick `{ok, _}` values only.\n- Q4: Handle as Q2.\n\nWhat I don't particularly like about this implementation is that it doesn't compose too well. I have to look at which modifier is the outer-one (List/Non-null) and which is the inner one and then handle these by looking at both at the same time. I'd much have preferred a semantics where I could have handled non-null and list separately in the execution engine. But perhaps my semantics are just off?\n## Question:\n\nAm I right or completely off track here? Can I help improving the specification in any way (Note: I'm not a native English speaker, this may have an effect)? But before I can submit a request on the specification, I would need to know the logic behind the dynamic execution semantics of the above queries in question.\n\nThanks in Advance!\n I read `[Stats]!` as preventing the list from being null but allowing elements of the list to be null, so I would expect Q2 to behave identically to Q1.\n > Q3\n> Since the rule is that null entries are removed from the list (at least that is how I read 4.2.2.9 in this case).\n\nThat's not how I read 4.2.2.9 (but I could be wrong).\n\nMy interpretation of `[Stats!]` is that the list itself may be null but that it may not contain null elements. I don't have any spec to back this up, but I would assume that resolution would behave the same way as when a non-null field returns null, so the end result would be:\n\n```\n{ data:\n    monster: {\n        statsV3: null\n    }\n}\n```\n\nThe element of the list cannot be null, so the null propagates to the list field as a whole, which can.\n > Q4\n> Either disallowed by the static semantics, or it essentially behaves as Q2.\n\nThis definitely behaves as you described Q2. The null propagates until it reaches `monster`, which is nullable.\n Hi Evan & Lee,\n\nThank you both for your comments. I'm somewhat offline with a cold at the moment, but I just wanted to give you a heads up and thanks. I'll come back to this with a vengeance later on once I have a better understanding (and my brain is back on-line :)\n Having read through it all:\n\nIn your example, there is a case I'm not sure I understand fully. The case is `Int!, []` and the other \"value\" cases, the result you wrote is `{ a: { b: null } }`, but as int is non-nullable, I would have expected that to propagate to the wrapper: `{ a: null }`. But perhaps I'm mistaken?\n\nWhat ultimately led me astray was the 4.2.2.9 section.\n- \"If the modified type of a List is Non\u2010Null, then that List may not contain any null items.\" -- I read this as `[T]!` for some type `T`. But this outright contradicts what you wrote above.\n- \"If the modified type of a Non\u2010Null is List, then null is not accepted, however an empty list is accepted.\" -- I read this as `[T!]` for some type `T`. Also in direct contradiction.\n\nI see how I \"flipped\" the designators by accident.\n\nPerhaps because there is a subtlety picked up naturally by native English speakers I fail to pick up? Maybe one could add the type scheme explicitly, so the mistake isn't made.\n\nOnce I read through your examples, it becomes quite clear how this is to be resolved and the documentation is actually pretty precise around `CompleteValue(..)`. You resolve the \"inner\" type of the non-null field and then complete that field.\n\nOne thing I would have written different in section 6.4.3 on value completion is point 3.c on how to complete a list of values. Specifically, how do you work yourself through the list[0]? If we have a list and we have an error at completing the element with a given index `i`, do we still try to complete elements `j > i` in the list, or do we abort completion at index `i` without ever looking at the remaining elements? In particular, I'd make it explicit how the presence of field errors (which are thrown) propagates. Mostly because some languages are less likely to use exceptions for handling the control flow[1]. I can somewhat guess that a single field error in a list propagates that error upwards, but I don't like guessing in specifications :)\n\nAlso in section 6.4.3, point 1 tells me how to handle a non-null value, but it doesn't say how to handle the presence of an error explicitly. Specifically, in your case above we have `Int! Error(\"whooops\")`. This is clearly a non-null Integer type. So we recurse on the inner type, use point 4 to resolve the `Int` scalar. This point says nothing about the resolution of an error. But we can argue that `Error(\"whooops\")` is not a valid, so it resolves to `null` which point 1 knows how to handle, by throwing a field error. But if we have `[Int!]! \"whoops\"` then the non-null handler in point 1 would recurse to point 3.a and get back a thrown field error, which it says nothing about how to handle.\n\nIn point 1.c and point 3.a we can \"throw a field error\". What does this mean? How does thrown errors propagate the recursion stack? Are they handled at some level of the recursion, or do they bleed through to the top-level?\n\nPerhaps my query becomes more coherent over the coming days once I start implementing the code paths of value completion as precisely as possible--but right now, the above questions are the ones I have w.r.t `CompleteValue(..)` call. The crux is the interaction of errors and values, and the propagation of errors in the recursion stack. I'd make the wording very boring and nitpicky: \"if _completedResult_ is an error, then ...\", and \"... otherwise, return the _completedResult_\". In short I would treat exceptions as were they values. That way, you can give them exception semantics, if you want, by being explicit about their propagation.\n\n[0] In a mechanized formalization in e.g., Agda, Coq or Twelf, you would need to be extremely specific in how you complete the list here. The interaction of completion with errors would need to be nailed down.\n\n[1] At least Haskell, Erlang, and Go would be likely to avoid using exceptions as control flow operators, and many OCaml and Standard ML implementations would too.\n Hi!\n\nJust FYI: I managed to get this working as expected in the code I have, so there is no reason to keep this issue open unless you want to improve the wording around the parts where I went astray.\n  For example, I have several app pages with several graphqls, which have lots of common code.\n\nSo, how can I reuse  common graphql code between several graphqls like the _#include_ in the C/C++ language or the _import_  in the Java language?\n You mean between different queries? That's what fragments are for!\n @lizherui try this: http://graphql.org/learn/queries/#fragments\n  :) Thanks! Not sure if it is worth changing this. It would complicate the grammar and force all implementations to make changes to their parser to fix something that probably isn't a real issue for anyone. Plus I've actually grown fond of this little quirk. If we ever release a TCK, I suggest we include a rule that makes sure a spec compliant implementation allows these forms.\n Without this being in the spec, then a linter is just a perspective and tools would need to support whatever the spec said, otherwise it would be a bug. So while a linter would help a query writer, it does not help those writing the tools.\n Interesting, I would expect that `... fragmentName` should be allowed. I can imagine a style preference where you would write `... myFragment` to match `... on MyType`.\n I was focused on the variable use case (title of the issue).\n\nFor the fragment style, having a space does allow for easier readability. So making this scoped to variable is perfect.\n Looks like a great change to me, perhaps it could be merged? Or we could make a branch for the next version of the spec (April, I suppose?) and merge it there? This might be controversial, but after a few more months of experience with GraphQL, I still believe this is a good change. @wincent any reason this was closed? No worries! I agree it's not a high priority item :)  Let's say I'm working on my BCaaS app (bean counter as a service). My only inputs are `Int`s and my only return values are `Int`s. Should my schema still contain GraphQL scalars like `String` and `Float`? Or is it appropriate to leave those types out, since they aren't used? \n\nIt looks like graphql-js leaves out unused scalars. This approach makes sense to me. GraphQL's predefined scalars aren't \"universals\", instead, they're saving the user a step of defining their own. In that way, like an unused custom scalar, if a predefined scalar isn't used, it's not present in the schema.\n\nIs that intended? Or should all GraphQL schemas contain the predefined scalar types?\n I wonder if GraphQL lets you override the default scalars. I would guess \"no\" since they are used in introspection, which should be consistent across all servers?\n  Same PR than https://github.com/graphql/graphql-js/pull/514.\n\nSee https://docs.travis-ci.com/user/notifications#IRC-notification for more information.\n\nNote that this requires removing the `n` flag on the IRC channel.\nSee https://freenode.net/kb/answer/channelmodes\n\n> n (prevent external send): Users outside the channel may not send messages to it. Keep in mind that bans and quiets will not apply to external users.\n  In Appendix B `Punctuator` includes `|`, but it was missing here.\n Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n  Currently a GraphQL document is only allows a [SourceCharacter :: `/[\\u0009\\u000A\\u000D\\u0020-\\uFFFF]/`](http://facebook.github.io/graphql/#sec-Source-Text) and [EscapedUnicode :: `/[0-9A-Fa-f]{4}/`](http://facebook.github.io/graphql/#EscapedUnicode) also prevents unicode characters above U+FFFF from being included into a GraphQL string.\n\nUnicode code points are actually in the range 0 to 0x10FFFF.  For example, [unicode emoji characters](http://unicode.org/emoji/charts/full-emoji-list.html) like \ud83d\ude00  (U+1F600) have code points above U+FFFF.\n\nIs there any reason why the source document doesn't allow unicode characters above U+FFFF?  Or can we remove that restriction?  Without that restriction the limitation of the unicode escape doesn't seem problematic.\n\nIf supporting a unicode escape for all unicode characters is desired, then one way of handling that is the way [swift supports unicode escapes](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html):\n\n> An arbitrary Unicode scalar, written as \\u{n}, where n is a 1\u20138 digit hexadecimal number with a value equal to a valid Unicode code point\n I also was reading the spec and realised this. Given the paragraph around it:\n\n> GraphQL documents are expressed as a sequence of Unicode characters. However, with few exceptions, most of GraphQL is expressed only in the original non\u2010control ASCII range so as to be as widely compatible with as many existing tools, languages, and serialization formats as possible and avoid display issues in text editors and source control.\n\nIt sounds to me an error of ignorance rather than intent.\n\nRust formerly had `\\uXXXX` and `\\UXXXXXXXX`, but changed to `\\u{x}` (the same as Swift does) some time before Rust 1.0.\n\nJSON (which is probably the main inspiration for the GraphQL syntax) does `\\uXXXX` and uses the abomination that is [UTF-16 surrogate pairs](https://en.wikipedia.org/wiki/UTF-16#U.2B10000_to_U.2B10FFFF) as a way of representing higher-order characters, e.g. U+1F600 (\ud83d\ude00) is escaped as `\"\\ud83d\\ude00\"` in JSON.\n\nFortunately you can avoid that insanity by simply expressing values literally. There\u2019s no real need for the escapes anyway once you get past U+001F (`\\u00XX`) and U+0022 (`\\\"`). (Unless you deal with combining characters that will attach to a string\u2019s quotation marks, which is fearfully ugly and points out the grammatical problem of parsing by codepoint rather than grapheme cluster, but this is all more advanced stuff that we wish wouldn\u2019t happen in real life, anyway.)\n\nAlso currently the escapes listed (`EscapedCharacter`) match those of JSON. (I think. As to the interpretation, what the GraphQL spec actually _says_ is that `\\f` would be U+0066, \u201cf\u201d, rather than U+000C which is what we all know it\u2019s supposed to be. It\u2019s really badly written.) Given that general tie, supporting `\\uXXXX` might not be a terrible idea, with or without `\\u{X}`.\n\nThe definition of the handling of `EscapedUnicode` is also extremely tacky, with spelling errors, poorly defined terms, _&c._:\n\n> Return the character value represented by the UTF16 hexidecimal identifier EscapedUnicode.\n\nWhat does that even _mean_? Seriously, that doesn\u2019t make sense.\n\nThis stuff all suggests to me that it was written by someone with a poor understanding of Unicode. This spec gravely needs both editorial and technical review.\n\n---\n\nI want to see how different implementations parse:\n- `\"\\ud83d\\ude00\"`: nonsensical in the current specification. If GraphQL wants to be like JSON, handling it as UTF-16 surrogate pairs is probably a good idea. If not (please don\u2019t go for surrogate pairs!), the grammar needs to be changed to allow for the supplemental planes (such as via `\\u{1F600}`).\n- `\"\ud83d\ude00\"`: illegal in the current specification, shouldn\u2019t tokenise. However, I hope that implementations accept it and treat it as a string containing the code point U+1F600.\n  This would allow chaining the result of a query into the input of a mutation, and therefore atomic operations (from the point of view of the client).\n\nA query containing a variable assignment would be considered a pseudo-mutation and would therefore run serially with the other mutation(s). \n\nIt may be useful to be able to retrieve the value of variables from a pseudo-schema-object in the result of a mutation.\n\nRelated to #88 \n @leebyron the kind of combined query/mutation I have in mind would simply obviate the need for a second round trip to the server in a case such as this, where an input to the mutation is required which can only be obtained as the result of an earlier query:\r\n\r\n````graphql\r\n{\r\n  repository(owner: \"Mermade\", name: \"openapi_specifications\") {\r\n    issues(last: 1) {\r\n      edges {\r\n        node {\r\n          $id := id\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmutation comment($cmid: String!, $id: ID!, $body: String!) {\r\n  addComment(input: {clientMutationId: $cmid, subjectId: $id, body: $body}) {\r\n    clientMutationId\r\n    commentEdge {\r\n      node {\r\n        databaseId __variables {\r\n          $id\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n````\r\n\r\nVariables:\r\n```json\r\n{\r\n   \"cmid\": \"1234\",\r\n   \"body\": \"New comment body\"\r\n}\r\n````\r\n\r\nThe query and mutation may have to be wrapped together, or the query be performed nested within the mutation, syntax is unimportant at this stage.\r\n\r\nI don't know if the `@export` feature described [in this issue](https://github.com/graphql/graphql-js/issues/462) is being proposed as a part of the GraphQL language? This issue would require another capability and that is the ability to run 2 operations at once, which the spec does not yet allow.\r\n\r\nVariable assigment via say @export would only be available if multiple operations are allowed We actually have a use for this feature for A/B testing. Right now we have the following problem: we have the feature flags exposed as graphql type and we want to exclude part of the query based on the picked variant. In the end, we want to have something like this:\r\n\r\n```graphql\r\nquery Q {\r\n    article {\r\n          ...WidgetA # query this only feature flag is active\r\n          ...WidgetB # query this only feature flag is inactive\r\n    }\r\n}\r\n```\r\n\r\nRight now our options are:\r\n\r\n1. Overfetching:\r\n\r\n```graphql\r\nquery Q {\r\n    featureFlags {\r\n         isFeatureActive\r\n    }\r\n    article {\r\n          ...WidgetA\r\n          ...WidgetB\r\n    }\r\n}\r\n```\r\n\r\nIn this case, we always fetch all necessary data for both `WidgetA` and `WidgetB` and decide which one to show on the frontend.\r\n\r\n2. Moving feature flag outside of graphql:\r\n\r\n```graphql\r\nquery Q($isFeatureActive: Boolean!) {\r\n    article {\r\n          ...WidgetA @include(if: $isFeatureActive)\r\n          ...WidgetB @skip(if: $isFeatureActive)\r\n    }\r\n}\r\n```\r\n\r\nWith `@export` directive we could've still had our feature flags inside of GraphQL schema and avoid overfetching:\r\n\r\n```graphql\r\nquery Flags {\r\n    featureFlags {\r\n         isFeatureActive @export(as: \"isFeatureActive\")\r\n    }\r\n}\r\n\r\nquery Q($isFeatureActive: Boolean!) {\r\n    article {\r\n          ...WidgetA @include(if: $isFeatureActive)\r\n          ...WidgetB @skip(if: $isFeatureActive)\r\n    }\r\n}\r\n```\r\n\r\nRight now we are trying to implement this variant on top of existing server and client libraries but would be nice to see it standardized. \r\n  The spec states that a schema requires a query type. This, however, has been a minor source of frustration for me. For example:\n- Some services do not need query functionality.\n- Writing tests for mutation functionality of a GraphQL implementation, there is no query.\n\nIn such cases a \"dummy\" query must be set up in the schema. Does anyone know the reason for this requirement? \n\nThank you!\n Thank you for your time! Curiosity: sated.\n  gitter is more accessible \n If we look for accesibleness (in spite of usability): IRC. \n\nIRC is open, supported in every platform and you do not even have to register anywhere.\n This just came up again at https://gitter.im/gitterHQ/gitter?at=582732efe097df7575a0ec5e\n\nhttps://github.com/gitterHQ/gitter/issues/1511 is related.\n Turning that around, would people show up to that room, expecting in-depth discussion and help, and then be disappointed with GraphQL as a technology if they didn't receive it? I think perhaps they would, which will put pressure on GraphQL maintainers and project leaders to spend time there.\n I think the problem lies with gitter not allowing communities to appreciate it's platform since the gate is outright closed. There are a billion channels on the web for discussing things even where there are likely no maintainers. Googling \"graphql forum\" brings up loads of results.\n\nThe github integration in gitter is second to none. You have a sidebar with a list of repository activity with popovers for previewing issues/commits/comments etc. Even if people aren't in there, it's nice to see a list of activity\n\nI think it sucks that I've registered about 10 Slack accounts (one for each tech) and they don't even have syntax highlighting... but I'll continue doing it to get where I'll find support :)\n\nPerhaps the room could be opened with a MOTD pointing to the Slack channel?\n\nHow about a Microsoft Teams room?! ... joking\n Maybe https://sameroom.io or similar could be used to bring various chat services like Slack, IRC, and Gitter together for the GraphQL community.\n Sux when ur asked for help and have to make another room ? I disagree and decided to do just that last night. Its called THE DEW DROP INN.  Point taken and will abide men. Thannks for the input. \n  Hello,  I'm the original creator and maintainer of the [GraphQL for .NET](https://github.com/graphql-dotnet/graphql-dotnet) project.  I have originally setup the project to serialize all fields as camelCase since that is my preference and seemingly idiomatic JavaScript/GraphQL.  In the .NET world however there can be strong preference for PascalCase even in your returned JSON structure.\n\nThat being said, I know the spec specifically points out that [a `Name` is case-sensitive](http://facebook.github.io/graphql/#Name).  My question is, if I change my project to allow case-sensitive fields, which fields still need to be camelCase to conform to the spec?\n\nThese seem to be required to be camelCase\n- `data`\n- `errors`, with a lowercase `message`, `locations`, `line` and `column`\n\nOnes I'm unsure about - all the fields related to introspection (and that are on introspection types), such as\n- `name`, `description`, `args`, `type`, `isDeprecated`, `deprecationReason`, `defaultValue`, etc.\n- `__schema`, `__typename`, `__type`, etc.\n\nAre there others that I'm missing?\n\nWhat do I need to ensure is camelCase to conform to the spec?  Thanks!\n  I have an input type `CreateUser`.\n\n``` graphql\ninput CreateUser {\n  firstName: String\n}\n```\n\nI am using it to define a mutation operation `createUser`.\n\n``` graphql\ntype Mutation {\n  createUser (user: CreateUser): User\n}\n```\n\nThe problem using this approach, I need to execute the `createUser` operation with a superfluous `blog` object, e.g.\n\n``` graphql\ncreateUser({\n  user: {\n    firstName: \"Gajus\"\n  }\n})\n```\n\nIt would be nice if I were able to execute it using just the properties of the input type, e.g.\n\n``` graphql\ncreateUser(firstName: \"gajus\")\n```\n\nIs there a way to destructure the input type in the definition of the operation parameter? e.g.\n\n``` graphql\ntype Mutation {\n  createUser (...CreateUser): User\n}\n```\n\nUsing this declaration I am getting an error:\n\n```\nGraphQLError: Syntax Error GraphQL (45:15) Expected Name, found ...\n44: type Mutation {\n45:   createUser (...CreateUser): User\n                  ^\n```\n  The semantics of EscapedCharacter are defined as:\n\n```\nStringCharacter :: \\ EscapedCharacter\n\n  * Return the character value of {EscapedCharacter}.\n```\n\nI'm not sure what this actually means, but it seems to imply that you would return the same sort of thing if EscapedCharacter is `\"` and if it is `n`.  Presumably this line should actually describe how b, f, n, r, and t map to other characters?\n  It is possible to deprecate fields and enum values, but not input values or arguments.  I think it should be possible to deprecate optional arguments and input fields.\n\nA natural way of evolving the schema in this case would be to make an input field optional if it is required, deprecate it, then remove it once clients stop explicitly setting the value.  We can add support for that into the server to detect when the input field is still used, but we would like deprecation warnings on the client so we can easily remove usage of these deprecated input fields.\n\nOne possible workaround is to create a new field with different input, but that is a more disruptive way of evolving the schema.\n\nNote that if __InputValue was just given isDeprecated and deprecationReason fields, then that would mean that an input object type could be deprecated, would that be undesirable?  Right now an __Type (object, interface or union) also can't be deprecated, so would we want that to be consistent with an input object type?\n\nAlso, should the spec disallow an argument to be deprecated if it is non-null (i.e. required)?  Otherwise, that effectively makes the field it is on deprecated.\n @leebyron any thoughts on this?\n > Perhaps that means also being able to mark arguments as deprecated. If input obj fields can be transitioned from required to optional to deprecated, then arguments should be the same.\n\nI'd be very supportive and a huge fan of this change. \ud83d\udc4d  We've already run into a few scenarios in our implementation where this would be valuable and I can foresee it becoming even more important in the future. \n\nI'd be happy to collaborate with anyone who wants to begin working on this.\n few places that are useful\r\n\r\n- [ ] args of connections/fields\r\n- [ ] args of mutations > The next steps for an idea like this would be to draft an RFC, probably in the form of a PR against the spec along with a good description of how deprecation best practice should work and any potential caveats.\r\n\r\nShort of digging through old PRs, what is the process for proposing an RFC, @leebyron? I'm looking for something akin to [Rust's RFC process](https://github.com/rust-lang/rfcs), but outside of Subscriptions there don't seem to be many guidelines on writing these. @gjtorikian: a rough outline of the contribution process can be found here: https://github.com/facebook/graphql/blob/master/CONTRIBUTING.md Yeah it was actually news to me that this was _not_ supported. (I would've sworn we've already put `deprecationReaon`s on arguments in our codebase without realizing that it wasn't actually sending deprecation notices!)\r\n\r\nAnyone working on a PR for this? Is there any update on this? Are there new ways of accomplishing this now?  If someone just want to get all the data,then there is much cumbersome to write done all the field.\na better way I think is make the sub selection optional,if there are sub selections,we return an subset of the original data,otherwise,we return a full set.\n That would result in a lot of problems:\n- More data would be returned than necessary\n- It would be hard to detect when clients are no longer using a deprecated field\n- Would it recursively return all data for object type fields?  If so, then that could cause infinite recursion if there are circular reference.\n @dylanahsmith Anyway,I have implemented in that way,and circular reference could be fixed if you use the right configuration.\nAnother thing is that currently,we are using static query ,which means the query string is not write directly by the client side devs.\n  I heard from @josephsavona that @leebyron had a proposal to add a global `__id` field to the specification similar to Relay\u2019s `Node` `id` field. See here: https://github.com/facebook/relay/issues/1061#issuecomment-227857031\n\nWhat's the status on such a field getting added to the specification and how can we speed that process up?\n The larger context is that a small number of Relay users have designed their schema such that the `id` field is a type-specific identifier (e.g. the database primary key). For a cache, however, it is substantially simpler to use global ids for object identification, and having a standardized \"id\" field name as part of the spec would help developers to design a schema that could be used with multiple clients (without forcing every client to deal with customizable id names). \n Yep, I completely understand all the benefits and as I\u2019ve been looking into Relay alternatives a global identification spec for the entire ecosystem seems like a great idea :blush:. So I\u2019m really excited for an `__id` specification for two reasons:\n1. I am one such Relay user who has naming clashes with `id`, `__id` is an exciting solution.\n2. I am a GraphQL user interested in building Relay alternatives and requesting a \u201cblessed\u201d specification from the GraphQL team endorsing `__id` :blush:\n Last I heard here https://github.com/facebook/relay/pull/1232#issuecomment-228403233, you (@josephsavona) and @leebyron  said that an `__id` addition to the language is being considered. What are some factors under consideration and how can we make the specification definite?\n Yeah, we're working on this and I'll have an RFC pull request set up shortly where we can talk about it in more detail.\n \ud83c\udf89\n What\u2019s the status on this @leebyron?\n This change would be amazing for our production GraphQL API. Can't wait to make it Relay compatible! Any updates would be greatly appreciated.\n @leebyron are you looking for someone to write up the `__id` RFC? I could take a pass at it.\n  Just an idea for discussion - adding the path to the response, like [this implementation in `graphql-js`](https://github.com/graphql/graphql-js/blob/1ed070fed63767e82470ca39d036539b99693c4c/src/__tests__/starWarsQuery-test.js#L438-L446):\n\n``` js\npath: [ 'hero', 'friends', 0, 'secretBackstory' ]\n```\n\nJust like it is helpful to know the location in the query associated with an error, it's helpful to know the location in the response.\n\nThis is already implemented in errors thrown from resolvers in `graphql-js`, so it would just be a matter of having the right error formatting to include that information.\n\nThis would be extremely helpful to differentiate when a field is `null` in the result because the result was actually `null`, and when it is because of a runtime error in the resolver.\n > This would be extremely helpful to differentiate when a field is null in the result because the result was actually null, and when it is because of a runtime error in the resolver.\n\nI think the simpler way of addressing that concern would be to omit the field in the result if there was an error rather.  Also, errors in non-null type fields could just not be propagated such that missing data could be used as an indicator of where the errors occur.\n\nHowever, even with that change your proposal would be useful to associate errors with specific elements in an array.\n There are a few reasons this is better than just returning `undefined` in this case:\n1. Being able to identify specific array elements that had errors\n2. Being able to associate specific error messages with specific parts of the result\n\nYou can imagine if you are rendering a huge page with one GraphQL query, it would be nice to show any relevant errors in the correct part of the UI, rather than at the top level. Of course, it is possible to build a custom error tagging system for this, but it would be much nicer if there was this relatively small built-in thing, especially since we already have line and column position for the error.\n > You can imagine if you are rendering a huge page with one GraphQL query, it would be nice to show any relevant errors in the correct part of the UI, rather than at the top level.\n\nIt sounds like you are using top-level errors as a way to display user input errors, which isn't the intended purpose for those errors.\n\nThe top-level errors entry was meant to have error messages that are intended for the developer.  This is mentioned in the graphql spec in the [Errors section](http://facebook.github.io/graphql/#sec-Errors):\n\n> Every error must contain an entry with the key message with a string description of the error intended for the developer as a guide to understand and correct the error.\n\nThis has been further clarified in a graphql spec issue (https://github.com/facebook/graphql/issues/117#issuecomment-170180628)\n > It sounds like you are using top-level errors as a way to display user input errors, which isn't the intended purpose for those errors.\n\nNo, I'm talking about a situation where a fetch to a backend API failed, causing that part of the GraphQL query to return `null`. It doesn't have anything to do with user input, and could happen on basically any fetch from a database or other API.\n\nIf the GraphQL `errors` field is intended to be used for runtime errors (which seems to match @leebyron's statement that it's for \"exceptional\" situations), then I'd say this use case certainly falls into that category. The only other option I see is for basically every single type to be a union type with `Error`, which seems undesirable since it will clutter the schema, and there is already an \"official\" place to put errors in the query result.\n Going to close and reopen this to have a better branch name than `patch-1`.\n  Currently, subselections are _disallowed_ on scalars, and _required_ on object types.\n\nHowever, if the API provides a mutation with an object return type, but the user is not interested in the result, they must still query at least one field (chosen at random). That means the user is forced to query data they didn't want in the first place -- kind of contrary to the idea behind graphql.\n\nWe could instead distinguish between correct object type vs. scalar usage by requiring **existence** of a subselection on an object type, instead of **non-emptiness**. Look at those mutations:\n\n``` graphql\nmutation foo {\n  mutateSomething(withArg: 12)     # bad\n  mutateSomething(withArg: 12) {}  # good\n}\n```\n\nThis could also work on queries: one might want to know whether some object exists, but none of its contents. \n\n``` graphql\nquery bar {\n  myObjectField     # bad\n  myObjectField {}  # good\n}\n```\n\nIn the query example, `myObjectField{}` would resolve to one of `{}` or `null`, depending on whether the field resolves to an object or not. And `{}` is a truthy value while `null` is falsy.\n\nPS: I am guessing this was already discussed somewhere, if so, please point me at it -- I cannot find the reasoning behind the design decision.\n or we could implement a new directive like `@omit` for ignore the result.\n Thanks for bringing this up again. The spec describes this as it does to avoid mistakes in queries, but I think it's worth further discussion.\n\nThe few times this has come up before, it's always been in the context of mutations and not caring about the response of the mutation. In those cases you work around by writing `{ __typename }` if you truly don't care about the result, but more often than not we find that this was a theoretical concern and in practice you almost always want _something_ from the mutation, even if it's just the `id` of the thing that was mutated.\n\nI'm curious if there are real cases that have come up in the context of queries where you only want to know of an object-field existance but not know anything else about it.\n\nOne maybe nice thing about disallowing `{}` is that if you're maintaining or refactoring a query and notice that the last field in a `{ ... }` should be removed, then you know that you can also remove the parent field as well.\n\nI'm curious for more opinions on this topic.\n I like the idea of having an @omit directive.  In fact, I found this convo by searching for whether this directive existed.  Would love to see this!\n If you only care about the presence of something, the wouldn't better semantics be adding a _hasFoo_ field to the object?\n  File name changed but documentation linking to it didn't.\n Thanks!\n   Thanks!\n  Lone means lone. Set of ALL operations must be set of one.\n Thanks for highlighting this! I'm not sure your proposed change is correct though. It seems to read that only one operation of any kind may exist within a document, but this rule seeks to only ensure that is the case if the one query is _anonymous_.\n Good point. I was thinking of the spec in isolation rather than globally.\n Awesome, thanks!\n    Clarify that \"null\" descriptions aren't OK. Metadata are very important.\n I think it maybe makes more sense to say that some things are \"trivially\ndescribed,\" such as self-explanatory types (that can be marked as such\neasily) or as types with inner types (where the description just wraps the\ninner type).  But as this is now implemented in the code so that\ngetDescription is not nullable, updating the docs makes sense in any case...\n It's currently implemented as allowing descriptions to be nullable - https://github.com/graphql/graphql-js/blob/master/src/type/introspection.js#L191\n\nThis was one of the things we intentionally loosened from FB's earlier version. When writing the spec for this version of graphql, we decided it would be too burdensome to always require descriptions at the introspection layer - but leave the decision on requiring descriptions as an implementation or lint-rule decision for individual users.\n  Mostly tweaking the defined type system to include everything referenced, plus a few typos\n  Saw this idea referenced in a Relay ticket: https://github.com/facebook/relay/issues/309#issuecomment-141588116\n\n> Per offline discussion with @leebyron and @dschafer we'll probably have to add support for fragment aliases in the language to make this seamless. This would use your earlier proposal, @fson:\n> \n> ```\n> # Relay products\n> fragment on User {\n>   foo: ${Child.getFragment('foo')},\n> }\n> # Raw GraphQL\n> fragment on User {\n>   foo: ...sub_0 # name generated by `relay-babel-plugin`\n> }\n> ```\n\nThought it might be useful to open a ticket here as a reminder or for more discussion.\n  Right now, when some error happens inside GraphQL schema or in the syntax wise we get errors as whole. Then it's our job to decide what to do with it.\n\nBut it would be great, if we can have a set of GraphQL error types(in the spec) which deals with different use cases.\n1. Syntax/Type Errors - These errors are for the errors in client provides query\n2. Runtime Errors - These are the error occurred in runtime specially with syntax errors and network related errors.\n3. User Errors - These are the errors we need to pass to the user.\n\nRight now, in the graphql-js implementation, we get all these errors as one type. But, it'll be useful if we've some mechanism to differentiate them.\n\nSo, it would be great GraphQL spec to define these errors. So, the implementations can use them. Also, the people who write GraphQL schemas can use them to define User Errors.\n\n---\n\nThen, in the transport layers we can check for these three types of errors and do necessary actions. \nIs there any plan to have these in spec. If so, I'd like to work on them.\n Awesome.\nHere's one of our member @mnmtanish's [writeup](https://voice.kadira.io/masking-graphql-errors-b1b9f15900c1#.d93pw6p6j) on this.\n\nHere's our idea for the spec.\n\nWe've a type called `GraphQLUserError`, It's a custom error type. Schema creators can import and throw that if needed.\n\nThis will do nothing much special, but it will allow us to filter these errors from the rest in the transport level.\n\nWhat do you think?\n I get it. It's hard to formalize a common error type. What we mean by the [3] is, we should not send programming errors to the client side. But, anyway it's an application level decision, not something GraphQL should decide.\n\nSo, we like the `graphql-js`'s implementation of sending all the errors and let the transport(app layer) to do whatever it needs.\n\nNow, we need to find a way to differentiate these syntax errors and what the schema really need to send to the client. \n\n> For an example, if there is a credit card related issue. we don't wanna send the original message to the client. (This is based on the never trust the client principle).\n> So, instead schema will send a error of `GraphQLUserError`.\n\n## Why we need this in the schema (even some mentioning)\n\nWe may be using schemas written by different people. If everyone following the same then it's easy for app/transport layer to decide on errors.\n\nBut, I'm not sure where it should goes in the spec.\n I don't have anything useful to add, but wanted to give an example of how I'm using @arunoda and @mnmtanish's [graphql-errors](https://github.com/kadirahq/graphql-errors) package pre-spec as a quick interim hack, in case there are others following the thread.\n\nExample [here.](https://github.com/graphql/graphql-js/issues/179#issuecomment-215824023)\n  Graphql do solve version problem by allow server add field dynamically without client changing their endpoint.\n\nThat's great, however, with an existing backend with versioning api, which is a proper way to support version change.\n\nFor example, with exist versioning backend api\n\n```\nendpoint: /api/v1/foo\nresponse:\n\n{\n    \"key\": \"value\"\n}\n\nendpoint: /api/v2/foo\nresponse:\n\n{\n    \"key\": [\n        \"value1\",\n        \"value\",\n    ],\n    \"additional\": \"wow\"\n}\n```\n\nThere are two problem,\n1. Given an frontend app1, currently use api `/api/v1/foo`, how to setup a graphql server allow app1's future requirement to `\"additional\"` data (and use the old version of `\"key\"`)?\n2. Given another frontend app2, use api `/api/v2/foo`, is that possible to allow both app1 and app2 use the same graphql server without overhead (such as introduce versioning inside graphql server)?\n See my conversation with @leebyron about versioning here: https://twitter.com/leeb/status/679045650575527936\n  First noticed here: https://facebook.github.io/graphql, and also seen in the Markdown source.\n\nSections 5.1 and 5.7 have the same name (\"Operations\") under \"Validation\" (at the same depth) causing TOC linking to fail.\n\nConsider re-titling 5.7 \"Variables,\" and removing a level of depth. Section 5.7.1 is the only child of 5.7, and 5.7 doesn't contain any overview text before 5.7.1 starts.\n Worth noting that this issue make deep linking to this section from implementation documentation difficult.\n  https://facebook.github.io/relay/docs/graphql-connections.html#content\n @leebyron I don\u2019t know if this is my unique experience, but too often I end up having to explain to newcomers that these are not _just_ for Relay, but instead a convention that\u2019s indeed a good idea in general.\r\n\r\nWhile I personally love Relay, the connection to Relay (no pun intended) really seems to ruffle people\u2019s feathers in such a way that they actively decide to _not_ use connections, without apparently understanding the full benefits. Instead what I usually hear is a lament about having to do \u2018more\u2019 work _for_ Relay when creating their schemas.\r\n\r\nWhile I understand that the GraphQL spec may not be the right place to describe conventions, I would _really_ like to see such convention specs be detached from Relay and where possible move closer to where the GraphQL spec lives.\r\n\r\n(The same applies to the Global Object Identification specification btw.)  - Fixes a few grammar issues.\n- Currently in the validation section there are two subsections named \"Operations\" (numbered 5.1 and 5.7).  This naming collision means the skiplink in the TOC for 5.7 sends you to 5.1.  I believe the intention was to have the \"Variables\" section as 5.7, so I removed the second \"Operations\" section and adjusted the child sections accordingly.  If this isn't what was intended, let me know and I can rebase this out of the PR.\n  Three small nits.  Fixes #125 \n Thanks!\n  _It was bound to come up. :boom:_\n\nWhat's the outlook from the GraphQL team on this? Whenever I've seen it brought up to the Falcor team, they say it's not their focus. \n\nWith the capabilities provided by Service Workers, and newer, smarter caching techniques emerging, is it out of the realm of possibilities to consider GraphQL queries/results being cached offline? \n Wouldn't you want caching on whatever backend more than in the frontend that I understand is the primary focus of this project?  I have implemented caching, especially with long poll or websocket updates from backend in frontends but it seems more like a separate project from the goal of this one as I understand it.  But I do see the point when combined with frontend local storage. \n Very cool. Thanks @leebyron. Will approach the Relay team.\n  This looks good. If we introduce union/interface types into the input system, we'll want to be careful (since the input type system should probably be contravariant and not covariant, but for the output type system this looks exactly right.\n > Yeah, currently the only possible pseudo-contravariance in input types in required (non-null) vs optional (nullable) but supporting that causes other issues. I think we'll need to divorce argument requirement from argument type nullability to support argument contravariance in the future.\n\nYep, I don't think we should do anything differently right now, just making a mental note if we ever do.\n  Remove duplicate \"is the result\" in _Evaluating a grouped field set_ > _Field entries_.\n  I was thinking through building a documentation explorer and something that'd be very useful is if you could define example queries alongside your type or field definition. These could then be auto expanded into embedded graphiql instances.\n  per offline discussion\n    Let's say you have a uniqueness constraint on a field in a mutation. For example the `email` field must not match any existing email in the database.\n\nIn https://github.com/graphql/graphql-js/issues/179 it's been suggested that we shouldn't use the server to validate our forms. But in the case of our uniqueness constraint the server is the only place with enough information to determine if our form is valid.\n\nThe format of the errors response appears to be aimed at debugging. Specifically a line number is given as the only context for the error. Presumably this is so that a programmer can then use that line number to find the issue in their query/mutation. So to me the current errors array looks more analogous to a stack trace then an error object like we'd traditionally expect in a RESTful API (eg. `{\"errors\": {\"email\": [\"this email has been taken\"]}}`).\n\nThe advantage of the error object is that we can easily match the keys in the error to the names of the fields in our form to add an error message for our users next to the offending field.\n\nI propose that changing the errors array to an errors object would give developers access to field names and error messages in a format that is easy to map on to their forms and display to users. Eg:\n\n``` json\n{\n  \"errors\": {\n    \"email\": {\n      \"messages\": [\"The email address zuckerberg@facebook.com has already been taken\"],\n      \"locations\": []\n    }\n  }\n}\n```\n\nRelevant Spec Section: https://facebook.github.io/graphql/#sec-Errors\n +1\n +1\n I was wondering how facebook handle error and display related error information for user with graphql?\n\n@leebyron \n Thanks @leebyron. `didSucceed` and `userError` should work for my usage.\n\nIt might be useful to spec out `userErrors` somewhere similar to how Relay specifies connections and edges without necessarily including them in the GraphQL language spec. I feel like user input error handling is as common a concern as pagination in my code. Would it make any sense to consider this for a future version of Relay?\n [Input validation and user-friendly error messages in GraphQL mutations](https://medium.com/@tarkus/validation-and-user-errors-in-graphql-mutations-39ca79cd00bf) on Medium.com\n  Let's say I have a schema for some translated content with a common interface for entries:\n\n```\ninterface Entry {\n  id: ID\n  slug: String\n  translations: [Entry]\n}\n\ntype Page implements Entry {\n  id: ID\n  slug: String\n  translations: [Page] # Page implements Entry, this should be ok\n}\n```\n\nIn graphql-js this errors, saying the translations on `Page` should be of type `[Entry]`. Since `Page` implements `Entry` and translations of a `Page` will only ever be `Page`s, this seems ok to me.\n\nTried the same with union types with the same result. It's not a disaster, I can widen it to the interface type and use a type fragment in queries, but it seems a little unwieldy. \n\nAm I missing a reason why it's not valid to narrow down an interface type when implementing an interface which specifies a field of an interface type? (uh, sorry, can't make that sentence any simpler)\n Yay, awesome!\n  This just feels like SQL all over again where you have to do string concatenation rather than building real data structures to talk to a server. Using a data format (or formats) would be far friendlier and less error prone to implement in the long run. For example I was working with a .NET implementation recently that didn't quite have the grammar implemented correctly and allowed for strings to be provided to the server that didn't have correctly closing curly braces. Data structure formats basically prevent this kind of thing and many other easy to create problems with custom grammars.\n\nIf the syntax could be defined in terms of data structures rather than a custom grammar it would make implementations on both client and server simpler and more flexible. Versioning the spec would likely also be simpler. Testing is definitely simpler on both ends as well since you can use the native data structures of your environment with a little conversion to json, or EDN, or whatever you want for the wire format(s).\n @kylewilt just out of curiosity, are you talking about implementing queries like in mongodb or elasticsearch, e.g.\n\n```\ndb.inventory.find(\n   {\n     type: 'food',\n     $or: [ { qty: { $gt: 100 } }, { price: { $lt: 9.95 } } ]\n   }\n)\n```\n\ninstead of using a SQL-like syntax?\n Yes that's the basic idea, of course that's a language specific implementation in your example. Ideally GraphQL would be defined in terms of pure conceptual data structures like maps, arrays/vectors, sets, etc with basic rules/expectations so that any language can fairly easily implement GraphQL using its native data structures rather than the string concatenation/parsing noise. \n\nYou can always define a standard textual representation over top of data structures but going the other direction is unpleasant and often harder to do because the grammars can start to deviate from something that is sensibly convertible to standard data structures in a consistent way. I can see a future world of \"GraphQL Mappers\" that turn your nice friendly language specific data structures that you normally prefer to work with into GraphQL text which is not really the world I'd prefer personally.\n\nHaving a non textual interface as the spec will simplify testing scenarios since you don't have to test for structured strings and enable faster throughput since you can pick more terse binary transport protocols or even direct function calls.\n  We have an interface `Customization` and around 20 types implementing this interface. The number of subtypes of `Customization` will grow over time, we are even considering adding subtypes dinamically.\n\nEach concrete type has it own set of attributes.\n\nOn the query side this is easy to represent. The problem is at the mutation side. We want to have a mutation method to add a customization to another object \n\n`addCustomizationToNode(nodeId: ID, customizationInput: CustomizationInput)`\n\nbut this is not currently possible to express since Input Objects cannot have interfaces, we would rather not have one mutation field per subtype, specially since those can change dynamically, potentially.\n\nDo you have any suggestions? Would make sense to have InputObjects take interfaces?\n\nThank you!\n Maybe some way of escaping the type system on input? Accepting a map os string to anything? as far as I can tell, everything in the input has to be type checked, am I missing something?\n I also think that this feature would be a valuable addition to GraphQL. I have similar feature in our API. \n\nWe model our mutations as `UpdateAction`s. So, for instance, we have a `Product` type. One can use update actions like `SetName(newName)`, `SetDescription(newDescription)`, `AddPrice(price, currency)`, etc. to update the product. So Ideally I would like to do it with following mutation:\n\n``` js\nmutation UpdateProduct {\n  updateProduct(id: \"1234\", version: 1, actions: [\n    {type: \"SetName\", newName: \"foo\"},\n    {type: \"AddPrice\", price: 123, currency: \"USD\"}\n  ])\n}\n```\n\nIt is also important in our case that all these update actions come in one list, since we guarantee that they all would be applied atomically.\n\nAn ability to define an input `Interface` type would allow us to define `ProductUpdateAction` which then will have `ObjectType` children like `SetName` and `AddPrice`. I guess union type would also work here, but I would prefer to have an interface type in this particular case. \n\nThere is also a discussion around input `UnionType`s: https://github.com/graphql/graphql-js/issues/207\n +1\n +1\n I would think support for polymorphic types would be desired as a first class feature. I'm guessing from this issue and the comments that it isn't, yet.\n You could think of a union input type as an Input Object type which only allows a single field to be specified per input object value.  Unfortunately that would need to be enforced with runtime checks rather than static validation.\n\nA union input type could be represented in a similar way, where a possible type is used in place of a field, and static validation can ensure that only a single type is specified.  E.g. `{ \"MyInputObject\": { \"foo\": \"bar\" } }` could be used to represent the input object value using JSON or maybe `[\"MyInputObject\", { \"foo\": \"bar\" }]` if you think about it as a tuple. A GraphQL literal would have more options for how to represent the union type, e.g. `MyInputObject({ foo: \"bar\" })` could be one option.\n There is another (pretty simple) use case for this feature: a required input parameter that can have one of two possible scalar values.\nWe could use this to retrieve a `node` from a tree either by it's `path` or by a unique `identifier`. Right now we need to use a `string` type and do the conversion in the resolving part or have two _optional_ scalar parameters and return an error at runtime if both are missing..\n\nI've seen that the [SWAPI-Example](http://graphql-swapi.parseapp.com/?query=%7B%0A%20%20film%20%7B%0A%20%20%20%20title%0A%20%20%7D%0A%7D) suffers from the same issue (with `id` vs `filmId`)\n Same use case as @bwaidelich for me: I'm retrieving an entity from either one of its alternate identifiers. \n\nCurrently the `eid` argument is declared as a `GraphQLID` (a string merely) and I'm identifying the type of the entity identifier in the resolving part.\n\nBut I'd like to use a `GraphQLUnionInputType` for these `eid` arguments, that would have a `resolveType()` function to identify the type, which GraphQL could use to cast and validate the input value accordingly. It would allow to catch the cases where the _entity id_ was not valid.\n\n### Current schema\n\n``` coffeescript\n    ...\n    product:\n      type: productType\n      description: \"Retrieves product details, given either a Portfolio or Produit entity id.\"\n      args:\n        eid:\n          type: new GraphQLNonNull( GraphQLID)\n          description: \"Product entity identifier, or entity identifier of one of its constitutive portfolios.\"\n```\n\nQuery:\n\n``` coffeescript\nquery productByCanonicalEID {\n  product( eid: \"ENTITY-ID-IN-CANONICAL-FORM\") { ...ProductFull }\n}\n\nquery productByAlternateEID {\n  product( eid: \"ENTITY-ID-IN-ALTERNATE-FORM\") { ...ProductFull }\n}\n```\n\n### Desired schema\n\n``` coffeescript\n    ...\n    ProductEntityIDType = new GraphQLScalarType { ... }\n    PortfolioEntityIDType = new GraphQLScalarType { ... }\n\n    entityIDUnionInputType = new GraphQLUnionInputType {\n      name: 'EntityID'\n      types: [ ProductEntityIDType, PortfolioEntityIDType ]\n      resolveType(value) {\n        # Lets assume the entity identifiers obey a naming convention,\n        #\u00a0they start with specific letters, which we can derive the type from\n        if value.startsWith( 'PO')\n          return PortfolioEntityIDType\n        if value.startsWith( 'PR') \n          return ProductEntityIDType\n      }\n    }\n    ...\n    product:\n      type: productType\n      description: \"Retrieves product details, given either a Portfolio or Produit entity id.\"\n      args:\n        eid:\n          type: new GraphQLNonNull( entityIDUnionInputType) # <\u2013 Desired change\n          description: \"Product entity identifier, or entity identifier of one of its constitutive portfolios.\"\n```\n\nQuery: the same, but argument `eid` would now be validated and be cast to one of the known entity ID types.\n Also was kinda surprised that it is not available. Though I understand why that is. Unlike with queries, this will probably have to be supported by syntax. Something like (using example above):\n\n```\nproduct( eid#alternate: \"ENTITY-ID-IN-ALTERNATE-FORM\") { ...ProductFull }\n```\n\nAs I could not find a ready solution, I made my own with some workarounds using existing syntax: [Union Input Type](https://github.com/Cardinal90/graphql-union-input-type). You could probably also use it in place of an interface.\n Any news on this? It will be really helpful for many people I think. Did this ever make it to the roadmap?  The rest of reactiflux has moved over to Discord and, currently, GraphQL seems split between the two.  I think it would be nice to have the community in one place.\n  Add table of contents for easier navigation.\n\nAfter read some of the content one day I came back days later and wanted to just jump to the section I was looking for.\n Sorry @leebyron but I did not understand what you mean by that.. are you suggesting that spec-md auto generate navigation based on the md? or I got wrong.\n    This PR adds language around the `subscription` operation type, which landed experimentally in `graphql-js@0.4.8`, to the GraphQL specification.\n\nThis is a WIP - there's still discussion to be had around subscriptions and what they mean for GraphQL, but I wanted to get the ball rolling on this so the can didn't get kicked too far down the road and also so that there was a place to discuss subscriptions in the context of the actual GraphQL specification.\n Are there any blockers on this PR? graphql-js now expects `subscriptionType` to be present under `__schema` on introspection queries, but this isn't part of the spec at all.\n /cc @leebyron \n @taion I would presume that if there's a blocker at all, it's that subscription support in graphql-js is still experimental. Not sure how the GraphQL team wants to handle cases like that with the spec.\n Possibly just update the spec then? I think this is causing the Python guys some trouble with setting up the Relay babel plugin; specifically on running the packaged introspection query against a non-graphql-js server.\n @leebyron np and totally understood. I will update based on your comments.\n @skevy Any updates on this? We would like to implement subscriptions in Ruby but are waiting on an official spec and libgraphqlparser to do so.\n Closing in favor of #267   Variable value coercion is implied during input coercion for the types, but there isn't a mention of when it should be done.  I believe this underspecification can lead to implementations missing input coercion on variables, using the raw unvalidated variable values instead, as was the case with graphql-ruby until I recently reported the issue https://github.com/rmosolgo/graphql-ruby/issues/46.\n\nThe semantics of whether input coercion errors should result in the operation to fail or if the field resolution that uses the variable should fail was unclear.  [graphql-js coerces variables when building the execution context](https://github.com/graphql/graphql-js/blob/v0.4.7/src/execution/execute.js#L198), so it looks like query errors would result in the operation to fail, thus I documented this behaviour in the specification.\n\nThe input coercion also implied that `null` variable values would be accepted for Non-Null types without raising an error, which doesn't make sense for variables which don't have their values validated like literals, so I changed the sentence to say that a query error should be raised.  [graphql-js raises an error in this case.](https://github.com/graphql/graphql-js/blob/v0.4.7/src/execution/values.js#L107-L111)\n    Updated a couple of examples to use the correct fragment definition, which uses `on` instead of `:` between the fragment name and the type name.\n  ```\nconst FooType = new GraphQLObjectType({\n  name: 'Foo',\n  fields: () => ({\n    id: globalIdField('Food', obj => obj.id),\n    bar: {\n      type: new GraphQLList(BarType),\n      resolve: obj => getBarsForFoo(obj.id),\n      resolveCost: n => n * 5,\n    },\n```\n\nIn this example, `n` is the number of times this field is requested across all Foos within the query. This may not be possible in pure GraphQL, since the number of results requested is dependent on how the schema is configured, but with a standardised API for connections like in Relay, it might be possible. The 5 is arbitrary, cheap fields would probably have a 0 or 1.\n\nThe end result would be the ability to reject queries over a certain cost, but also allow IDEs to warn developers that a particular query is risky.\n I  just found out that this has been implemented in Sangria:\n\nhttp://sangria-graphql.org/learn/#query-complexity-analysis\n\nTo that end, it might not be necessary to define it in the spec, and leave it up to implementations instead.\n I think this provides too narrow a view of how the cost might be calculated.  For instance, the cost would at least depend on the arguments in a lot of cases, like of a paginated field (e.g. `users(first: $count)`).  The cost might also depend on other similar selections, which might even re-use the same data, e.g. when using dataloader to batch load and cache datastore queries.\n\nTrying to calculate the cost of a query before it is made can actually be quite difficult, so another possible approach would be to use time as the unit of cost, where a timeout would be used to abort expensive queries.\n\nI think it should just be an implementation detail.\n One can provide reasonably faithful cost estimations for evaluating a graph query, if the average branching factors of edge types (i.e. fields) can be calculated from the contents of the data store. \n\nIn case of the Star Wars example, if you have a query like \n`hero {  \n  name  \n  friends {  \n    name  \n  }  \n}`\nthen you can estimate the number of _friends_ expected to be retrieved by calculating the average branching factor for _friends_ which is (4+1+3+4+1+4+3)/7 = 2.85 in case of the [Star Wars knowledge base](https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsData.js). One can further customize this estimate for _friends_ edges running between specific types of nodes.\n\nIn case of nested queries, like \n`{\n  hero {\n    name\n    friends {\n      name\n      appearsIn\n      friends {\n        name\n      }\n    }\n  }\n}`\none can estimate the size of the expected result set by a sum-product. \nThe result set is expected to contain \n- H nodes for heros, plus\n- H \\* F nodes by navigating along _friends_ from each hero (where F=2.85 above), plus\n- H \\* F \\* A nodes by further navigating along _appearsIn_ from each of the previous nodes.\n\nWe described this estimate 10 years ago in an [academic paper](http://static.inf.mit.bme.hu/pub/varro/2005/gramot05_vvf.pdf), so better estimates are likely to exist since then.\n\n(I am new to GraphQL as a language, sorry if I misused its terminology - or gave a far too academic answer...)\n This is great additional context and insight, thanks!\n I wouldn't put faith in cost estimations that rely on averages with respect to branching factors.  The average might be very low but if you are trying to protect against abuse, then you really want to pay attention the upper bound on the branch factor.\n\nAlso, be careful about calculating the cost of queries that require server-side filtering, since they could scan a large number of objects and return very few results.  The cost of a request isn't always about the amount of data that is returned.\n\nMaybe this discussion can be moved to the graphql-js repo, since it doesn't seem like something to standardize in the graphql spec.\n Here's an interesting package that does a pretty good cost analysis for graphql queries: https://github.com/pa-bru/graphql-cost-analysis  I'm trying to implement pagination algorithm for my data and I don't know how to handle cases when `first` and `last` are negative.\n\nWhat is your opinion about this?\n\nref: https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm\n Should this issue be on Relay instead? Pagination is a Relay feature, not GraphQL\n  For an example, have a look at following query:\n\n``` js\nquery postAndComments($postCount: Int!) {\n  getRecentPosts(count: $postCount) {\n    title,\n    content,\n    ...comments\n  }\n}\n\nfragment comments on Post {\n  comments(limit: $commentLimit) {\n    content,\n    timestamp\n  }\n}\n```\n\nNow this throws an error:\n\n``` json\n{\n  \"errors\": [\n    {\n      \"message\": \"Variable \\\"$commentLimit\\\" is not defined by operation \\\"postAndComments\\\".\"\n    }\n  ]\n}\n```\n\nIf we allow to this, I think it'd be great. Here's the use case.\n\nWith this, I can use `comments` fragments in queries where `commentLimit` query variable does not exists as well.\n\nWhat you guys think about this? \n Yeah. I get it. \nWe can always define it and send a null a value. \n\nI am gonna close this. \n  scala.js emits constructor names with`$` chars , react-relay takes constructor name as mutation query name and resulting in failed transactions :(. i reported this in scala.js channel\n\n> @sjrd is it possible to remove $ in generated constructor/class names for scalajsdefined classes ? graphql supported names set /[_A-Za-z][_0-9A-Za-z]*/, with current constructor names graphql api requests are failing in fastOptJS mode\n\nresponse from scala.js author : \n\n> @chandu0101 No it is not possible. graphql most be fixed to support all valid Javascript identifiers.\n\nso is it possible to accept names that comply with javascript identifiers ? \n :+1: \n  Should there be a map type?\n\nI have a structure that looks like this:\n\n```\n  Item {\n     title {\n        de_DE,\n        fr,\n        pa,\n        .....\n     }\n  }\n```\n\nThe point here is that the number of language strings might be arbitrary. I find this hard to model using GraphQLObject, because:\n1. The number of locales is undefined. While the resolver could handle this dynamically, I think it's a problem in Relay that the schema cannot reflect these dynamic fields.\n2. I would like to query all the existing locales, which isn't allowed, it seems (\"must have a sub-selection\").\n\nIf I make my GraphQL server return a JSON object for \"title\", the Relay client doesn't complain (although  maybe shouldComponentUpdate breaks), but I think I'm skirting by here. At the very least, I think I couldn't generate a schema that confirms to the spec.\n I think this is a valid concern as well. I currently thinking of ways to add GraphQL endpoint for our API. We are building project-based multi-tenant service. For example every project has a list of products which have name and description. Just like in your case these are localized strings as well. \n\nOne way one can approach this problem is to parametrize the field:\n\n``` js\nquery ProductNames {\n  products {\n    nameEn: name(locale: \"en\")\n    nameDe: name(locale: \"de_DE\")\n  }\n}\n```\n\nAnother approach, as you mentioned, would be to generate a schema of-the-fly. In our case it would be possible, since every project has a limited set of locales which are defined in the config of this project. \n\nWhere it becomes more tricky is an addition user-defined data types. Users of our API can define new attributes for products (visually through the merchant-center application). These attributes are also typed, so it's possible to generate GraphQL schema for this project, but it has some implications:\n- Generating schema on every request comes with big performance penalty, since we need to load config from a DB in order to do so\n- to compensate for this performance penalty we need to implement some schema caching and cache invalidation logic\n- Schema now becomes tenant-specific. This means that it becomes much  harder to integrate with generic tools like GraphiQL and do introspection in general\n- You can't even do an introspection queries without the auth anymore.\n\nI guess one can just put all custom attribute JSON in a string scalar, but I don't think that other developers will appreciate JSON inside of string inside of another JSON :) I feel that generic JSON/Map-like type can provide a very useful middle-ground for these use-cases. It can also help a lot with a migration to the GraphQL. One can quickly start with Map-like structure and after some time develop schema generation and caching mechanisms.\n Hello,\n\nI agree about this, and as @OlegIlyenko said, JSON string inside JSON string seems awkward.\nI think Map is one portion of what JSON can provide and I have exposed my point of view in https://github.com/graphql/graphql-js/issues/172\nSo :+1: to include specs for a \"JSON or RawObject or however you want to call it\" type.\n +1\n Hi,\n\nI have a use case where I have 'server based schema' and 'client based schema'.  The server based schema is pretty much static and will follow normal project/application changes through time.  However the client based schema is specific to client side and generated on the fly for exclusive use by the client/user.  It's shape is not ideal for a generic map type as it can become deeply hierarchical.\n\nWhat I need to do is store the resulting client side JSON blob against the user on the server side. I specifically do not want any validation or type checking done on this JSON blob server side except for checking for valid JSON.  At the moment I'm storing it as stringified JSON against an attribute in server side schema which does not seem ideal. \n\nSo I'm very much in favor of JSONObject/RawObject/UncheckedObject or whatever as simple JSON object as proposed here: https://github.com/graphql/graphql-js/pull/172.\n It looks like the use case of @miracle2k can be solved by just using a list. So something like:\n\n```\n  Item {\n     titles {\n        language\n        text\n     }\n  }\n```\n\nwherein `titles` is an array. One can always create an input argument if you want to select a subset.\n\n@clintwood 's use case however looks different since there's no known schema and may be hierarchical.\n\nIMO, as long as there's a known structure, a list type could replace a map.\n @jvliwanag correct me if I am wrong, but this would mean that the values in the list would have to return as an array. This is OK if someone is developing an API from scratch and has control over defining the response payload.\n\nBut if an existing API is being moved over to use GraphQL, which already has a defined contract returning a map of key value pairs (even if the values are always of a defined object type / structure), then it appears this is unavoidable.\n\nI am interested to know how it would be possible to use a list, unfortunately the the list type does not seem to accept anything except an array:\n[graphql/graphql-js/blob/master/src/execution/execute.js#L679-L683](https://github.com/graphql/graphql-js/blob/master/src/execution/execute.js#L679-L683).\n\nInterestingly the error:\n\n```\n User Error: expected iterable, but did not find one.\n```\n\nSuggests it could be possible to supply a `Map` or `Set`, but of course the code says otherwise :crying_cat_face: \n +1. Maps would be useful in mutations for sending arbitrary key/value pairs.\n +1 as well, imagine this can also allow for embedded documents in query responses if using a record store on the backend?\n Please try to use JSON-LD language maps: http://www.w3.org/TR/json-ld/#index-maps\n I agree with @leebyron about the solution to the original problem.\n\nIn the case of user-defined JSON data, can we just make it clear that custom scalars aren't restricted to how they can be serialized.  E.g. with graphql-js you can serialize a custom JSON scalar using arrays, objects, etc.\n alternatively:\n\n```\nitem {\n  titles(languages: [\"en\", \"fr\"])\n}\n```\n\nresult:\n\n```\n\"item\": {\n  \"titles\": [\"Hello\", \"Bonjour\"]\n}\n```\n\nYou can specify the list of language in a variable\n\nAdvantage of this approach:\n1. static query: no need to specify languages before writing the fragment (versus approach 1 in @leebyron 's comment\n2. didn't create a new Object type. (versus approach 2 in @leebyron 's comment)\n +1 for map support. This \"anti-pattern\" logic seems like over-thinking it to me. Sure some people will abuse it but that is true for anything.. \n +1, map support is useful for some situations that the system always return less data than expect, I think.\n +1 Currently I'm dealing with an API that data is arbitrary (as users can create their own contentTypes on the CMS), so there is no way I can create an `entryType` as I have no idea what fields are in there. Having a mapType will be super useful for these cases.\n\n**Update:** Just tried this and is working great so far!: https://github.com/taion/graphql-type-json (thank you @taion).\n I have the same use case as @juancabrera. Our API delivers content defined and managed through a custom CMS, and a main feature is being flexible and dynamic. In the application, we model the objects as a base set of common fields, and then a \"fields\" map with all of the dynamic properties that we don't know about on the server.\n\n```\n{\n  \"contentId\": 123456,\n  \"type\": \"video\",\n  \"fields\": {\n    \"title\": \"fake video 1\",\n    \"releaseDate\": \"...\",\n    ...\n  }\n}\n```\n\nWe'd like to give our client app devs the ability to query and transform the content in the way they want, but without having to create a strict schema on the server.\n +1 for maps. In my use-case I have objects of this shape (in typescript): \n\n``` typescript\ninterface GenericObject { \n  id: string, \n  label: string,\n  types: string[], \n  objectProps: {[key: string]: GenericObject[]}\n  dataProps: {[key: string]}: string[]} \n}\n```\n\nUsing the list of key-values would mean I am doing a transformation on the server to send the data and then do the reverse transformation on the client to build up that map again. \nUsing the JSON value type would mean I can not fetch related objs (via objectProps) with their respective fields.\nUsing arguments would mean I need to know all the properties in advance, which is not possible.\n\nAlso the size of data we talk about here is rather small. So paging is not an issue.\n We have the exact same need as @jarwol \n I am in agreement with @leebyron after watching what has happened in other \"JSON\" type apis at my company. The path of least resistance is the path most often traveled. \n\nThis means that if there is a choice of creating a new type that has more semantic meaning to the UI or creating a map that has no tooling support or contract, but is \"quick\" to create on the server, then a map is going to be used.\n I would personally opt for 2 seperated types. \nAs I see it there are 2 use cases of the data:\n1) view, the data is shown to a user in his/her 's preferred language\n2) admin, the data is to be edited (translations added / changed / removed) by an administrative user\n\nThis might come across as perhaps anti-pattern, though in my opinion it is not. Since these are 2 completely separated concerns / representations even if the source for both is the same in your db.\n\nThus:\n1) VIEW: Type is the minimal set, language is given as a variable and resolver is responsible of choosing the correct one to return.\nChanges are high that you want localised data for more types then just \"Item\", therefore using a variable is also reusable across your schema queries, mutations, ...\n\n```\ntype Item {\n   title: String\n }\n```\n\nSelected by:\n\n```\nquery ($language: String!) {\n    Item(language:$language) {\n        title\n    }\n    variables {\n        language:'en-US'\n    }\n}\n```\n\n2) ADMIN: Type is extensive administrative set. Here you can choose your own preferred medicine:\n_Array based_\n\n```\ntype Language {\n    code:String\n    text:String\n}\ntype Item {\n    title: [Language]\n}\n```\n\n_Unified languages type_\n(listing all possible?)\n\n```\ntype Languages {\n    nl-BE:String\n    en-US:String\n    fr-FR:String\n    nl-FR:String\n}\n\ntype Item {\n    title:Languages\n}\n\n```\n\n_Plain object_\n\n```\nscalar Object\n\ntype Item {\n    title: Object\n}\n```\n We have the same issue as @OlegIlyenko: user defined data types.\r\nWould be interested to hear how other users are tackling this. I have a similar use case. Instead of the value of the Map being a simple string, I'd need GraphQL types as I'd like to use field resolvers there.\r\n\r\nConsider a schema like this:\r\n\r\n```\r\ntype Book {\r\n  id: ID\r\n  name: String\r\n}\r\n\r\ntype User {\r\n  name: String\r\n\r\n  # This is invalid, but roughly what I'd need\r\n  favouriteBooks: Map<String, Book>\r\n}\r\n```\r\n\r\nA response should look like this:\r\n\r\n```\r\n{\r\n  name: \"Jane Doe\",\r\n  favouriteBooks: {\r\n    science: {\r\n      id: '1'\r\n    },\r\n    novel: {\r\n      id: '2'\r\n    },\r\n    ...\r\n  }\r\n}\r\n```\r\nThe book category names are dynamic and change often, therefore I'd like to not specify them in the GraphQL response. Note that this is just a contrived example. I'm not looking for a solution to this particular problem. \r\n\r\nI understand the value of using a list instead, but it would be great to use this to work with clients / server responses that were designed before the GraphQL layer was in place. I would like to support ES6 Map construction directly from json. The ES6 Map constructor accepts and array of Entries where the Entry \"type\" is a two element array where the elements are of different underlying types one for the key and one for the value e.g. [string object]. I can't do this currently in GraphQL.  @amannn: Even \"with clients / server responses that were designed before the GraphQL layer was in place\", isn't a schema like the following similarly easy to produce/consume?\r\n\r\n```\r\ntype Book {\r\n  id: ID!\r\n  name: String\r\n}\r\n\r\ntype User {\r\n  name: String\r\n  favouriteBooks: [FavoriteBook]\r\n}\r\n\r\ntype FavoriteBook {\r\n  category: String\r\n  book: Book\r\n}\r\n```\r\n\r\nThe obvious use case for having `favouriteBooks` be a map would be to do `O(1)` look-up by category name, but if that's what I care about I can create a look-up structure easily enough.\r\n\r\n```\r\nconst booksByCategory = {};\r\nbooks.forEach(({category, book}) => booksByCategory[category] = book);\r\n``` @wincent Thanks for your reply!\r\n\r\nSure, the consumption of a list is no problem. But to use this with existing infrastructure, I'd need to do the following this:\r\n\r\n - In my case, my GraphQL layer wraps existing REST endpoints. I'd have to transform `favouriteBooks` in REST responses into a list, so they match the schema.\r\n - Either I rewrite the parts of my UI code that consume `favouriteBooks` to work with the new data structure, or I have to transform them back into a map in a wrapper component. If I do the latter and the UI components have a callback to update the data, I have to transform them back into a list before calling a mutation (given a similar input type as outlined above).\r\n - When the GraphQL layer receives the mutation, it has to transform the list back into a map in order to pass it on to a REST endpoint.\r\n\r\nSo it could work, but what I'm trying to say is that it will probably end up in quite a bit of back-and-forth transformation which increases complexity. It would be great if the GraphQL- and the UI layer could use the same data structure as they are already known to REST endpoints. @wincent. If we ignore the fact that we can treat {} as a map of sorts and use the new ES6 Map object, my current code avoids things like: \r\n\r\n`\r\nbooks.forEach(({category, book}) => booksByCategory[category] = book);\r\n`\r\n\r\nin favor of:\r\n\r\n`\r\nmap = new Map([ entry1, entry2, ... ]) where each entry is [key:string, value:object]\r\n`\r\n\r\nthat way I get the underlying library to do all the looping for me. Since this is now part of the language and many languages have a map construct, surely graphql schema should support a construct like this more directly. If we can achieve the Entry construct then a map is just a list of Entries, however this is very JavaScript specific\r\n > If we can achieve the Entry construct then a map is just a list of Entries, however this is very JavaScript specific.\r\n\r\nTrue, @serle. GraphQL is very intentionally language-agnostic, so it's good to point that out. There's nothing JS-specific about building maps from lists of key-value pairs, though. That's the standard map constructor in a huge number of programming languages, from C++ down to Python.\r\n\r\nThat said, though, it does feel really awkward to represent maps as key-value pairs. To the extent we're interfacing with e.g. REST APIs, it's an extra step in marshalling and unmarshalling data in the GraphQL layer, and it feels clunky. If you want maps or other interesting GraphQL transforms then I recommend you look at [`graphql-lodash`](https://github.com/APIs-guru/graphql-lodash). I don\u2019t think there\u2019s a strong argument (yet) for maps in the GraphQL *specification*, but client tooling can definitely fill the gaps! @wincent\u2019s example could become a map with GraphQL Lodash with this query (assuming `User` is the root query type):\r\n\r\n```graphql\r\n{\r\n  favoriteBooks @_(\r\n    keyBy: \"category\"\r\n    mapValues: \"book\"\r\n  ) {\r\n    category\r\n    book { name }\r\n  }\r\n}\r\n```\r\n\r\nExactly the shape you want without having to change your UI code! If it turns out *a lot* of people use GraphQL Lodash for maps then maybe we should consider adding maps to the specification. I think the issue is more having seamless serialization/deserialization support on the client. Not sure Relay is quite there. Given that GraphQL fundamentally serves out data structures and most of them are now fundamentally  baked into each language in order to promote standardization, I feel that GraphQL should have a rich type system to promote API clarity and eliminated unnecessary workarounds and transformations. \r\n\r\nWith regard to maps, maybe a more general approach is to introduce a Tuple type i.e. a fixed size array where each element has a predefined type which can either be a primitive or custom type. In this way we could achieve both the Entry concept and thus a Map as well as other more general use cases. However, I still feel that it is cleaner to explicitly have a Map type with standard language mappings. A tuple type isn't really relevant here because there's no particular relevant _ordering_ between the key and the value in an entry struct. @taion for the ES6 map the key is always Entry[0] and the value is always Entry[1] As a huge fan of Typescript, I am really enjoying trying to get a nascent GraphQL version of our API started. But, as many others have mentioned the lack of a basic `Map` type is a huge hinderance.\r\n\r\nWe don't always know what we're going to receive, especially in the case of user generated content.\r\n\r\nAnd, unlike the `JSONType` mentioned above, or the list of tuples idea, I would prefer a fully typed solution as well.\r\n\r\nSomething like:\r\n\r\n`Map<String,Type>`\r\n\r\nI see this as a massive handicap for an API that deals with non-deterministic data. I don't think anybody's recommending the use of the JSON scalar type for typed data, BTW \u2013 for now the best workaround is to serialize as a set of entries.\r\n\r\nI still agree that it would be better if GraphQL had first-class support for mapping types, like Flow, TypeScript, &c. Note that in practical terms, I was able to define a custom scalar and just output the map as a JSON structure. This worked fine with relay classic, but doesn't with relay modern, since the code tries to process these nested objects here: https://github.com/facebook/relay/blob/9a401c625ad6bb4632478c14c9f54eb1f47179d9/packages/relay-runtime/util/recycleNodesInto.js#L19 I have a use case with a slight wrinkle. My back end is running Django + graphene. The backend has a model with a field that is stored in the database as JSON. The front end is Angular 4. It constructs a JSON map representing what amounts to a parse tree for a small expression language, and then wants to pass the tree to the back end. Obviously it can be stringified before the GraphQL call and destringified on the back end, but it would be very nice to avoid that, with the added benefit of letting the platform ensure that the front end is really passing a valid JSON map to the back end. I just stumbled upon another use case: [highlights in elastic search responses](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html#_fragmenter). They look like this:\r\n\r\n```json\r\n{\r\n  \"source\": {\r\n    \"message\": \"Hi Jane!\",\r\n    \"recipient\": {\r\n      \"name\": \"Jane\"\r\n    }\r\n  },\r\n  \"highlight\": {\r\n    \"message\": [\r\n      \"Hi <em>Jane</em>!\"\r\n    ],\r\n    \"recipient.name\": [\r\n      \"<em>Jane</em>\",\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nHere `message` and `recipient.name` are paths to fields in the `source` that was found. You could try to create a `SearchResponseHighlight` type that contains all the fields but I can think of the following issues:\r\n\r\n - I guess it's easy for this to get out of sync as at least in my case the type of the `source` is defined somewhere else as the types related to search.\r\n - Queries for retrieving such data would look a bit redundant and the user has to make sure that `highlight` is always in sync with the requested fields.\r\n - GraphQL doesn't support field names with dots in them currently. I think a map type can be quite useful to replace something like:\r\n\r\n```\r\n{\r\n  map {\r\n    key\r\n    value {\r\n      fieldOnValue\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nInto:\r\n\r\n```\r\n{\r\n  map {\r\n    fieldOnValue\r\n  }\r\n}\r\n```\r\n\r\nI think this might also make some kinds of connections simpler, since the edge cursor could maybe just be a key on the object?\r\n\r\nOne question to answer would be if the map is ordered or unordered. Not all languages support ordered maps so some cases would still have to use the first approach. I was initially shocked at the lack of a native map type in GraphQL. It really kind of defeats the concept of GraphQL serving data in _exactly_ the format in which clients need it.\r\n\r\nNow, I feel differently. As is, aside from type recursion, there is only one unbounded type in GraphQL, which is List. This actually makes it a lot more tractable to think about how to build abstractions on top of GraphQL.\r\n\r\nThe cost of this is that clients have to manage their own data. But maybe this is as it should be. After all, while GraphQL is meant to reproduce _graphs_ of data, in fact, queries are _trees_. You bring your own graphification. Maybe maps and other higher-level structures should similarly be deserialized out of more elemental pieces. Then something like a directive could be used in the schema to specify that a given list field should be interpreted as a map, either by pulling out a given field as the key or identifying key and value fields of entries. I don't think this changes the fact that being able to limit values in a map would be a huge benefit. If the argument is that maps are harder to reason about I don't buy it. \r\n\r\nThink of maps as keys not with simple values but with huge objects underneath. If you're only interested in the name of each person (`Map<id, Person>`) it would be more efficient to simply ask for the name.\r\n\r\n```graphql\r\nmapOfPeople {\r\n   name\r\n   photo {\r\n    small\r\n  }\r\n}\r\n```\r\n\r\nBut, it's impossible to model the data THROUGH the map. So anything that has a set of dynamic keys has to be emitted as json data and is opaque to the client. I wonder if there's a way to get best of both worlds as in protobuf: https://developers.google.com/protocol-buffers/docs/proto#maps +1\r\nI was really surprized that there is no way to produce a hashMap with graphQL.\r\nI really loved graphQL and I was ready to convince my colleagues to migrate from Rest to GraphQL.\r\n\r\nBut the absence of maps would make my argument imposible. We would have to massively refactor our frontend application.\r\n\r\nI appreciate the people who claim that this is an antipattern. But I personally belive that there is a reason why we use both in computer science. Some times the right thing do is using an array, and some times is using a hashmap. There is not one answer here.\r\nSo, I really believe that is should be up to the users to decide. \r\n\r\nSome people (like us) have already frontend applications that use Maps all over the place. Some people simply like it.\r\n\r\nSometimes accessing stuff like\r\n`userGroups[ myUser.groupId ] \r\n`\r\nis easier and cleaner than doing the more \"manual\" version:\r\n`userGroups.find (g => g.id == myUser.groupId)\r\n`\r\nIt seems much more performent too (in js at least)\r\n\r\nAnd after all, the idea behind graphQL is that the client asks the structure that it needs.\r\n\r\nI really encourage the graphql people to consider this. I don't see this as an anti-pattern. Map, Dict, Object, KeyValue(Stores) are ubiquitous. Why? Because they makes our life easier. And access faster.\r\n\r\nI just experimenting with GQL in an app which use map-like structures... of course we can represent a map with a tuple and convert it in both directions, but, well, why? It's so painful! \r\n\r\n> And after all, the idea behind graphQL is that the client asks the structure that it needs.\r\n\r\nA big +1. If a car is designed to get you from A to B, then to push the car seems very strange. You often want to work with normalized data on the client. It can be easier and more performant.\r\n\r\nSomething like getting a few users and merging them into a redux store is simpler if they are returned as `Map<string, User>`. These are still well defined types. @DylanVann But that's also an argument for not having a formal Map type. We use Redux too, at my company. We ingest data from the network via our reducer layer into a normalized representation in the Redux store, and then use a selector layer to present a more convenient denormalized view of the data to our React view layer.\r\n\r\nFrom that perspective, it's only very slightly more difficult to ingest an array of entities by adding them to Redux's key-value representation than it is to merge a map of entities. It's basically something like `Object.assign({}, prevState, ...inputArray.map(obj => { [obj.id]: obj }))`, which is only slightly more difficult than `Object.assign({}, prevState, inputMap)`. \r\n\r\nMy point is, either way, you usually have to have _some sort_ of ingestion of the raw data from GraphQL. Adding a native Map type to GraphQL makes ingestion slightly mildly easier but multiplies by some small constant factor the complexity of all tooling, while not actually reducing complexity of GraphQL schemas themseleves (field of type `map<ID, Entity>` vs field of type `[Entity]`). I would posit that the best extensions to GraphQL are the things that significantly impact that last point. @acjay, Sure, I could convert the data myself, from a list to a map. You are right on this.\r\nLikewise, I could survive if there were no aliases in graphQL. I could convert the field keys myself on the client, to match my needs.\r\nBut, I cannot imagine anyone who would prefer writing JS code to apply aliases, instead of defining them in the graphql query. The second is much simpler, more clear and more straight-forward.\r\n\r\nSame is true for maps.\r\nYes, we can do it ourselves, but it would be **great** if we didn't have to. You can use something like [normalizr](https://github.com/paularmstrong/normalizr) on the client to deal with arrays being returned, but it would be nicer in some cases if the API could just represent a Map.\r\n\r\nThe existence of a workaround for not having a feature isn't an argument for not having the feature.\r\n\r\nedit: It actually could be an argument, but in this case I think the workaround is overly complex. Tricky without something like generic types or extensions of lists in GraphQL, though. How do you know if a list is supposed to be a map? This missing Map type is a problem for me as well.\r\n\r\nI recognize that any fundamental change to the GraphQL spec is difficult, but the lack of this feature is particularly problematic because it's supported in many of the type systems and services that GraphQL interfaces with.\r\n\r\nThis leads to implementing custom resolvers on the server, followed by custom transforms on the client, to deal with situations where my server is sending a Map, and my client wants a Map, and GraphQL is in the middle with no support for Maps.  Yes, **it is possible, and I have done it**, but it is fair bit of boilerplate and abstraction that seems to defeat the purpose of _writing the API spec in GraphQL_.\r\n\r\nNote that storing data in this way is actually recommended by services such as [Firebase](https://firebase.google.com/docs/firestore/solutions/arrays#solution_a_map_of_values) -- it is amenable to mutations or referencing of subsets of items in the collection.  You don't need to ensure consistency of the index location over time as other elements are added or removed.  This is a common pattern in APIs where pagination is not required and/or element ordering is not important to the spec.\r\n\r\n(This is the case I am facing as well: I am returning a set of objects from which I individually reference items for further updates, meaning that with an array I must re-index the payload into a map on the client to avoid an `O(N)` search for each update.)\r\n\r\n---\r\n\r\nHere are some examples of how this type is handled in specifications that have close adjacency to GraphQL.  This is a hypothetical object `Apple` with a field `seeds` containing one or more objects indexed by a string key.  Apologies in advance for any minor typos.\r\n\r\n```json\r\n// Example Apple Payload (JSON)\r\n{\r\n  \"seeds\": {\r\n    \"alpha\": { \"weight\": 1 }, \r\n    \"beta\":  { \"weight\": 2 },\r\n    \"gamma\": { \"weight\": 3 },\r\n  }\r\n}\r\n```\r\n\r\n**Typescript**\r\n\r\nhttps://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types\r\n\r\n```typescript\r\ninterface Apple {\r\n  seeds: {\r\n    [key: string]: {\r\n      weight: number;\r\n    };\r\n  };\r\n}\r\n```\r\n\r\n**Javascript + Flow**\r\n\r\nhttps://flow.org/en/docs/types/objects/#toc-objects-as-maps\r\n\r\n```javascript\r\ntype Apple = {\r\n  seeds: {\r\n    [string]: {\r\n      weight: number\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Python (via `typings`)**\r\n\r\nhttps://www.python.org/dev/peps/pep-0484/#the-typing-module\r\n\r\n```python\r\nclass AppleSeed:\r\n  weight: int\r\n\r\nclass Apple:\r\n  seeds: Dict[str, AppleSeed]\r\n```\r\n\r\n**JSONSchema (Used by MongoDB)**\r\n\r\nhttps://spacetelescope.github.io/understanding-json-schema/reference/object.html#pattern-properties\r\n\r\n```json\r\n{\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"seeds\": {\r\n      \"type\": \"object\",\r\n      \"patternProperties\": {\r\n        \".+\": {\r\n          \"type\": \"object\",\r\n          \"properties\": {\r\n            \"weight\": \"integer\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n I do not think that map is an anti-pattern. It is rather an extension (or even a functional superset) of an array.\r\nGiven that a map structure, when serialised to JSON, looks like:\r\n\r\n```JSON\r\n{\"mapStruct\": \r\n  {\r\n    \"key1\": \"value1\",\r\n    \"key2\": \"value2\"\r\n  }\r\n}\r\n```\r\n\r\nIt can then be viewed as an ordered list of values with explicit string indices - basically, a LinkedHashMap in Java if you will; which in turn is based on a HashMap and LinkedList. \r\nIn contrast, an array uses implicit numeric indices.\r\nIf need be, in most of the languages one can retrieve a _list_ of keys available in a map which can then be used to mimic array access: either by using the literal string value or the numeric position thereof.\r\nTherefore, when serialised to JSON, a map is an ordered structure. Deserialised, it that can be accessed as both a map and an array.\r\n\r\nHaving said the above, I do not see an issue with the pagination either. \r\nPagination depends not only on the ordered data structure but also on the backend.\r\nIf the backend guarantees the ordering of the result - fine, if it returns values in arbitrary positions, pagination will not make sense regardless of the data structure used.\r\n\r\nThus, the behaviour here is identical for both arrays and maps. \r\n\r\nI like the suggestion to use typed `Map<String, Value> mapStruct`. \r\nConsider the following property declaration:\r\n```\r\n  mapStruct: Map(Value)!\r\n```\r\n\r\nthat would translate to something like:\r\n```\r\nmapStruct: {\r\n  key1: Value,   \r\n  key2: Value,   \r\n  ...\r\n}\r\n```\r\n There's a GraphQL WG meeting coming up soon. Perhaps the right thing to do is to put together some sort of formal proposal, discuss it at the WG meeting, and finally put this issue to rest once and for all, in whichever manner works best? I've composed [this document](https://github.com/gintautassulskus/graphql_proposal_map/blob/master/graphql_wg_map.md) that could hopefully serve as a starting point for the proposal.\r\nThe document has three main parts: motivation, specification and other considerations.\r\n\r\nAny feedback, discussion and edits are greatly appreciated. Of course, do not leave out the text clarity, style and grammar, especially the articles :-)\r\n\r\nPS. I understand that the proposed solution will not satisfy everyone, but we have to start somewhere.  @gintautassulskus @taion \r\nWe have the standard checklist for adding new features:\r\n* Are we solving a real problem?\r\n* Does this enable new use cases?\r\n* How common is this use case?\r\n* Can we enable it without a change to GraphQL?\r\n* Is so, just how awkward is it?\r\n\r\nHere is [relevant part from @leebyron talk](https://youtu.be/mePT9MNTM98?t=20m32s)\r\n\r\n> I've composed this document that could hopefully serve as a starting point for the proposal.\r\n\r\n@gintautassulskus I couldn't find example query that do subselection on map value.\r\nI personaly think that this feature shouldn't brake current assumption that shape of query should match shape of result. So query shouldn't be like that:\r\n```\r\n{\r\n  mapField {\r\n    fieldOnValue\r\n  }\r\n}\r\n```\r\nBecause responce will look like that:\r\n```json\r\n{\r\n  \"mapField\": {\r\n    \"foo\": {\r\n      \"fieldOnValue\": \"bar\"\r\n    }\r\n  }\r\n}\r\n```\r\nI think it's one of the most critical parts of this proposal. @IvanGoncharov\r\n\r\nTo be clear, I don\u2019t care one way or another how this turns out, so long as it does get resolved. This issue has been open for 2 years now \u2013 unless we think the issue is that we\u2019re missing the \u201cright\u201d proposal, we should accept or reject what\u2019s here one way or another.  I have an idea on oh this could look like. Lets assume that we have a User\ntype that we want to create the Map with it (in Query type).\nSchema would be like:\n\ntype User {\n    id:Int\n    name:String\n    favoriteColor:String\n    #.....\n}\n\ntype Query {\n    userMap: [Int:User]\n\n    #or userMap:{Int:User},\n         #so that it looks more like JSON\n}\n\n\nThe query would look exactly like the ones for arrays:\nquery {\n    userMap { id, name }\n}\n\n\nAnd the result would be:\n{\n    \"data\": {\n          \"userMap\": {\n                 \"1\": {\"id\":1, \"name\":\"Linus\"},\n                 \"2\": {......},\n                 \"3\":{......}\n            }\n     }\n}\n\nDepending on the serializer that one uses, there will be limitations in\nplace for the type of the map keys.\nFor example, if we serialize to JSON,  it would have sense that we use\ntypes that can be converted to Strings (strings, integers, or even custom\nscalars that can be converted into strings).\n\nIn my oppinion, graphQL itself should not bother with this type\nrestriction: the serializer that one uses will handle it.\n\nBut if we decide that this is an important issue, we could simply whitelist\na number of scalars that are allowed to be used as map keys.\n\nOn Thu, May 10, 2018, 05:48 Jimmy Jia <notifications@github.com> wrote:\n\n> @IvanGoncharov <https://github.com/IvanGoncharov>\n>\n> To be clear, I don\u2019t care one way or another how this turns out, so long\n> as it does get resolved. This issue has been open for 2 years now \u2013 unless\n> we think the issue is that we\u2019re missing the \u201cright\u201d proposal, we should\n> accept or reject what\u2019s here one way or another.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/facebook/graphql/issues/101#issuecomment-387943754>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ADUvhBQEt-L6NgzAAtvvYJePvk79yNCzks5tw7h0gaJpZM4GIZEB>\n> .\n>\n I agree with @IvanGoncharov  about not breaking assumptions. GraphQL is all about specifying which keys of data are important to you, and adding implicit keys to the response breaks that. When integrating different systems this might not be always feasible, but nothing prevents you of handling it with a wrapper type as mentioned before:\r\n\r\n```\r\ntype MyHashMap {\r\n  key: string!\r\n  value: User\r\n}\r\n\r\ntype User {\r\n  firstname: string\r\n  lastname: string\r\n}\r\n\r\ntype Query {\r\n  users: [MyHashMap]\r\n}\r\n\r\nquery {\r\n  users {\r\n    key\r\n    value {\r\n      firstname\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis is no different from pagination, or any other complex data structure. It just needs to be documented, since it's no obvious for a newcomer how to achieve it. A change in the spec might look convenient at first glance, but doesn't enable new use cases and will require a lot of effort on every graphql implementation and related tooling to catch up.\r\nAlso there will be some edge cases that are not easy to capture in the spec, eg:\r\n- What should happen if the map has too many keys, and a client needs to paginate the returned result?\r\n- What if they keys don't have a single type, like some systems allow?\r\n\r\nI completely appreciate the issue, it happened to me many times but having some recommendations on how to do it and perhaps some helper code should be enough.\r\n @IvanGoncharov thanks, these are very good points. The presentation mentions production testing. The proposal could at least validate the acceptance of the concept.  The implementation and testing would follow if need be.\r\n\r\n@alkismavridis That looks like a neat solution. The only quirk I see is that `[Int:User]`requires a hardcoded `id` field. Maybe a meta field `__key` would do.\r\n\r\nGotusso, I see your point. You think standardising the approach to avoid custom solutions is a bit of a stretch?\r\n\r\n No, I think it would be fair enough to have a separate spec and a reference implementation in the spirit of Relay's pagination. That can cover most of the cases, and the community could use it or not depending on their particular needs. I think that the solution about the wrapper object is not helping much.\nThe real benefit would be to get ready-to-use map types on the client,\nwithout the need of converting some other data type o map, every time.\n\nIf we embrace  the idea that client-side proccessing is required, we could\nforget the map-support completely and use lists, which would be converted\non the client to maps, by choosing a property as key, or something like\nthat.\n\nIn fact, we wrote in our project our own ListToMap(list, propToUseAsKey)\nfunctions to handle this.\nAnd we call this every time we need to use a map.\n\nI think the whole idea for map type support in graphQL is not having to do\nthat, whicg I personally would find extremely handy and helpful.\n\nAs for Gotusso's comment, yes that is correct. The implementation method\nwould choose what property to use as key. But I think this is fair enough,\nsince most of the times, the key that has sense is application specific.\nSome times this is could be a DB id, some times it is a timestamp etc. In\nany case, the application knows that and can specify that.\n\nSo, I think giving this responsibility to the implementation method is a\nfair choice.\nThe client then, would choose what fields to fetch from the value object,\nbut not what key to use. This is definatelly a tradeoff, but I think not so\nsignificant.\n\n\nOn Thu, May 10, 2018, 12:12 Franco Gotusso <notifications@github.com> wrote:\n\n> No, I think it would be fair enough to have a separate spec and a\n> reference implementation in the spirit of Relay's pagination. That can\n> cover most of the cases, and the community could use it or not depending on\n> their particular needs.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/facebook/graphql/issues/101#issuecomment-388012699>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ADUvhMUKpbcMK6hZjDBFGArjidvlmn4wks5txBKGgaJpZM4GIZEB>\n> .\n>\n In Apollo the GraphQL API is cached and can be used  sort of like a redux store. Ideally you'd want it to be normalized, but that doesn't seem possible currently.\r\n\r\nIn one case if I'm using the cache I have to loop over a bunch of items instead of just checking an ID. It's not insurmountable to work around this but it definitely doesn't seem ideal.  ship it!\n  I like it. Ship it.\n   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n  Use `ImplementsInterfaces` syntax from GraphQL IDL in the examples.\n  Suppose we have a forum where users can reply to comments recursively:\n\n``` graphql\ntype RootQuery {\n  message(id: String): Message\n  messages: [Message]\n}\n\ntype Message {\n  id: String!\n  content: String\n  comments: [Message]\n}\n```\n\nHow could the client query for the nested comments?\n\nThis only goes three levels deep:\n\n``` graphql\n{\n  messages {\n    comments {\n      id\n      content\n      comments {\n        id\n        content\n        comments {\n          id\n          content       \n        }\n      }\n    }   \n  }\n}\n```\n\nWould a consecutive query starting at the last comment be the right solution?\n\n``` graphql\n{\n  message as comment($commentId) {\n    comments {\n      id\n      content\n      comments {\n        ...\n      }\n    }\n  }\n}\n```\n\n[Original SO post](https://stackoverflow.com/questions/32442814/structuring-graphql-types/32497480#32497480)\n Saw similar question in Relay repo: https://github.com/facebook/relay/issues/246\n Yeah that's what I'd thought.\n @petrbela Can we re-open this issue, as that issue only  talks about the relay side of things. I would like to know how to accomplish recursive object types while creating a graphQL server.\n @nmn +1\n @nmn You can define recursive object types by passing a thunk (a function without arguments) that returns the fields:\n\n``` js\nconst Message = new GraphQLObjectType({\n  name: 'Message',\n  fields: () => ({\n    comments: {\n      type: new GraphQLList(Message),\n      resolve(message) {\n        return getComments(message.id);\n      },\n    },\n    content: {\n      type: GraphQLString,\n    },\n  }),\n});\n```\n\nYou can even define mutually recursive objects and GraphQL schema is smart enough to lazily call the `fields` functions to resolve them when needed.\n @fson In other words, in the query, you only ask for \"one level\" of message's comments\n\n```\n{\n  message(1) {\n    id\n    comments {\n      content\n    }\n  }\n}\n```\n\nAnd the `comments` field could return all nested comments\n\n``` js\n{\n  \"message\": {\n    \"id\": 1,\n    \"comments\": [\n      {\n        \"content\": \"First comment\",\n        \"comments\": [\n          {\n            \"content\": \"Nested comment\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nIs that so? It seems to be against logic since the reply structure doesn't exactly mirror the query. Does the `getComments` method return the whole nested tree? How would the GraphQL executor know to expand the `comments` field once it steps into resolving the first comment? The query only tells the executor to ask for the `content` field.\n @petrbela Only asking for one level of nested comments would return one level of nested comments. So you would explicitly make a query that fetches comments as deep as you need to go. The GraphQL executor resolves the fields recursively from top to bottom, so `getComments(message.id)` would simply return the list of comment messages for the given message. In other words, there isn't anything specific needed on the server to support these nested queries. The only trick is to define the fields with a thunk, to avoid problems with the execution order of the type definitions.\n\nI made a gist with a working example of the recursive messages/comments schema, if you want to play with it: https://gist.github.com/fson/a14f5edf2ae3fb5294dd\n Thanks for the comments.\n\nThe main question was if you could return a recursively nested object (without knowing the depth) in a **single** query.\n\nSeems the only way would be to send a query with a lot of nesting (at least as much as the deepest reply tree), and GraphQL would expand each branch until it reaches a `null` object (leaf) in each of the branches. This should theoretically work with Relay, too, if I'm not mistaken.\n\nOr do you have any other idea?\n Yeah, as far as I know, it's not possible to write a recursive query of unlimited depth. Trying to do so using fragments will result in an error \"Cannot spread fragment \"MessageFragment\" within itself.\":\n\n``` graphql\nfragment MessageFragment on Message {\n  content\n  comments {\n    ...MessageFragment\n  }\n}\n```\n\nThis is because fragments are fully expanded before execution, and this fragment would result in infinite expansion.\n\nI think a query with deep (but finite) nesting would be the only way to query a hierarchy like that. You can make that query using conditional fragments like @josephsavona suggested in the [related Relay issue](https://github.com/facebook/relay/issues/246#issuecomment-138050699) and Relay will expand it to a such deeply nested query.\n\nI also think this is rarely a problem for real life UIs, because you wouldn't want to fetch _infinite_ layers of comments anyway, but instead fetch some number of levels first and then have a way for the user to load more comments from a nested tree, like Reddit does.\n >  it's not possible to write a recursive query of unlimited depth\n\nIt's even explicitly _forbidden_ by the spec! \n\n> The graph of fragment spreads must not form any cycles including spreading itself. Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n\nhttp://facebook.github.io/graphql/#sec-Fragment-spreads-must-not-form-cycles\n Closing this issue since I believe it is answered. We explicitly do not allow fragment recursion or the querying of recursive structured since it can result in un-bound results.\n\nTypically you also never really want to require something of infinite depth anyhow, so it's good to put a bound on these things.\n\nA pattern I often see using fragments:\n\n```\n{\n  messages {\n    ...CommentsRecursive\n  }\n}\n\nfragment CommentsRecursive on Message {\n  comments {\n    ...CommentFields\n    comments {\n      ...CommentFields\n      comments {\n        ...CommentFields\n      }\n    }\n  }\n}\n\nfragment CommentFields on Comment {\n  id\n  content\n}\n```\n\nthis lets you define the fields you want at each depth level in one place, and then also explicitly state the \"recursive\" structure you want - in the above example it's 3 levels deep, but you can see how you could easily add more.\n is really there no other option here for fetching nested data, where the depth is unknown? There are plenty of normal situations where data is nested but definitely _not_ infinitely recursive, such as the the comment case. Are we just supposed to tell users that they can't comment past a depth of 3?\n > Without an ability to make this guarantee, allowing for cyclic queries could in fact expose infinite execution queries which could be used as an attack vector.\n\nsure, I understand why it would be a problem, I'm suggesting that being able to tell GraphQL that it has that guarantee would be a great feature. The alternative of copy/pasting a fragment nth times is not the best or even feasible in some cases. \n\nI also appreciate the concern handled by \"show more comments\" but I don't know that that its a good idea for GraphQL to make that choice for our app, in the same way it doesn't require I paginate all lists above a certain length.\n Commenting for any further Bingers/Jeevers:\r\n\r\n```\r\nconst recursiveType = new GraphQLScalarType({\r\n  name: `MyFunAntiGraphQLRecursiveType`,\r\n\r\n  description: `Bails out of GraphQL conventions and just returns the straight JSON Object.`,\r\n\r\n  serialize(_) {\r\n    return _;\r\n  },\r\n});\r\n```\r\n\r\nOf course I'd highly, highly, highly (very highly) recommend not doing as such. But if you need an escape hatch, welcome to LOST **strawman:** would be useful to have the recursion expanded and limited by the query language:\r\n\r\n```\r\n{\r\n  messages {\r\n    ...Comments\r\n  }\r\n}\r\n\r\nfragment Comments on Message {\r\n  id\r\n  content\r\n  comments {\r\n    ...Comments * 3\r\n  }\r\n}\r\n```\r\n\r\nThe `* 3` expands it three levels deep, or some other bikeshedded syntax.\r\n\r\nProbably hard to implemen. If there are multiple recursions or anything else in the spec, who knows. The parser could read the fragment, and the count. Once it has built out the fragment, ignoring the recursion, it could copy and stamp the nodes down the tree. Haven't really looked much into the GraphQL parser to figure out if how it'd be implemented \ud83e\udd14  This may be a silly counter argument but such a syntax would encourage a ridiculous level of recursion :) Currently, I\u2019d have to copy paste a selection 150 times (so I\u2019m bound to think twice about doing it) whereas typing * 150 would be far easier. The current syntax (or lack of one) almost serves as a natural deterrent. If one has need for that level of recursion then batched resolution becomes really important (to work around the N+1 query proliferation problem: see graphql-resolve-batch on github/npm.  As a note to others that may be doing nested recursions, like using the example per @leebyron:  Make sure that each level has a unique ID, including unique against any copy objects that use the same structure. Eg., if you copy an object that is constructed using this, and you don't change each ID, Apollo Client cache can get the sub-elements mixed up (because the typename on all is the same). This is not a bug, of course, but it can be quite perplexing to unravel. I have implemented some graphql alternative parsers a few years ago, and have been pondering recently about this again..\r\n\r\n@leebyron You are probably aware that Datomic Pull Query does supports a syntax for recursive querying, and I do find it useful for some graph/entity domains.. Do you still maintain the position that it's \"dangerous\" enough that GraphQL spec should not really support at all? (not even a N depth limited recursion)\r\n\r\nIt still does not seem like an elegant solution to repeat a query fragment N times.. it's just that in real business applications, a bug introduced by missing data is more likely to occur than security issues  (specially inside VPNs..)\r\n\r\nPerhaps the way to go in GraphQL would be something like `comments(recurse: true) { }`, right? With no special syntax needed... Just commenting here in case there are news about this topic.\r\n\r\nthanks for sharing your thoughts and great work :)\r\n\r\n Just pointing out that there is a [\"scalar\" JsonType](https://github.com/taion/graphql-type-json) available. For dynamic and very app-specific data I found it very useful; you could use it for recursive comments but I wouldn't.  Should this also include directives? Something like:\n\n```\nDirectiveDefinition : directive Name ArgumentsDefinition?\n```\n\nThis doesn't capture scope / validation rules, so perhaps it should include an 'on' clause?\n\n```\nDirectiveDefinition : directive Name ArgumentsDefinition? DirectiveScopes?\nDirectiveScopes : on DirectiveScope+\nDirectiveScope : field | fragment | operation\n```\n\nSo include would be defined like:\n\n```\ndirective include(if: Boolean!) on field, fragment\n```\n Is there any movement on this? This is a pretty compelling piece of the GraphQL puzzle and opens up the possibility of tooling around schema design and also allows the creation of a cross language test suite.\n I ended up implementing most of this grammar in a project I'm working on. Here's the relevant lines from a PEG grammar (just the type parsing stuff):\n\n```\nTypeDefinition <- ObjectTypeDefinition / InterfaceTypeDefinition / UnionTypeDefinition / ScalarTypeDefinition / EnumTypeDefinition / InputObjectTypeDefinition / TypeExtensionDefinition / DirectiveDefinition\nObjectTypeDefinition <- \"type\" _ Name _ ImplementsInterfaces? _ \"{\" __ (FieldDefinition __)* \"}\"\nImplementsInterfaces <- \"implements\" _ (Name _)+\nFieldDefinition <- Name _ ArgumentsDefinition? _ ':' _ InputType\nArgumentsDefinition <- '(' _ ( InputValueDefinition _ )* ')'\nInputValueDefinition <- Name _ ':' _ InputType _ DefaultValue?\nInterfaceTypeDefinition <- \"interface\" _ Name _ '{' __ (FieldDefinition __)+ '}'\nUnionTypeDefinition <- (\"union\" / \"Union\") _ Name _ \"=\" _ UnionMembers\nUnionMembers <- NamedType _ (\"|\" _ NamedType _)*\nScalarTypeDefinition <- \"scalar\" _ Name\nEnumTypeDefinition <- \"enum\" _ Name _ \"{\" __ (EnumValue __)+ __ \"}\"\nInputTypeDefinition <- Name _ ':' _ InputType _ DefaultValue?\nInputObjectTypeDefinition <- \"input\" _ Name _ \"{\" __ (InputTypeDefinition __)+ \"}\"\nDirectiveDefinition <- \"directive\" _ Name _ \"on\" _ (Name _)+ ArgumentsDefinition?\nTypeExtensionDefinition <- \"extend\" _ ObjectTypeDefinition\n```\n\nI _think_ this is basically compatible with the language defined in this PR, with a few additions (directives).\n\nAnswering the questions @leebyron asked:\n- description and deprecation are both expressed via directives\n- not sure what top level schema means - we define a query root object like:\n\n```\ntype QueryRoot{}\n```\n\nthen extend it as needed (I'm assuming that's what you're referencing?)\n\n```\nextend type QueryRoot {\n    __schema : __Schema!\n    __type(name: String!) : __Type\n}\n```\n- It's not clear what validation would be required. We're doing a little to catch compliance with the relay extensions and handle some of our own extensions, but nothing that passes the grammar has brought up anything interesting.\n - Got a concrete example for implementing metadata (`description`, `isDeprecated`, etc) using directives @nuance ?\n- Top level schema I think refers to being able to parse the schema itself which is fairly trivial, just needs to be spec'd fully, but it looks like your example could use existing primitives\n\n``` graphql\nschema {\n  query: QueryType\n  mutation: MutationType\n}\n```\n- You can't mix type defs and queries which is described in the spec already, but presumably not in the execution section yet\n- Schema validation would be somewhat different to query validation, but as you point out if it is parsable then it's probably right, not sure what semantics could be validated? Guidance on orphan/unreferenced types, circular references, for a start\n For reference there are some concrete examples here: https://github.com/matthewmueller/graph.ql\n\nDescriptions are assumed to be in comments immediately preceding the thing it's describing, assuming deprecation etc could be handled in a similar fashion with a specially formatted comment.\n\nAnother possibility for metadata might be type annotations starting with `@`:\n\n``` graphql\n@description Describes a person\ntype Person {\n  @isDeprecated true\n  field: Int\n}\n```\n Thinking more about how this is done with directives, you could make something quite readable:\n\n``` graphql\n@metadata(description: \"Describes a person\")\ntype Person {\n  @metadata(isDeprecated true)\n  field: Int\n}\n```\n Enums are also an issue, since `value`s are not able to be supplied using the current syntax\n Updated to rebase atop recent changes and includes syntax for defining directives based on https://github.com/graphql/graphql-js/pull/318\n Updated to rebase, fixed some outdated language and added `SchemaDefinition`\n @leebyron can you share anything about your thinking on a syntax for descriptions?  Do you expect it to use directives? comments?  Or is it still a ways off?\n @charlieschwabacher Lee has said somewhere that he wants it to be in comment format, because that will be the easiest to read and format. I can't find the issue(s) where he said that any more, but I'm 100% sure about it.\n Yep, I think we should use comments as doc blocks to describe types and fields. It's a little annoying and \"un-pure\" from the parser's point of view since technically comments are \"ignored\" tokens, however it's hard to ignore the better developer ergonomics and it's also quite easy to point to prior art like JavaDoc.\n I'll update this RFC soon to reflect progress made in the experimental implementation in graphql-js. Deprecation is now supported in that implementation via a `@deprecated` directive.\n @helfer @leebyron - I'm happy to hear that, and agree about comments being the most ergonomic.  thanks for the update!\n FYI, as a proof of concept, I already implemented comment-based descriptions in sangria. If you would like to experiment with them, you can check it out here: http://toolbox.sangria-graphql.org/proxy (all `##` comments are treated as descriptions and all changes to the schema definition are reflected in GraphiQL and documentation panel)\n > it's hard to ignore the better developer ergonomics\n\nCan you elaborate on how the developer ergonomics are better?\n\nI'm just a bystander using GraphQL for hobby projects, but I have to admit I'm disappointed to see a future where comments are officially used to embed directives like this. I was hoping for something like `@description`. When you're in a position to update the GraphQL spec itself, why not just use a different syntax and remove all possible ambiguity? Even just a single different leading character instead of `#`?\n\n(I know people widely complain about JSON's lack of comments, given it's now popularly adopted for config files, but I think the reasoning was quite prescient \u2013\u00a0if they were supported, comment directives would have sprung up in every JSON parser and hurt interoperability. Sure, this discussion would effectively make comments-as-descriptions in GraphQL \"official\", but still \u2013\u00a0why not introduce a new syntax, remove ambiguity, and let comments be comments?)\n Just to give another (less frequent but possibly important ?) use case for the type definition language: I'm working on a specification at OASIS that is interested in using GraphQL as part of the transport language, but for that we would need the type language to be specified and relatively stable. So this is a case where we cannot use any programming language specification.\n I've grown accustomed to the comment approach, but it would be nice to also add a way to have non-visible comments. I think the main issue for me is you can't add internal comments like \"# TODO add a limit to this field later\" or similar.\n\nI kind of like the \"##\" idea since it reminds me of \"/**\" in javadoc.\n I would vote for parser friendly solution. It is easy to support description in parser, if it is defined using something like \"%\", \"##\" or \"@\".\n\nIt harder to support description with existing comment format. It takes multiple pass to identify which comment is description. \n I really like the Python-like docstring approach and was thinking of suggesting exactly the same thing :)\n\n> it's easy for those less familiar with the language to misinterpret the strings a important to runtime behavior and become confused.\n\nAren't they indeed important to runtime behavior and thus this isn't a misinterpretation? One of the major reasons I don't like the `#` comment approach is because we don't expect things that look like comments to affect, nor be available at, runtime. But descriptions are available at runtime and are used in the GraphiQL \"Docs\" browser via introspection and such.\n\n(Maybe I'm misunderstanding what you mean by \"runtime behavior\" though.)\n As a concrete example, how can I do this? https://github.com/apollostack/GitHunt-API/blob/01f91419f16c0eaf93ca74e64f270df8d9195f1b/api/sql/schema.js#L54\n\n```\n  # The SQL ID of this entry\n  id: Int!\n  # XXX to be changed\n  vote: Vote!\n}\n```\n\nThis is a real \"comment\" in the sense that it's an internal note in the code.\n\nWould that need to be written with a blank line in between?\n\n```\n  # XXX to be changed\n\n  vote: Vote!\n```\n\nThat kind of seems to ruin the idea of ignoring whitespace.\n I'd vote for letting comments be comments, not descriptions. As mentioned above, docstrings have worked out well in Clojure. It is reasonable for some people to be confused by new syntax the first time they see the syntax. However, using comments as descriptions is confusing, regardless of familiarity with syntax. It conflates developer-targeted documentation with user-targeted documentation. Please don't use comments to provide descriptions. Any alternative (metadata, directives, totally new syntax, etc.) is better.\n Perhaps descriptions could be directives?\n\n``` graphql\nmyField: String! @description(text: \"\n  Get the content of myField!\n\")\n```\n\nAlso, is there any reason not to have `\"` be a multiline string? I don't know if there is value in having separate syntax for single-line and multiline strings, but I could be missing something.\n Now, I may be a little late to the discussion, but I would like to weigh in with my 2 cents on the topic of description syntax.\n\nI would greatly prefer the double-quoted string syntax over any other proposal.\n\nFurthermore, I would make strings multiline by default. That is -- Docstrings would be terminated by a next matching unescaped double quote. Even if the matching quote character is on another line.\n\nEscaping double quote character would be achieved by prefixing it with with a backslash (`\\`). Common escape sequences `\\n`, `\\t`, `\\\\` `\\\"` would be accepted and replaced with appropriate characters.\n\nI would reserve triple quoted strings for verbatim string syntax. This means, anything you write within triple quotes will be taken as a verbatim value (no escape sequences needed). Only thing that terminates a verbatim string is a matching triple quotes pair.\n\nSee how [string literals have been defined in Ceylon language](https://ceylon-lang.org/documentation/1.3/tour/basics/#string_literals) for example.\n\n``` graphql\n\"Long description of what the Foo type is all about\n that spans multiple lines.\"\ntype Foo {\n  \"\"\"\n  Definition of the `bar` attribute. \n\n  I want to have code sample here with embedded HTML snippet,\n  so I should use triple quoted doc string to make my life easier:\n  <script type=\"application/graphql\">\n  query{\n    foo { bar(\"some argument value\") }\n  }\n  </script>\n  \"\"\"\n  bar(\"this is an argument.\" arg: String): String\n}\n```\n @leebyron Whats the status on this? I'm really waiting to get directives to be allowed on any location. Can we maybe split it in the multi-line comments and the allow-directives-on-everything to be merged first? Why do interface fields have to all be the same type? @sbussard This is probably the wrong issue to discuss that, but implementation of interface fields do not have to be the same type, they do however have to be covariant (http://facebook.github.io/graphql/#sec-Object-type-validation) @leebyron I think it should be forbidden to add directives on argument definitions of directives and on type definitions used by directives arguments.\r\nWhen I tried to implement parsing of applied directives from IDL ( the first version of https://github.com/graphql/graphql-js/pull/746) it proved to be very complex. Part of the complexity was caused by the fact that directive argument and also types of those arguments could have directives applied on them. E.g.:\r\n```graphql\r\ndirective @testDirective(\r\n  arg: SomeScalar @testDirective(arg: \"test\")\r\n  #                    ^^^^ here\r\n) on ARGUMENT_DEFINITION | SCALAR\r\nscalar SomeScalar @testDirective(arg: \"test2\")\r\n#                      ^^^^ and here\r\n```\r\nAnd here is circular dependency between two directives:\r\n```graphql\r\ndirective @testA(\r\n  arg: SomeScalar @testB(arg: \"test\")\r\n) on ARGUMENT_DEFINITION\r\ndirective @testB(\r\n  arg: SomeScalar @testA(arg: \"test\")\r\n) on ARGUMENT_DEFINITION\r\n```\r\nWithout such restriction in place, it will be hard to implement full support of directives in tools and libraries. That\u2019s why I think it's important to add it into this release. @IvanGoncharov I'm curious to what that complexity is specifically so we can address it. This is a fairly sensitive balance between simplifying the schema grammar (in which currently, arguments on directives are no different from arguments anywhere else) and being restrictive as to where directives can be placed.\r\n\r\n > This is a fairly sensitive balance between simplifying the schema grammar (in which currently, arguments on directives are no different from arguments anywhere else) and being restrictive as to where directives can be placed.\r\n\r\n@leebyron Instead of forbidding to apply directives on directives argument, the spec can forbid any recursion in directive definition similar to how it's done for the Fragments:\r\n> The graph of fragment spreads must not form any cycles including spreading itself.\r\n--------------------------\r\n>  I'm curious to what that complexity is specifically so we can address it. \r\n\r\nAccording to this PR, a directive on arguments is an:\r\n> indicator that they should be evaluated differently by a validator, executor...\r\n\r\nThat allows directive to change parsing, coercion, and validation of arguments. That means that to build directive object(e.g. `GraphQLDirective`) you need to figure out if the same directive is correctly applied on its own arguments. For example:\r\n\r\n```graphql\r\ndirective @coerceDifferently(\r\n  arg: String @coerceDifferently(arg: \"invalidValueAccordingToChangedCoertion\")\r\n) on ARGUMENT_DEFINITION\r\n```\r\n Are we planning to include some frequently used directives in the spec? For example, `@unique` can be used for Scalar typed field whenever we want to say that the value of the field is unique.\r\n\r\n> Investigate impact on validation rules\r\n\r\nI do not understand what exactly this means. Can anyone explain it a little bit? Just out of curiosity, is EBNF or ABNF notation available? It would make the creation of a parser for other third party libraries easier. @foomip I'm actually very close to finishing a parser implementation like that, within the next week or so I'd say. I don't want to spam this thread but I can post it here if you like? I'll for sure tweet about it when it's done. @foomip maybe this can help you: https://github.com/graphql-java/graphql-java/blob/master/src/main/antlr/Graphql.g4 \r\n\r\nThis is a grammar for graphql including IDL. @foomip or this =) https://github.com/railt/railt/blob/master/src/Railt/Compiler/resources/grammar/sdl.pp (only IDL including some proposes) Thanks @andimarek @SerafimArts will have a look. @gjtorikian would be great to have a look at your implementation, once you are ready :)\r\n\r\nJust to give you guys some background into what trying to do. I am looking at creating a parser that takes a GraphQL SDL file and converts it to an equivalent EDN definition for Clojure's Lacinia GraphQL implementation - https://github.com/walmartlabs/lacinia. Not sure if it is 100% compatible but I think most of the SDL structure should be portable to the equivalent EDN notation. @foomip souns good. But... the current standard is a draft and contain a little flaws. Take it into account. @SerafimArts will do thanks. Gotta start somewhere :) > would be great to have a look at your implementation, once you are ready :)\r\n\r\n@foomip Finally got around to [writing about](https://www.gjtorikian.com/posts/2017/08/15/wrapping-rust-in-ruby-to-parse-gql) and releasing the lib. @foomip Another possibility, using Pegex: https://github.com/graphql-perl/graphql-perl/blob/master/graphql.pgx @leebyron would be great if this PR could be renamed to `[RFC] GraphQL SDL additions` as discussed in the working group meeting. \ud83d\udc4d  Yeah totally agree - lots of documents will include both type info and queries in one, so it would be great to have a well-defined way for them to live side by side. After releasing most recent SDL spec changes in sangria, I got some user feedback:\r\n\r\nhttps://github.com/sangria-graphql/sangria/issues/308\r\n\r\nI would like to make a suggestion regarding these grammar changes:\r\n\r\n```\r\nObjectTypeDefinition : Description? type Name ImplementsInterfaces? Directives[Const]? FieldDefinitions\r\nFieldDefinitions : { FieldDefinition+ }\r\nInterfaceTypeDefinition : Description? interface Name Directives[Const]? FieldDefinitions\r\nEnumTypeDefinition : Description? enum Name Directives[Const]? { EnumValueDefinition+ }\r\nInputObjectTypeDefinition : Description? input Name Directives[Const]? { InputValueDefinition+ }\r\n```\r\n\r\nAt the moment the parser defines that the field list must contain at least one field (or enum value in case of the enum). My suggestion is to implement this restriction as a validation rule and allow field list to be empty at the parsing stage. \r\n\r\nEffectively, this approach yields very similar results, but also provides following advantages:\r\n\r\n* Since the field list verification takes place at the semantic validation stage, it might produce better validation errors with deeper semantic insights\r\n* Validation provides a very robust mechanism for semantic analysis. If the field list of generated based on, let's say, directive information, then more complex validation and overarching workflow can be implemented. Right now the validation is baked into the parser and provides very little flexibility in this regard \r\n* It might provide a smooth migration path for people who are using types with empty field lists right now.\r\n\r\nWould love to hear your thoughts on this :) It's good that you mention this particular use case, I also encountered on a few occasions. I think it often desired when the schema definition is split between different files.\r\n\r\nI think I also would prefer to keep it consistent with other language constructs. I wonder whether we can also skip the curly braces and define the syntax like this (assuming that we will decide to implement it corresponding validation rules):\r\n\r\n```\r\nInputObjectTypeDefinition : Description? input Name Directives[Const]? InputValueDefinitions?\r\nObjectTypeDefinition : Description? type Name ImplementsInterfaces? Directives[Const]? FieldDefinitions?\r\nInterfaceTypeDefinition : Description? interface Name Directives[Const]? FieldDefinitions?\r\nEnumTypeDefinition : Description? enum Name Directives[Const]? EnumValueDefinitions?\r\n\r\nEnumValueDefinitions : { EnumValueDefinition+ }\r\nInputValueDefinitions : { InputValueDefinition+ }\r\nFieldDefinitions : { FieldDefinition+ }\r\n``` Indeed, this is a concern. I think it should not be a big problem if people just need to search and replace the codebase. On the other hand, of SDL is stored in the external DB then it might involve multi-staged migration. @BjRo would be interesting to hear your thoughts on this matter.\r\n\r\n@stubailo It would be also interesting to hear your thoughts on this suggestion. Do you think that proposed parser/validation separation might provide value beyond the ease of migration? @OlegIlyenko @leebyron First of all, thx for discussing this. I like your ideas. It would definitely make things a bit easier to manage and also a bit tidier in our SDL schema. We have both cases (multiple files and empty field definitions).\r\n\r\nRegarding the migration aspects, I think it depends on the setup. For us it's relatively easy to adopt such changes since we have the SDL files, the application code, our project documentation and how-to-guides in a single source code repository. A pull request on our side is able to change all affected portions at once and we can do this more or less manually. A strict behaviour of the parser and the `GraphQL` framework can be handled in this scenario.\r\n\r\nSDL stored in an external DB looks like an entirely different beast to me, since you can't change all portions at once. One way to address this is to have the `GraphQL` server running in a compatibility mode (that allows both formats) and then doing the schema update separately. If I'm not mistaken, this is also what Sangria allows you currently to do (though it needs to be specifically enabled).\r\n\r\nI think the community would benefit from a schema migration tool for such breaking changes, so that the schema updates behave fairly consistent and can be mostly automated. It would be interesting to hear @schickling thoughts on this (given that `Graphcool` has externally stored SDL schemas).  I agree with @acjay, I was under the impression that directives wouldn't be available through introspection? Although I think there's tons of potential for allowing directives to be available through introspection and allowing developers better ways to grow their use of the language in a dynamic way without requiring changes to the spec for every new concept. \r\n\r\nAnyways, in the case that they are available for introspection, I think either the ability to add directives to directive definitions needs to be added back, or there needs to be a visibility concept for directives.\r\n\r\nFor example a `@cost` directive (used for declaring rough cost of a field) likely has the purpose of being passed along to users of the schema, so it should be available through introspection. However a `@cache(maxAge:60000)` directive is likely used more as config into the implementing framework, so it shouldn't be available through introspection, or else implementation details bleed out.\r\n\r\nThis means there's a visibility requirement, and I see two possible solutions.\r\n1. Directives need a visibility concept and the SDL adds a public/private keyword for DirectiveDefinition. Frameworks can then use the visibility to resolve introspection queries.\r\n2. The DirectiveDefinition allows other directives be used on it (which isn't allowed right now) and then frameworks are responsible for looking for something like a `@private` directive filtering things appropriately\r\neg: `directive @private @cache(maxAge: Int) on FIELD_DEFINITION`\r\n\r\nI like 1. better, but in another scenario where I'm stitching schemas automatically through a proxy service, passing on that `@cache` directive could be very useful. Although I wouldn't want it to bleed past the proxy even though I may want other directives to be allowed through, so I'd need a custom directive anyways. Then all of my services have to look for something like a `@private(hops=2)` directive or just pass something like `@namespaced_for_proxy_private` directive through, so eventually the field will be marked private. So if I need a custom directive here and to rely on the frameworks anyways 2. as a general approach may be better. @leebyron why is the spec still dated October 2016 at [http://facebook.github.io/graphql/](http://facebook.github.io/graphql/)?  @ermik Because it's the last official release.\r\nYou can find the draft of the next release (including SDL) here:\r\nhttp://facebook.github.io/graphql/draft/\r\n  I'm not sure if the semicolons were deliberate. But the way I understand semicolons is that they are used to separate complete sentences. Let me know your thoughts on this. Thanks.\n  I'm fairly certain this is not currently possible, and I'm not even sure it is desirable. That said, is there some way to specify an argument variable based on previously fetched data?\n\nFor example, lets assume we have a contentItem type. That contentItem has two fields, `isLive` and `liveData`. `liveData` includes a bunch of information about who set the contentItem to be live and when. We want that information, but only if the contentItem is actually live.\n\n```\nquery content {\n  contentItem {\n    isLive\n    liveData @include(if: $isLive) {\n      liveTime\n      user {\n        username\n      }\n    }\n  }\n}\n```\n\nIf it is not possible, is this a feature worth considering? I see three big downsides. First, it adds some complexity to the resolution of fields. Second, we lose some parallel execution in the query, though not all. Third, there are many use cases for such a variable that are really bad design.\n\nI am going to admit that the original reason I wrote this issue was one of those ~~_mildly_~~ bad design decisions. Fortunately, I realized it was really bad design as I start writing it down. However, the `isLive/liveData` example stuck with me as useful. Granted, right now it would just return `undefined` or `null`, which is probably just as good. Still, something to think about.\n +1\n\nUse case: mutations based on prior payloads.\n\nFor example, say we want to create some content for a user after they register based on preferences they give us:\n\n```\nmutation M {\n   createUser(firstName: 'bob') { id }\n   createPreferences(user_id: #createUser.id, preferences: \"doesn't appreciate purple\") {\n       success\n    }\n}\n```\n\nI don't think there's a way to achieve the above without two requests at the moment. What do you think @leebyron \n > However, the isLive/liveData example stuck with me as useful. Granted, right now it would just return undefined or null, which is probably just as good\n\nYes, that isn't really a concrete example of an actual problem.\n\nI can kind of see where you are going with that though, since you might just need one field, but need a fallback to other fields if it doesn't exist.  For example, if a user hasn't uploaded their photo, you might want to show a stock picture that is derived based on their country, initials, and/or some other field.\n\nIf you are using your own API, the solution there is probably to let the server compute the fallback, which could be requested through another field or argument to specify that you want a fallback image.  That way you can simplify the client code, reduce the response size and provide consistency across client apps.\n\nThe proposed feature might be more useful for a third-party apps which don't have control over the API, although there will probably always be more complex conditions in the client side code that won't be representable in GraphQL to capture the differences in data requirements between those code paths.\n\n@jtmarmon what if you move your mutations on some other object out of the top-level fields on the mutation root.  E.g. normally you could use a `user` field on the mutation root of type UserMutation in order to create preferences as follows:\n\n``` graphql\nmutation M($userId: ID) {\n  user(id: $userId) {\n    createPreferences(preferences: \"doesn't appreciate purple\") {\n      success\n    }\n  }\n}\n```\n\nthen you just need to expose that UserMutation on the payload of the createUser mutation, so the GraphQL for your two mutations might look like\n\n``` graphql\nmutation M {\n  createUser(firstName: 'bob') {\n    user {\n      id\n    }\n    mutation {\n      createPreferences(preferences: \"doesn't appreciate purple\") {\n        success\n      }\n    }\n  }\n}\n```\n\nthat way you are basically using GraphQL in an object oriented way, similar to method chaining in a programming language.\n You can just write one mutation `createUserWithPreferences`. I think we might be opening a can of worms if we add non-pure operations inside GraphQL body, there are questions of, eg, ordering. \n\nAs for original questions, one way to do it would be to create an interface with two implementations. One will include liveData, another will not. Then you could query them as following:\n\n```\nquery content {\n  contentItem {\n    isLive\n    ... onLive {\n      liveData {\n        liveTime\n        user {\n          username\n        }\n      }\n    }\n  }\n}\n```\n > I think we might be opening a can of worms if we add non-pure operations inside GraphQL body, there are questions of, e.g. ordering.\n\nThe ordering is specified as being serial for mutations, including for the sub-selections: http://facebook.github.io/graphql/#sec-Serial-execution\n It's only serial on the top level, subselections are executed in parallel.\n\nThere are many other questions - can you execute mutations only inside other mutations? What is the type of mutations? Do mutation payloads need to include what mutations are going to be possible inside them? Also what is going to be the result of the above query?\n Oh, I see.  It is using \"normally\" to mean unordered.  The previous section explains that clearer and also says that non-top level mutation fields must be side-effect free.\n\nSo yes, it does look like a `createUserWithPreferences` would be needed to do that right now, but that might be heading towards designing the schema for a specific client, which GraphQL allows us to avoid in most cases.\n\nIf we wanted to support that type of non-top level mutation, then we would want to distinguish between a mutation object type and a query object type to specify that selections in a mutation object type are executed serially.\n You could create a mutation that knows how to handle any kind of related object, but I realize that it's a lot of work.\n We at taobao have implemented it in this way and it works great.\n  We need a way to listen to changes performed by someone else than the local client in order to build true real-time apps based on GraphQL. Similar to how Firebase and Meteor work.\n\nI know this is being discussed on Slack but a proper ticket is missing.\n I made a small write-up about my thought on a GraphQL subscription mechanism:\n\nhttps://gist.github.com/OlegIlyenko/a5a9ab1b000ba0b5b1ad\n\nAny comments and thoughts on this idea are appreciated :)\n +1\n Closing this aging issue since Subscriptions are captured in spec  Should input objects return a keyed set when introspecting for `inputFields` the way object do for `fields`?\n\nCurrently, the spec on introspection says that input objects have an `inputFields` query that returns a list. Object, on the other hand, have a `fields` query that returns a keyed set. Both input objects and objects take maps, even if the keys are just 0, 1, 2, 3. Is there a reason that introspection does not return a keyed set of fields for input objects? In a similar vein, why not just have the introspection query be 'fields' for both?\n Apologies, I think I was confused. No, I was definitely confused. There is not a lot of literature on mutations in GraphQL, and therefore not a lot of literature on really big blobs of data in Input Objects. I was trying to tease out the implementation of GraphQL-JS vs the actual spec and Object vs Input Object. \n\nI went back and ran the introspections again now that I have significantly more experience with Input Object, I think perhaps I was leaving out the name field, which made the two seem different. Also, defining `fields` on the GraphQL-JS GraphQLInputObject, but introspecting on `inputFields` was causing some confusion (I created a separate ticket for that issue on that project (graphql/graphql-js#144).\n\nSorry for wasting your time on this.\n  in section 5 ### Field Selections on Objects, Interfaces, and Unions Types,\n\" Because fields are not declared on unions, direct field selection on union-typed selection set. This is true even if concrete implementors of the union define the fieldName.\"\nwhat does \"direct field selection on union-typed selection set.\" mean?\n @leebyron  .why the following is invalid.it is indirectly queried through a fragment ,the union concrete implementors  instead of the union itself.\uff08your original words are Fields from a union-typed selection set must only be queried indirectly via\na fragment\uff09\n\n``` !graphql\nfragment directFieldSelectionOnUnion on CatOrDog {\n   name\n   barkVolume\n }\n```\n  This looks good to me!\n :+1: this will definitely simplify the transition from REST to GraphQL for mutations, otherwise, a boolean field would need to be provided to distinguish between setting a field to be `null` and not changing the field.\n :+1: \nSeems like it has been some time. Is this still on roadmap? \n I created a fork a short while ago that allows for this. I've not merged in the most recent commits yet but it's working in production.\n\nhttps://www.npmjs.com/package/graphql-nullable\n :+1: Looks like this PR was open for quite a while now. Just wanted to give my option on this change.\n\nI'm coming from scala background. I don't see an addition of `null` as a problem. It opens up quite a few interesting possibilities. In general statically-typed languages still make it possible to distinguish between `undefined` (property is not defined on object) and `null` (for example all scala JSON libraries have `JNull` or `JsNull` AST nodes). I tried to implement this proposal in the [sangria](https://github.com/sangria-graphql/sangria) and it looks good so far. If one does not care about distinction between `null` and `undefined` then they can be just treated the same (it happens pretty often). But on the other hand, if you need to distinguish between them, then this addition is very helpful.\n\n> Note: there is a potential semantic difference between the input value\n> explicitly declaring an input field's value as the value `null` vs having not\n> declared the input field at all. GraphQL services may optionally interpret these\n> two cases differently if it is advantageous.\n\nI like this part and would keep it like this. So that it's up to the server implementation to decide whether to treat them differently or not. This would also mean that standard protocols (like introspection API or relay connection) can't relay on this mechanism, if I understand it correctly.\n Any reason why this RFC is restricted to mutations? Could it be applied to explicit input field arguments? E.g. a query being interpreted to a SQL clause `where table.field is NULL`.\n It doesn't look like this RFC is specific to mutations.  Mutations are just the prominent example.  The only change to the spec that mentions mutations is this added line:\n\n> For example, to represent deleting a field vs not altering a field during a mutation, respectively.\n LGTM :+1: \n\nComing from a ruby background not being able to send `null` to set an attribute to a `nil` value is certainly surprising.\n I'd be very happy to see this change land. We have a number of places where our GraphQL layer bridges to REST services that have special handling for explicit nulls in e.g. `PATCH` operations, and it would be much easier to bridge to those services if we have the option of using a `null` literal.\n We often have NULLs in our database represent default values (i.e. a localizer with a NULL locale is the default translation). We've had to hack around this, but would be great for GraphQL to support natively.\n Not to be a bother, but what's the status on this?  Are there still open questions?\n There are still open questions on how to resolve \"nullability\" with \"optionality\" once a value can be explicitly provided and be the value `null`. That also has implications on whether the value `null` should be replaced with a default value or not.\n\nThis is still open, but it's been lower priority relative to some of the other proposals we've been working the kinks out of.\n Thanks for the quick response @leebyron, that's good to hear.\n\nDefault values mean well, but my current practical problem, unless I'm doing it wrong, is that database updates happen based on changesets, and so right now it's impossible to know whether the client wanted a field nulled or simply left unchanged. (I'm probably beating one rotten carcass of a horse here, but since this is marked RFC I wanted to throw another vote in the hat for bona fide nulls.)\n BTW, I think in most other contexts that I've seen, \"value is required\" (may not be `undefined`) and \"`null` is permitted\" are treated as orthogonal concepts.\n\nOne place this comes up the most strongly is for e.g. a `PATCH` update (for a partial update of an object). In such a case, certain non-nullable fields may still not be required (i.e. to have their values not be changed).\n Yeah, to be clear here the question isn't \"is it a good idea to introduce a `null` value\" the question is \"is it worth the additional introduced complexity\"\n\nSplitting the concepts of optionality and nullability actually adds a lot of cascading changes to GraphQL, so while in isolation it's perfectly easy to make a case for why having them separate is fine, what we actually want to be doing here is striving to maintain GraphQL's simplicity whenever possible.\n\nThe costs of maintaining simplicity is that there are often corner-cases where GraphQL feels awkward, but the value is that the primary cases feel simple. I understand that may feel like a slight - it certainly doesn't feel like a corner-case when you're the one experiencing it, but it is the reality that most mutations in GraphQL use the action pattern rather than the CRUD pattern, so \"setting a field to null\" is actually a case we haven't had to deal with in production yet.\n\nAnd also to be clear, I do think having a `null` literal is a good idea - I do want to make enabling CRUD style operations more reasonable, I would just like to do so with as little collateral damage to simplicity as possible.\n That was thoughtfully written. Thanks. :)\n\nNot sure if it's been discussed elsewhere \u2013 could you sidestep those issues if you defined some `Relay.NULL` constant for us to use, instead of messing with the JS `null` literal?\n I don't think `Relay.NULL` can be the answer, since input types can't be union types.\n\nThe CRUD stuff just comes up when migrating existing systems to GraphQL, I guess.\n Ah, forgot about that. Never mind then.\n I might be the first person to say that I'd like to see more work on this RFC before it is part of the spec.  Don't get me wrong, I do want to see implicit / explicit nulls.\n\n2 things:\n\nIt is my opinion that there ought not to be multiple interpretations of what happens for implicit or explicit null, depending on which GraphQL service is being used.  But that's what 2 different sections say: \n\n> A GraphQL service may interpret the two forms differently, if it is advantageous.\n> \n> ---\n> \n> Note: there is a potential semantic difference between the input value explicitly declaring an input field's value as the value `null` vs having not declared the input field at all. GraphQL services may optionally interpret these two cases differently if it is advantageous.\n\nIn practical terms, there's a high chance of my company going from graphql-java to graphql-go, and I don't want to get bitten.  It's pretty easy to let seemingly minor things make major impact down the line, like changing the \"ordering\" of a contractually unordered collection (I refer to [Java 8 HashMaps](https://examples.javacodegeeks.com/core-java/util/hashmap/hashmap-changes-in-java-8) and the 75% of PRD issues attributable to this, even though I love how Java 8 HashMap is now).\nIn theoretical terms, the first comment says there are 3 distinct semantical interpretations of variables in a query, so why should the semantics of the GraphQL service be a black box to the querier?\n\nBesides that, I'd also like some more clarity on null + lists.\nConsider this, with the value after coercion being left as an exercise for the reader.\n\n| Spec | imp/exp Null | Input Type | Coerced Value |\n| --- | --- | --- | --- |\n| Current | N/A | String | null |\n| Current | N/A | [String] | ? |\n| Current | N/A | [String!] | ? |\n| Current | N/A | [[[[String]]]] | ? |\n| Proposed | Implicit | String | null |\n| Proposed | Implicit | [String] | ? |\n| Proposed | Implicit | [String!] | ? |\n| Proposed | Implicit | [[[[String]]]] | ? |\n| Proposed | Explicit | String | null |\n| Proposed | Explicit | [String] | ? |\n| Proposed | Explicit | [String!] | ? |\n| Proposed | Explicit | [[[[String]]]] | ? |\n\nTake the case of [[String] from graphql-java](https://github.com/graphql-java/graphql-java/issues/74).\nAn implicit null was input to [String], yielding the (unexpected) value of a list object with 1 null element.\nSo in the case of `null` input coercion, we might do something different for implicit or explicit.\nMy first thoughts are to word things in such as way that explicit nulls are always coerced into the input [thus potentially yielding list of (list of (null))], while implicit nulls are never coerced but substituted directly for the `null` value [thus yielding null with the chance of NPE].\n\nLast and least, typo on spec/Section 3 -- Type System.md line 117, it has 2 \"then\"s\n Is there any update on this branch? Our CRUD API is a bit inconvenient, because you can't set values to null without using 'replace'. I am considering adding some other way of nullifying fields, but if null literal is about to land, I'd rather wait for it to happen.\n\nI can help landing this in graphql-js, if some work there is needed.\n If I may put my two cents in, based on the SQL design we have to distinguish creation mutation from update mutation. \n1. On `INSERT` when you don't specify a column value it's considered as `NULL`.\n2. On `UPDATE` when you don't specify a column value it's considered unchanged and you have to explicitly set the column to `NULL` if you want to reset the corresponding value.\n\nIMO GraphQL have to keep this policy. Indeed when an update action is done on a table row, user isn't always aware of the whole table schema despite of introspection and therefor should be able to omit column. \n\nThere are two ways to reset a column in that situation:\n- Allow the use of `null` or any dedicated keyword in the request as a column value: \n\n```\nmutation { \n  editThing(foo : \"stuff\", bar : null) { ... }\n}\n```\n- Explicitly define a keyword attribute to reset columns:\n\n```\nmutation { \n  editThing(change : { foo : \"stuff\" }, reset : { bar }) { ... }\n}\n```\n\nFirst solution seems more standard and is pretty straightforward to every readers. \nSecond is also a valuable design but can lead to a lot of different implementation. If preferred it may be a good thing to define common keywords in the spec and stick to it to keep code understandable to everyone at first sight.\n\nSecond solution is for now the only one to really work in production, but I personally find that the code written is more complex to maintain compared to the first one cause it requires a special formatting in the front and back-end.\n I certainly understand the argument around complexity that missing vs. specified null semantics introduces. I think a counter-argument could also be made that enabling the CRUD model and being able to push `null` values is simpler for some scenarios since it presents a more direct migration path from REST-style web services.\n\nWe've actually added support to our own GraphQL library for a `null` literal since supplying separate mutations for clearing values was not a good option in our case.\n I'd like to add to @danielkwinsor table more kind of types: `[[Int]!]`, `[[Int!]]` etc.\nHow should input coercion work in this cases?\n`[[Int]!]` can be `null`or `[[null]]`.\n`[[Int!]]` can be `null`, `[null]` or invalid.\n`[[[Int!]]]` can be `null`, `[null]`, `[[null]]` or invalid.\n`[[[Int]]!]` can be `null`, `[[null]]` or `[[[null]]]`.\n\nIMO it's very surprising that explicit `null` will be proper \"no list\", but implicit \"no value\" will be list(s) of single `null`, or even invalid input.\nSo I think it's a bad idea to coerce both explicit and implicit null to list. Same goes with nested nulls: `[null]` won't silently coerce to `[[null]]`, for `[[Int]]` it will stay `[null]`, and for `[[Int]!]` it will get rejected as invalid value.\n Thanks for the discussion! I'm still interested in furthering this and really happy to have some additional concerns tossed in - that will help define clear behavior in the spec.\n\nI think the next step is prototyping this so the coercion rules can be toyed with until we have something that is both easy to explain (and predict) but are also valuable to solve the problems at hand\n Per @danielkwinsor's comment, I do think it'd be good to eliminate the odd behavior that lists have when `null` is the input value (even though this is probably tangential).\n\nCurrently, [per the spec](http://facebook.github.io/graphql/#sec-Lists):\n\n> If the value passed as an input to a list type is not as list, it should be coerced as though the input was a list of size one, where the value passed is the only item in the list. This is to allow inputs that accept a \u201cvar args\u201d to declare their input type as a list; if only one argument is passed (a common case), the client can just pass that value rather than constructing the list.\n\nSo if the input type is `[String!]`, and the provided value is `null`, it seems that this would require that input to be interpreted as `[null]`, and then subsequently reject it. I think this behavior would surprise most people, and in fact I don't even think most implementations behave like this. As a side-effect, it also means that `[String!]` is not really distinct from `[String!]!`.\n\nPerhaps we could add to the spec some language like this:\n\n> If the value passed as an input to a list type is not a list **and is not `null`**, it should be coerced as though the input was a list of size one...\n\nThat way, if you really did want a list that has a single `null` value inside it, you have to be explicit. In the far more likely case that you just wanted to ignore that argument/input field, you wouldn't get the curious `[null]` value instead.\n `null` as explicitly passed is not ambiguous. Coercion is. So if list may be coerced from single value,I expect error instead. \nWe are solving there same problem that been solved in SQL... \nRequired list of required value is clear error for null\nRequired list should be coerced to empty list. Backend then handle it as desired..\nNot required list should be treated as null.\n Is the change in https://github.com/facebook/graphql/commit/98187c86963708b524380ffe6f0fd22959c26faa (i.e.   clarifying the spec re: the non-nullable input list) just a proposal? Can we expect to see this in `graphql-js` any time soon?\n\n> [String!] is not really distinct from [String!]!\n\nThis is the problem I'm hitting. I would like to have lists as optional input arguments (`[String!]`), but now clients must provide an empty list, or I must remove the non-null requirement on the Strings themselves.\n [String!] should be coerced to null,\n[String!]! should be coerced to empty list\n Party today, null is in :)\n\nOn Wed, Oct 26, 2016, 09:40 Lee Byron notifications@github.com wrote:\n\n> Just got a careful review from @dschafer https://github.com/dschafer\n> offline - so merging this now.\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> https://github.com/facebook/graphql/pull/83#issuecomment-256407085, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AAKjiN7CpvY38QhBukOMUHXsxbmnSTuDks5q34KTgaJpZM4FuxB0\n> .\n Work in progress in https://github.com/graphql/graphql-js/pull/544\n  Thank you for this great work! The idea is awesome and README.md itself was interesting to me.\n\nIs there any plan to write additional documentation for mutation on README.md?\n Any progress on this? The spec makes hardly any mention of mutations - there's not even a section for it, it's only mentioned in passing a few times. I can't seem to find much information about mutations beyond very basic examples on the web either.\n  in section4.md ,\n\n```\nTake an example query for a trivial app. In this case there is a User type with\nthree fields: id, user, and birthday.\n```\n\nuser should be  name\n\n```\nTake an example query for a trivial app. In this case there is a User type with\nthree fields: id, name, and birthday.\n```\n @leebyron  sir  is there a skype channel or slack  we can discuss some confusing in current  spec?\n  \ud83c\udfac take 1 for Atom https://atom.io/packages/language-graphql\n\nsyntax only, looking forward to trying autocomplete :)\n Since I guess lots of people are using GraphGL for Android projects, is it a good idea to make an IntelliJ plugin?\n On my way\n I finished a basic version:\nhttps://github.com/Gregoor/graphql-intellij-plugin\n\n@leebyron: Is it possible that the spec is a bit incomplete in respect to type definitions starting with 'input'? But the grammar at the end was extremly helpful, thanks for that!\n Looks like @devknoll is on it. \nhttps://twitter.com/devknoll/status/666469020976066560\nhttps://twitter.com/devknoll/status/666476905739108352 \n\n![image](https://cloud.githubusercontent.com/assets/95672/11349068/3bb1e304-91f8-11e5-88cc-d2278d02c6b0.png)\n I've created a GraphQL plugin for IntelliJ IDEA and WebStorm that relies on the JavaScript reference implementation. It provides roughly the same features as Graph_i_QL, including schema-aware completion, error highlighting, and in-editor schema documentation:\n\nhttps://github.com/jimkyndemeyer/js-graphql-intellij-plugin\n\nThe integration between the Java-based plugin and the reference implementation JavaScript parser is available as a Node.js based language service:\n\nhttps://github.com/jimkyndemeyer/js-graphql-language-service\n\nIt might prove useful for enabling GraphQL language features in other IDEs, much like the TypeScript language service did for Sublime and Atom.\n Awesome, that looks way better than what I did :) I'll try it, as soon as it is approved. Any idea how I can help the ~100 downloaders of my plugin migrate to your plugin?\n\nEdit: I think I'll just put up a notification.\n @Gregoor A notification should do the trick :) How long did it take to get your plugin approved?\n\nIn case you want early access to the plugin, it can be downloaded from https://dl.dropboxusercontent.com/u/12996502/js-graphql-intellij-plugin/1.0.0/js-graphql-intellij-plugin.jar\n\nJust add it using \"Install plugin from disk...\"\n I think the approval process is bound to their 9-5 work cycle (in the czech republic). At least that's the feeling I got.\n\nThanks for the direct link.\n I started on a Vim plugin: https://github.com/jparise/vim-graphql\n\nIt still needs work but handles file detection, syntax highlighting, and folding pretty well so far.\n Can some one make a graphql package for lovely sublime text? :smile: \n @abdulhannanali I just released a GraphQL package for Sublime Text.\nhttps://packagecontrol.io/packages/GraphQL\n\nRight now is just a syntax highlighter, but we plan to add autocompletion and almost all the capabilities we have with GraphiQL.\nSource code: https://github.com/graphql-python/GraphQL-SublimeText\n Autocomplete and lint from a GraphQL endpoint in atom.\r\n\r\nhttps://github.com/nicolaslopezj/atom-graphql-autocomplete\r\n\r\n<img width=\"649\" alt=\"example\" src=\"https://cloud.githubusercontent.com/assets/2042567/20637990/4c0f0320-b377-11e6-973a-d6cdd0220a29.png\">\r\n @nicolaslopezj That's great news. Would you consider using https://github.com/graphcool/graphql-config#method-2-configuration-via-graphqlrc-file to configure the endpoint? Yes I will! @nicolaslopezj - that looks cool :D I've been working to provide a language service interface for GraphQL that could be used across common IDEs. It'll also support firing up the GraphQL server to cache schema/fragment definitions/etc to be used for validation/autocomplete suggestions. The interface has methods to bring other common IDE features, such as hyperlink/outline views/and etc.\r\n\r\nIt's been developed and tested with Nuclide, but I thought this could be useful for Atom users as well - it'd be awesome if we can collaborate on making that happen! For @abdulhannanali and anyone else sad about the Sublime Text highlighter not working, I just released one that does. https://packagecontrol.io/packages/GraphQL @dncrews Thanks a  lot @dncrews will surely help people using Sublime but I have long moved to [Visual Studio Code](https://code.visualstudio.com/) :heart:  Derailing this thread a bit because these are not IDEs but since we're talking syntax highlighting, some highlighting libraries as of 21 March 2017:\r\n\r\n- [Prism](http://prismjs.com/) (JS) **does** [support GraphQL](https://github.com/PrismJS/prism/pull/971)\r\n- [Highlight.js](https://highlightjs.org/) (JS) **does not** [support GraphQL](https://github.com/isagalaev/highlight.js/issues/1471)\r\n- [Linguist](https://github.com/github/linguist) (Ruby) **does** [support GraphQL](https://github.com/github/linguist/pull/2947)\r\n- [Pygments](http://pygments.org/) (Python) **does not** [support GraphQL](http://pygments.org/languages/#supported-languages) (but one might look into [this](https://gist.github.com/mrtnzlml/7e3fe17f52592d88ecc2ca0c9da1097b))\r\n\r\nLet me know if you are aware of other ones. A port of @jimkyndemeyer's GraphQL plugin for IntelliJ IDEA to work with Python  files in the JetBrains IDE would be amazing as well.\r\nCurrently, the Python client toolset is very lacking, and that is a pain that will interfere with GraphQL's growth.\r\n Could be awesome to see a plugin for PHPStorm ! @jimkyndemeyer Awesome work! Your plugin changed my life in Javascript. Wondering though, do you think it would be hard work to make it also autocomplete queries in PHP Heredoc ?\r\n\r\nExample:\r\n\r\n```php\r\nprivate function getQuery()\r\n{\r\n\r\n    $query = <<<'GQL'\r\nquery ProgrammesForHome($region: String, $travelStart: DateTime, $page: Int, $limit: Int) {\r\n  programmes(region: $region, page: $page, limit: $limit) {\r\n    total\r\n    page\r\n    limit\r\n    edges {\r\n      node {\r\n        id\r\n        name\r\n        catchPhrase\r\n        price {\r\n          amount\r\n          currency {\r\n            code\r\n          }\r\n        }\r\n        offers {\r\n          id\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nGQL;\r\n\r\n    return $query;\r\n}\r\n```  Looks good.\n   Ok, got it. :dog: \n    In my experience `long` is pretty common primitive data type. It also used to represent pretty common things like timestamps or cent amounts. As a result of it, most of modern programming languages naively support 64-bit integer values in one form or another. Is there particular reason why `long` scalar type was not included in the spec?\n Thanks a lot for the reply. I would agree with your suggestion to model it with custom/separate type. I would prefer to strictly define the capabilities of datatype, since it establishes a protocol between client and server, and they both need to know, whether number is bounded or unbounded and what is the maximum size. For that reason I created built-in/custom scalars for `Int` (32-bits), Long (64-bits), BigInt (unbounded), Float (64-bits) and BigDecimal (unbounded) in scala implementation.\n\n> The GraphQL spec does not specify a maximum byte width or storage size for its Int and Float type\n\nThis surprises me, because as far as I understood from the spec, `Int` GraphQL scalar type is 32-bit integer value:\n\n> The Int scalar type represents a signed 32\u2010bit numeric non\u2010fractional values. Response formats that support a 32\u2010bit integer or a number type should use that type to represent this scalar.\n\nhttps://facebook.github.io/graphql/#sec-Int\n\nThe same is for the float:\n\n> The Float scalar type represents signed double\u2010precision fractional values as specified by IEEE 754. \n\nWhich means 64-bits (according to the standard: https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n\nDid I misunderstood the spec?\n Since spec explicitly states that:\n\n> If the integer input value represents a value less than -231 or greater than or equal to 231, a query error should be raised.\n\nDoes this mean that reference implementation does not conform to this part of the spec?\n @leebyron The spec doesn't limit the size of int tokens:\nhttp://facebook.github.io/graphql/#sec-Int-Value\n\nThe reference impl also doesn't check the size, so it is possible to create a custom long scalar which allows the usage of int tokens (literals) as input. See https://github.com/andimarek/graphql-java/pull/94#issuecomment-190008636.\n\nIs this intended or just a gap in the spec and the size of the int token should be limited?\n\nThanks!\n Thanks for the quick response. \n  After creating [scala GraphQL implementation](http://sangria-graphql.org) I must admit, that the test quality and coverage of [nodejs reference implemention](https://github.com/graphql/graphql-js) is very good. In fact it helped me a lot during the development (as well as the reference implementation itself, of course). After re-implementing most of the tests in scala I now pretty confident, that most of the functionality is tested. \n\nAfter seeing all these tests it become apparent to me, that there are a lot of edge cases and things that GraphQL library can get wrong, especially in terms of semantics, validation, execution, error handling, etc.. People are already created implementations in [many different languages](https://github.com/chentsulin/awesome-graphql). I feel that it is important to create a TCK (Technology Compatibility Kit) for GraphQL specification in order to ensure success of GraphQL itself, higher adoption and growth of the ecosystem. Having implemented other specifications in the past, I must admit that a TCK makes specification implementation much easier and faster process. It also helps to adopt an implementation as specification evolves. \n\nWith TCK I mean a set of acceptance tests, that are distributed in some form (as a library, for instance) and can be used by library authors to verify, that their implementation confirms to the spec. Of course, TCK can't cover all of the cases, but at least it gives a good baseline and as ecosystem grows, it ensures that all parts of it remain compatible with each other or at least minimizes risk of incompatibility.\n\nAt the react-europe conference I had a short conversation with @schrockn about this topic. He said, that there are plans for something like this, so I wanted to follow-up here and ask for more information. Do you still have plans to create something like a TCK for GraphQL spec? If yes, do you already have an idea which form it will take? I guess implementing something like this can be a challenging task, considering that it suppose to test implementations written in different languages. As far as I saw, tests in the reference implementation are pretty generic - many of them take some query, execute it and then verify resulting JS object. At the moment they all implemented in terms of the nodejs implementation, but maybe they can be reused or extracted in the TCK somehow?\n Thanks for the reply! Glad to hear that you already thought about it. The approach you described sounds good to me. I was also thinking about something like this. \n\nAbout the schema, reference implementation now has a schema materialiser, which also can be implemented in other languages. Resulting schema does not contain the resolve method, but even in this form it can be used for many tests that do not require execution, like query validation and parsing or introspection. As far as I saw, even execution tests have very similar `resolve` implementations, which are in most cases fall in one of these categories: \n- successful resolve with `null`\n- successful resolve with not-null value\n- successful resolve of promise with `null`\n- successful resolve of promise with not-null value\n- exception is thrown\n- promise was resolved with failure\n\nMaybe we can create an enum of possible implementation behaviours and then enhance textual schema representation to include this information in some form. This will allow schema materialiser to create simple implementations of resolve method. This means that a test schema can be completely generated from textual description, just like test cases. What do you think about this idea?\n We started to work on compatibility acceptance tests here:\n\nhttps://github.com/graphql-cats/graphql-cats\n\nIf you are working on a GraphQL implementation, it would be great if you could share your opinion and join us.\n  Hello, everybody there! At first, I want to say thanks to you guys, who invent this small, but powerful query language.\n\nBut the main article of this issue, that the license that apply to this specification is not fit this kind of things, I think, that `BSD-3-Clause` license better to apply to the source code, but the specification should be licensed with Creative Common License.\n\n[Creative Common License Attribution 4.0 Internation](https://creativecommons.org/licenses/by/4.0/), I think, is better.\n\nThanks!\n Closing this: after discussing with folks in the know, they decided it was best to continue to use a software license for this (even though it's a little bit weird).\n  This is a totally stylistic, bikeshedding comment...  but maybe worth considering if I'm not missing something obvious.\n\nIt seems like both the informal schema format and query variables could be simplified by eliminating the colon from type definitions and dollar sign from variables. Right now the colon is used in so many different contexts (variables, types, interfaces, aliases).  The similarity between type definitions and passing arguments in particular is mildly confusing.\n\nWhy not change :\n\n```\ntype Person : NamedEntity {\n  name: String\n  gravatar(height: Int, width: Int): Gravatar\n}\n```\n\nto \n\n```\ntype Person : NamedEntity {\n  name String\n  gravatar(height Int, width Int) Gravatar\n}\n```\n\nThe same with queries.  Why not change:\n\n```\nquery myQuery($someTest: Boolean, $size: Boolean) {\n  gravatar(size: $size)\n  experimentalField @include(if: $someTest)\n}\n```\n\nto \n\n```\nquery myQuery($someTest Boolean, $size Boolean) {\n  gravatar(size: $size)\n  experimentalField @include(if: $someTest)\n}\n```\n\nso that outer type definitions and inner arguments don't look so similar.\n\nFinally, is the dollar sign really required?  Why not just:\n\n```\nquery myQuery(someTest Boolean, size Boolean) {\n  gravatar(size: size)\n  experimentalField @include(if: someTest)\n}\n```\n Makes sense, thanks.\n  :+1: \n  I can understand why making types nullable by default might be a reasonable decision for growing systems adding new features but I think there are reasons why this might not be ideal:\n\n1) This conflates the idea of nullability with providing reasonable default values. By allowing new features to be nullable by default, we push more responsibility to the application logic for determining what might be the right behavior.\n\n2) Because making types nullable is so easy in practice, it promotes not considering if data should even be nullable or not. This could escalate the system's entropy more quickly making it hard to reason about the system's intended behaviour.\n\nI'd love to hear other thoughts or ideas on this!\n Just wanted to add my 2 cents. This topic also concerned me quite a bit , so I glad that @matthewcheok started this discussion. \n\nI definitely can see the advantages of nullable as a default. Backwards-compatibility and error-handling are good and valid arguments in favor of it. Still I feel that in many cases not-null default can be advantageous. In addition to @matthewcheok arguments (which I agree with), I also would like to point out these two aspects of it:\n1. In many programming languages this concept is implemented as not-null by default. I'm coming from scala background where nullable values are represented with `Option` type which serves as a container for nullable value. But scala is not the only example of it, languages like kotlin, groovy, c#, haskell, java, etc. all share the same approach to this issue. Even the flow type checker, which is heavily used in graphql-js itself, also takes this approach. I feel that nullable as a default can potentially confuse developers working with these languages (which on itself can case frustration or even hard-to-find bugs because of this mismatch)\n2. As a consequence of the first point, I noticed, that it can be pretty challenging to implement this concept in statically-typed languages, which natively support \"maybe\" types like scala. I currently working on scala implementation of graphql. First I tried to implement not-null type for schema definition DSL, but at some point I gave up on this idea and decided to introduce [OptionType](https://github.com/OlegIlyenko/sangria/blob/d65cde5d031c3733509b54cd12c3984f265ad548/src/main/scala/sangria/schema/GraphQLSchema.scala#L187) which replaces `NotNullType` in schema DSL (it still work in progress, so things can change dramatically in future, but this what current state of implementation is). Of course it still will produce correct introspection results (with nullable default and not-null type, according to the spec) \n In addition to @dschafer's points, another fairly significant reason we chose to default to nullable values is the relative cost of changing from one to the other once you have deployed a schema and have shipped clients which are consuming that schema.\n\nConsider the case that non-null is the default, and you set up a schema for a comment discussion feature:\n\n```\ntype Comment {\n  author: User \n  message: String\n}\n```\n\nThen, you build Android and iOS apps, and launch them. A week later, you get bug reports that comments is not working for some users. You dig in and realize that if a user deleted their account, the comments they left behind are still there but there is no longer an `author` to load, so your servers are returning an error and as a consequence entire comments views don't load if they include a comment from a deleted user.\n\nLet's fix this by changing the schema so `author` can return null.\n\n```\ntype Comment {\n  author: User?\n  message: String\n}\n```\n\nThis gets deployed and you check back in with your users who are reporting this issue. They should see comments now, just without the author, right? Nope. Your users are now reporting that when they load a comment view, their app crashes. What? Null-pointer exception. You were indexing directly into that `comment.author.picture.url` in your app code, and at the time, `author` was non-nullable so that was safe. The server change you made was a breaking change. Yikes!\n\nIf the default had been nullable, then your original schema as defined would have Just Worked\u2122. \n\nFor clients that understand nullability (Swift, recent Java and ObjC to a degree), they will warn you about accessing values without first checking for null. If you're checking null for something that you think should never be null, then you can have that conversation and go alter the schema. Perhaps you decide that there's _always_ a message, an empty string can always suffice, so you change the schema to improve developer ergonomics on the client:\n\n```\ntype Comment {\n  author: User\n  message: String!\n}\n```\n\nNow we've ended up at the same result, but via the incremental application of _becoming more specific_ rather than the late realization that you were _too specific from the start_ and had to add breaking changes to correct. In fact, this change is totally safe. Any client that was previously checking for null will continue to work just fine.\n\nThis tale is slightly contrived, but we've suffered through versions of it at Facebook and it's a big part of why the default is nullable. As @dschafer pointed out, the probability that _something_ will go wrong in the backend is more than 0 when loading data from storage, which is what GraphQL is designed to help you do.\n\nIn practice (perhaps unfortunately), most people do not think about nullability when designing their type systems. It's why most languages with strong types have no concept of non-null vs nullable with the obvious exception of those inspired by functional programming. And of course nearly all dynamically typed languages have no concept of this either. If most people do not think about nullability, we wanted to define the one that required less typing to be the safer of the two options, and let the incremental application of knowledge to allow for improvements from that position.\n > In many programming languages this concept is implemented as not-null by default. ... I feel that nullable as a default can potentially confuse developers working with these languages\n\nMany, but not the majority. I would contend that a non-null default would cause more confusion from programmers of more mainstream imperative languages and not used to thinking about this concept at all than a nullable default would cause confusion from those who use languages where they must think about nullability when defining types all the type because they have access to Option/Either/Maybe/?.\n\n> As a consequence of the first point, I noticed, that it can be pretty challenging to implement this concept in statically-typed languages, which natively support \"maybe\" types like Scala. ... and decided to introduce OptionType which replaces NotNullType in schema DSL ... Of course it still will produce correct introspection results\n\nI strongly support this approach. Ultimately, the default for nullability is a moot-point when you have good GraphQL core libraries which respect the ergonomics of the particular language or environment. For strong typed languages that replace the concept of null with Maybe/Option/Either, I would expect to use a GraphQL library in exactly the way you define.\n  :+1: \n  For example http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html\n  One-place inconsistency. :rotating_light: \n  Thanks for your work so far! Looking forward to the final spec.\n  Most likely a copy/paste error from possibleTypes in Union right above.\n  I think this example is valid because `nickname` is defined in `Pet` interface too. So I changed it to `barkVolume` which is the field of a concrete implementor `Dog`.\n I didn't know about tests in graphqh-js. I replace my commit.\n  If we have a simple query, with only a SelectionSet:\n\n```\n{\n    hero {\n        name\n    }\n}\n```\n\nwhich is the same as\n\n```\nquery HeroNameQuery {\n    hero {\n        name\n    }\n}\n```\n\nThe tests in `graphql.js` show this expected answer:\n\n```\n{\n    data: {\n        hero: {\n            name: 'R2-D2'\n        }\n    }\n}\n```\n\nI know we can have many root in one query:\n\n```\nquery FetchLukeAndLeiaAliased {\n    luke: human(id: \"1000\") {\n        name\n    }\n    leia: human(id: \"1003\") {\n        name\n    }\n}\n```\n\nResulting in this answer:\n\n```\n{\n    data: {\n        luke: {\n            name: 'Luke Skywalker'\n        },\n        leia: {\n            name: 'Leia Organa'\n        }\n    }\n}\n```\n\nBut, and it's my main concern, what if we have more that one operation in one query, which seems to be valid in the specifications (examples in http://facebook.github.io/graphql/#sec-All-Variable-Uses-Defined and http://facebook.github.io/graphql/#sec-All-Variables-Used).\n\nFor example what is the expected answer for this graphql query (dumb query just for the example):\n\n```\nquery LukeAndLeiaNames {\n    luke: human(id: \"1000\") {\n        name\n    }\n    leia: human(id: \"1003\") {\n        name\n    }\n}\n\nquery LukeAndLeiaHomePlanet {\n    luke: human(id: \"1000\") {\n        homePlanet\n    }\n    leia: human(id: \"1003\") {\n        homePlanet\n    }\n}\n```\n\nI currently have no idea, except that there should be one more level between `data` and a query result using the name of the operation (which must be unique in the document, as said in the specification).\n\nOr each query have its own \"object\" response, with `data`, `errors`... But in this case how are they \"encapsulated\"? In a main object with the operation names used as keys ? I could not find anything about this in the specification or the graphql.js tests.\n\nThanks for your answer, I'm currently writing a python graphql server and it will help me to know that ;)\n @dschafer thanks for your answer but it doesn't help me a lot. I understand how it is supposed to work internally.\n\nBut, let's forget the server, consider it a black box and imagine I am a client.\n\nIf I send this document:\n\n```\nquery LukeAndLeiaNames {\n    luke: human(id: \"1000\") {\n        name\n    }\n    leia: human(id: \"1003\") {\n        name\n    }\n}\n\nquery LukeAndLeiaHomePlanet {\n    luke: human(id: \"1000\") {\n        homePlanet\n    }\n    leia: human(id: \"1003\") {\n        homePlanet\n    }\n}\n```\n\nWhat do I get in response from the server?\n Ok I understand, thank you. I understood that the executor could only handle one operation at a time but maybe it could have been called many times one operation after the other.\n\nSo now what wonder me is... what's the point of having a document that can contains many operations ?\n And to finish: how the client is supposed to send which operation to run if there are many operations in the document ?\n\nUntil now I imagined graphql as a simple `GraphQLQuery => Server => Response`  behavior. The client sending its query in string at a server endpoint. So I'm a bit disappointed by this many-operations document :-/\n Ok thanks a lot for your answers. I started to think like that about the argument for the operation to run, and for the \"storage\" of queries on the server (like redis does for lua scripts).\n\nI now have a better understanding of the whole thing and can go back to my graphql server in python.\n\nThanks a lot.\n  Cheer up.\n  Very fascinating read! Thank you for open-sourcing :)\n\nLooks like the _Input Coercion_ paragraph of Non-Null types in [Section 3 -- Type System](https://github.com/facebook/graphql/blob/master/Section%203%20--%20Type%20System.md#non-null) has incorrectly been copied from the section right above about Lists.\n   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!\n Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!\n      Hey facebook,\n\nFirst of all, thanks for open sourcing this, I'm so excited I forgot how to even.\n\nWith that out of the way, I have a question, how is pagination implemented in the facebook schema? There is no mention of pagination in the spec so I assume is implemented adhoc using the primitives provided by the spec. A hint on how to model this common use case would be really appreciated. \n\nWhat I have in mind is some is some `Page` type. Which yields the following question: is it possible to define generic types the same way that List is defined? Asking because ideally such `Page` type would be `Page<T>`\n\nAlso, I'd also appreciate some advice on how to model querying for the count of a list property or a paginated property. In [2.10.1 Types of fragments](http://facebook.github.io/graphql/#sec-Types-on-fragments) there is the following example:\n\n```\nquery FragmentTyping\n{\n  profiles(handles: [\"zuck\", \"cocacola\"]) {\n    handle\n    ...userFragment\n    ...pageFragment\n  }\n}\n\nfragment userFragment on User {\n  friends { count }\n}\n\nfragment pageFragment on Page {\n  likers { count }\n}\n```\n\nThere is no schema attached for that example, but as far as I understand, those fragments are trying to get the total number of friends of a user and the total number of likes of a Page. It is hard to say without the schema, but if we assume that a User has a List of Users, the fist fragment is really querying for the property `count` in each individual User of said list, and not the property `count` in the list itself (which is the intention, arguably). Any light in this topic would be very much appreciated.\n\nThanks for open sourcing this and for your time. \n As far as what I've seen in the past on GraphQL, if you wanted pagination, one schema you could use to achieve that would be:\n\n```\ntype FriendList {\n  count: Int,\n  edges: [User!]\n}\n\ntype User {\n  friends(first: Int, after: ID): FriendList\n}\n```\n\nThis should hopefully answer both of your questions. Pagination would be implemented by using the `first` and `after` field arguments on `friends`, and the `count` accessed would be on the type `FriendList`, a wrapper over the list of `User`s.\n\nI'm not entirely sure if this has been changed, so I would love to see @leebyron pitch in too :smile: \n @devknoll thanks for your response. Yup, I guess something among those lines is always possible. There are some caveats with an approach is that you'd have to duplicate the `FriendList` type for every type you want to paginate over `PostList` etc.\n\nThis relates to the question I mentioned, whether or not is possible to create generic types just like the native `List`.\n We don't support generic types like `Page<T>`, as representing them client-side can be really tricky. Is it a template type? Is it a generic interface? Lots of questions and complexity we chose to avoid, at least for now.\n\n@devknoll, you're pretty much on the money with that answer. We have a convention that we use at Facebook that we call `Connection`. We have some helper functions on the server side that keeps us from duplicating the work of implementing this convention, and avoids mistakes. That gets you most of the value you would get from having some kind of template type or generics.\n\nAt Facebook, it looks like this:\n\n```\ntype UserConnection {\n  count: Int\n  nodes: [User]\n  edges: [UserConnectionEdge]\n}\n\ntype UserConnectionEdge {\n  node: User\n  cursor: String\n}\n```\n\nYou can imagine replacing `User` with any type here and the type model still works. The `nodes` field is a shorthand for `edges { node { ... } }` when all you want are the nodes at the end of the connection. `edges` also has `cursor` as a utility for performing pagination. \n\nPagination in GraphQL at Facebook looks something like:\n\n```\ntype User {\n...\nfriends(after: String, first: Int, before: String, last: Int): UserConnection\n...\n}\n```\n\nSo here, the `friends` field on a `User` accepts a couple arguments. `after` accepts a value that `cursor` gave you in a prior query, and `first` limits how many items are returned. `before` and `last` are the same ideas, but for paginating from the back of a list towards the front.\n\nSo again, _this is just a convention that Facebook uses_. GraphQL itself **doesn't** know what pagination is, it just enables patterns like these. Underlying code is responsible for actually reading these arguments and applying them in a sensible way.\n\n---\n\nYou could also imagine a much simpler pagination model that just does `offset`, `limit`. There are some issues with this approach (for example, if the front of the list changes often, or when deep into a very long list), but it's simplicity is compelling.\n\nIn this model, you might instead type things as:\n\n```\ntype User {\n...\nfriends(offset: Int, limit: Int): [User]\n...\n}\n```\n\nNow there's no additional `Connection` type at all; I would suggest that `offset` and `limit` work here just as they do in SQL.\n :dancer: \n\n@leebyron thanks! I'll play around with this ideas. Thank you!\n @leebyron What do you think about documenting that pattern somewhere more visible than this issue?\n @leebyron I've been playing with this and it works great. The duplication in the server is not a problem as you mentioned, a function to define a connection type for a given types solves the problem just fine.\n\nI have a couple of follow up questions and I was hoping you could shed some light:\n\n> ```\n> type UserConnectionEdge {\n>   node: User\n>   cursor: String\n> }\n> ```\n- why do you guys put the cursor of every node along with that node? What's the use case behind this decision? Wouldn't it be enough to have a before and after (first and last item) cursor at the connection level?\n- why do you call it connection? I'm just trying to understand the abstraction properly. I've been thinking about it in terms of pages. I'm wondering if there are any caveats. \n- I'm thinking to implement pagination like this. I'd love feedback. \n\n```\ntype UserPage {\n  count: Int\n  nodes: [User]\n  after: String\n  before: String\n}\n```\n\nand the entry point would be the same\n\n```\ntype User {\n...\nfriends(offset: Int, limit: Int): [User]\n...\n}\n```\n\nThank you so much in advance.\n @leebyron Thanks for your informational reply.  It's helped a lot! So sorry to revive this old thread.. but I'm completely lost as to how to implement one piece of what you said:\n\n> `after` accepts a value that `cursor` gave you in a prior query\n\nOk.. and I've definitely gotten that to work by taking a look at the edge cursors on the `/graphql` response in my browser.  Problem is.. how do I make this work for the _first_ \"page\" of items, when I have no \"prior query\" to work from?\n\nI tried leaving `after` as `undefined` in my query, but I only got the following error:\n\n> Uncaught Invariant Violation: callsFromGraphQL(): Expected a declared value for variable, $curs.\n\nIt seems, if you define `first` and `after` in your container's fragment, then they're required parameters.  But I have no value for `after`, so how in the world does one initialize this?\n\nThanks!\n @RavenHursT, ensure that your variable is not required. \n\nFor example, this query should error if no value is provided for `$after` since it's required to be a non-null string (`String!`).\n\n```\nquery Example($after: String!) { \n  someConnection(after: $after) { count }\n}\n```\n\nWhere this example which accepts null (just `String`), should not error if no value is provided for `$after`. This is considered best practice for using variables with pagination.\n\n```\nquery Example($after: String) { \n  someConnection(after: $after) { count }\n}\n```\n @leebyron yeah.. turns out that you have to explicitly set default variables w/ `null`, not just allow them to be `undefined`:\n\nhttp://stackoverflow.com/questions/34406667/relay-pagination-how-to-initialize-after-value/34407181#34407181\n\nThanks.\n That sounds like a bug actually. What GraphQL library are you using? graph-js?\n We're using `express-graphql`\n > We don't support generic types like `Page<T>`\r\n\r\nwell it's working: https://launchpad.graphql.com/nxqjv8k4l7\r\n\r\nWith this `Page` template type for example:\r\n```js\r\nfunction Page(Type) {\r\n\treturn new ObjectType({\r\n\t\tname: `Page${Type}`,\r\n\t\tdescription: `A simple pagination method\r\n - nodes contains the actual list of data\r\n - cursor is the end cursor or falsy if there are no more pages`,\r\n\t\tfields: {\r\n\t\t\tnodes: {type: new NonNull(new List(new NonNull(Type)))},\r\n\t\t\tcursor: {type: String},\r\n\t\t},\r\n\t});\r\n}\r\nconst QueryType = new ObjectType({\r\n\tname: 'Query',\r\n\tfields: {\r\n\t\tfoos: {\r\n\t\t\ttype: Page(Foo),\r\n\t\t\targs: listArgs,\r\n\t\t\tresolve: (_, args) =>getFoos(args),\r\n\t\t},\r\n\t},\r\n});\r\n```  I'm a developer of LoopBack (http://www.loopback.io), an open source Node.js framework for building APIs with rich data integrations. I'm opening this issue to explore the possibility of collaboration as both projects try to solve similar problems. \n\nLoopBack already provides a lot of capabilities as you outline in the GraphQL spec, including:\n1. A JSON based definition language for data models (types and validations) - http://docs.strongloop.com/display/LB/Model+definition+JSON+file\n2. Relations that connect models (BelongsTo, HasMany, HasOne, HasMany-Through, EmbedsMany, ReferencesMany, Polymorphic) to form data graphs - http://docs.strongloop.com/display/LB/Creating+model+relations\n3. A JSON based query language - http://docs.strongloop.com/display/LB/Querying+data\n4. A large list of connectors that implement the CRUD operations based on the specs - http://docs.strongloop.com/display/LB/Connecting+models+to+data+sources\n\nWhat do you think? \n\nPS: I'm not sure if this is a good way to reach out. Please let me know if we should take it offline. Thanks in advance.\n This is interesting, feel free to drop me an email to talk more in depth. I'm curious to know what you imagine a collaboration looking like in this case.\n Closing this. Looking forward to following up over email \n I would certainly be interested to know if anything came out of this exchange.\n\nI just read [Start using GraphQL with Graffiti](https://blog.risingstack.com/start-using-graphql-with-graffiti/): \"Graffiti provides an express middleware, a hapi plugin and a koa middleware to convert your existing models into a GraphQL schema and exposes it over HTTP.\"\n\nThis made me wonder if, similarly, a REST API designed with Loopback could also be automagically exposed as a GraphQL endpoint... (I'm evaluating both hapi vs. loopback at this point).\n hi @leebyron and @sebastienbarre, sorry for the late reply, I'm back from my vacation.\n\ncoincidentally, we're actually in the process of kickstarting a React SDK with another community member - @LucaColonnello.  I can make some introductions via email.  @leebyron I have your thread from @raymondfeng .  @sebastienbarre if your'e interested please ping me at `al (at) strongloop.com`.  \n@LucaColonnello has put together a set of options in a proposal that you guys can review.\n\nHere at SL, we're going take isomorphic LB in the browser, strip it down to be more lightweight so that a React based MVC like Flux can bind to the JS objects directly to implement objects like Store.\n Yeah guys,\nintegrate GraphQL and Relay with Loopback (with the in browser implementation) could be great!\n\nNow I'm working on a demo made in React as a porting of the Angular once of the ToDo example.\n @LucaColonnello - do you mind posting the Gist and the slides so folks can get on the same page? thx!\n Oh Yeah,\nthese were only Draft, but I think that working together we can create something really cool!!!!!!!!!!\n\nExample gist:\nhttps://gist.github.com/LucaColonnello/55ffd0a311bbf64becc1\n\nSlides.com presentation of some ideas:\nhttp://slides.com/lucacolonnello/react-sdk-for-loopback/#/\n :+1: \n :+1: \n :+1: \n :+1:\n :8ball: \n :+1:\n :+1: \n :+1: \n :-1:\n wait I mean :+1:\n :+1:\n", "text_all_count": 93927, "text_word_token": ["It", "looks", "like", "the", "specification", "be", "not", "clear", "if", "the", "client", "provides", "a", "request", "without", "variables", "do", "the", "field", "variables", "should", "be", "assigned", "null", "or", "or", "both", "be", "valid", "Context", "In", "the", "altair", "LINK", "tool", "the", "default", "value", "be", "set", "to", "without", "the", "double", "quotes", "and", "in", "the", "graphql", "java", "implementation", "it", "s", "expecting", "a", "null", "value", "if", "not", "variables", "be", "needed", "NUMBER", "The", "result", "be", "the", "queries", "be", "rejected", "on", "the", "server", "side", "so", "do", "the", "server", "side", "be", "too", "stick", "or", "be", "it", "the", "client", "side", "which", "be", "provide", "the", "wrong", "value", "What", "do", "you", "mean", "be", "So", "de", "jure", "even", "NUMBER", "but", "thanks", "I", "think", "you", "answered", "my", "question", "Let", "coercedValues", "be", "an", "empty", "unordered", "Map", "NUMBER", "I", "guess", "by", "empty", "they", "mean", "but", "I", "m", "not", "understanding", "why", "they", "mention", "empty", "unordered", "Map", "since", "it", "s", "empty", "there", "s", "nothing", "to", "sort", "Could", "we", "support", "some", "markdown", "in", "GraphQL", "comments", "The", "benefit", "be", "not", "huge", "and", "be", "definitely", "the", "lowest", "priority", "issue", "on", "here", "but", "this", "proposal", "could", "make", "sense", "in", "some", "contexts", "NUMBER", "I", "could", "possibly", "want", "to", "put", "emphasis", "on", "a", "certain", "part", "of", "a", "comment", "so", "that", "other", "people", "who", "read", "the", "docs", "for", "my", "API", "don", "t", "overlook", "it", "NUMBER", "That", "s", "about", "as", "far", "as", "I", "get", "with", "thinking", "this", "through", "NUMBER", "I", "have", "an", "example", "below", "but", "it", "s", "pretty", "simple", "NUMBER", "I", "would", "imagine", "that", "this", "be", "a", "pretty", "easy", "job", "and", "I", "d", "be", "willing", "to", "shoot", "a", "PR", "over", "to", "graphql", "js", "if", "accepted", "NUMBER", "Obviously", "it", "probably", "wouldn", "t", "be", "a", "wise", "idea", "to", "have", "full", "support", "for", "Markdown", "NUMBER", "I", "was", "thinking", "of", "Italics", "Bold", "Strikethrough", "Links", "maybe", "For", "example", "graphql", "enum", "MessageStatus", "If", "a", "message", "could", "not", "successfully", "be", "delivered", "NUMBER", "Failed", "If", "a", "message", "was", "successfully", "delivered", "but", "_has", "not", "been_", "read", "by", "the", "other", "user", "s", "NUMBER", "Delivered", "If", "a", "message", "was", "successfully", "delivered", "and", "_has", "been_", "read", "by", "the", "other", "user", "s", "NUMBER", "Read", "Could", "possibly", "return", "the", "following", "in", "the", "docs", "If", "a", "message", "could", "not", "successfully", "be", "delivered", "NUMBER", "If", "a", "message", "was", "successfully", "delivered", "but", "has", "not", "be", "read", "by", "the", "other", "user", "s", "NUMBER", "If", "a", "message", "was", "successfully", "delivered", "and", "has", "be", "read", "by", "the", "other", "user", "s", "NUMBER", "I", "would", "appreciate", "if", "you", "could", "describe", "the", "motivation", "behind", "this", "proposal", "NUMBER", "I", "remember", "raising", "similar", "issue", "in", "past", "in", "a", "context", "of", "an", "empty", "string", "ID", "s", "LINK", "ATM", "I", "have", "some", "concerns", "about", "this", "constraint", "NUMBER", "It", "be", "a", "breaking", "change", "and", "I", "have", "a", "feeling", "that", "in", "might", "affect", "some", "of", "the", "API", "NUMBER", "Also", "this", "limitation", "as", "well", "as", "disallowing", "empty", "strings", "might", "cause", "issue", "integrating", "with", "legacy", "systems", "NUMBER", "also", "comes", "in", "mind", "I", "have", "seen", "API", "that", "use", "such", "IDs", "NUMBER", "But", "also", "in", "general", "I", "think", "IDs", "should", "be", "opaque", "NUMBER", "I", "see", "constraints", "like", "this", "as", "part", "of", "the", "application", "domain", "so", "I", "feel", "that", "we", "should", "not", "enforce", "them", "in", "the", "spec", "NUMBER", "currently", "the", "name", "only", "support", "_A", "Za", "z", "_", "NUMBER", "NUMBER", "A", "Za", "z", "And", "to", "add", "more", "background", "information", "The", "character", "tends", "to", "interfere", "with", "parsing", "of", "a", "name", "such", "as", "x", "y", "NUMBER", "Is", "this", "now", "an", "identifier", "x", "y", "or", "be", "it", "a", "subtraction", "SUB", "x", "y", "in", "an", "AST", "node", "In", "most", "languages", "this", "be", "ambiguous", "and", "thus", "the", "character", "be", "often", "disallowed", "in", "identifier", "names", "NUMBER", "Even", "if", "GraphQL", "doesn", "t", "use", "languages", "in", "which", "it", "be", "embedded", "often", "do", "NUMBER", "An", "important", "exception", "to", "the", "rule", "be", "Lisp", "like", "languages", "Common", "Lisp", "Scheme", "Racket", "Clojure", "where", "the", "notation", "be", "an", "s", "expression", "x", "y", "in", "the", "above", "case", "NUMBER", "Since", "everything", "be", "code", "as", "a", "prefix", "it", "be", "clear", "one", "can", "use", "names", "with", "a", "dash", "in", "those", "languages", "and", "it", "be", "seen", "quite", "often", "on", "those", "languages", "NUMBER", "E", "NUMBER", "g", "NUMBER", "string", "append", "hello", "world", "NUMBER", "Likewise", "catenative", "languages", "be", "likely", "to", "accept", "a", "in", "other", "positions", "as", "well", "NUMBER", "IvanGoncharov", "jlouis", "Thanks", "very", "much", "for", "the", "explanation", "NUMBER", "I", "asked", "this", "question", "because", "I", "be", "developing", "a", "GraphQL", "schema", "where", "there", "be", "something", "like", "address", "en", "GB", "Address", "in", "English", "zh", "CN", "Address", "in", "Simplified", "Chinese", "zh", "HK", "Address", "in", "Traditional", "Chinese", "Maybe", "I", "have", "to", "change", "to", "another", "approach", "NUMBER", "liweinan", "NUMBER", "we", "had", "exactly", "the", "same", "challenge", "for", "localized", "strings", "in", "out", "API", "NUMBER", "Since", "the", "set", "of", "available", "locales", "be", "dynamic", "and", "change", "over", "time", "we", "decided", "not", "to", "bake", "such", "field", "as", "en", "or", "en", "GB", "into", "the", "GraphQL", "schema", "and", "in", "general", "I", "would", "advise", "not", "to", "do", "so", "NUMBER", "We", "ended", "up", "provide", "NUMBER", "GraphQL", "field", "for", "every", "localized", "property", "for", "NUMBER", "different", "use", "cases", "our", "clients", "have", "graphql", "type", "LocalizedString", "locale", "String", "value", "String", "type", "User", "address", "locale", "String", "fallbackLocales", "String", "LocalizedString", "addressAllLocales", "LocalizedString", "address", "field", "be", "designed", "for", "customer", "facing", "apps", "that", "normally", "work", "with", "a", "single", "locale", "user", "language", "NUMBER", "addressAllLocales", "be", "designed", "for", "admin", "style", "applications", "that", "normally", "present", "localized", "strings", "in", "all", "locales", "and", "allow", "users", "to", "view", "and", "edit", "them", "NUMBER", "Not", "sure", "whether", "this", "approach", "will", "work", "for", "you", "but", "I", "hope", "this", "helps", "IvanGoncharov", "sure", "thanks", "very", "much", "for", "your", "clarification", "NUMBER", "Proposal", "There", "should", "be", "three", "NUMBER", "GraphQL", "specs", "for", "Queries", "Mutations", "and", "Subscriptions", "NUMBER", "When", "I", "looked", "at", "GraphQL", "JS", "on", "Github", "LINK", "js", "which", "be", "supposed", "to", "be", "the", "Reference", "Implementation", "of", "the", "GraphQL", "spec", "it", "seems", "to", "include", "Queries", "Mutations", "and", "Subscriptions", "NUMBER", "Sometimes", "we", "just", "need", "the", "Queries", "capability", "or", "Queries", "and", "Mutations", "but", "not", "Subscriptions", "NUMBER", "By", "splitting", "the", "GraphQL", "spec", "into", "the", "three", "aforementioned", "parts", "this", "Proposal", "it", "will", "encourage", "modular", "implementations", "NUMBER", "Thanks", "This", "might", "also", "be", "a", "challenge", "since", "aspects", "of", "GraphQL", "like", "Introspection", "make", "reference", "to", "mutation", "and", "subscription", "root", "types", "presumably", "any", "service", "even", "if", "only", "support", "queries", "would", "need", "to", "respond", "well", "to", "introspection", "queries", "that", "reference", "these", "Hmm", "NUMBER", "I", "didn", "t", "think", "about", "that", "but", "I", "m", "not", "sure", "the", "service", "needs", "to", "respond", "to", "introspection", "queries", "referencing", "mutation", "and", "subscription", "root", "types", "with", "anything", "other", "than", "indicating", "lack", "of", "support", "for", "those", "queries", "NUMBER", "This", "way", "the", "spec", "be", "untangled", "NUMBER", "Ideally", "I", "should", "be", "able", "to", "implement", "separate", "concepts", "Queries", "Mutations", "Subscriptions", "separately", "NUMBER", "Subscriptions", "can", "conform", "to", "the", "GraphQL", "Subscriptions", "spec", "but", "be", "use", "with", "Non", "GraphQL", "Mutations", "NUMBER", "Why", "not", "Same", "with", "Mutations", "which", "can", "conform", "to", "the", "GraphQL", "Mutations", "spec", "but", "be", "use", "with", "Non", "GraphQL", "Subscriptions", "like", "notifications", "streamed", "from", "the", "db", "s", "change", "log", "in", "some", "custom", "format", "use", "some", "streaming", "API", "with", "exactly", "once", "processing", "etc", "NUMBER", "I", "know", "all", "of", "it", "can", "be", "do", "today", "if", "you", "don", "t", "mind", "having", "more", "code", "to", "maintain", "than", "you", "have", "to", "why", "should", "I", "implement", "GraphQL", "Mutations", "if", "I", "only", "need", "GraphQL", "Queries", "Imagine", "I", "have", "to", "combine", "GraphQL", "Queries", "with", "Non", "GraphQL", "Mutations", "e", "NUMBER", "g", "NUMBER", "writes", "come", "over", "Kafka", "Streams", "API", "directly", "from", "clients", "that", "be", "outside", "my", "scope", "of", "responsibility", "The", "question", "be", "why", "as", "implementor", "do", "I", "need", "to", "implement", "parts", "of", "the", "spec", "that", "I", "have", "no", "use", "for", "Why", "be", "completely", "separate", "or", "should", "be", "separate", "concepts", "bundled", "together", "in", "one", "spec", "What", "be", "special", "about", "the", "Queries", "Subscriptions", "Mutations", "set", "that", "makes", "it", "immune", "to", "decomposition", "At", "a", "point", "you", "can", "definitely", "build", "a", "process", "which", "follows", "Python", "s", "PEP", "Python", "Enhancement", "Proposal", "The", "Bittorrent", "BEP", "Bittorrent", "enhancement", "proposal", "or", "the", "scheme", "SRFI", "Scheme", "Requests", "for", "Implementation", "NUMBER", "The", "idea", "be", "that", "you", "have", "a", "base", "system", "which", "be", "the", "minimum", "requirement", "for", "compliance", "and", "extensions", "be", "then", "numbered", "as", "BEP", "NUMBER", "BEP", "NUMBER", "and", "so", "on", "NUMBER", "Clients", "experimentally", "build", "those", "and", "they", "then", "become", "standardized", "later", "if", "enough", "clients", "de", "facto", "implement", "them", "NUMBER", "BitTorrent", "had", "the", "Azureus", "Vuze", "client", "which", "were", "build", "in", "Java", "and", "was", "add", "features", "at", "a", "much", "faster", "pace", "than", "every", "other", "client", "and", "their", "features", "were", "rarely", "the", "ones", "the", "rest", "of", "the", "community", "ended", "up", "use", "NUMBER", "So", "all", "the", "BEPs", "were", "write", "down", "and", "people", "steered", "around", "those", "proposals", "and", "implement", "the", "other", "proposals", "which", "were", "then", "accepted", "into", "the", "standard", "eventually", "NUMBER", "Specifications", "evolve", "NUMBER", "Support", "the", "evolution", "NUMBER", "I", "was", "afraid", "the", "Jun", "NUMBER", "specification", "would", "be", "bloated", "and", "mess", "up", "things", "but", "luckily", "my", "worry", "was", "only", "that", "a", "worry", "NUMBER", "The", "change", "be", "mostly", "clarifications", "and", "sensible", "extensions", "NUMBER", "It", "will", "take", "some", "time", "to", "adapt", "my", "GraphQL", "server", "code", "base", "but", "we", "be", "slowly", "get", "there", "jlouis", "yes", "that", "be", "exactly", "what", "I", "was", "hinting", "at", "but", "did", "not", "want", "to", "get", "into", "the", "how", "ahead", "of", "agreeing", "on", "the", "what", "of", "the", "proposal", "NUMBER", "The", "reference", "you", "make", "to", "the", "BitTorrent", "Azureus", "Vuze", "client", "reminds", "me", "of", "Apollo", "server", "client", "NUMBER", "Thank", "you", "for", "framing", "it", "in", "historical", "context", "NUMBER", "I", "agree", "NUMBER", "that", "we", "need", "this", "kind", "of", "thinking", "in", "order", "for", "GraphQL", "to", "evolve", "naturally", "NUMBER", "Maybe", "NUMBER", "years", "down", "the", "line", "someone", "will", "reference", "this", "and", "come", "out", "with", "the", "base", "spec", "and", "reference", "implementation", "that", "will", "support", "spec", "extensions", "in", "the", "way", "you", "describe", "NUMBER", "But", "for", "now", "I", "be", "get", "massive", "resistance", "on", "Twitter", "see", "discussions", "under", "my", "handle", "marcfawzi", "stubailo", "compared", "the", "argument", "to", "someone", "not", "wanting", "to", "use", "Underscore", "because", "they", "only", "need", "a", "few", "function", "from", "it", "NUMBER", "I", "had", "to", "state", "that", "it", "s", "about", "implementation", "cost", "not", "usage", "cost", "I", "love", "your", "framing", "NUMBER", "Thank", "you", "NUMBER", "I", "think", "the", "case", "be", "pretty", "clear", "now", "NUMBER", "I", "look", "forward", "to", "this", "get", "resurrected", "in", "a", "few", "years", "when", "the", "community", "realizes", "that", "they", "need", "to", "have", "that", "level", "of", "abstraction", "in", "the", "process", "NUMBER", "To", "be", "clear", "the", "base", "case", "for", "me", "be", "Queries", "NUMBER", "Everything", "above", "that", "Mutations", "Live", "Queries", "Cache", "Subscriptions", "etc", "should", "be", "an", "extension", "IMO", "NUMBER", "What", "be", "special", "about", "queries", "Without", "them", "GraphQL", "be", "meaningless", "NUMBER", "I", "can", "t", "say", "the", "same", "about", "Mutations", "and", "Subscriptions", "as", "well", "as", "all", "other", "non", "standard", "features", "out", "there", "NUMBER", "Fair", "enough", "NUMBER", "The", "onus", "on", "us", "the", "community", "to", "come", "up", "with", "a", "compelling", "case", "NUMBER", "I", "believe", "I", "have", "one", "at", "the", "moment", "on", "the", "roadmap", "but", "will", "be", "better", "informed", "when", "we", "do", "the", "actual", "work", "NUMBER", "To", "clarify", "the", "use", "case", "can", "be", "do", "with", "GraphQL", "as", "be", "today", "but", "it", "should", "demonstrate", "how", "a", "PEP", "like", "process", "would", "allow", "us", "to", "contribute", "to", "the", "spec", "and", "partake", "in", "its", "evolution", "as", "oppose", "to", "many", "folks", "in", "our", "position", "doing", "custom", "work", "in", "isolation", "NUMBER", "That", "be", "the", "key", "point", "of", "this", "proposal", "NUMBER", "I", "ll", "leave", "this", "open", "for", "a", "few", "days", "then", "close", "it", "in", "case", "other", "have", "any", "other", "input", "NUMBER", "The", "issue", "Here", "s", "a", "link", "to", "the", "specification", "for", "not", "null", "LINK", "sec", "Input", "Objects", "It", "says", "Otherwise", "if", "the", "field", "be", "not", "required", "then", "no", "entry", "be", "add", "to", "the", "coerced", "unordered", "map", "NUMBER", "This", "means", "that", "we", "have", "an", "opportunity", "to", "behave", "differently", "in", "our", "application", "code", "based", "on", "whether", "the", "user", "explicitly", "posts", "null", "for", "a", "field", "or", "simply", "omits", "the", "field", "NUMBER", "However", "we", "have", "no", "way", "of", "restricting", "the", "options", "available", "to", "a", "user", "NUMBER", "Consider", "the", "following", "schema", "graphql", "input", "PersonInput", "id", "ID", "name", "String", "Does", "not", "support", "partial", "update", "i", "NUMBER", "e", "NUMBER", "null", "or", "omission", "results", "in", "this", "field", "be", "set", "to", "null", "in", "the", "database", "hobby", "String", "Supports", "partial", "update", "i", "NUMBER", "e", "NUMBER", "null", "means", "to", "unset", "this", "field", "omission", "means", "to", "leave", "the", "exist", "value", "as", "be", "type", "Person", "NUMBER", "omitted", "for", "brevity", "type", "Mutation", "updatePerson", "input", "PersonInput", "Person", "Consider", "the", "following", "scenarios", "Scenario", "NUMBER", "User", "wants", "to", "blank", "out", "all", "values", "for", "a", "person", "Option", "NUMBER", "Setting", "all", "field", "to", "null", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "name", "null", "hobby", "null", "I", "think", "this", "be", "the", "most", "idiomatic", "approach", "a", "user", "would", "use", "NUMBER", "The", "server", "do", "exactly", "what", "the", "user", "wanted", "NUMBER", "Option", "NUMBER", "Omitting", "all", "field", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "This", "doesn", "t", "feel", "like", "a", "natural", "thing", "to", "do", "NUMBER", "The", "server", "nulls", "out", "the", "name", "but", "the", "hobby", "be", "left", "as", "be", "NUMBER", "The", "user", "didn", "t", "achieve", "what", "they", "wanted", "but", "they", "will", "be", "left", "wondering", "why", "NUMBER", "They", "will", "probably", "write", "a", "more", "specific", "query", "and", "maybe", "file", "a", "bug", "against", "the", "API", "saying", "the", "hobby", "field", "doesn", "t", "work", "as", "expected", "NUMBER", "Scenario", "NUMBER", "User", "wants", "to", "blank", "out", "the", "hobby", "for", "a", "person", "Option", "NUMBER", "Providing", "the", "exist", "name", "with", "the", "hobby", "set", "to", "null", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "name", "John", "hobby", "null", "I", "think", "this", "be", "the", "most", "idiomatic", "approach", "a", "user", "would", "use", "NUMBER", "The", "server", "do", "exactly", "what", "the", "user", "wanted", "NUMBER", "Option", "NUMBER", "Providing", "the", "exist", "name", "with", "the", "hobby", "omitted", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "name", "John", "This", "doesn", "t", "feel", "like", "a", "natural", "thing", "to", "do", "NUMBER", "The", "server", "do", "not", "blank", "out", "the", "hobby", "NUMBER", "The", "user", "would", "probably", "retry", "the", "query", "use", "option", "NUMBER", "at", "this", "point", "NUMBER", "Option", "NUMBER", "Just", "setting", "the", "hobby", "to", "null", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "hobby", "null", "This", "feels", "natural", "especially", "in", "the", "GraphQL", "world", "where", "the", "API", "can", "constantly", "evolve", "and", "new", "field", "can", "be", "add", "NUMBER", "The", "server", "nulls", "out", "the", "hobby", "as", "expected", "NUMBER", "However", "it", "also", "nulls", "out", "the", "name", "which", "the", "user", "did", "not", "expect", "NUMBER", "Scenario", "NUMBER", "User", "wants", "to", "blank", "out", "the", "name", "for", "a", "person", "Option", "NUMBER", "Providing", "the", "exist", "hobby", "with", "the", "name", "set", "to", "null", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "name", "null", "hobby", "Skydiving", "I", "think", "this", "be", "the", "most", "idiomatic", "approach", "a", "user", "would", "use", "NUMBER", "The", "server", "do", "exactly", "what", "the", "user", "wanted", "NUMBER", "Option", "NUMBER", "Providing", "the", "exist", "hobby", "with", "the", "name", "omitted", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "hobby", "Skydiving", "This", "doesn", "t", "feel", "like", "a", "natural", "thing", "to", "do", "NUMBER", "However", "the", "server", "do", "exactly", "what", "the", "user", "wanted", "NUMBER", "Option", "NUMBER", "Just", "setting", "the", "name", "to", "null", "The", "user", "posts", "the", "following", "object", "json", "id", "NUMBER", "name", "null", "This", "feels", "natural", "especially", "in", "the", "GraphQL", "world", "where", "the", "API", "can", "constantly", "evolve", "NUMBER", "The", "server", "do", "exactly", "what", "the", "user", "wanted", "NUMBER", "I", "have", "not", "illustrated", "examples", "of", "the", "scenarios", "regard", "a", "field", "which", "be", "always", "mandatory", "but", "can", "be", "omitted", "from", "an", "update", "to", "retain", "its", "exist", "value", "NUMBER", "Description", "The", "following", "cases", "illustrate", "that", "there", "be", "several", "points", "of", "ambiguity", "in", "our", "API", "Scenario", "NUMBER", "Option", "NUMBER", "quite", "painful", "Scenario", "NUMBER", "Option", "NUMBER", "not", "that", "much", "of", "a", "pain", "point", "Scenario", "NUMBER", "Option", "NUMBER", "quite", "painful", "It", "s", "easy", "to", "turn", "around", "at", "this", "point", "based", "on", "these", "trivial", "examples", "and", "say", "Well", "why", "the", "hell", "would", "you", "do", "that", "for", "Why", "not", "be", "consistent", "The", "reason", "we", "be", "facing", "this", "dilemma", "be", "because", "we", "have", "many", "mutations", "none", "of", "which", "support", "partial", "update", "i", "NUMBER", "e", "NUMBER", "all", "field", "be", "always", "required", "explicitly", "and", "our", "consumers", "want", "some", "APIs", "to", "start", "support", "partial", "update", "NUMBER", "At", "the", "moment", "some", "field", "be", "optional", "so", "both", "null", "AND", "omission", "translate", "to", "blank", "it", "out", "NUMBER", "However", "we", "would", "need", "to", "start", "treating", "omission", "differently", "i", "NUMBER", "e", "NUMBER", "leave", "as", "be", "NUMBER", "Without", "excessive", "comments", "in", "our", "documentation", "and", "validation", "in", "our", "API", "our", "API", "will", "be", "difficult", "to", "understand", "and", "seem", "inconsistent", "to", "end", "users", "NUMBER", "It", "would", "be", "great", "if", "we", "could", "define", "input", "types", "like", "the", "following", "graphql", "input", "ExampleInput", "id", "ID", "field", "NUMBER", "String", "null", "Can", "be", "a", "string", "or", "null", "but", "must", "always", "be", "provide", "i", "NUMBER", "e", "NUMBER", "do", "not", "support", "partial", "update", "NUMBER", "This", "would", "be", "a", "solution", "to", "the", "scenarios", "I", "listed", "above", "NUMBER", "field", "NUMBER", "String", "Can", "be", "a", "string", "to", "update", "the", "value", "or", "omitted", "to", "leave", "as", "be", "but", "can", "t", "be", "null", "NUMBER", "This", "would", "be", "a", "solution", "to", "the", "scenario", "I", "briefly", "mention", "above", "in", "bold", "but", "did", "not", "provide", "examples", "for", "NUMBER", "trevorah", "peterstarling", "joaojeronimo", "craigbilner", "belema", "jackharvey", "NUMBER", "You", "guys", "might", "be", "interested", "in", "this", "This", "proposal", "directly", "relate", "to", "a", "discussion", "in", "LINK", "As", "was", "discussed", "at", "the", "latest", "WG", "meeting", "I", "m", "creating", "several", "alternative", "proposals", "NUMBER", "This", "one", "implement", "propose", "solution", "LINK", "issuecomment", "NUMBER", "NUMBER", "Limit", "the", "validation", "to", "only", "these", "directives", "that", "be", "explicitly", "marked", "as", "unique", "NUMBER", "This", "implies", "that", "we", "need", "to", "introduce", "a", "new", "option", "in", "the", "directive", "definition", "NUMBER", "It", "limits", "the", "scope", "of", "Directives", "Are", "Unique", "Per", "Location", "to", "directives", "that", "be", "explicitly", "marked", "as", "unique", "NUMBER", "This", "proposal", "be", "mutually", "exclusive", "with", "other", "alternative", "proposals", "RFC", "Limit", "uniqueness", "to", "skip", "include", "and", "deprecate", "directives", "NUMBER", "RFC", "Limit", "directive", "uniqueness", "to", "explicitly", "marked", "directives", "NUMBER", "this", "one", "leebyron", "IvanGoncharov", "jjergus", "I", "would", "appreciate", "your", "reviews", "NUMBER", "Closes", "NUMBER", "Closes", "NUMBER", "OlegIlyenko", "I", "need", "a", "couple", "more", "days", "to", "think", "about", "NUMBER", "vs", "NUMBER", "vs", "keep", "everything", "as", "be", "NUMBER", "But", "here", "be", "a", "couple", "points", "after", "quick", "review", "NUMBER", "I", "don", "t", "like", "unique", "in", "front", "of", "the", "directive", "unique", "directive", "example", "on", "OBJECT", "INTERFACE", "How", "about", "directive", "example", "uniquely", "on", "OBJECT", "INTERFACE", "NUMBER", "I", "think", "directives", "should", "be", "unique", "by", "default", "since", "it", "what", "make", "sense", "in", "most", "of", "the", "cases", "NUMBER", "If", "you", "want", "to", "support", "some", "advance", "usage", "of", "your", "directive", "chaining", "accumulation", "etc", "NUMBER", "you", "should", "explicitly", "allow", "this", "NUMBER", "Can", "t", "come", "up", "with", "better", "English", "word", "so", "I", "will", "use", "nonUniquely", "as", "temporary", "keyword", "directive", "example", "nonUniquely", "on", "OBJECT", "INTERFACE", "NUMBER", "IvanGoncharov", "thanks", "a", "lot", "for", "your", "feedback", "and", "for", "taking", "your", "time", "to", "review", "the", "PR", "These", "be", "good", "points", "NUMBER", "I", "think", "the", "reason", "I", "use", "unique", "directive", "NUMBER", "syntax", "be", "because", "it", "makes", "presence", "of", "an", "additional", "constraint", "on", "directives", "explicit", "NUMBER", "For", "me", "personally", "it", "be", "more", "intuitive", "to", "assume", "that", "without", "any", "explicitly", "stated", "information", "the", "entity", "be", "unconstrained", "NUMBER", "SQL", "DDL", "be", "one", "example", "of", "this", "approach", "NUMBER", "As", "well", "as", "the", "GraphQL", "itself", "where", "you", "need", "to", "put", "an", "explicit", "to", "add", "extra", "not", "null", "constraint", "on", "the", "field", "NUMBER", "That", "said", "I", "also", "think", "that", "your", "suggestion", "has", "a", "good", "argument", "default", "that", "represents", "the", "prevalent", "use", "case", "NUMBER", "So", "I", "think", "I", "don", "t", "have", "a", "strong", "preference", "between", "these", "two", "alternatives", "NUMBER", "Maybe", "you", "have", "some", "good", "examples", "of", "non", "standard", "directives", "that", "be", "widely", "use", "and", "either", "need", "to", "be", "unique", "or", "non", "unique", "would", "be", "interesting", "to", "compare", "both", "cases", "NUMBER", "Also", "you", "be", "interesting", "to", "hear", "opinions", "on", "this", "aspect", "from", "other", "reviewer", "NUMBER", "Regarding", "unique", "directive", "example", "vs", "directive", "example", "uniquely", "NUMBER", "The", "second", "variation", "look", "a", "bit", "odd", "to", "me", "so", "I", "think", "I", "would", "prefer", "the", "first", "one", "but", "it", "s", "more", "personal", "opinion", "NUMBER", "Although", "with", "the", "syntax", "of", "the", "second", "one", "it", "might", "be", "easier", "to", "add", "additional", "constraints", "in", "future", "NUMBER", "So", "I", "guess", "this", "be", "a", "thing", "to", "consider", "NUMBER", "Also", "in", "my", "experience", "directives", "be", "very", "rarely", "authored", "in", "the", "SDL", "NUMBER", "Most", "of", "the", "time", "I", "worked", "with", "and", "saw", "them", "use", "in", "the", "host", "language", "NUMBER", "From", "this", "perspective", "most", "of", "the", "time", "directive", "definitions", "in", "sdl", "show", "up", "in", "the", "rendered", "output", "of", "actual", "schema", "in", "this", "case", "I", "would", "prefer", "more", "explicit", "unique", "directive", "NUMBER", "NUMBER", "But", "maybe", "it", "s", "just", "me", "I", "m", "not", "sure", "about", "this", "point", "NUMBER", "I", "think", "a", "near", "ideal", "English", "word", "would", "be", "repeatable", "basically", "you", "be", "allow", "to", "repeat", "the", "directive", "at", "the", "same", "location", "NUMBER", "I", "still", "don", "t", "think", "that", "s", "a", "perfect", "word", "but", "I", "think", "it", "s", "better", "than", "nonUnique", "NUMBER", "I", "also", "wonder", "if", "instead", "of", "add", "a", "language", "keyword", "we", "should", "instead", "allow", "directives", "on", "directive", "definitions", "NUMBER", "Then", "you", "d", "have", "something", "like", "directive", "repeatable", "on", "DIRECTIVE", "directive", "my_skip", "if", "Boolean", "repeatable", "on", "FIELD", "I", "agree", "with", "IvanGoncharov", "that", "by", "default", "most", "directives", "will", "be", "unique", "per", "location", "NUMBER", "A", "couple", "of", "potential", "directive", "examples", "ignore_validation", "basically", "if", "validation", "on", "this", "fail", "keep", "going", "NUMBER", "This", "one", "should", "probably", "not", "be", "repeatable", "NUMBER", "ignore_validation_rules", "rules_to_ignore", "ValidationRuleName", "this", "could", "go", "either", "way", "but", "I", "think", "most", "implementers", "of", "this", "would", "first", "make", "it", "non", "repeatable", "unique", "as", "it", "s", "easier", "to", "implement", "if", "it", "s", "more", "rather", "than", "less", "strict", "NUMBER", "Then", "once", "the", "need", "for", "it", "to", "be", "repeatable", "be", "clear", "it", "can", "be", "upgrade", "NUMBER", "As", "I", "think", "it", "ll", "be", "easier", "to", "implement", "unique", "directives", "I", "suspect", "it", "s", "better", "if", "by", "default", "the", "implementer", "doesn", "t", "have", "to", "worry", "about", "merge", "them", "NUMBER", "I", "m", "not", "totally", "sure", "we", "ll", "ever", "get", "to", "a", "set", "of", "NUMBER", "consistent", "directive", "merge", "rules", "that", "work", "for", "all", "use", "cases", "NUMBER", "But", "if", "we", "did", "this", "it", "would", "be", "easy", "if", "we", "decided", "say", "that", "skip", "IvanGoncharov", "those", "argument", "be", "pretty", "convincing", "to", "me", "NUMBER", "It", "do", "end", "up", "potentially", "open", "up", "a", "class", "of", "things", "we", "want", "to", "add", "to", "directive", "definitions", "and", "this", "argument", "basically", "means", "this", "entire", "class", "cannot", "be", "experimentally", "add", "via", "directives", "first", "but", "instead", "must", "be", "add", "to", "the", "language", "NUMBER", "I", "can", "t", "immediately", "think", "of", "another", "example", "that", "lives", "in", "this", "class", "though", "so", "maybe", "this", "be", "indeed", "the", "only", "thing", "in", "the", "entire", "class", "of", "additions", "to", "directive", "definitions", "we", "would", "want", "to", "add", "NUMBER", "mjmahone", "I", "also", "like", "repeatable", "it", "looks", "and", "sounds", "good", "in", "SDL", "NUMBER", "I", "also", "don", "t", "have", "a", "strong", "opinion", "on", "the", "default", "NUMBER", "If", "we", "have", "a", "strong", "consensus", "on", "non", "repeatable", "default", "then", "let", "s", "do", "it", "NUMBER", "Also", "if", "most", "of", "that", "directives", "that", "people", "be", "use", "in", "practice", "be", "non", "repeatable", "then", "I", "think", "it", "be", "indeed", "a", "very", "good", "idea", "to", "represent", "it", "as", "the", "SDL", "default", "NUMBER", "I", "also", "wonder", "if", "instead", "of", "add", "a", "language", "keyword", "we", "should", "instead", "allow", "directives", "on", "directive", "definitions", "I", "thought", "about", "this", "as", "well", "but", "I", "think", "I", "would", "agree", "with", "IvanGoncharov", "s", "argument", "NUMBER", "I", "feel", "that", "the", "syntax", "will", "get", "quite", "confusing", "in", "SDL", "NUMBER", "ATM", "I", "also", "can", "t", "think", "of", "other", "use", "cases", "for", "directives", "on", "directives", "NUMBER", "Fixed", "typo", "in", "spec", "acknoledgment", "acknowledgement", "It", "s", "a", "great", "spec", "Thanks", "for", "a", "great", "spec", "Re", "applies", "NUMBER", "but", "as", "an", "RFC", "NUMBER", "This", "change", "be", "a", "major", "spec", "breaking", "change", "and", "if", "it", "be", "desire", "able", "we", "should", "provide", "an", "upgrade", "path", "for", "exist", "schemas", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "mailto", "cla", "fb", "NUMBER", "com", "subject", "CLA", "NUMBER", "for", "NUMBER", "facebook", "NUMBER", "Fgraphql", "NUMBER", "NUMBER", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "This", "validation", "requirement", "was", "a", "really", "nasty", "breaking", "change", "for", "exist", "GraphQL", "type", "systems", "NUMBER", "Additionally", "it", "be", "in", "my", "opinion", "actively", "harmful", "to", "an", "iterative", "development", "model", "where", "you", "d", "define", "an", "interface", "that", "a", "field", "returns", "develop", "on", "the", "client", "against", "that", "interface", "then", "days", "or", "weeks", "later", "create", "one", "or", "more", "types", "that", "implement", "the", "interface", "which", "old", "clients", "can", "start", "use", "immediately", "NUMBER", "develop", "on", "the", "client", "against", "that", "interface", "How", "can", "you", "develop", "against", "an", "interface", "if", "it", "s", "not", "implement", "Do", "you", "use", "some", "mocking", "tool", "What", "would", "be", "the", "value", "of", "__typename", "for", "a", "field", "that", "returns", "such", "interface", "At", "least", "internally", "we", "have", "a", "lot", "of", "tooling", "that", "generates", "client", "side", "language", "specific", "models", "NUMBER", "So", "for", "Relay", "we", "have", "flow", "types", "for", "fragment", "that", "you", "define", "NUMBER", "How", "we", "frequently", "do", "this", "NUMBER", "Create", "the", "interface", "definition", "with", "the", "field", "you", "ll", "want", "to", "support", "on", "that", "interface", "NUMBER", "NUMBER", "Add", "a", "field", "to", "another", "type", "which", "returns", "that", "interface", "NUMBER", "On", "the", "server", "the", "implementation", "always", "returns", "null", "NUMBER", "NUMBER", "Build", "your", "client", "use", "the", "generate", "flow", "types", "and", "potentially", "client", "defined", "dummy", "data", "NUMBER", "NUMBER", "Implement", "the", "interface", "with", "a", "specific", "object", "have", "the", "field", "you", "defined", "in", "NUMBER", "return", "that", "object", "NUMBER", "Because", "GraphQL", "schemas", "be", "meant", "to", "be", "forwards", "compatible", "all", "of", "our", "clients", "have", "the", "concept", "of", "an", "unknown", "implementation", "of", "Interface", "Foo", "build", "into", "them", "with", "the", "assumption", "that", "we", "ll", "get", "objects", "with", "__typename", "we", "don", "t", "know", "but", "because", "we", "ve", "build", "our", "fragment", "against", "the", "Interface", "and", "not", "a", "specific", "object", "it", "s", "OK", "NUMBER", "It", "be", "interesting", "to", "see", "this", "PR", "I", "also", "had", "mix", "feelings", "about", "this", "validation", "NUMBER", "In", "my", "case", "ita", "breaking", "change", "as", "well", "NUMBER", "In", "our", "case", "we", "provide", "a", "multi", "tenant", "system", "where", "most", "of", "the", "schema", "be", "static", "but", "small", "parts", "of", "the", "schema", "be", "specific", "to", "the", "tenant", "and", "generate", "dynamically", "for", "each", "project", "it", "be", "a", "set", "of", "custom", "product", "attributes", "NUMBER", "All", "tenant", "defined", "parts", "of", "the", "schema", "implement", "a", "common", "interface", "it", "be", "advantageous", "to", "consider", "the", "interface", "as", "a", "part", "of", "the", "static", "schema", "and", "assume", "that", "it", "be", "always", "present", "for", "all", "tenants", "NUMBER", "On", "the", "other", "hand", "user", "defined", "types", "the", "implementations", "of", "this", "interface", "might", "or", "might", "not", "be", "present", "NUMBER", "So", "it", "be", "possible", "that", "some", "tenants", "end", "up", "in", "a", "situation", "where", "they", "have", "a", "non", "implement", "interface", "NUMBER", "Though", "it", "be", "still", "useful", "to", "have", "this", "interface", "in", "the", "schema", "for", "client", "side", "tooling", "NUMBER", "For", "the", "moment", "be", "we", "disabled", "the", "validation", "in", "our", "project", "NUMBER", "I", "believe", "it", "would", "be", "possible", "to", "refactor", "the", "schema", "but", "I", "think", "I", "would", "prefer", "to", "avoid", "it", "NUMBER", "In", "general", "I", "don", "t", "mind", "this", "validation", "as", "log", "as", "it", "be", "not", "prescribed", "by", "the", "GraphQL", "spec", "NUMBER", "I", "see", "it", "more", "as", "helper", "that", "specific", "implementation", "might", "adopt", "to", "help", "users", "avoid", "common", "schema", "configuration", "issue", "NUMBER", "As", "long", "as", "there", "be", "an", "easy", "way", "to", "disable", "the", "validation", "and", "it", "be", "not", "part", "of", "the", "spec", "I", "think", "it", "should", "be", "fine", "NUMBER", "As", "this", "validation", "will", "not", "be", "include", "in", "graphql", "js", "v", "NUMBER", "I", "m", "going", "to", "merge", "this", "and", "put", "up", "a", "new", "PR", "for", "add", "this", "validation", "back", "in", "NUMBER", "I", "do", "not", "want", "our", "spec", "and", "reference", "implementations", "get", "out", "of", "date", "NUMBER", "I", "m", "still", "very", "open", "to", "add", "this", "validation", "NUMBER", "But", "because", "it", "s", "a", "major", "breaking", "change", "we", "need", "more", "discussion", "on", "the", "value", "of", "this", "enforcement", "vs", "NUMBER", "allowing", "un", "implement", "interfaces", "NUMBER", "New", "PR", "with", "RFC", "NUMBER", "mjmahone", "It", "s", "a", "draft", "version", "of", "a", "specification", "so", "it", "s", "normal", "that", "it", "deviates", "from", "graphql", "js", "NUMBER", "Plus", "it", "safe", "do", "any", "change", "until", "a", "new", "release", "be", "publish", "NUMBER", "I", "agree", "that", "it", "makes", "sense", "to", "prove", "that", "such", "validation", "doesn", "t", "cause", "more", "harm", "than", "good", "NUMBER", "And", "I", "NUMBER", "agree", "that", "it", "worth", "to", "exclude", "this", "validation", "from", "upcoming", "release", "if", "no", "good", "solution", "find", "for", "both", "your", "and", "OlegIlyenko", "use", "cases", "NUMBER", "But", "I", "don", "t", "understand", "what", "be", "a", "reason", "for", "such", "a", "quick", "merge", "NUMBER", "It", "was", "worth", "to", "wait", "at", "least", "a", "day", "to", "hear", "what", "others", "have", "to", "say", "especially", "the", "mattkrick", "the", "author", "of", "original", "PR", "and", "leebyron", "the", "person", "who", "merge", "that", "PR", "NUMBER", "I", "m", "totally", "against", "merge", "such", "non", "trivial", "PRs", "without", "giving", "the", "community", "some", "time", "for", "feedback", "NUMBER", "As", "far", "as", "I", "remember", "previously", "all", "non", "editorial", "change", "were", "opened", "for", "discussion", "for", "more", "than", "NUMBER", "hours", "NUMBER", "IvanGoncharov", "sorry", "about", "that", "NUMBER", "I", "was", "under", "the", "impression", "that", "graphql", "js", "and", "graphql", "needed", "to", "stay", "in", "sync", "as", "quickly", "as", "possible", "NUMBER", "Which", "meant", "in", "my", "mind", "as", "soon", "as", "it", "became", "obvious", "that", "NUMBER", "wasn", "t", "going", "to", "include", "this", "spec", "addition", "we", "should", "get", "rid", "of", "it", "rather", "than", "letting", "the", "two", "drift", "NUMBER", "This", "be", "my", "error", "had", "I", "realized", "it", "was", "OK", "for", "the", "spec", "and", "reference", "implementation", "to", "be", "out", "of", "sync", "for", "a", "few", "days", "I", "would", "have", "happily", "left", "this", "un", "merge", "NUMBER", "I", "m", "sorry", "and", "will", "allow", "more", "time", "for", "comments", "from", "the", "community", "going", "forward", "NUMBER", "Of", "note", "prior", "to", "merge", "this", "I", "had", "reached", "out", "to", "leebyron", "already", "and", "he", "OK", "d", "the", "graphql", "js", "strategy", "NUMBER", "I", "likely", "misunderstood", "what", "he", "wanted", "us", "to", "do", "for", "the", "spec", "though", "NUMBER", "mjmahone", "Thanks", "for", "the", "explanation", "Nothing", "bad", "happened", "but", "I", "think", "it", "s", "a", "good", "idea", "to", "have", "some", "kind", "contribution", "guide", "that", "explains", "what", "to", "do", "in", "such", "situations", "NUMBER", "Also", "if", "possible", "keep", "us", "in", "sync", "with", "Facebook", "internal", "discussions", "so", "we", "be", "all", "on", "the", "same", "page", "NUMBER", "good", "call", "NUMBER", "the", "important", "part", "getPossibleTypes", "returning", "an", "empty", "array", "was", "not", "rolled", "back", "in", "the", "reference", "implementation", "so", "I", "m", "cool", "with", "this", "NUMBER", "The", "multitenancy", "use", "case", "be", "a", "fun", "one", "Certainly", "makes", "the", "case", "for", "favoring", "NUMBER", "to", "many", "over", "NUMBER", "to", "many", "NUMBER", "So", "if", "it", "s", "not", "an", "error", "be", "it", "a", "warning", "info", "Is", "there", "a", "utility", "function", "that", "I", "can", "use", "to", "find", "unuse", "interfaces", "All", "other", "places", "reference", "it", "as", "type", "system", "definition", "language", "NUMBER", "leebyron", "Just", "to", "clarify", "schema", "definition", "language", "was", "renamed", "to", "type", "system", "definition", "language", "right", "So", "what", "abbreviation", "should", "be", "use", "instead", "of", "SDL", "TSDL", "or", "TSD", "Reported", "by", "OlegIlyenko", "in", "LINK", "issuecomment", "NUMBER", "I", "think", "it", "should", "be", "add", "in", "upcomming", "release", "for", "consistency", "with", "other", "definition", "extensions", "NUMBER", "When", "link", "to", "the", "website", "many", "places", "either", "due", "to", "wanting", "to", "stay", "up", "to", "date", "or", "because", "they", "did", "so", "before", "the", "website", "moved", "to", "have", "multiple", "spec", "version", "live", "link", "directly", "to", "a", "position", "in", "the", "spec", "use", "the", "top", "level", "path", "rather", "than", "a", "specific", "version", "NUMBER", "For", "example", "they", "link", "to", "LINK", "sec", "Enums", "rather", "than", "LINK", "sec", "Enums", "The", "problem", "be", "that", "the", "TAG", "refresh", "loses", "any", "query", "string", "or", "hash", "fragment", "of", "the", "URL", "NUMBER", "So", "the", "above", "instead", "of", "redirecting", "to", "the", "desired", "LINK", "sec", "Enums", "instead", "just", "goes", "to", "the", "top", "of", "the", "page", "LINK", "This", "change", "add", "some", "JS", "that", "performs", "the", "redirect", "additionally", "repeating", "the", "current", "URL", "s", "query", "string", "NUMBER", "and", "fragment", "NUMBER", "on", "the", "redirect", "so", "that", "the", "browser", "jumps", "to", "the", "correct", "position", "on", "the", "resulting", "page", "NUMBER", "It", "also", "alters", "the", "TAG", "refresh", "to", "wait", "NUMBER", "second", "allowing", "the", "JS", "to", "get", "in", "but", "still", "offering", "progressive", "enhancement", "for", "cases", "where", "the", "JS", "be", "not", "executed", "NUMBER", "The", "effect", "can", "be", "seen", "by", "comparing", "LINK", "sec", "Enums", "before", "with", "LINK", "sec", "Enums", "after", "ind", "NUMBER", "go", "Thanks", "for", "PR", "BTW", "NUMBER", "index", "NUMBER", "html", "generate", "by", "this", "script", "LINK", "so", "you", "should", "edit", "it", "instead", "NUMBER", "When", "link", "to", "the", "website", "many", "places", "either", "due", "to", "wanting", "to", "stay", "up", "to", "date", "or", "because", "they", "did", "so", "before", "the", "website", "moved", "to", "have", "multiple", "spec", "version", "live", "link", "directly", "to", "a", "position", "in", "the", "spec", "use", "the", "top", "level", "path", "rather", "than", "a", "specific", "version", "NUMBER", "I", "think", "all", "such", "links", "preceded", "NUMBER", "and", "propose", "redirection", "makes", "sense", "only", "for", "October", "NUMBER", "NUMBER", "But", "we", "plan", "to", "publish", "next", "release", "in", "a", "short", "while", "so", "after", "that", "release", "should", "we", "still", "redirect", "to", "October", "NUMBER", "or", "to", "a", "new", "release", "Moreover", "a", "new", "version", "of", "spec", "allows", "you", "to", "reference", "things", "like", "examples", "and", "algorithms", "LINK", "example", "NUMBER", "e", "NUMBER", "d", "LINK", "CollectFields", "And", "such", "links", "be", "very", "useful", "but", "be", "highly", "unstable", "so", "we", "can", "t", "maintain", "them", "between", "release", "NUMBER", "Also", "there", "be", "a", "high", "risk", "that", "text", "surrounding", "a", "link", "will", "contradict", "with", "part", "of", "spec", "it", "references", "because", "of", "specification", "change", "NUMBER", "MSleepyPanda", "Thanks", "for", "quick", "PR", "Would", "be", "great", "if", "you", "also", "fix", "Explanatory", "Text", "in", "the", "same", "section", "to", "keep", "it", "in", "sync", "NUMBER", "While", "i", "m", "at", "it", "re", "Example", "NUMBER", "fragment", "scalarSelectionsNotAllowedOnBoolean", "on", "Dog", "Why", "Boolean", "barkVolume", "be", "an", "Int", "NUMBER", "Also", "the", "intent", "be", "to", "convey", "that", "no", "further", "selections", "be", "allow", "on", "primitives", "NUMBER", "I", "d", "propose", "change", "the", "name", "to", "scalarSelectionsNotAllowed", "NUMBER", "I", "d", "expand", "the", "example", "by", "enumSelectionsNotAllowed", "NUMBER", "While", "i", "m", "at", "it", "re", "Example", "NUMBER", "fragment", "scalarSelectionsNotAllowedOnBoolean", "on", "Dog", "Why", "Boolean", "barkVolume", "be", "an", "Int", "NUMBER", "Also", "the", "intent", "be", "to", "convey", "that", "no", "further", "selections", "be", "allow", "on", "primitives", "NUMBER", "MSleepyPanda", "Good", "catch", "I", "d", "propose", "change", "the", "name", "to", "scalarSelectionsNotAllowed", "NUMBER", "I", "d", "expand", "the", "example", "by", "enumSelectionsNotAllowed", "NUMBER", "Makes", "total", "sense", "to", "me", "but", "I", "suggest", "keep", "onInt", "part", "to", "prevent", "possible", "confusion", "NUMBER", "MSleepyPanda", "This", "and", "NUMBER", "both", "look", "good", "Next", "step", "be", "the", "review", "by", "leebyron", "If", "you", "find", "any", "other", "places", "where", "clarification", "needed", "to", "feel", "free", "to", "open", "PR", "or", "create", "an", "issue", "NUMBER", "For", "motivation", "see", "discussion", "in", "LINK", "To", "achieve", "full", "consistency", "I", "would", "also", "change", "typeA", "and", "typeB", "must", "both", "be", "Non", "Null", "NUMBER", "to", "If", "typeA", "or", "typeB", "be", "not", "a", "Non", "Null", "return", "false", "NUMBER", "Same", "here", "typeA", "and", "typeB", "must", "both", "be", "List", "NUMBER", "Addressed", "review", "In", "the", "section", "NUMBER", "Field", "Arguments", "LINK", "sec", "Field", "Arguments", "Object", "field", "be", "conceptually", "function", "which", "yield", "values", "NUMBER", "Occasionally", "object", "field", "can", "accept", "argument", "to", "further", "specify", "the", "return", "value", "NUMBER", "Object", "field", "argument", "be", "defined", "as", "a", "list", "of", "all", "possible", "argument", "names", "and", "their", "expected", "input", "types", "NUMBER", "All", "argument", "defined", "within", "a", "field", "must", "not", "have", "a", "name", "which", "begins", "with", "__", "two", "underscores", "as", "this", "be", "use", "exclusively", "by", "GraphQL", "s", "introspection", "system", "NUMBER", "For", "example", "a", "Person", "type", "with", "a", "picture", "field", "could", "accept", "an", "argument", "to", "determine", "what", "size", "of", "an", "image", "to", "return", "NUMBER", "It", "misses", "to", "mention", "that", "if", "a", "Type", "be", "a", "NamedType", "it", "can", "only", "refer", "to", "the", "name", "of", "an", "input", "object", "type", "NUMBER", "It", "misses", "to", "mention", "that", "if", "a", "Type", "be", "a", "NamedType", "it", "can", "only", "refer", "to", "the", "name", "of", "an", "input", "object", "type", "NUMBER", "tinganho", "Actually", "no", "also", "you", "can", "use", "scalars", "both", "standard", "String", "Int", "NUMBER", "and", "custom", "NUMBER", "That", "s", "why", "specification", "uses", "input", "type", "term", "for", "everything", "that", "can", "be", "use", "as", "an", "argument", "list", "of", "all", "possible", "argument", "names", "and", "their", "expected", "input", "types", "NUMBER", "OK", "I", "might", "put", "too", "much", "restriction", "NUMBER", "But", "all", "types", "except", "Object", "types", "LINK", "sec", "Objects", "But", "if", "this", "sentence", "be", "clear", "enough", "then", "I", "m", "fine", "to", "close", "list", "of", "all", "possible", "argument", "names", "and", "their", "expected", "input", "types", "NUMBER", "OK", "I", "might", "put", "too", "much", "restriction", "NUMBER", "But", "all", "types", "except", "Object", "types", "Except", "for", "Object", "types", "interfaces", "and", "unions", "and", "the", "same", "types", "wrapped", "in", "List", "and", "NonNull", "NUMBER", "That", "s", "why", "input", "type", "term", "consistently", "use", "in", "specification", "text", "NUMBER", "But", "if", "this", "sentence", "be", "clear", "enough", "then", "I", "m", "fine", "to", "close", "I", "think", "input", "type", "sounds", "very", "similar", "to", "input", "object", "but", "I", "can", "t", "think", "of", "a", "better", "alternative", "NUMBER", "I", "m", "wondering", "if", "there", "be", "any", "plan", "to", "add", "an", "alternative", "binary", "protocol", "to", "GraphQL", "I", "think", "it", "be", "good", "if", "it", "be", "optional", "and", "if", "one", "can", "just", "opt", "in", "to", "it", "NUMBER", "An", "example", "We", "manually", "byte", "encode", "all", "field", "graphql", "type", "RootQuery", "starship", "NUMBER", "type", "Starship", "id", "ID", "NUMBER", "name", "String", "NUMBER", "length", "unit", "LengthUnit", "METER", "Float", "NUMBER", "Instead", "of", "sending", "this", "query", "graphql", "query", "startship", "id", "name", "length", "We", "send", "this", "compact", "one", "instead", "graphql", "NUMBER", "query", "NUMBER", "starhsip", "NUMBER", "id", "NUMBER", "name", "NUMBER", "length", "And", "instead", "of", "receiving", "JSON", "json", "data", "starship", "id", "NUMBER", "name", "Albert", "Einstein", "length", "NUMBER", "We", "receive", "a", "byte", "encoded", "response", "graphql", "NUMBER", "starship", "NUMBER", "NUMBER", "id", "NUMBER", "Albert", "Einstein", "name", "NUMBER", "NUMBER", "length", "The", "binary", "protocol", "should", "not", "replace", "the", "textual", "one", "NUMBER", "I", "still", "think", "it", "be", "good", "with", "JSON", "NUMBER", "Though", "I", "think", "there", "be", "a", "good", "use", "case", "to", "have", "both", "NUMBER", "I", "ve", "seen", "many", "use", "cases", "where", "one", "use", "gRPC", "for", "internal", "communication", "microservice", "to", "microservice", "and", "GraphQL", "for", "external", "API", "NUMBER", "And", "it", "would", "be", "practical", "if", "GraphQL", "just", "allow", "one", "to", "use", "a", "binary", "protocol", "so", "devs", "don", "t", "have", "to", "use", "both", "NUMBER", "JSON", "be", "preferred", "but", "explicitly", "not", "required", "LINK", "sec", "Serialization", "Format", "I", "doubt", "there", "will", "be", "any", "implementation", "of", "an", "alternative", "to", "JSON", "unless", "GraphQL", "support", "blesses", "it", "NUMBER", "Though", "this", "be", "just", "for", "the", "response", "side", "NUMBER", "You", "be", "still", "miss", "the", "request", "side", "gRPC", "space", "that", "would", "work", "well", "alongside", "GraphQL", "I", "m", "not", "sure", "what", "you", "mean", "here", "NUMBER", "To", "enable", "both", "gRPC", "and", "GraphQL", "NUMBER", "You", "have", "to", "define", "your", "types", "or", "message", "for", "both", "NUMBER", "Which", "requires", "a", "lot", "of", "work", "NUMBER", "GraphQL", "be", "just", "lacking", "the", "optimizations", "that", "gRPC", "has", "why", "can", "t", "you", "just", "add", "it", "as", "an", "opt", "in", "feature", "I", "think", "it", "makes", "perfect", "sense", "no", "I", "propose", "the", "possibility", "of", "serializing", "composite", "types", "like", "Object", "into", "scalar", "values", "NUMBER", "This", "functional", "will", "be", "useful", "in", "those", "cases", "when", "some", "object", "can", "be", "represented", "in", "a", "scalar", "value", "but", "it", "provides", "can", "a", "functional", "a", "set", "of", "field", "NUMBER", "We", "can", "use", "the", "name", "__toScalar", "field", "as", "the", "serializable", "value", "name", "NUMBER", "Double", "underline", "at", "the", "beginning", "be", "compatible", "with", "the", "standard", "adopted", "for", "system", "names", "NUMBER", "For", "example", "Definition", "graphql", "type", "DateTimeObject", "year", "Int", "month", "Int", "NUMBER", "ago", "String", "format", "format", "String", "String", "__toScalar", "DateTime", "Usage", "As", "Object", "graphql", "date", "year", "month", "json", "date", "year", "NUMBER", "month", "NUMBER", "As", "Scalar", "graphql", "date", "__toScalar", "field", "usage", "json", "date", "NUMBER", "NUMBER", "NUMBER", "T", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Right", "now", "there", "be", "only", "two", "directives", "in", "core", "include", "which", "ignores", "field", "if", "true", "and", "its", "exact", "opposite", "NUMBER", "skip", "NUMBER", "But", "skip", "be", "poorly", "named", "because", "it", "s", "not", "the", "parallel", "opposite", "word", "NUMBER", "It", "should", "really", "be", "named", "exclude", "to", "make", "the", "API", "more", "consistent", "and", "intuitive", "NUMBER", "I", "realize", "this", "isn", "t", "giving", "us", "new", "functionality", "and", "it", "s", "one", "of", "many", "small", "things", "but", "it", "would", "just", "be", "nice", "from", "a", "design", "and", "consistency", "standpoint", "NUMBER", "NUMBER", "I", "also", "get", "the", "same", "feeling", "after", "work", "with", "other", "extensions", "for", "a", "while", "NUMBER", "On", "a", "side", "note", "but", "I", "think", "it", "be", "a", "bit", "relate", "I", "wanted", "to", "ask", "about", "another", "limitation", "that", "was", "add", "at", "some", "point", "RFC", "Add", "Validation", "rule", "for", "unique", "directives", "per", "location", "NUMBER", "LINK", "From", "the", "moment", "this", "validation", "was", "introduce", "I", "felt", "that", "it", "was", "quite", "limiting", "NUMBER", "Considering", "that", "now", "there", "be", "a", "good", "support", "for", "splitting", "the", "schema", "across", "multiple", "file", "I", "think", "that", "it", "might", "be", "a", "good", "idea", "to", "reassess", "this", "validation", "NUMBER", "Do", "you", "think", "it", "makes", "sense", "to", "reconsider", "it", "I", "personally", "would", "vote", "in", "favor", "of", "remove", "it", "or", "at", "least", "limiting", "the", "validation", "to", "a", "subset", "of", "directives", "Just", "to", "give", "a", "small", "example", "where", "it", "might", "be", "helpful", "NUMBER", "Considering", "the", "schema", "delegation", "case", "where", "multiple", "GraphQL", "schemas", "be", "merge", "into", "one", "NUMBER", "I", "can", "define", "the", "config", "like", "this", "LINK", "gateway", "blob", "master", "testSchema", "NUMBER", "graphql", "L", "NUMBER", "L", "NUMBER", "With", "the", "new", "extension", "I", "can", "potentially", "split", "the", "schema", "in", "NUMBER", "file", "graphql", "file", "NUMBER", "schema", "includeGraphQL", "name", "starWars", "url", "LINK", "graphql", "NUMBER", "org", "graphql", "query", "Query", "file", "NUMBER", "extend", "schema", "includeGraphQL", "name", "universe", "url", "LINK", "But", "even", "if", "directives", "be", "not", "split", "across", "different", "extensions", "I", "would", "still", "find", "it", "helpful", "to", "be", "able", "to", "use", "the", "same", "directive", "multiple", "times", "with", "different", "argument", "at", "the", "same", "location", "NUMBER", "Sure", "thing", "I", "ll", "create", "a", "new", "issue", "NUMBER", "I", "created", "a", "separate", "issue", "for", "this", "Limiting", "the", "scope", "of", "Directives", "Are", "Unique", "Per", "Location", "validation", "LINK", "Similarly", "to", "JS", "s", "shorthand", "object", "props", "destructuring", "I", "d", "like", "to", "propose", "to", "write", "queries", "either", "like", "graphql", "posts", "q", "limit", "id", "content", "or", "more", "simply", "graphql", "posts", "q", "limit", "id", "content", "instead", "of", "the", "current", "graphql", "posts", "q", "q", "limit", "limit", "id", "content", "They", "require", "to", "fit", "the", "models", "argument", "and", "have", "corresponding", "variables", "json", "q", "Foo", "bar", "NUMBER", "limit", "NUMBER", "Also", "I", "find", "it", "really", "verbose", "to", "do", "graphql", "query", "Foo", "id", "ID", "foo", "id", "id", "name", "description", "the", "shorthand", "argument", "wouldn", "t", "simplify", "it", "much", "that", "s", "slightly", "better", "graphql", "query", "Foo", "id", "ID", "foo", "id", "name", "description", "My", "problem", "be", "with", "the", "query", "or", "mutation", "or", "subscription", "wrapper", "NUMBER", "I", "understand", "it", "s", "good", "to", "put", "the", "type", "constraint", "for", "a", "variable", "only", "once", "I", "can", "t", "see", "a", "better", "way", "though", "When", "we", "have", "a", "big", "API", "with", "several", "function", "NUMBER", "We", "have", "a", "gigantic", "documentation", "of", "Schema", "with", "queries", "mutations", "and", "subscriptions", "NUMBER", "So", "this", "gets", "complicated", "and", "confusing", "with", "time", "because", "of", "the", "order", "of", "things", "NUMBER", "A", "separator", "in", "sessions", "besides", "the", "own", "comments", "with", "something", "like", "Accordion", "would", "be", "perfect", "NUMBER", "Cheers", "NUMBER", "I", "write", "here", "because", "I", "thought", "it", "was", "your", "team", "who", "support", "GraphiQL", "NUMBER", "To", "have", "something", "like", "Accordion", "would", "need", "to", "create", "something", "in", "the", "graphql", "syntax", "to", "get", "such", "a", "feature", "NUMBER", "I", "m", "wrong", "MichelDiz", "try", "posting", "an", "issue", "on", "the", "GraphiQL", "repo", "LINK", "this", "repo", "be", "for", "the", "GraphQL", "spec", "GraphiQL", "with", "the", "I", "be", "the", "IDE", "NUMBER", "I", "know", "that", "I", "think", "you", "didn", "t", "understand", "my", "point", "NUMBER", "The", "IDE", "will", "be", "irrelevant", "if", "there", "be", "no", "specification", "in", "the", "GraphQL", "syntax", "NUMBER", "Did", "you", "get", "it", "PS", "You", "would", "need", "to", "specify", "in", "Schema", "where", "and", "when", "to", "do", "Accordion", "NUMBER", "IDE", "react", "to", "Schema", "NUMBER", "Matches", "graphql", "js", "PR", "LINK", "js", "pull", "NUMBER", "For", "background", "see", "LINK", "js", "issue", "NUMBER", "I", "think", "we", "should", "change", "the", "spec", "and", "revert", "this", "change", "there", "be", "no", "reason", "a", "schema", "should", "be", "required", "to", "have", "objects", "implement", "each", "interface", "NUMBER", "A", "very", "common", "pattern", "be", "to", "create", "an", "interface", "first", "start", "programming", "against", "that", "then", "weeks", "later", "actually", "implement", "that", "interface", "NUMBER", "This", "be", "also", "a", "really", "nasty", "breaking", "change", "for", "large", "exist", "schemas", "NUMBER", "image", "LINK", "images", "NUMBER", "githubusercontent", "NUMBER", "com", "NUMBER", "NUMBER", "NUMBER", "a", "NUMBER", "c", "NUMBER", "fd", "NUMBER", "e", "NUMBER", "NUMBER", "bec", "NUMBER", "e", "NUMBER", "f", "NUMBER", "cf", "NUMBER", "png", "LINK", "example", "a", "NUMBER", "Thanks", "I", "miss", "it", "in", "NUMBER", "Can", "you", "please", "sign", "CLA", "Done", "Subscription", "allows", "client", "to", "get", "message", "when", "they", "appear", "but", "in", "case", "of", "failures", "client", "do", "not", "have", "the", "option", "to", "ack", "nack", "to", "skip", "message", "NUMBER", "This", "allows", "the", "replay", "of", "message", "Better", "transaction", "handle", "Simply", "Put", "Exposing", "kakfa", "via", "graphql", "schema", "Exposing", "kakfa", "via", "graphql", "schema", "On", "Mar", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "AM", "Senthil", "Sivanath", "TAG", "write", "Subscription", "allows", "client", "to", "get", "message", "when", "they", "appear", "but", "in", "case", "of", "failures", "client", "do", "not", "have", "the", "option", "to", "ack", "nack", "to", "skip", "message", "NUMBER", "This", "allows", "the", "replay", "of", "message", "Better", "transaction", "handle", "Simply", "Put", "Exposing", "kakfa", "via", "graphql", "schema", "You", "be", "receiving", "this", "because", "you", "be", "subscribed", "to", "this", "thread", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "Rendering", "Preview", "LINK", "nmocjoypvp", "NUMBER", "now", "NUMBER", "sh", "This", "be", "a", "NON", "BREAKING", "validation", "change", "which", "allows", "some", "previously", "invalid", "queries", "NUMBER", "It", "be", "also", "a", "behavioral", "execution", "change", "which", "change", "how", "values", "interact", "with", "variable", "and", "argument", "default", "values", "NUMBER", "There", "be", "currently", "ambiguity", "and", "inconsistency", "in", "how", "null", "values", "be", "coerced", "and", "resolve", "as", "part", "of", "variable", "values", "default", "values", "and", "argument", "values", "NUMBER", "This", "inconsistency", "and", "ambiguity", "can", "allow", "for", "null", "values", "to", "appear", "at", "non", "null", "argument", "which", "might", "result", "in", "unforseen", "null", "pointer", "error", "NUMBER", "The", "version", "of", "this", "proposal", "to", "be", "merge", "include", "the", "following", "NEW", "Non", "null", "argument", "and", "input", "object", "field", "be", "no", "longer", "required", "to", "be", "provide", "a", "value", "variable", "if", "that", "argument", "also", "supplies", "a", "default", "value", "NUMBER", "NEW", "Similarly", "non", "null", "input", "object", "field", "can", "be", "omitted", "if", "they", "supply", "a", "default", "value", "NUMBER", "Note", "that", "previously", "this", "validation", "clause", "was", "miss", "from", "the", "spec", "however", "has", "long", "be", "include", "in", "reference", "implementations", "NEW", "All", "variables", "can", "now", "have", "default", "values", "by", "way", "of", "remove", "a", "validation", "rule", "NUMBER", "Previously", "it", "was", "invalid", "to", "supply", "a", "default", "value", "with", "a", "non", "null", "variable", "NUMBER", "BUG", "FIX", "Variables", "with", "a", "nullable", "type", "and", "a", "null", "default", "value", "cannot", "be", "provide", "to", "a", "non", "null", "argument", "or", "input", "field", "NUMBER", "NEW", "Optional", "nullable", "variables", "can", "now", "be", "use", "for", "argument", "or", "input", "object", "field", "which", "supply", "default", "values", "NUMBER", "CLARITY", "Redefine", "CoerceVariableValues", "to", "make", "it", "more", "clear", "how", "to", "treat", "a", "lack", "of", "runtime", "value", "vs", "the", "explicit", "value", "null", "with", "respect", "to", "default", "values", "and", "type", "coercion", "NUMBER", "NEW", "Redefine", "CoerceArgumentValues", "to", "ensure", "provide", "a", "null", "variable", "value", "to", "a", "Non", "Null", "argument", "type", "causes", "a", "field", "error", "and", "to", "add", "clarity", "to", "how", "null", "values", "and", "default", "values", "should", "be", "treated", "NUMBER", "NEW", "Redefine", "Input", "object", "coercion", "rules", "to", "ensure", "provide", "a", "null", "value", "or", "runtime", "variable", "value", "to", "a", "non", "null", "type", "causes", "a", "field", "error", "and", "improve", "clarity", "for", "these", "coercion", "rules", "NUMBER", "This", "mirrors", "the", "change", "to", "CoerceArgumentValues", "NUMBER", "Previous", "version", "of", "this", "proposal", "TAG", "This", "appears", "in", "three", "distinct", "but", "relate", "issue", "Validation", "All", "Variable", "Usages", "be", "Allowed", "The", "explicit", "value", "null", "may", "be", "use", "as", "a", "default", "value", "for", "a", "variable", "with", "a", "nullable", "type", "however", "this", "rule", "asks", "to", "treat", "a", "variable", "s", "type", "as", "non", "null", "if", "it", "has", "a", "default", "value", "NUMBER", "Instead", "this", "rule", "should", "specifically", "only", "treat", "the", "variable", "s", "type", "as", "non", "null", "if", "the", "default", "value", "be", "not", "null", "NUMBER", "Additionally", "the", "AreTypesCompatible", "algorithm", "be", "underspecificied", "which", "could", "lead", "to", "further", "misinterpretation", "of", "this", "validation", "rule", "NUMBER", "Coercing", "Variable", "Values", "CoerceVariableValues", "allows", "the", "explicit", "null", "value", "to", "be", "use", "instead", "of", "a", "default", "value", "NUMBER", "This", "can", "result", "in", "a", "null", "value", "flowing", "to", "a", "non", "null", "argument", "due", "to", "the", "validation", "rule", "mention", "above", "NUMBER", "Instead", "a", "default", "value", "must", "be", "use", "even", "when", "an", "explicit", "null", "value", "be", "provide", "NUMBER", "This", "be", "also", "more", "consistent", "with", "the", "explanation", "for", "validation", "rule", "Variable", "Default", "Value", "Is", "Allowed", "Also", "how", "to", "treat", "an", "explicit", "null", "value", "be", "currently", "underspecified", "NUMBER", "While", "an", "input", "object", "explains", "that", "a", "null", "value", "should", "result", "in", "an", "explicit", "null", "value", "at", "the", "input", "object", "field", "there", "be", "no", "similar", "explaination", "for", "typical", "scalar", "input", "types", "NUMBER", "Instead", "CoerceVariableValues", "should", "explicitly", "handle", "the", "null", "value", "to", "make", "it", "clear", "a", "null", "be", "the", "resulting", "value", "in", "the", "coercedValues", "Map", "NUMBER", "Coercing", "Argument", "Values", "The", "CoerceArgumentValues", "algorithm", "be", "intentionally", "similar", "to", "CoerceVariableValues", "and", "suffers", "from", "the", "same", "inconsistency", "NUMBER", "Explicit", "null", "values", "should", "not", "take", "precedence", "over", "default", "values", "and", "should", "also", "be", "explicitly", "handle", "rather", "than", "left", "to", "underspecified", "input", "scalar", "coercion", "NUMBER", "Since", "this", "change", "behavior", "I", "d", "love", "your", "feedback", "IvanGoncharov", "OlegIlyenko", "et", "al", "cc", "bbakerman", "leebyron", "I", "fully", "agree", "with", "the", "change", "from", "Validation", "All", "Variable", "Usages", "be", "Allowed", "Coercing", "Variable", "Values", "Coercing", "Argument", "Values", "Explicit", "null", "values", "should", "not", "take", "precedence", "over", "default", "values", "NUMBER", "This", "be", "very", "confusing", "at", "the", "first", "glance", "especially", "for", "argument", "values", "NUMBER", "Here", "be", "the", "example", "from", "JS", "js", "function", "f", "arg", "foo", "return", "arg", "f", "foo", "f", "null", "null", "f", "bar", "bar", "And", "same", "in", "Python", "and", "probably", "all", "other", "langs", "so", "I", "would", "expect", "the", "same", "from", "GraphQL", "NUMBER", "But", "I", "fully", "understand", "technical", "challenge", "here", "so", "I", "need", "to", "think", "more", "about", "it", "NUMBER", "Absolutely", "correct", "IvanGoncharov", "NUMBER", "There", "be", "two", "paths", "forward", "to", "solve", "for", "the", "ambiguity", "each", "of", "which", "have", "some", "tradeoffs", "NUMBER", "The", "path", "I", "m", "proposing", "here", "preserves", "the", "ability", "to", "treat", "var", "String", "default", "as", "non", "nullable", "and", "usable", "in", "an", "argument", "expecting", "String", "NUMBER", "The", "tradeoff", "be", "that", "a", "default", "value", "would", "take", "precedence", "over", "an", "explicit", "null", "value", "NUMBER", "The", "alternative", "be", "to", "no", "longer", "treat", "var", "String", "default", "as", "non", "nullable", "while", "preserving", "explicit", "null", "over", "default", "values", "NUMBER", "This", "would", "mean", "queries", "which", "pass", "variables", "with", "default", "values", "to", "argument", "expecting", "non", "null", "types", "would", "no", "longer", "be", "valid", "NUMBER", "My", "concern", "be", "that", "the", "change", "cost", "of", "this", "alternative", "be", "too", "high", "since", "passing", "a", "variable", "with", "a", "default", "value", "to", "a", "non", "null", "argument", "be", "an", "exist", "pattern", "NUMBER", "However", "I", "m", "less", "certain", "how", "common", "overriding", "a", "default", "value", "with", "an", "explicit", "null", "value", "be", "though", "I", "certainly", "understand", "the", "incongruity", "with", "exist", "programming", "languages", "NUMBER", "I", "haven", "t", "find", "an", "example", "of", "it", "within", "queries", "at", "Facebook", "yet", "so", "I", "would", "love", "to", "hear", "use", "cases", "to", "better", "understand", "change", "cost", "NUMBER", "It", "s", "an", "interesting", "change", "NUMBER", "I", "remember", "the", "time", "when", "I", "finally", "correctly", "implement", "the", "support", "for", "the", "null", "in", "sangria", "NUMBER", "As", "far", "as", "I", "remember", "my", "initial", "implementation", "was", "doing", "the", "same", "as", "was", "suggested", "in", "this", "PR", "Explicit", "null", "values", "should", "not", "take", "precedence", "over", "default", "values", "NUMBER", "NUMBER", "Later", "on", "I", "refactored", "it", "in", "order", "to", "comply", "with", "the", "reference", "implementation", "NUMBER", "Along", "the", "way", "I", "also", "faced", "these", "issue", "where", "null", "value", "can", "potentially", "appear", "in", "nullable", "the", "argument", "with", "a", "default", "value", "which", "might", "be", "treated", "as", "not", "null", "since", "it", "has", "a", "default", "NUMBER", "As", "a", "solution", "to", "this", "problem", "I", "introduce", "following", "NUMBER", "things", "I", "delay", "the", "value", "resolution", "to", "the", "last", "moment", "NUMBER", "This", "led", "to", "the", "introduction", "of", "a", "new", "Trinary", "LINK", "graphql", "sangria", "blob", "cb", "NUMBER", "d", "NUMBER", "b", "NUMBER", "de", "NUMBER", "f", "NUMBER", "fd", "NUMBER", "e", "NUMBER", "a", "NUMBER", "bfa", "NUMBER", "dc", "NUMBER", "src", "main", "scala", "sangria", "execution", "ValueCoercionHelper", "NUMBER", "scala", "L", "NUMBER", "L", "NUMBER", "container", "which", "able", "to", "preserve", "information", "about", "the", "default", "value", "NullWithDefault", "NUMBER", "By", "default", "nullable", "argument", "with", "a", "default", "value", "be", "treated", "as", "non", "null", "on", "a", "type", "level", "NUMBER", "But", "since", "I", "have", "a", "Trinary", "value", "around", "I", "can", "force", "the", "usage", "of", "a", "default", "value", "which", "might", "come", "from", "the", "variable", "definition", "this", "one", "has", "precedence", "over", "other", "default", "values", "or", "argument", "input", "field", "default", "NUMBER", "I", "also", "provide", "an", "extra", "function", "to", "get", "a", "nullable", "variation", "of", "the", "value", "Option", "Value", "this", "one", "behaves", "in", "the", "same", "way", "as", "reference", "implementation", "at", "the", "moment", "NUMBER", "I", "find", "this", "solution", "quite", "robust", "by", "default", "it", "behaves", "similarly", "to", "the", "proposal", "in", "this", "PR", "but", "it", "also", "provides", "a", "way", "to", "propagate", "explicit", "null", "value", "and", "ignore", "all", "of", "the", "defaults", "when", "this", "information", "be", "significant", "NUMBER", "Though", "it", "be", "still", "possible", "to", "trick", "the", "system", "by", "setting", "the", "default", "value", "to", "null", "like", "here", "graphql", "type", "Query", "article", "id", "ID", "null", "Atricle", "Do", "you", "think", "it", "would", "make", "sense", "to", "disallow", "this", "for", "argument", "input", "field", "and", "variables", "I", "personally", "don", "t", "have", "practical", "insights", "on", "API", "that", "takes", "advantage", "of", "the", "null", "value", "NUMBER", "I", "know", "that", "some", "people", "use", "it", "to", "explicitly", "unset", "field", "in", "the", "database", "NUMBER", "But", "in", "this", "scenario", "I", "don", "t", "really", "see", "the", "need", "for", "a", "default", "value", "NUMBER", "So", "it", "s", "hard", "for", "me", "to", "assess", "the", "impact", "of", "this", "change", "but", "I", "find", "the", "use", "case", "quite", "niche", "NUMBER", "leebyron", "It", "s", "not", "an", "ideal", "solution", "since", "we", "be", "trying", "to", "fix", "validation", "issue", "by", "change", "execution", "behavior", "NUMBER", "Ideally", "we", "would", "allow", "defaults", "to", "be", "specified", "on", "nonull", "argument", "graphql", "query", "foo", "arg", "String", "foo", "arg", "foo", "arg", "null", "Exception", "query", "bar", "arg", "String", "bar", "arg", "bar", "arg", "null", "arg", "null", "But", "it", "s", "not", "a", "viable", "alternative", "since", "it", "will", "break", "huge", "number", "of", "exist", "queries", "So", "practically", "speaking", "if", "there", "be", "no", "GraphQL", "APIs", "that", "distinguish", "between", "null", "and", "default", "value", "in", "field", "argument", "then", "I", "don", "t", "see", "a", "point", "to", "fight", "for", "theoretical", "purity", "NUMBER", "That", "said", "I", "think", "it", "s", "very", "important", "question", "so", "we", "need", "to", "be", "extremely", "careful", "and", "do", "some", "research", "beyond", "the", "Facebook", "use", "case", "NUMBER", "I", "volunteer", "to", "do", "research", "on", "a", "major", "public", "APIs", "Shopify", "Yelp", "NUMBER", "NUMBER", "GitHub", "was", "my", "first", "victim", "and", "tried", "to", "pass", "nulls", "in", "every", "field", "with", "a", "default", "argument", "NUMBER", "A", "few", "of", "them", "treat", "null", "the", "same", "way", "as", "absent", "value", "but", "in", "one", "case", "it", "actually", "broke", "query", "image", "LINK", "images", "NUMBER", "githubusercontent", "NUMBER", "com", "NUMBER", "NUMBER", "NUMBER", "e", "NUMBER", "NUMBER", "NUMBER", "e", "NUMBER", "NUMBER", "f", "NUMBER", "NUMBER", "b", "NUMBER", "a", "NUMBER", "d", "NUMBER", "png", "Moreover", "in", "GitHub", "schema", "repository", "defined", "as", "nullable", "so", "absence", "of", "this", "field", "inside", "data", "suggests", "that", "it", "wasn", "t", "simple", "exception", "inside", "resolver", "NUMBER", "IIUC", "this", "be", "the", "same", "issue", "as", "LINK", "I", "also", "find", "the", "explicit", "nulls", "don", "t", "take", "precedence", "over", "defaults", "confusing", "NUMBER", "Per", "the", "issue", "I", "originally", "file", "I", "think", "this", "can", "be", "solve", "by", "by", "allowing", "non", "null", "variables", "argument", "input", "field", "to", "have", "default", "values", "NUMBER", "This", "be", "I", "think", "what", "you", "mean", "by", "The", "alternative", "be", "to", "no", "longer", "treat", "var", "String", "default", "as", "non", "nullable", "while", "preserving", "explicit", "null", "over", "default", "values", "NUMBER", "This", "would", "mean", "queries", "which", "pass", "variables", "with", "default", "values", "to", "argument", "expecting", "non", "null", "types", "would", "no", "longer", "be", "valid", "NUMBER", "The", "change", "cost", "of", "that", "approach", "be", "real", "but", "the", "migration", "be", "fairly", "trivial", "and", "I", "think", "important", "anywhere", "that", "this", "ambiguity", "currently", "occur", "the", "author", "be", "forced", "to", "resolve", "it", "by", "add", "a", "to", "the", "variable", "to", "make", "it", "clear", "that", "explicit", "nulls", "be", "forbidden", "NUMBER", "If", "they", "did", "intend", "to", "support", "nulls", "for", "that", "variable", "then", "their", "query", "be", "invalid", "no", "matter", "what", "and", "that", "s", "something", "they", "should", "be", "aware", "of", "NUMBER", "Excellent", "feedback", "everyone", "NUMBER", "I", "ve", "made", "serious", "revisions", "which", "I", "hope", "both", "protect", "against", "allowing", "null", "values", "to", "non", "null", "argument", "while", "preserving", "exist", "behavior", "NUMBER", "The", "result", "be", "a", "bit", "broader", "in", "scope", "however", "no", "longer", "breaks", "exist", "queries", "in", "either", "validation", "or", "execution", "NUMBER", "The", "reference", "PR", "has", "also", "be", "update", "in", "graphql", "graphql", "js", "NUMBER", "This", "update", "better", "defines", "the", "difference", "between", "a", "required", "and", "non", "null", "argument", "input", "field", "as", "a", "non", "null", "type", "which", "include", "a", "default", "value", "be", "no", "longer", "required", "NUMBER", "As", "such", "the", "validation", "rule", "which", "prohibited", "queries", "from", "use", "non", "null", "variables", "and", "default", "values", "has", "be", "remove", "completely", "NUMBER", "This", "change", "also", "add", "clarity", "to", "the", "input", "field", "validation", "this", "rule", "has", "existed", "in", "the", "GraphQL", "NUMBER", "js", "reference", "implementation", "however", "was", "find", "miss", "within", "the", "spec", "NUMBER", "It", "essentially", "mirrors", "the", "change", "of", "the", "required", "argument", "rule", "NUMBER", "This", "also", "update", "the", "CoerceVariableValues", "and", "CoerceArgumentValues", "algorithms", "to", "retain", "the", "behavior", "of", "explicit", "null", "values", "overriding", "a", "default", "value", "minimizing", "breaking", "change", "however", "critically", "add", "additional", "protection", "to", "CoerceArgumentValues", "to", "explicitly", "block", "null", "variable", "values", "from", "passing", "into", "a", "non", "null", "argument", "NUMBER", "This", "retains", "the", "exist", "common", "pattern", "of", "passing", "a", "nullable", "variable", "with", "a", "default", "value", "into", "a", "non", "null", "argument", "while", "remove", "the", "problematic", "case", "of", "an", "explicit", "null", "value", "at", "runtime", "NUMBER", "I", "d", "love", "another", "look", "at", "this", "and", "the", "accompanying", "PR", "NUMBER", "I", "feel", "confident", "in", "this", "approach", "but", "would", "appreciate", "your", "feedback", "NUMBER", "I", "m", "a", "bit", "torn", "on", "the", "one", "hand", "I", "think", "this", "approach", "be", "probably", "the", "best", "we", "can", "do", "in", "terms", "of", "a", "clarification", "that", "be", "strictly", "non", "breaking", "NUMBER", "On", "the", "other", "hand", "I", "m", "not", "sure", "that", "strictly", "non", "breaking", "be", "something", "we", "should", "be", "striving", "for", "in", "this", "case", "The", "last", "publish", "spec", "be", "still", "marked", "as", "a", "draft", "with", "no", "implicit", "or", "explicit", "compatibility", "guarantees", "NUMBER", "Even", "Golang", "whose", "explicit", "compatibility", "guarantee", "LINK", "be", "one", "I", "use", "as", "a", "good", "model", "reserves", "the", "right", "to", "clarify", "undefined", "or", "inconsistent", "behaviour", "in", "a", "way", "that", "may", "break", "program", "NUMBER", "The", "from", "scratch", "design", "if", "we", "weren", "t", "concerned", "about", "compatibility", "at", "all", "be", "I", "think", "fairly", "uncontroversially", "to", "decouple", "default", "values", "from", "the", "nullability", "of", "argument", "entirely", "NUMBER", "For", "anyone", "new", "to", "the", "spec", "that", "behaviour", "seems", "the", "least", "surprising", "and", "much", "simpler", "than", "the", "behaviour", "propose", "here", "NUMBER", "I", "realize", "that", "putting", "a", "breaking", "change", "like", "that", "in", "the", "spec", "causes", "its", "own", "huge", "set", "of", "pains", "for", "implementations", "that", "have", "to", "migrate", "but", "I", "guess", "I", "m", "not", "convinced", "that", "isn", "t", "still", "the", "best", "long", "term", "solution", "NUMBER", "All", "that", "said", "I", "do", "believe", "this", "current", "approach", "be", "the", "best", "we", "can", "do", "while", "be", "non", "breaking", "so", "if", "that", "s", "the", "way", "that", "we", "want", "to", "go", "then", "I", "won", "t", "object", "further", "NUMBER", "Change", "the", "Variable", "Usages", "be", "Allowed", "rule", "tweaking", "the", "rules", "for", "treating", "nullable", "variables", "as", "non", "null", "for", "the", "sake", "of", "determining", "where", "they", "re", "allow", "to", "be", "use", "NUMBER", "This", "be", "not", "what", "I", "would", "do", "in", "a", "from", "scratch", "design", "NUMBER", "Instead", "I", "would", "propose", "remove", "the", "ability", "for", "nullable", "variables", "to", "flow", "into", "non", "null", "argument", "at", "all", "NUMBER", "Yup", "this", "be", "the", "one", "that", "be", "bugging", "me", "I", "will", "look", "at", "editing", "this", "to", "both", "make", "it", "more", "clear", "where", "the", "caveat", "for", "exist", "systems", "be", "while", "make", "it", "possible", "or", "even", "encourage", "for", "new", "systems", "not", "to", "adopt", "that", "caveat", "NUMBER", "Awesome", "NUMBER", "I", "was", "going", "to", "suggest", "that", "we", "include", "an", "RFC", "NUMBER", "header", "in", "the", "spec", "so", "we", "can", "use", "SHOULD", "MAY", "appropriately", "here", "but", "I", "note", "that", "you", "already", "did", "that", "it", "just", "hasn", "t", "made", "it", "into", "LINK", "yet", "NUMBER", "I", "think", "that", "servers", "SHOULD", "prevent", "nullable", "variables", "from", "flowing", "into", "non", "null", "argument", "but", "they", "MAY", "permit", "it", "in", "accordance", "with", "old", "version", "of", "the", "spec", "in", "order", "to", "maintain", "compatibility", "NUMBER", "Thoughts", "be", "there", "other", "differences", "from", "the", "current", "state", "of", "this", "PR", "that", "you", "would", "consider", "approaching", "differently", "in", "a", "from", "scratch", "design", "I", "ll", "go", "through", "again", "but", "I", "think", "that", "was", "the", "only", "one", "NUMBER", "However", "I", "don", "t", "think", "we", "should", "be", "terribly", "concerned", "with", "a", "bifurcation", "of", "tooling", "NUMBER", "I", "agree", "with", "mike", "marcacci", "I", "think", "most", "of", "the", "tooling", "doesn", "t", "need", "to", "be", "backward", "compatible", "NUMBER", "There", "be", "only", "one", "scenario", "we", "shouldn", "t", "break", "exist", "queries", "compiled", "inside", "clients", "that", "were", "deployed", "in", "production", "should", "be", "still", "support", "by", "GraphQL", "server", "NUMBER", "That", "means", "that", "all", "client", "libraries", "ESlint", "plugin", "client", "code", "generation", "GraphiQL", "and", "other", "libraries", "tool", "that", "be", "use", "only", "in", "development", "or", "during", "build", "process", "can", "be", "easily", "update", "NUMBER", "The", "only", "part", "of", "the", "ecosystem", "that", "should", "be", "backward", "compatible", "be", "GraphQL", "servers", "and", "maybe", "some", "proxy", "servers", "e", "NUMBER", "g", "NUMBER", "Apollo", "Engine", "NUMBER", "That", "s", "why", "I", "think", "both", "specification", "and", "graphql", "js", "should", "use", "from", "scratch", "behavior", "by", "default", "NUMBER", "Compatibility", "section", "of", "the", "specification", "can", "provide", "an", "alternative", "version", "of", "IsVariableUsageAllowed", "function", "and", "graphql", "js", "can", "have", "VariablesInAllowedPositionCompatible", "validation", "rule", "NUMBER", "Because", "we", "re", "already", "altering", "the", "spec", "for", "query", "validation", "to", "expand", "the", "definition", "of", "validity", "we", "re", "going", "to", "see", "a", "mismatch", "in", "the", "wild", "some", "servers", "won", "t", "update", "their", "software", "while", "new", "clients", "will", "expect", "looser", "queries", "to", "work", "NUMBER", "This", "be", "not", "a", "problem", "since", "if", "a", "new", "client", "stops", "work", "with", "old", "servers", "it", "would", "be", "caught", "during", "development", "NUMBER", "So", "I", "think", "we", "should", "distinguish", "between", "change", "that", "will", "break", "already", "deployed", "clients", "and", "change", "that", "will", "result", "in", "temporary", "inconvenience", "during", "development", "NUMBER", "However", "I", "fully", "agree", "that", "breaking", "change", "be", "unavoidable", "in", "the", "future", "and", "we", "should", "prepare", "for", "them", "This", "be", "probably", "unavoidable", "and", "makes", "me", "think", "that", "there", "should", "be", "a", "graphql", "version", "or", "programmatically", "readable", "feature", "set", "as", "discussed", "in", "the", "WG", "meeting", "supplied", "in", "the", "result", "of", "an", "introspection", "query", "NUMBER", "I", "think", "any", "mechanism", "involving", "introspection", "query", "be", "not", "a", "solution", "since", "the", "majority", "of", "GraphQL", "clients", "doesn", "t", "do", "any", "handshake", "they", "just", "send", "queries", "to", "the", "server", "NUMBER", "So", "the", "only", "solution", "I", "see", "be", "for", "sever", "to", "detect", "what", "was", "the", "expected", "behavior", "during", "client", "development", "and", "fallback", "to", "it", "NUMBER", "So", "I", "think", "having", "some", "kind", "of", "graphql", "version", "delivered", "together", "with", "GraphQL", "query", "be", "the", "right", "call", "NUMBER", "After", "discussing", "this", "in", "depth", "with", "dschafer", "at", "a", "whiteboard", "we", "ve", "talked", "ourselves", "out", "of", "any", "breaking", "change", "I", "think", "that", "having", "a", "fork", "in", "the", "expected", "behavior", "of", "validation", "rules", "be", "just", "too", "easy", "to", "get", "wrong", "liable", "to", "cause", "issue", "during", "deployment", "and", "could", "create", "a", "bifurcation", "of", "tooling", "environments", "NUMBER", "We", "came", "up", "with", "mitigation", "strategies", "for", "Facebook", "s", "codebases", "and", "APIs", "however", "also", "agreed", "that", "public", "APIs", "like", "Github", "would", "be", "much", "much", "more", "challenging", "to", "solve", "for", "NUMBER", "leebyron", "I", "want", "to", "propose", "a", "solution", "NUMBER", "Currently", "all", "GraphQL", "clients", "send", "GraphQL", "request", "document", "inside", "query", "field", "NUMBER", "But", "ExecuteRequest", "names", "the", "same", "parameter", "document", "ExecuteRequest", "schema", "document", "operationName", "variableValues", "initialValue", "So", "it", "makes", "sense", "to", "rename", "this", "field", "to", "document", "inside", "GraphQL", "request", "NUMBER", "In", "addition", "to", "that", "we", "can", "make", "version", "a", "required", "field", "for", "all", "request", "that", "use", "document", "NUMBER", "And", "both", "specification", "and", "reference", "implementation", "should", "provide", "the", "algorithm", "for", "converting", "request", "documents", "to", "a", "new", "version", "NUMBER", "So", "a", "server", "can", "implement", "the", "following", "algorithm", "Request", "contains", "document", "if", "the", "request", "also", "contains", "query", "return", "a", "fatal", "error", "if", "the", "request", "doesn", "t", "contain", "version", "return", "a", "fatal", "error", "use", "version", "from", "the", "request", "Request", "contains", "query", "then", "assume", "version", "be", "equal", "to", "legacy", "one", "e", "NUMBER", "g", "NUMBER", "NUMBER", "if", "version", "be", "newer", "than", "the", "last", "version", "support", "by", "server", "return", "fatal", "error", "NUMBER", "Pros", "Don", "t", "break", "any", "deployed", "client", "NUMBER", "Add", "version", "to", "queries", "that", "allow", "bugfixes", "similar", "to", "this", "one", "NUMBER", "Allows", "clear", "error", "message", "Rename", "query", "to", "document", "that", "makes", "sense", "on", "its", "own", "and", "solve", "a", "lot", "of", "terminology", "problem", "NUMBER", "Cons", "One", "additional", "field", "in", "every", "request", "NUMBER", "New", "clients", "stop", "work", "with", "old", "servers", "NUMBER", "I", "also", "think", "we", "should", "use", "an", "integer", "for", "version", "field", "and", "increment", "it", "only", "when", "breaking", "change", "be", "made", "NUMBER", "I", "think", "these", "be", "interesting", "ideas", "but", "I", "d", "love", "to", "avoid", "expanding", "the", "surface", "area", "of", "this", "proposal", "since", "I", "believe", "it", "be", "in", "a", "final", "reviewable", "state", "NUMBER", "Agreed", "apologies", "for", "nudging", "the", "discussion", "off", "topic", "NUMBER", "To", "reiterate", "what", "I", "intended", "to", "be", "the", "core", "point", "of", "my", "review", "the", "current", "proposal", "successfully", "avoids", "breaking", "things", "that", "be", "already", "deployed", "while", "add", "very", "little", "mess", "NUMBER", "This", "ended", "up", "a", "much", "cleaner", "solution", "than", "initially", "seem", "possible", "I", "m", "looking", "to", "create", "a", "GraphQL", "query", "that", "selectively", "add", "remove", "field", "based", "on", "a", "variable", "type", "which", "be", "a", "string", "query", "ResultsPage", "casetype", "String", "According", "to", "the", "reference", "on", "Directives", "you", "can", "use", "a", "boolean", "value", "to", "either", "include", "or", "skip", "certain", "field", "query", "Hero", "episode", "Episode", "withFriends", "Boolean", "hero", "episode", "episode", "name", "friends", "include", "if", "withFriends", "name", "How", "could", "I", "do", "something", "similar", "with", "this", "string", "value", "i", "NUMBER", "e", "NUMBER", "only", "include", "the", "friends", "field", "if", "casetype", "foo", "NUMBER", "What", "be", "the", "best", "way", "to", "approach", "this", "problem", "use", "GraphQL", "Thanks", "romeboards", "GraphQL", "be", "designed", "to", "be", "as", "simple", "as", "possible", "so", "it", "doesn", "t", "support", "constructions", "from", "programming", "languages", "e", "NUMBER", "g", "NUMBER", "comparations", "NUMBER", "So", "you", "can", "include", "exclude", "field", "only", "based", "on", "the", "boolean", "query", "parameters", "NUMBER", "But", "as", "I", "understand", "you", "want", "to", "change", "query", "result", "based", "value", "of", "enum", "which", "be", "not", "possible", "according", "to", "GraphQL", "spec", "NUMBER", "So", "can", "you", "please", "describe", "your", "use", "case", "in", "more", "details", "Mainly", "how", "be", "your", "schema", "looks", "like", "and", "why", "your", "frontend", "needs", "different", "responses", "GraphQL", "be", "very", "powerful", "for", "query", "but", "be", "weak", "for", "mutation", "in", "my", "opinion", "NUMBER", "Second", "GraphQL", "be", "based", "on", "resolvers", "there", "be", "no", "resources", "concept", "which", "makes", "create", "update", "and", "destroy", "actions", "complex", "NUMBER", "For", "example", "there", "be", "User", "type", "we", "can", "CRUD", "it", "like", "RESETful", "API", "graphql", "query", "allUsers", "User", "user", "id", "ID", "User", "mutation", "createUser", "input", "UserInput", "User", "updateUser", "id", "ID", "input", "UserInput", "User", "destroyUser", "id", "ID", "User", "If", "we", "have", "NUMBER", "or", "more", "types", "like", "User", "GraphQL", "schema", "will", "become", "hard", "to", "manage", "NUMBER", "My", "proposal", "be", "add", "class", "things", "will", "like", "graphql", "class", "User", "init", "id", "ID", "mutate", "init", "params", "User", "NUMBER", "Lets", "static", "all", "User", "var", "name", "String", "let", "username", "String", "followingCount", "Int", "createdAt", "Date", "mutate", "update", "params", "User", "NUMBER", "Vars", "Boolean", "mutate", "destroy", "Boolean", "mutate", "follow", "userID", "ID", "Boolean", "articles", "state", "ArticleState", "Article", "And", "you", "can", "use", "it", "like", "graphql", "query", "createParams", "User", "NUMBER", "Lets", "userID", "ID", "updateParams", "User", "NUMBER", "Vars", "followUserID", "ID", "User", "NUMBER", "all", "Get", "list", "id", "name", "User", "params", "createParams", "Create", "id", "name", "User", "id", "userID", "Read", "update", "params", "updateParams", "Update", "name", "username", "follow", "userID", "followUserID", "followingCount", "User", "id", "userID", "destroy", "Destroy", "Field", "types", "be", "var", "e", "NUMBER", "g", "NUMBER", "var", "name", "String", "let", "e", "NUMBER", "g", "NUMBER", "let", "username", "String", "default", "e", "NUMBER", "g", "NUMBER", "followCount", "Int", "mutate", "e", "NUMBER", "g", "NUMBER", "mutate", "update", "params", "User", "NUMBER", "Vars", "For", "var", "and", "let", "it", "will", "automatically", "generate", "inputs", "User", "NUMBER", "Vars", "and", "User", "NUMBER", "Lets", "NUMBER", "graphql", "input", "User", "NUMBER", "Vars", "name", "String", "input", "User", "NUMBER", "Lets", "name", "String", "username", "String", "User", "NUMBER", "Vars", "only", "include", "var", "field", "and", "User", "NUMBER", "Lets", "include", "var", "and", "let", "field", "NUMBER", "For", "mutate", "it", "means", "the", "query", "be", "a", "mutation", "NUMBER", "For", "default", "it", "just", "normal", "field", "NUMBER", "The", "reason", "we", "have", "var", "and", "let", "be", "that", "let", "field", "should", "only", "be", "use", "on", "creating", "and", "var", "can", "be", "use", "on", "creating", "and", "update", "NUMBER", "Let", "s", "take", "a", "closer", "look", "at", "graphql", "User", "id", "userID", "update", "params", "updateParams", "name", "username", "follow", "userID", "followUserID", "followingCount", "This", "query", "has", "two", "mutations", "update", "and", "follow", "NUMBER", "Although", "follow", "be", "below", "username", "GraphQL", "will", "still", "execute", "all", "mutations", "serially", "first", "and", "then", "resolve", "other", "field", "e", "NUMBER", "g", "name", "username", "and", "followingCount", "parallelly", "NUMBER", "What", "do", "mean", "It", "means", "the", "resolvers", "will", "return", "both", "parent", "and", "result", "and", "returning", "parent", "will", "replace", "the", "original", "one", "NUMBER", "js", "const", "userType", "update", "parent", "args", "ctx", "NUMBER", "return", "parent", "obj", "result", "result", "Wait", "sorry", "subscription", "can", "only", "take", "one", "root", "field", "per", "request", "document", "Wait", "sorry", "subscription", "can", "only", "take", "one", "root", "field", "per", "request", "document", "That", "s", "correct", "NUMBER", "Is", "that", "a", "limitation", "that", "will", "cause", "problem", "for", "you", "robzhu", "leebyron", "I", "see", "NUMBER", "I", "haven", "t", "yet", "start", "implement", "subscriptions", "NUMBER", "We", "re", "looking", "to", "potentially", "migrate", "to", "them", "to", "implement", "what", "s", "essentially", "a", "live", "query", "hence", "my", "discussions", "on", "other", "tickets", "from", "an", "exist", "system", "that", "uses", "an", "ad", "hoc", "Web", "Socket", "protocol", "NUMBER", "But", "since", "this", "be", "still", "in", "the", "early", "stages", "I", "can", "t", "say", "for", "sure", "whether", "this", "be", "an", "issue", "NUMBER", "It", "s", "probably", "fine", "NUMBER", "It", "seems", "like", "the", "issue", "could", "be", "skirted", "by", "having", "a", "field", "represent", "a", "whole", "bunch", "of", "different", "events", "and", "return", "a", "union", "of", "event", "payloads", "NUMBER", "I", "was", "just", "surprised", "since", "Sangria", "s", "pre", "spec", "subscription", "implementation", "LINK", "graphql", "NUMBER", "org", "learn", "stream", "based", "subscriptions", "doesn", "t", "have", "this", "restriction", "so", "just", "wanted", "to", "make", "sure", "I", "understood", "NUMBER", "It", "seems", "like", "they", "solve", "the", "problem", "by", "largely", "treating", "the", "document", "as", "independent", "subscriptions", "and", "the", "event", "stream", "simply", "only", "contain", "one", "of", "the", "root", "field", "per", "payload", "NUMBER", "For", "now", "GraphQL", "lets", "developers", "decide", "error", "format", "which", "makes", "developer", "bewildered", "NUMBER", "For", "example", "graphql", "type", "Mutation", "register", "input", "RegisterInput", "User", "verifyPhone", "pin", "String", "Phone", "register", "may", "have", "error", "like", "email", "format", "be", "wrong", "email", "already", "use", "password", "be", "too", "easy", "NUMBER", "So", "its", "error", "be", "like", "json", "error", "message", "Email", "not", "find", "field", "field", "Email", "message", "Email", "format", "be", "wrong", "field", "Password", "message", "Password", "be", "too", "easy", "verifyPhone", "may", "have", "two", "types", "of", "error", "json", "error", "message", "Pin", "be", "wrong", "type", "wrong", "or", "json", "error", "message", "Pin", "be", "expired", "type", "expired", "These", "error", "be", "so", "different", "so", "I", "can", "t", "just", "use", "the", "same", "format", "implementation", "of", "formatError", "NUMBER", "One", "way", "to", "solve", "it", "be", "graphql", "type", "RegisterValidateError", "message", "String", "field", "ValidationField", "type", "RegisterPayload", "user", "User", "error", "RegisterValidateError", "enum", "VerifyPhoneErrorType", "wrong", "expired", "type", "VerifyPhoneError", "message", "String", "type", "VerifyPhoneErrorType", "type", "VerifyPhonePayload", "phone", "Phone", "error", "VerifyPhoneError", "type", "Mutation", "register", "input", "RegisterInput", "RegisterPayload", "verifyPhone", "pin", "String", "VerifyPhonePayload", "But", "I", "think", "it", "ll", "be", "good", "if", "GraphQL", "support", "native", "typed", "error", "and", "add", "throw", "keyword", "to", "hint", "clients", "which", "error", "might", "throw", "in", "the", "query", "NUMBER", "So", "it", "ll", "be", "like", "the", "following", "graphql", "error", "RegisterValidateError", "message", "String", "field", "ValidationField", "enum", "VerifyPhoneErrorType", "wrong", "expired", "error", "VerifyPhoneError", "message", "String", "type", "VerifyPhoneErrorType", "type", "Mutation", "register", "input", "RegisterInput", "User", "throw", "RegisterValidateError", "RegisterTooManyTimesError", "verifyPhone", "pin", "String", "Phone", "throw", "VerifyPhoneError", "And", "the", "response", "s", "error", "have", "the", "type", "json", "error", "type", "RegisterValidateError", "message", "Email", "not", "find", "field", "NUMBER", "Is", "there", "any", "update", "here", "The", "idea", "be", "similar", "to", "how", "you", "can", "prepare", "variables", "in", "relay", "before", "use", "them", "NUMBER", "So", "the", "proposal", "be", "to", "add", "a", "layer", "before", "use", "the", "argument", "in", "the", "resolve", "field", "NUMBER", "Example", "in", "javascript", "export", "const", "userMutation", "type", "userType", "args", "id", "type", "GraphQLID", "prepare", "arg", "return", "arg", "NUMBER", "resolve", "obj", "args", "here", "args", "NUMBER", "id", "be", "incremented", "by", "NUMBER", "This", "could", "be", "useful", "when", "IDs", "be", "in", "base", "NUMBER", "so", "that", "it", "s", "easier", "to", "use", "e", "NUMBER", "g", "NUMBER", "fromGlobalId", "with", "relay", "NUMBER", "Another", "use", "case", "be", "for", "pagination", "NUMBER", "So", "I", "set", "up", "a", "basic", "connection", "type", "with", "limit", "and", "offset", "argument", "NUMBER", "Then", "to", "see", "if", "there", "s", "a", "next", "page", "I", "query", "for", "limit", "NUMBER", "in", "my", "db", "NUMBER", "Instead", "of", "incrementing", "in", "my", "resolve", "it", "would", "be", "much", "easier", "to", "do", "this", "args", "limit", "type", "GraphQLInt", "prepare", "arg", "return", "arg", "NUMBER", "resolve", "obj", "args", "args", "NUMBER", "limit", "be", "incremented", "by", "NUMBER", "as", "I", "reuse", "the", "connection", "type", "NUMBER", "Though", "maybe", "I", "m", "just", "miss", "something", "or", "just", "use", "GraphQL", "wrong", "Would", "love", "to", "know", "if", "someone", "else", "has", "this", "issue", "NUMBER", "Edit", "Btw", "be", "I", "posting", "this", "in", "the", "wrong", "repo", "Maybe", "this", "should", "be", "in", "the", "graphql", "js", "repo", "rather", "than", "this", "one", "I", "notice", "that", "all", "the", "error", "mention", "in", "the", "specification", "could", "be", "divided", "into", "the", "following", "categories", "syntax", "error", "validation", "error", "query", "error", "field", "error", "I", "review", "exist", "error", "mentions", "in", "the", "spec", "text", "and", "clarified", "their", "type", "NUMBER", "In", "future", "it", "would", "be", "great", "to", "add", "separate", "Errors", "types", "section", "to", "list", "all", "possible", "error", "types", "and", "describe", "them", "NUMBER", "I", "think", "to", "start", "we", "could", "just", "group", "into", "NUMBER", "Syntax", "NUMBER", "Validation", "NUMBER", "Execution", "In", "your", "text", "you", "separate", "query", "from", "field", "but", "it", "seems", "like", "a", "lot", "of", "the", "examples", "be", "actually", "validation", "error", "right", "Hmm", "I", "m", "a", "bit", "worried", "about", "further", "overloading", "the", "word", "query", "it", "s", "already", "hard", "to", "tell", "the", "difference", "between", "documents", "operations", "query", "operations", "etc", "NUMBER", "In", "that", "sense", "there", "be", "really", "NUMBER", "behaviorally", "different", "error", "those", "that", "result", "in", "no", "data", "key", "and", "those", "that", "be", "local", "to", "one", "field", "in", "the", "response", "NUMBER", "stubailo", "leebyron", "I", "think", "it", "very", "important", "to", "make", "it", "more", "explicit", "in", "the", "spec", "NUMBER", "For", "example", "I", "was", "very", "surprised", "to", "find", "out", "that", "error", "during", "coercion", "of", "query", "variables", "be", "fatal", "error", "NUMBER", "So", "I", "think", "error", "names", "should", "describe", "the", "expected", "result", "of", "error", "instead", "of", "a", "place", "where", "they", "were", "originated", "NUMBER", "What", "do", "you", "think", "about", "use", "partial", "error", "and", "fatal", "error", "Currently", "the", "spec", "requires", "data", "to", "be", "the", "first", "field", "in", "a", "response", "NUMBER", "But", "after", "my", "PR", "LINK", "js", "pull", "NUMBER", "was", "merge", "into", "graphql", "js", "error", "always", "precede", "data", "image", "LINK", "images", "NUMBER", "githubusercontent", "NUMBER", "com", "NUMBER", "NUMBER", "e", "NUMBER", "a", "NUMBER", "dea", "cee", "NUMBER", "NUMBER", "e", "NUMBER", "NUMBER", "a", "NUMBER", "b", "NUMBER", "a", "NUMBER", "png", "I", "still", "think", "that", "having", "error", "as", "the", "first", "property", "be", "a", "big", "DX", "improvement", "so", "I", "update", "the", "spec", "to", "reflect", "the", "change", "in", "graphql", "js", "NUMBER", "Why", "should", "the", "order", "matter", "I", "like", "having", "error", "first", "but", "it", "seems", "arbitrary", "NUMBER", "And", "what", "of", "JSON", "libraries", "that", "leave", "order", "undefined", "I", "ve", "always", "find", "the", "ordering", "requirements", "odd", "NUMBER", "At", "most", "the", "specification", "can", "put", "a", "should", "on", "them", "because", "JSON", "encoders", "be", "free", "to", "do", "whatever", "they", "want", "NUMBER", "If", "the", "internal", "representation", "of", "a", "JSON", "dict", "be", "a", "large", "hash", "table", "then", "the", "rendering", "order", "be", "going", "to", "be", "arbitrary", "NUMBER", "Furthermore", "some", "languages", "Go", "be", "one", "example", "randomizes", "the", "order", "in", "which", "you", "visit", "a", "hash", "table", "in", "order", "to", "make", "it", "explicit", "to", "the", "programmer", "that", "they", "cannot", "rely", "on", "the", "ordering", "NUMBER", "In", "short", "requiring", "order", "here", "be", "rather", "brittle", "and", "be", "bound", "to", "create", "problem", "down", "the", "line", "NUMBER", "acjay", "jlouis", "GraphQL", "spec", "only", "recommends", "order", "of", "properties", "for", "more", "details", "see", "LINK", "This", "PR", "just", "makes", "graphql", "js", "reference", "implementation", "in", "line", "with", "spec", "recommendation", "I", "think", "order", "requirements", "in", "the", "spec", "be", "for", "parsers", "which", "rely", "on", "the", "order", "to", "more", "efficiently", "parse", "the", "result", "NUMBER", "IMO", "that", "makes", "error", "at", "the", "front", "even", "more", "valuable", "since", "it", "be", "super", "useful", "to", "know", "about", "error", "first", "in", "the", "case", "of", "a", "huge", "result", "NUMBER", "If", "it", "s", "framed", "as", "a", "recommendation", "it", "shouldn", "t", "be", "an", "issue", "since", "things", "be", "still", "valid", "GraphQL", "even", "if", "they", "return", "data", "first", "NUMBER", "If", "it", "s", "framed", "as", "a", "recommendation", "it", "shouldn", "t", "be", "an", "issue", "since", "things", "be", "still", "valid", "GraphQL", "even", "if", "they", "return", "data", "first", "NUMBER", "You", "right", "NUMBER", "But", "I", "think", "the", "spec", "should", "recommend", "only", "best", "practices", "and", "error", "first", "approach", "provide", "better", "UX", "NUMBER", "Moreover", "spec", "recommendation", "should", "be", "implement", "at", "least", "in", "the", "reference", "implementation", "NUMBER", "Yep", "I", "just", "think", "there", "s", "a", "big", "difference", "between", "recommend", "vs", "NUMBER", "require", "in", "a", "spec", "I", "totally", "agree", "error", "first", "be", "the", "best", "approach", "NUMBER", "leebyron", "Great", "improvment", "Hope", "it", "will", "be", "merge", "soon", "NUMBER", "I", "ve", "recently", "run", "into", "a", "use", "case", "where", "version", "specific", "resources", "would", "be", "incredibly", "helpful", "with", "my", "GraphQL", "API", "NUMBER", "I", "have", "probably", "only", "spent", "NUMBER", "months", "with", "GraphQL", "so", "I", "potentially", "could", "have", "miss", "something", "where", "this", "be", "concerned", "NUMBER", "Anyway", "let", "s", "take", "the", "following", "example", "and", "go", "from", "there", "Post", "NUMBER", "I", "went", "to", "the", "beach", "today", "NUMBER", "Post", "NUMBER", "I", "went", "to", "the", "beach", "today", "and", "I", "get", "really", "sunburned", "NUMBER", "Currently", "achieving", "something", "similar", "to", "this", "be", "really", "involved", "and", "no", "solution", "feels", "right", "NUMBER", "It", "more", "or", "less", "just", "feels", "like", "I", "m", "hacking", "together", "a", "temporary", "solution", "NUMBER", "I", "think", "the", "use", "case", "for", "add", "version", "capabilities", "to", "the", "spec", "would", "eliminate", "both", "confusion", "and", "complexity", "NUMBER", "I", "know", "that", "GraphQL", "be", "versionless", "but", "from", "my", "understanding", "that", "be", "both", "intentional", "and", "for", "the", "API", "as", "a", "whole", "NUMBER", "Would", "something", "to", "this", "extent", "even", "be", "possible", "Do", "you", "think", "that", "this", "use", "case", "be", "actually", "helpful", "to", "others", "I", "m", "open", "to", "discussing", "this", "in", "greater", "detail", "NUMBER", "If", "something", "like", "this", "exists", "can", "you", "point", "me", "to", "the", "right", "direction", "All", "of", "my", "search", "queries", "have", "returned", "everything", "about", "GraphQL", "as", "a", "whole", "be", "versionless", "NUMBER", "I", "couldn", "t", "find", "anything", "for", "my", "use", "case", "NUMBER", "Here", "s", "an", "implementation", "of", "how", "I", "think", "this", "would", "look", "NUMBER", "Also", "I", "may", "have", "gotten", "something", "wrong", "here", "but", "you", "get", "the", "idea", "NUMBER", "graphql", "type", "Post", "id", "ID", "title", "String", "body", "String", "version", "Version", "use", "the", "new", "Type", "query", "Post", "id", "id", "version", "version", "Post", "id", "id", "filter", "version", "version", "id", "title", "body", "It", "seems", "as", "if", "these", "issue", "be", "not", "looked", "at", "too", "often", "NUMBER", "Is", "there", "a", "better", "place", "to", "hold", "discussions", "This", "be", "the", "right", "place", "it", "just", "takes", "a", "bit", "of", "time", "NUMBER", "Something", "like", "these", "would", "be", "easily", "implement", "into", "your", "Object", "rather", "than", "a", "new", "Versioning", "Type", "NUMBER", "Why", "not", "just", "put", "your", "Post", "type", "in", "an", "Array", "I", "m", "unaware", "of", "the", "ability", "to", "put", "a", "Type", "into", "an", "array", "NUMBER", "But", "even", "if", "it", "were", "possible", "that", "opens", "the", "door", "for", "a", "lot", "of", "problem", "NUMBER", "The", "first", "I", "can", "think", "of", "be", "querying", "a", "single", "Post", "NUMBER", "I", "m", "not", "sure", "how", "well", "it", "would", "work", "with", "Mutations", "either", "NUMBER", "Anyway", "I", "do", "think", "this", "feature", "be", "completely", "valid", "and", "worth", "a", "discussion", "I", "too", "think", "this", "be", "worth", "a", "discussion", "NUMBER", "Why", "not", "put", "a", "list", "of", "postHistorys", "in", "your", "Post", "graphql", "type", "Post", "id", "ID", "title", "String", "postHistory", "PostHistory", "and", "then", "just", "query", "with", "a", "Version", "see", "here", "LINK", "mutations", "will", "be", "a", "bit", "tricky", "and", "there", "be", "surely", "even", "better", "ways", "to", "do", "this", "NUMBER", "I", "just", "doesnt", "feel", "right", "to", "let", "graphQL", "handle", "your", "business", "logic", "of", "keep", "track", "of", "data", "Out", "of", "the", "box", "that", "wouldn", "t", "work", "NUMBER", "I", "d", "have", "to", "write", "a", "bit", "of", "logic", "to", "implement", "that", "NUMBER", "However", "if", "it", "were", "part", "of", "the", "spec", "this", "feature", "could", "be", "write", "in", "exist", "implementations", "NUMBER", "Both", "by", "the", "community", "and", "by", "graphql", "graphql", "js", "NUMBER", "I", "m", "really", "not", "sure", "how", "the", "implementation", "details", "would", "look", "NUMBER", "I", "ve", "be", "pondering", "this", "since", "I", "write", "this", "issue", "NUMBER", "if", "it", "were", "part", "of", "the", "spec", "this", "feature", "could", "be", "write", "in", "exist", "implementations", "You", "wouldn", "t", "want", "us", "_implementors_", "to", "take", "all", "the", "fun", "now", "would", "you", "For", "real", "though", "the", "most", "successful", "new", "features", "have", "followed", "the", "_reverse_", "process", "NUMBER", "Instead", "of", "going", "into", "the", "spec", "first", "then", "into", "a", "real", "world", "application", "they", "_start_", "in", "an", "application", "and", "then", "become", "part", "of", "the", "spec", "NUMBER", "Subscriptions", "stand", "out", "FB", "build", "subscriptions", "_on", "top_", "of", "the", "spec", "first", "then", "opened", "an", "RFC", "to", "update", "the", "spec", "NUMBER", "So", "if", "you", "think", "this", "idea", "be", "valuable", "how", "about", "demonstrating", "its", "value", "first", "and", "showing", "how", "it", "may", "be", "implement", "With", "a", "good", "demonstration", "more", "of", "us", "may", "be", "convinced", "that", "it", "s", "a", "good", "addition", "to", "GraphQL", "at", "the", "language", "runtime", "level", "NUMBER", "That", "sounds", "like", "a", "good", "plan", "NUMBER", "I", "ll", "go", "ahead", "and", "fork", "graphql", "js", "to", "get", "start", "NUMBER", "Thanks", "for", "the", "advice", "i", "be", "use", "gatsby", "with", "graphql", "and", "when", "i", "try", "to", "query", "use", "graphiql", "it", "be", "showing", "this", "error", "message", "Cannot", "query", "field", "childMarkdownRemark", "The", "proposal", "come", "from", "the", "needs", "of", "a", "better", "organization", "of", "tool", "around", "GraphQL", "NUMBER", "Many", "people", "companies", "have", "to", "swap", "the", "order", "of", "the", "naming", "of", "mutations", "because", "they", "want", "the", "relate", "mutations", "to", "be", "as", "close", "as", "possible", "in", "the", "tool", "NUMBER", "For", "example", "createOrder", "updateOrder", "vs", "orderCreate", "orderUpdate", "As", "you", "can", "notice", "the", "second", "example", "seems", "a", "little", "weird", "to", "read", "because", "it", "breaks", "English", "language", "but", "people", "need", "to", "do", "this", "because", "they", "want", "those", "mutations", "to", "be", "close", "like", "I", "said", "NUMBER", "In", "my", "personal", "opinion", "that", "looks", "a", "little", "bit", "ugly", "and", "I", "don", "t", "like", "that", "my", "GraphQL", "design", "be", "driven", "by", "the", "lack", "of", "organization", "support", "of", "the", "tool", "NUMBER", "The", "proposal", "be", "to", "add", "another", "introspection", "at", "least", "for", "the", "mutations", "where", "tool", "can", "use", "it", "for", "group", "mutations", "or", "whatever", "they", "will", "be", "use", "it", "NUMBER", "From", "my", "point", "of", "view", "this", "be", "strictly", "use", "for", "that", "propose", "and", "no", "for", "anything", "outside", "that", "I", "wouldn", "t", "want", "people", "to", "do", "any", "crazy", "thing", "with", "that", "value", "NUMBER", "Some", "example", "code", "would", "be", "like", "js", "var", "root", "group", "message", "getMessage", "function", "id", "NUMBER", "group", "message", "createMessage", "function", "input", "NUMBER", "I", "be", "use", "decorator", "for", "the", "sack", "of", "a", "clean", "example", "but", "I", "be", "pretty", "much", "there", "be", "an", "alternatives", "NUMBER", "I", "be", "not", "sure", "how", "the", "introspection", "will", "look", "like", "because", "I", "didn", "t", "understand", "how", "it", "looks", "like", "for", "mutations", "but", "I", "be", "expecting", "something", "like", "graphql", "type", "__Schema", "types", "__Type", "queryType", "__Type", "mutationType", "__Type", "group", "String", "TAG", "The", "expectation", "be", "that", "SDL", "will", "be", "read", "far", "more", "often", "than", "it", "be", "write", "That", "be", "a", "very", "fair", "statement", "NUMBER", "However", "can", "the", "same", "not", "be", "said", "about", "GraphQL", "operations", "i", "NUMBER", "e", "NUMBER", "queries", "mutations", "and", "subscriptions", "Those", "of", "course", "can", "have", "fragment", "which", "be", "synonymous", "to", "mixins", "NUMBER", "What", "differentiates", "fragment", "from", "mixins", "in", "regard", "to", "readability", "and", "maintainability", "Operations", "themselves", "be", "typically", "write", "more", "often", "than", "types", "and", "interfaces", "but", "I", "would", "bet", "that", "given", "any", "one", "type", "or", "interface", "and", "any", "one", "operation", "of", "comparable", "complexity", "one", "would", "be", "read", "or", "change", "just", "as", "frequently", "or", "rarely", "as", "the", "other", "on", "average", "NUMBER", "If", "add", "mixin", "support", "be", "important", "to", "you", "I", "would", "recommend", "you", "build", "it", "I", "be", "by", "no", "means", "against", "doing", "this", "and", "would", "be", "glad", "to", "report", "my", "findings", "NUMBER", "I", "actually", "created", "a", "ticket", "for", "it", "in", "my", "project", "s", "issue", "tracker", "immediately", "after", "open", "this", "issue", "NUMBER", "However", "beyond", "write", "a", "formal", "specification", "I", "m", "not", "sure", "how", "to", "best", "proceed", "considering", "that", "my", "implementation", "would", "be", "dependent", "on", "the", "library", "on", "which", "it", "build", "NUMBER", "Thus", "the", "potential", "audience", "who", "could", "try", "it", "out", "in", "their", "projects", "would", "be", "limited", "NUMBER", "I", "d", "hate", "to", "build", "it", "and", "be", "the", "only", "one", "to", "report", "their", "findings", "NUMBER", "I", "m", "obviously", "already", "biased", "to", "support", "them", "NUMBER", "Do", "you", "have", "any", "suggestions", "as", "to", "how", "to", "proceed", "in", "this", "regard", "If", "add", "mixin", "support", "be", "important", "to", "you", "I", "would", "recommend", "you", "build", "it", "I", "ve", "already", "do", "it", "LINK", "graphql", "partials", "As", "I", "mention", "in", "LINK", "issuecomment", "NUMBER", "tylercrompton", "Please", "try", "my", "piece", "of", "code", "out", "and", "we", "can", "maybe", "get", "some", "common", "findings", "Thanks", "for", "the", "great", "work", "and", "the", "really", "good", "news", "NUMBER", "NUMBER", "Finally", "TAG", "NUMBER", "bits", "since", "it", "be", "still", "a", "work", "draft", "instead", "of", "a", "standard", "NUMBER", "But", "it", "may", "be", "way", "too", "late", "for", "that", "I", "don", "t", "know", "NUMBER", "I", "be", "willing", "to", "do", "the", "legwork", "for", "any", "such", "change", "but", "without", "a", "decision", "I", "don", "t", "think", "there", "s", "much", "I", "can", "do", "about", "this", "NUMBER", "leebyron", "wincent", "Sorry", "to", "bother", "but", "this", "issue", "has", "just", "sat", "here", "for", "a", "month", "NUMBER", "How", "and", "where", "should", "I", "open", "a", "discussion", "about", "this", "What", "be", "the", "proper", "place", "for", "graphql", "spec", "feedback", "What", "be", "the", "proper", "place", "for", "graphql", "spec", "feedback", "The", "issue", "tracker", "here", "be", "a", "reasonable", "place", "to", "start", "NUMBER", "If", "you", "want", "to", "go", "beyond", "an", "initial", "exploratory", "conversation", "about", "a", "topic", "then", "see", "CONTRIBUTING", "NUMBER", "md", "LINK", "in", "the", "root", "of", "the", "repo", "for", "a", "description", "of", "the", "basic", "stages", "that", "a", "proposal", "to", "change", "the", "spec", "should", "generally", "go", "through", "the", "process", "itself", "be", "evolving", "but", "that", "document", "captures", "some", "current", "thinking", "about", "it", "NUMBER", "I", "would", "like", "to", "get", "a", "definitive", "answer", "on", "what", "be", "the", "default", "way", "to", "handle", "them", "That", "be", "going", "to", "be", "tricky", "as", "there", "may", "not", "be", "a", "definitive", "answer", "as", "such", "NUMBER", "The", "NUMBER", "bit", "int", "size", "was", "very", "intentionally", "chosen", "for", "maximum", "interoperability", "knowing", "that", "pretty", "much", "all", "significant", "current", "systems", "that", "one", "might", "wish", "to", "use", "GraphQL", "with", "will", "be", "capable", "of", "representing", "numbers", "in", "this", "way", "NUMBER", "Once", "you", "want", "to", "go", "beyond", "that", "you", "be", "pretty", "much", "inevitably", "in", "the", "territory", "of", "the", "implementation", "specific", "which", "means", "that", "it", "be", "going", "to", "be", "difficult", "to", "get", "it", "into", "the", "spec", "NUMBER", "Even", "if", "just", "in", "a", "supplemental", "advisory", "addendum", "part", "of", "the", "value", "of", "the", "spec", "be", "that", "it", "can", "reasonably", "be", "implement", "in", "its", "totality", "everywhere", "and", "once", "you", "start", "add", "additional", "layers", "of", "guidelines", "it", "be", "no", "longer", "necessarily", "clear", "where", "the", "core", "spec", "ends", "and", "the", "optional", "part", "begins", "NUMBER", "What", "do", "it", "means", "to", "say", "a", "library", "implement", "the", "spec", "I", "could", "go", "on", "but", "you", "can", "probably", "see", "where", "the", "logical", "conclusions", "lie", "NUMBER", "I", "wonder", "if", "a", "document", "in", "the", "spirit", "of", "the", "Relay", "Modern", "Conventions", "could", "be", "beneficial", "NUMBER", "GraphQL", "doesn", "t", "define", "eg", "pagination", "but", "in", "Relay", "Modern", "there", "be", "a", "convention", "for", "doing", "just", "that", "on", "top", "of", "GraphQL", "NUMBER", "It", "might", "be", "useful", "to", "have", "a", "document", "which", "defines", "an", "extend", "type", "Zoo", "of", "commonly", "use", "types", "which", "a", "server", "can", "adhere", "to", "NUMBER", "Some", "of", "the", "trickery", "that", "be", "going", "on", "here", "be", "that", "different", "languages", "treat", "integer", "values", "differently", "Erlang", "Common", "Lisp", "and", "Haskell", "defines", "arbitrarily", "sized", "integers", "by", "default", "NUMBER", "Hence", "they", "have", "no", "problem", "dumping", "you", "a", "NUMBER", "bit", "integer", "as", "a", "result", "NUMBER", "OCaml", "uses", "one", "bit", "for", "tagging", "in", "its", "integer", "scheme", "NUMBER", "Thus", "integers", "be", "NUMBER", "bit", "by", "default", "and", "the", "NUMBER", "bit", "integers", "have", "a", "considerable", "performance", "degradation", "if", "you", "use", "them", "NUMBER", "Perl", "and", "Javascript", "doesn", "t", "define", "an", "integer", "type", "at", "all", "and", "be", "thus", "only", "precise", "up", "to", "NUMBER", "bit", "SQL", "has", "a", "DECIMAL", "type", "for", "fix", "point", "arithmetic", "NUMBER", "If", "a", "spec", "try", "to", "cater", "to", "a", "specific", "language", "you", "exclude", "some", "languages", "from", "the", "implementation", "NUMBER", "So", "it", "makes", "sense", "to", "start", "with", "a", "lowest", "common", "denominator", "NUMBER", "Other", "considerations", "JSON", "might", "not", "be", "the", "transport", "NUMBER", "Other", "transports", "define", "different", "integer", "types", "NUMBER", "Expect", "coercions", "NUMBER", "Were", "I", "to", "define", "some", "of", "the", "above", "types", "I", "d", "probably", "define", "them", "as", "user", "defined", "scalar", "types", "and", "build", "proper", "resolvers", "in", "the", "languages", "I", "intend", "to", "work", "with", "NUMBER", "Poly", "language", "systems", "tend", "to", "need", "some", "special", "handle", "when", "traversing", "the", "language", "barrier", "anyway", "NUMBER", "I", "m", "going", "to", "respect", "the", "decision", "to", "leave", "this", "out", "of", "the", "spec", "NUMBER", "However", "for", "posterity", "I", "will", "express", "my", "disagreement", "with", "the", "issue", "here", "NUMBER", "I", "fear", "that", "not", "recommending", "an", "universal", "default", "do", "not", "result", "in", "people", "choosing", "the", "best", "type", "based", "on", "the", "type", "of", "data", "NUMBER", "I", "fear", "that", "they", "will", "instead", "stick", "with", "NUMBER", "bit", "integers", "hoping", "that", "they", "will", "be", "enough", "until", "they", "be", "not", "NUMBER", "Github", "use", "integer", "for", "repository", "size", "be", "already", "an", "example", "of", "this", "it", "will", "break", "with", "the", "first", "NUMBER", "terabyte", "repository", "NUMBER", "I", "be", "betting", "that", "if", "YouTube", "add", "a", "GraphQL", "API", "for", "their", "service", "the", "person", "implement", "that", "will", "decide", "that", "viewCount", "property", "for", "a", "video", "should", "be", "of", "type", "Int", "because", "it", "be", "the", "most", "natural", "type", "for", "such", "a", "value", "completely", "forgetting", "that", "YouTube", "has", "almost", "NUMBER", "videos", "with", "more", "than", "NUMBER", "billion", "views", "NUMBER", "When", "the", "general", "migration", "from", "NUMBER", "bit", "OS", "to", "NUMBER", "bit", "OS", "happened", "we", "saw", "this", "sort", "of", "thing", "en", "masse", "and", "it", "was", "a", "very", "painful", "transition", "and", "currently", "the", "integer", "size", "be", "no", "longer", "an", "issue", "as", "the", "default", "selected", "integer", "in", "programming", "languages", "can", "be", "larger", "than", "NUMBER", "bit", "NUMBER", "It", "feels", "like", "a", "renaissaince", "back", "to", "those", "days", "get", "all", "these", "NUMBER", "bit", "problem", "again", "NUMBER", "But", "even", "when", "people", "select", "a", "datatype", "larger", "than", "NUMBER", "bits", "for", "the", "GraphQL", "API", "the", "end", "result", "be", "not", "going", "to", "be", "terribly", "nice", "since", "everyone", "will", "select", "differently", "NUMBER", "This", "means", "conversions", "between", "the", "different", "types", "across", "the", "board", "NUMBER", "This", "be", "similar", "to", "Java", "where", "half", "of", "the", "APIs", "decide", "they", "want", "long", "and", "half", "of", "them", "want", "int", "NUMBER", "The", "result", "be", "typecasts", "all", "around", "warnings", "about", "possible", "loss", "of", "precision", "and", "hard", "to", "diagnose", "bug", "because", "people", "don", "t", "want", "to", "use", "conversion", "helpers", "that", "will", "error", "out", "if", "the", "value", "exceeds", "the", "new", "range", "NUMBER", "The", "only", "solution", "to", "both", "of", "these", "problem", "be", "that", "the", "default", "type", "people", "pick", "for", "an", "integer", "be", "large", "enough", "for", "most", "uses", "NUMBER", "If", "this", "default", "integer", "type", "would", "be", "NUMBER", "bit", "integer", "it", "would", "be", "represented", "by", "the", "following", "types", "in", "programming", "languages", "Language", "Type", "JavaScript", "Number", "Python", "int", "or", "automatically", "long", "for", "NUMBER", "bit", "Python", "NUMBER", "C", "C", "int", "NUMBER", "_t", "Go", "int", "NUMBER", "C", "long", "Java", "long", "PHP", "integer", "or", "automatically", "float", "for", "NUMBER", "bit", "VB", "NUMBER", "NET", "Long", "OCaml", "int", "or", "unfortunately", "Int", "NUMBER", "for", "NUMBER", "bit", "but", "see", "below", "Note", "OCaml", "has", "NUMBER", "bit", "integers", "on", "NUMBER", "bit", "platforms", "so", "even", "the", "current", "GraphQL", "default", "for", "maximum", "compatibility", "cannot", "be", "represented", "by", "them", "forcing", "the", "use", "of", "Int", "NUMBER", "for", "NUMBER", "bit", "platforms", "NUMBER", "So", "this", "do", "not", "I", "don", "t", "know", "maybe", "my", "viewpoint", "be", "limited", "but", "I", "fail", "to", "see", "in", "what", "kind", "of", "environments", "this", "would", "actually", "pose", "a", "problem", "NUMBER", "Sure", "some", "embedded", "controllers", "for", "IoT", "be", "mostly", "NUMBER", "bit", "and", "might", "have", "slow", "NUMBER", "bit", "numbers", "and", "might", "access", "GraphQL", "APIs", "but", "I", "doubt", "the", "integer", "size", "problem", "would", "be", "a", "major", "obstacle", "there", "NUMBER", "In", "case", "somebody", "stumbles", "upon", "this", "from", "a", "search", "I", "created", "a", "custom", "scalar", "for", "this", "and", "publish", "the", "library", "LINK", "scalar", "int", "NUMBER", "In", "the", "spirit", "established", "in", "Relay", "of", "make", "specs", "outside", "of", "the", "GraphQL", "spec", "for", "auxiliary", "ideas", "maybe", "that", "s", "what", "s", "needed", "here", "so", "that", "libraries", "can", "adopt", "a", "uniform", "approach", "NUMBER", "LINK", "return", "error", "NUMBER", "This", "repository", "be", "for", "discussing", "the", "graphql", "specification", "not", "for", "issue", "with", "specific", "implementations", "NUMBER", "hi", "how", "i", "can", "set", "same", "index", "for", "listOf", "type", "me", "need", "next", "structure", "for", "response", "JSON", "data", "operative_control", "que", "NUMBER", "R", "NUMBER", "NUMBER", "NUMBER", "R", "NUMBER", "NUMBER", "NUMBER", "I", "understant", "that", "its", "no", "good", "but", "me", "need", "only", "this", "structure", "NUMBER", "or", "how", "can", "return", "custom", "data", "raw", "not", "encode", "for", "example", "que", "Type", "string", "and", "set", "custom", "json", "data", "return", "json_encode", "que", "response", "data", "operative_control", "que", "NUMBER", "R", "NUMBER", "NUMBER", "R", "NUMBER", "class", "OperativeControlType", "extend", "ObjectType", "public", "function", "__construct", "config", "field", "function", "return", "que", "type", "Type", "listOf", "Types", "OperativeControlValue", "resolve", "function", "que", "return", "que", "parent", "__construct", "config", "class", "OperativeControlValueType", "extend", "ObjectType", "public", "function", "__construct", "config", "field", "function", "return", "R", "Type", "string", "parent", "__construct", "config", "class", "QueryType", "extend", "ObjectType", "public", "function", "__construct", "config", "field", "function", "return", "operative_control", "type", "Types", "operativeControl", "resolve", "function", "root", "args", "return", "NUMBER", "R", "NUMBER", "NUMBER", "R", "NUMBER", "parent", "__construct", "config", "Hi", "Guys", "First", "thank", "you", "for", "your", "incredibly", "hard", "work", "and", "brilliant", "design", "NUMBER", "You", "ve", "helped", "me", "and", "many", "others", "NUMBER", "I", "believe", "that", "there", "s", "an", "IP", "issue", "over", "GraphQL", "that", "needs", "to", "be", "brought", "to", "Facebook", "s", "attention", "NUMBER", "GraphQL", "patents", "be", "issue", "and", "there", "be", "no", "patent", "grants", "in", "the", "specification", "NUMBER", "I", "read", "these", "patents", "to", "cover", "core", "functionality", "and", "difficult", "thought", "not", "impossible", "to", "design", "around", "NUMBER", "However", "the", "current", "spec", "leads", "most", "implementations", "to", "be", "infringers", "NUMBER", "For", "more", "here", "be", "my", "full", "thoughts", "NUMBER", "LINK", "dwalsh", "NUMBER", "sdlr", "use", "graphql", "why", "facebook", "now", "owns", "you", "NUMBER", "c", "NUMBER", "I", "ve", "be", "a", "Facebook", "licensing", "defender", "for", "other", "OSS", "like", "React", "but", "I", "think", "this", "be", "a", "completely", "different", "issue", "and", "hope", "this", "can", "start", "a", "dialogue", "up", "the", "chain", "NUMBER", "Thank", "you", "Hi", "LawJolla", "thanks", "for", "highlight", "this", "and", "for", "the", "well", "researched", "blog", "post", "NUMBER", "I", "ll", "bring", "this", "to", "the", "attention", "of", "our", "legal", "council", "for", "their", "suggestion", "on", "how", "to", "resolve", "this", "issue", "NUMBER", "We", "definitely", "want", "to", "ensure", "the", "community", "has", "all", "necessary", "rights", "to", "be", "able", "to", "use", "GraphQL", "I", "ll", "make", "sure", "we", "get", "a", "speedy", "resolution", "NUMBER", "leebyron", "in", "general", "the", "patent", "appendage", "to", "FB", "s", "BSD", "patent", "license", "be", "at", "best", "just", "a", "paper", "tiger", "as", "LawJolla", "contests", "NUMBER", "Or", "at", "worst", "it", "be", "a", "poor", "message", "like", "FB", "be", "just", "another", "large", "enterprise", "that", "only", "thinks", "about", "its", "greedy", "self", "NUMBER", "I", "m", "paraphrasing", "the", "overall", "perspective", "of", "comments", "I", "ve", "read", "when", "I", "say", "that", "NUMBER", "I", "guess", "the", "question", "be", "be", "the", "value", "of", "the", "protection", "expected", "from", "the", "add", "patent", "conditions", "higher", "than", "the", "negativity", "and", "uncertainty", "it", "causes", "NUMBER", "I", "d", "think", "not", "and", "it", "be", "not", "really", "true", "to", "OSS", "community", "values", "if", "FB", "were", "honest", "about", "it", "NUMBER", "Scott", "Hi", "smolinari", "I", "understand", "this", "be", "a", "contentious", "issue", "and", "that", "the", "legal", "portion", "of", "open", "source", "can", "be", "frustrating", "since", "decisions", "they", "be", "not", "always", "in", "the", "hands", "of", "the", "engineers", "build", "the", "software", "and", "their", "implications", "be", "not", "always", "clearly", "understood", "NUMBER", "I", "m", "discussing", "this", "issue", "with", "our", "legal", "council", "and", "will", "try", "to", "find", "a", "solution", "that", "provides", "the", "necessary", "legal", "rights", "for", "the", "community", "to", "continue", "to", "use", "and", "contribute", "to", "GraphQL", "NUMBER", "I", "ll", "share", "update", "as", "soon", "as", "I", "can", "NUMBER", "leebyron", "sorry", "if", "I", "ask", "something", "that", "be", "already", "answer", "but", "between", "English", "and", "my", "ignorance", "I", "be", "really", "lost", "NUMBER", "Does", "the", "Patent", "affects", "the", "Specification", "itself", "I", "be", "kind", "of", "fine", "if", "you", "put", "some", "patent", "on", "the", "implementation", "of", "such", "of", "specification", "but", "I", "wouldn", "t", "expect", "to", "be", "affected", "even", "use", "the", "specification", "NUMBER", "I", "can", "t", "even", "imagine", "that", "leebyron", "thanks", "for", "your", "help", "and", "quick", "attention", "As", "someone", "who", "s", "patented", "many", "inventions", "for", "large", "companies", "I", "know", "how", "the", "machinery", "works", "NUMBER", "Facebook", "counsel", "farms", "the", "IP", "to", "an", "external", "firm", "that", "handles", "the", "application", "independently", "NUMBER", "Then", "three", "years", "later", "FB", "decides", "that", "open", "source", "a", "the", "better", "route", "but", "the", "outside", "firm", "continues", "to", "chew", "the", "application", "NUMBER", "But", "GraphQL", "be", "a", "different", "open", "source", "monster", "from", "other", "FB", "projects", "because", "it", "s", "a", "spec", "without", "a", "patent", "grant", "and", "not", "software", "NUMBER", "And", "thank", "you", "again", "for", "your", "hard", "work", "and", "advocacy", "Your", "time", "and", "brilliance", "greatly", "benefits", "my", "life", "and", "makes", "my", "business", "goal", "possible", "NUMBER", "I", "just", "run", "into", "this", "article", "NUMBER", "LINK", "reverdev", "why", "we", "moved", "from", "angular", "NUMBER", "to", "vue", "js", "and", "why", "we", "didnt", "choose", "react", "ef", "NUMBER", "d", "NUMBER", "f", "NUMBER", "Notice", "the", "part", "about", "FB", "s", "license", "and", "how", "it", "helped", "sway", "the", "decision", "away", "from", "React", "NUMBER", "and", "this", "note", "in", "the", "comments", "and", "the", "licensing", "on", "React", "be", "just", "ridiculous", "but", "we", "ve", "know", "about", "that", "for", "more", "than", "a", "year", "we", "re", "just", "paying", "attention", "now", "I", "ask", "again", "be", "the", "expected", "protection", "of", "the", "BSD", "patent", "license", "worth", "such", "negative", "vibes", "which", "seem", "to", "be", "get", "worse", "Is", "FB", "s", "OSS", "really", "the", "place", "to", "leverage", "the", "fight", "against", "patent", "trolling", "if", "that", "be", "the", "intended", "purpose", "Scott", "It", "would", "be", "helpful", "to", "link", "to", "the", "patent", "relate", "to", "this", "LINK", "It", "looks", "like", "that", "patent", "covers", "GraphQL", "how", "do", "this", "affect", "companies", "who", "be", "relying", "on", "GraphQL", "be", "the", "big", "question", "here", "NUMBER", "Perhaps", "this", "be", "why", "the", "reference", "implementation", "for", "JavaScript", "include", "the", "PATENTS", "grant", "LINK", "js", "blob", "master", "PATENTS", "My", "personal", "opinion", "be", "we", "should", "EndSoftwarePatents", "very", "disappointed", "that", "anyone", "would", "put", "their", "name", "on", "that", "patent", "file", "especially", "when", "patents", "do", "not", "encourage", "innovation", "at", "all", "NUMBER", "leebyron", "thank", "you", "for", "the", "reply", "and", "the", "link", "to", "that", "blog", "post", "leebyron", "I", "could", "understand", "any", "Patent", "Law", "against", "any", "law", "sue", "because", "of", "the", "usage", "or", "any", "spec", "lib", "and", "frameworks", "made", "by", "Facebook", "but", "I", "can", "t", "not", "understand", "anything", "add", "it", "outside", "that", "specially", "on", "open", "source", "projects", "NUMBER", "There", "be", "a", "lot", "of", "fuss", "about", "FB", "OSS", "patents", "and", "the", "way", "they", "re", "granted", "but", "the", "whole", "issue", "be", "moot", "until", "and", "unless", "those", "patents", "hold", "up", "in", "court", "which", "knowing", "the", "prior", "art", "for", "both", "GraphQL", "and", "Reacf", "I", "heavily", "doubt", "they", "they", "could", "NUMBER", "so", "if", "company", "A", "uses", "GQL", "and", "sues", "FB", "then", "FB", "sues", "back", "and", "try", "to", "force", "them", "to", "not", "use", "GQL", "I", "think", "we", "will", "have", "a", "laugh", "then", "NUMBER", "Can", "t", "see", "how", "it", "would", "work", "NUMBER", "Seems", "better", "off", "for", "FB", "to", "change", "the", "license", "to", "remove", "that", "non", "sense", "NUMBER", "A", "fan", "and", "advocate", "for", "both", "GQL", "and", "React", "and", "FB", "OSS", "in", "general", "NUMBER", "I", "realize", "the", "issue", "be", "raise", "be", "about", "infringing", "for", "simply", "developing", "a", "GQL", "server", "NUMBER", "Same", "comment", "applies", "here", "moot", "until", "GQL", "patent", "be", "proven", "valid", "in", "a", "legal", "case", "NUMBER", "Till", "then", "it", "s", "pure", "legal", "posturing", "NUMBER", "As", "LawJolla", "commented", "I", "think", "there", "be", "a", "big", "difference", "between", "React", "and", "GraphQL", "specially", "regard", "patents", "NUMBER", "While", "one", "be", "a", "framework", "the", "other", "be", "a", "specification", "NUMBER", "So", "we", "can", "t", "really", "look", "at", "both", "with", "the", "same", "eyes", "neither", "accept", "the", "React", "license", "explanation", "LINK", "react", "s", "license", "in", "the", "GraphQL", "topic", "NUMBER", "Focusing", "on", "GraphQL", "here", "be", "some", "of", "my", "worries", "whose", "answers", "might", "help", "to", "understand", "what", "be", "the", "real", "implications", "of", "the", "Patent", "How", "this", "affects", "the", "different", "frameworks", "and", "ecosystems", "GraphQL", "server", "implementations", "both", "open", "source", "and", "close", "source", "SaaS", "NUMBER", "NUMBER", "GraphQL", "server", "tooling", "GraphQL", "clients", "it", "seems", "this", "case", "will", "be", "the", "less", "vulnerable", "to", "the", "Patent", "as", "analyzed", "by", "the", "article", "How", "this", "affects", "to", "new", "specifications", "highly", "inspired", "by", "the", "GraphQL", "spec", "Let", "s", "say", "GraphQL", "LINK", "language", "Could", "Facebook", "demand", "them", "Compared", "to", "GraphQL", "SQL", "it", "s", "be", "a", "specification", "standard", "that", "s", "be", "around", "for", "some", "years", "now", "and", "have", "zero", "patents", "associated", "to", "the", "standard", "itself", "NUMBER", "So", "should", "we", "accept", "the", "Patent", "argument", "for", "the", "GraphQL", "case", "Perhaps", "including", "a", "patent", "grant", "in", "the", "GraphQL", "spec", "will", "help", "to", "alleviate", "this", "concerns", "NUMBER", "We", "re", "grateful", "for", "GraphQL", "and", "believe", "it", "be", "the", "future", "of", "inter", "application", "API", "s", "with", "GRPC", "be", "the", "future", "of", "intra", "application", "API", "s", "NUMBER", "I", "wanted", "to", "mention", "that", "at", "GitLab", "we", "decided", "to", "put", "our", "GraphQL", "implementation", "on", "hold", "in", "LINK", "org", "gitlab", "ce", "issue", "NUMBER", "note_", "NUMBER", "our", "Senior", "Director", "of", "Legal", "Affairs", "mentions", "If", "we", "were", "to", "allow", "this", "license", "it", "could", "lead", "to", "potential", "future", "conflict", "with", "software", "licensed", "under", "Apache", "NUMBER", "Also", "we", "could", "be", "impairing", "the", "future", "rights", "of", "our", "customers", "NUMBER", "Essentially", "this", "be", "not", "really", "an", "open", "source", "product", "based", "on", "the", "implications", "of", "the", "license", "NUMBER", "While", "there", "be", "no", "payment", "of", "cash", "payment", "be", "in", "the", "form", "of", "giving", "up", "future", "rights", "NUMBER", "syrusakbary", "dead", "on", "and", "well", "said", "NUMBER", "The", "longer", "that", "this", "drags", "out", "the", "more", "I", "wonder", "what", "s", "going", "on", "NUMBER", "I", "have", "faith", "in", "Facebook", "and", "still", "do", "NUMBER", "But", "the", "answer", "be", "obvious", "and", "the", "fact", "we", "re", "so", "far", "into", "this", "without", "any", "legal", "uttering", "be", "disturbing", "NUMBER", "Software", "patents", "be", "rarely", "commercially", "valuable", "because", "most", "claim", "arbitrary", "elements", "NUMBER", "That", "be", "if", "you", "were", "independently", "designing", "a", "similar", "system", "odds", "be", "high", "your", "implementation", "just", "by", "sheer", "implementation", "chance", "would", "zig", "instead", "of", "zag", "NUMBER", "That", "zag", "would", "miss", "the", "claimed", "patented", "arbitrary", "implementation", "NUMBER", "But", "a", "way", "to", "make", "sure", "your", "arbitrary", "implementations", "be", "followed", "be", "to", "create", "an", "open", "spec", "NUMBER", "Then", "the", "arbitrary", "claimed", "elements", "and", "GraphQLs", "patents", "have", "a", "few", "be", "followed", "and", "infringed", "NUMBER", "Was", "GraphQL", "open", "sourced", "as", "a", "tech", "poisoned", "pill", "I", "don", "t", "think", "so", "NUMBER", "But", "as", "previously", "expressed", "this", "delay", "be", "worrisome", "NUMBER", "Since", "Facebook", "legal", "may", "read", "this", "post", "I", "think", "the", "developer", "community", "be", "in", "enough", "of", "an", "uproar", "to", "mount", "a", "crowdsourced", "crowdfunded", "USPTO", "request", "for", "reexamination", "of", "Facebook", "s", "patents", "to", "invalidate", "them", "NUMBER", "I", "think", "the", "real", "issue", "here", "be", "that", "the", "patent", "be", "patentable", "at", "all", "Reading", "the", "linked", "article", "says", "the", "examiner", "request", "they", "limit", "to", "social", "networks", "but", "that", "sounds", "non", "intuitive", "what", "kind", "of", "social", "network", "isn", "t", "based", "on", "a", "graph", "And", "querying", "graphs", "be", "not", "new", "or", "innovative", "I", "ve", "worked", "with", "XML", "databases", "many", "years", "ago", "where", "you", "could", "issue", "XPath", "style", "request", "over", "a", "network", "connection", "and", "they", "would", "traverse", "and", "return", "results", "NUMBER", "GraphQL", "be", "hardly", "different", "from", "that", "it", "s", "just", "a", "nicer", "application", "of", "it", "since", "we", "now", "live", "in", "a", "mostly", "XPath", "XSLT", "XML", "free", "world", "NUMBER", "Since", "the", "language", "of", "the", "patent", "be", "too", "broad", "do", "it", "mean", "that", "anyone", "implement", "any", "such", "hierarchical", "querying", "system", "be", "violating", "this", "patent", "Such", "query", "languages", "have", "be", "around", "for", "a", "long", "time", "before", "GraphQL", "came", "into", "the", "picture", "NUMBER", "Netflix", "s", "Falcor", "comes", "to", "mind", "NUMBER", "How", "will", "such", "query", "languages", "be", "affected", "by", "this", "patent", "Will", "someone", "be", "liable", "to", "get", "sued", "for", "build", "and", "distributing", "another", "hierarchical", "query", "language", "system", "which", "was", "implement", "independently", "of", "GraphQL", "And", "will", "the", "users", "of", "that", "system", "also", "become", "liable", "If", "so", "that", "be", "really", "bad", "and", "it", "won", "t", "be", "solve", "by", "just", "including", "a", "license", "grant", "along", "with", "GraphQL", "NUMBER", "If", "I", "be", "liable", "to", "get", "sued", "because", "I", "be", "build", "use", "a", "completely", "independent", "hierarchical", "querying", "system", "that", "sounds", "very", "unfair", "NUMBER", "Please", "clarify", "this", "point", "as", "well", "NUMBER", "Based", "on", "my", "reading", "of", "the", "patent", "and", "the", "comments", "in", "the", "Medium", "article", "by", "LawJolla", "I", "don", "t", "see", "the", "GraphQL", "patent", "passing", "the", "obvious", "test", "NUMBER", "The", "question", "would", "be", "whether", "or", "not", "a", "social", "network", "system", "be", "an", "obvious", "limitation", "to", "someone", "skilled", "in", "the", "art", "NUMBER", "Given", "the", "volume", "of", "prior", "art", "file", "with", "the", "USPTO", "use", "that", "terminology", "it", "seems", "hard", "to", "believe", "any", "argument", "claiming", "non", "obviousness", "be", "credible", "NUMBER", "A", "method", "of", "organizing", "and", "communicating", "abstract", "information", "which", "the", "Examiner", "stated", "the", "patent", "amounted", "to", "before", "add", "the", "social", "networking", "system", "limitation", "in", "the", "claim", "still", "fail", "to", "qualify", "for", "a", "patent", "if", "an", "obvious", "limitation", "be", "applied", "to", "the", "claim", "NUMBER", "I", "agree", "with", "emrul", "on", "this", "NUMBER", "Edit", "To", "put", "it", "another", "way", "to", "invalidate", "the", "patent", "you", "just", "need", "to", "prove", "someone", "queried", "data", "over", "a", "graph", "before", "Facebook", "file", "and", "that", "data", "was", "part", "of", "a", "social", "network", "system", "NUMBER", "bsbechtel", "When", "was", "the", "file", "date", "I", "did", "this", "back", "in", "NUMBER", "LINK", "It", "s", "a", "similar", "concept", "but", "with", "a", "declarative", "permissions", "system", "NUMBER", "since", "a", "few", "people", "mention", "prior", "art", "there", "s", "also", "the", "SPARQL", "LINK", "specification", "from", "NUMBER", "and", "finalized", "in", "NUMBER", "you", "can", "see", "an", "example", "in", "the", "Wikidata", "Query", "Service", "LINK", "here", "s", "an", "example", "query", "to", "try", "SELECT", "computer", "computerLabel", "location", "locationLabel", "WHERE", "SERVICE", "wikibase", "label", "bd", "serviceParam", "wikibase", "language", "AUTO_LANGUAGE", "en", "NUMBER", "OPTIONAL", "computer", "wdt", "P", "NUMBER", "wd", "Q", "NUMBER", "OPTIONAL", "computer", "wdt", "P", "NUMBER", "location", "NUMBER", "LIMIT", "NUMBER", "May", "not", "look", "like", "GraphQL", "but", "it", "be", "use", "one", "schema", "to", "query", "multiple", "other", "schemas", "which", "be", "basically", "what", "GraphQL", "be", "for", "NUMBER", "cc", "LawJolla", "I", "can", "t", "believe", "we", "be", "talking", "about", "patenting", "an", "specification", "like", "this", "one", "I", "refused", "to", "even", "think", "about", "it", "NUMBER", "With", "all", "the", "respect", "to", "all", "the", "engineering", "department", "of", "Facebook", "but", "I", "would", "crash", "the", "legal", "department", "for", "this", "my", "ethic", "as", "an", "engineer", "worth", "more", "than", "whatever", "Facebook", "could", "pay", "me", "NUMBER", "How", "it", "s", "possible", "to", "accept", "this", "I", "would", "prefer", "Facebook", "to", "be", "like", "Microsoft", "NUMBER", "and", "close", "source", "everything", "it", "s", "way", "better", "than", "put", "this", "out", "there", "open", "source", "and", "many", "of", "us", "that", "have", "no", "clue", "about", "legal", "details", "go", "to", "the", "hell", "because", "of", "this", "practices", "from", "Facebook", "NUMBER", "I", "know", "that", "be", "not", "NUMBER", "the", "engineering", "department", "of", "Facebook", "faults", "but", "if", "you", "can", "t", "win", "this", "battle", "who", "will", "either", "you", "really", "work", "harder", "on", "this", "or", "the", "whole", "industry", "will", "becomes", "this", "nightmare", "I", "bet", "a", "lot", "of", "companies", "will", "start", "copying", "this", "practices", "and", "there", "be", "no", "going", "back", "NUMBER", "omouse", "pretty", "much", "just", "put", "some", "JSON", "at", "front", "and", "it", "s", "the", "same", "NUMBER", "So", "basically", "patent", "JSON", "structures", "This", "doesn", "t", "even", "makes", "sense", "NUMBER", "I", "wouldn", "t", "care", "about", "the", "implementation", "on", "NodeJS", "and", "those", "code", "but", "patent", "in", "this", "specification", "really", "Last", "time", "I", "commented", "I", "stated", "that", "the", "discussion", "be", "moot", "until", "the", "patent", "be", "test", "in", "court", "and", "given", "the", "prior", "art", "no", "one", "should", "assume", "that", "the", "patent", "be", "valid", "NUMBER", "I", "was", "wrong", "NUMBER", "People", "be", "worried", "about", "the", "lawsuit", "and", "cost", "of", "fighting", "it", "not", "about", "whether", "they", "d", "prevail", "or", "not", "NUMBER", "Here", "be", "some", "of", "the", "better", "know", "prior", "art", "LINK", "api", "debate", "odata", "vs", "graphql", "vs", "ords", "idibidiart", "I", "understand", "the", "concern", "but", "I", "think", "both", "discussions", "be", "worth", "having", "and", "also", "closely", "relate", "NUMBER", "It", "only", "takes", "one", "case", "to", "invalidate", "the", "patent", "unlike", "a", "copyrighting", "license", "NUMBER", "Yes", "the", "legal", "fight", "would", "be", "expensive", "and", "time", "consuming", "for", "that", "individual", "team", "but", "it", "would", "also", "be", "a", "case", "where", "a", "win", "for", "that", "team", "would", "be", "a", "win", "for", "the", "entire", "open", "source", "community", "NUMBER", "Hopefully", "the", "community", "would", "realize", "this", "and", "find", "various", "ways", "to", "express", "their", "support", "NUMBER", "I", "should", "mention", "that", "at", "the", "end", "of", "the", "day", "a", "solution", "that", "works", "for", "Facebook", "the", "open", "source", "community", "and", "the", "US", "Patent", "System", "be", "the", "optimal", "outcome", "whatever", "that", "solution", "may", "be", "NUMBER", "idibidiart", "I", "would", "be", "fine", "if", "the", "Patent", "be", "ONLY", "for", "prevent", "any", "lawsuit", "from", "anyone", "because", "they", "were", "use", "the", "specification", "and", "or", "any", "tool", "from", "Facebook", "NUMBER", "NUMBER", "agree", "on", "that", "because", "it", "s", "money", "for", "Facebook", "at", "the", "end", "of", "the", "day", "and", "it", "s", "not", "fair", "for", "them", "to", "open", "source", "and", "help", "the", "community", "and", "then", "have", "to", "pay", "shit", "lot", "of", "money", "dealing", "with", "lawsuit", "from", "opportunists", "But", "that", "be", "one", "thing", "the", "other", "side", "of", "the", "coin", "be", "to", "constraint", "the", "business", "from", "use", "it", "specially", "when", "you", "be", "open", "sourcing", "under", "BSD", "bsbechtel", "yordis", "Agree", "on", "all", "points", "NUMBER", "This", "be", "a", "serious", "issue", "NUMBER", "I", "know", "leebyron", "be", "a", "serious", "guy", "and", "be", "NUMBER", "behind", "open", "source", "and", "doing", "the", "right", "thing", "NUMBER", "He", "s", "a", "pillar", "in", "the", "community", "NUMBER", "I", "also", "know", "corporate", "legal", "departments", "be", "full", "of", "people", "trying", "to", "justify", "their", "existence", "NUMBER", "It", "would", "not", "be", "fun", "for", "those", "at", "FB", "Legal", "if", "this", "lack", "of", "foresight", "cost", "them", "a", "useless", "legal", "battle", "with", "other", "patent", "holders", "whose", "patents", "be", "infringed", "upon", "by", "the", "FB", "patent", "NUMBER", "Just", "because", "one", "company", "has", "a", "patent", "on", "something", "it", "do", "not", "mean", "that", "it", "doesn", "t", "infringe", "on", "other", "patents", "NUMBER", "Reference", "LINK", "can", "a", "patent", "infringe", "another", "patent", "rlz", "NUMBER", "C", "NUMBER", "CHFA_enUS", "NUMBER", "US", "NUMBER", "oq", "can", "a", "patent", "infringe", "aqs", "chrome", "NUMBER", "j", "NUMBER", "i", "NUMBER", "j", "NUMBER", "l", "NUMBER", "j", "NUMBER", "j", "NUMBER", "sourceid", "chrome", "ie", "UTF", "NUMBER", "There", "be", "a", "potential", "material", "risk", "to", "FB", "themselves", "from", "their", "patents", "come", "under", "scrutiny", "NUMBER", "Normally", "companies", "acquire", "patents", "to", "use", "in", "bargaining", "in", "case", "of", "lawsuits", "and", "not", "in", "preemptive", "fashion", "as", "FB", "has", "do", "NUMBER", "There", "be", "definitely", "a", "risk", "to", "FB", "here", "NUMBER", "If", "they", "re", "smart", "they", "ll", "put", "a", "lid", "on", "this", "whole", "thing", "undo", "the", "stupid", "license", "and", "regain", "trust", "of", "the", "OSS", "community", "before", "things", "get", "out", "of", "control", "for", "them", "and", "the", "companies", "who", "have", "invested", "in", "GraphQL", "NUMBER", "idibidiart", "I", "hope", "they", "don", "t", "because", "they", "I", "screwed", "badly", "my", "own", "company", "all", "my", "businesses", "be", "run", "on", "top", "of", "GraphQL", "endpoints", "so", "FWIW", "I", "have", "build", "and", "use", "a", "library", "which", "implement", "hierarchical", "querying", "abilities", "on", "top", "of", "a", "REST", "API", "build", "use", "Flask", "and", "SQLAlchemy", "NUMBER", "Have", "be", "work", "on", "it", "since", "late", "NUMBER", "LINK", "sqlalchemy", "booster", "It", "would", "allow", "you", "to", "declaratively", "build", "API", "endpoints", "which", "can", "be", "queried", "like", "resources", "id", "_ds", "f", "id", "op", "v", "NUMBER", "attrs", "id", "name", "rels", "rel", "NUMBER", "attrs", "id", "date", "etc", "NUMBER", "But", "I", "be", "not", "sure", "if", "small", "projects", "like", "mine", "can", "prove", "that", "they", "were", "in", "prior", "use", "before", "GraphQL", "came", "into", "picture", "NUMBER", "In", "my", "case", "I", "be", "the", "sole", "user", "of", "my", "library", "NUMBER", "But", "surely", "libraries", "like", "Falcor", "and", "specifications", "like", "SPARQL", "point", "out", "above", "should", "be", "able", "to", "make", "an", "use", "case", "for", "prior", "art", "NUMBER", "It", "be", "sad", "that", "this", "be", "even", "be", "debated", "NUMBER", "I", "would", "like", "to", "think", "of", "this", "as", "something", "as", "abstract", "as", "REST", "itself", "and", "hence", "should", "be", "out", "of", "bounds", "for", "any", "patent", "application", "NUMBER", "A", "specification", "in", "this", "context", "be", "an", "API", "right", "The", "graphQL", "query", "mutation", "and", "schema", "spec", "be", "the", "API", "for", "GraphQL", "NUMBER", "If", "that", "s", "incorrect", "please", "explain", "how", "else", "it", "would", "need", "to", "be", "framed", "NUMBER", "If", "it", "be", "correct", "the", "Google", "vs", "Oracle", "Android", "battle", "proved", "that", "you", "cannot", "patent", "an", "API", "NUMBER", "LINK", "blog", "blogs", "why", "you", "cant", "copyright", "an", "api", "It", "s", "a", "basic", "fact", "of", "copyright", "law", "that", "you", "can", "t", "copyright", "methods", "or", "procedures", "for", "doing", "things", "NUMBER", "You", "might", "be", "able", "to", "copyright", "particular", "expressions", "for", "things", "like", "an", "evocative", "description", "of", "how", "to", "combine", "and", "prepare", "ingredients", "in", "a", "recipe", "but", "you", "can", "t", "copyright", "the", "basic", "facts", "behind", "it", "the", "ingredients", "their", "amounts", "and", "the", "order", "in", "which", "you", "combine", "them", "NUMBER", "The", "same", "be", "true", "of", "blank", "accounting", "form", "the", "rules", "of", "games", "or", "any", "other", "situation", "where", "you", "need", "a", "set", "of", "structures", "in", "order", "to", "interface", "with", "an", "underlying", "system", "NUMBER", "What", "you", "re", "doing", "be", "creating", "a", "set", "of", "ideas", "of", "how", "to", "interact", "with", "a", "system", "and", "ideas", "in", "themselves", "aren", "t", "copyrightable", "NUMBER", "You", "might", "copyright", "the", "book", "on", "accounting", "that", "contains", "your", "blank", "form", "and", "explains", "them", "you", "might", "copyright", "the", "booklet", "that", "contains", "your", "particular", "description", "of", "the", "rules", "of", "your", "new", "board", "game", "NUMBER", "But", "the", "underlying", "ideas", "that", "those", "things", "describe", "the", "form", "and", "the", "rules", "can", "be", "use", "by", "others", "without", "your", "permission", "NUMBER", "The", "same", "thing", "should", "be", "true", "for", "APIs", "NUMBER", "An", "API", "or", "application", "programming", "interface", "be", "a", "framework", "use", "to", "communicate", "with", "a", "given", "computer", "system", "NUMBER", "If", "I", "want", "an", "application", "to", "perform", "a", "particular", "calculation", "on", "a", "couple", "of", "variables", "and", "send", "me", "the", "result", "I", "need", "a", "way", "to", "structure", "that", "request", "NUMBER", "Just", "as", "with", "the", "rules", "of", "the", "game", "the", "particular", "name", "of", "that", "request", "and", "the", "order", "in", "which", "it", "takes", "its", "inputs", "and", "how", "it", "spits", "back", "its", "result", "be", "all", "parts", "of", "a", "process", "and", "method", "an", "idea", "NUMBER", "But", "a", "case", "decided", "by", "the", "Federal", "Circuit", "this", "past", "May", "throw", "that", "into", "confusion", "NUMBER", "the", "Google", "vs", "Oracle", "Android", "battle", "proved", "that", "you", "cannot", "patent", "an", "API", "NUMBER", "Patents", "and", "copyrights", "be", "entirely", "different", "things", "with", "very", "different", "rules", "and", "anyway", "the", "Federal", "Circuit", "upheld", "Oracle", "s", "copyright", "claim", "in", "that", "case", "NUMBER", "As", "a", "more", "general", "note", "for", "this", "thread", "it", "s", "pretty", "obvious", "that", "Lee", "be", "aware", "of", "the", "concerns", "and", "work", "with", "the", "Facebook", "legal", "team", "to", "come", "to", "a", "solution", "NUMBER", "I", "look", "forward", "to", "putting", "this", "to", "rest", "NUMBER", "In", "the", "meantime", "there", "s", "not", "a", "lot", "that", "anybody", "can", "do", "and", "speculating", "about", "complicated", "legal", "topics", "be", "resulting", "in", "a", "lot", "of", "misinformation", "and", "confusion", "here", "NUMBER", "If", "you", "re", "not", "a", "lawyer", "practicing", "American", "IP", "law", "i", "NUMBER", "e", "NUMBER", "LawJolla", "please", "kindly", "stop", "NUMBER", "leebyron", "you", "may", "want", "to", "consider", "locking", "this", "thread", "until", "Facebook", "legal", "has", "something", "concrete", "to", "share", "NUMBER", "I", "thougjt", "the", "issue", "be", "they", "patented", "the", "specification", "not", "merely", "copyright", "it", "Locking", "the", "thread", "be", "a", "panic", "driven", "move", "NUMBER", "I", "would", "do", "the", "same", "if", "I", "was", "FB", "but", "c", "mon", "guys", "if", "you", "shutdown", "one", "avenue", "for", "release", "frustration", "and", "sharing", "mis", "information", "people", "will", "find", "otheravenurs", "like", "Hacker", "News", "et", "al", "amd", "then", "it", "will", "really", "get", "out", "of", "hand", "I", "believe", "the", "patent", "covers", "software", "that", "do", "the", "stuff", "that", "GraphQL", "do", "such", "that", "GraphQL", "itself", "be", "just", "one", "embodiment", "NUMBER", "If", "you", "created", "your", "own", "implementation", "of", "GraphQL", "you", "d", "be", "infringing", "NUMBER", "If", "you", "created", "your", "own", "implementation", "of", "something", "sufficiently", "similar", "you", "d", "be", "infringing", "NUMBER", "You", "can", "only", "copyright", "a", "specification", "NUMBER", "Right", "So", "if", "they", "can", "t", "patent", "the", "specification", "but", "they", "have", "patented", "how", "GraphQL", "do", "stuff", "then", "chances", "be", "their", "patent", "infringes", "IBM", "s", "patents", "for", "OData", "and", "other", "patents", "held", "by", "major", "players", "in", "this", "field", "NUMBER", "That", "s", "just", "my", "naive", "brain", "can", "work", "out", "NUMBER", "Whether", "the", "discussion", "amongst", "us", "developers", "be", "generating", "misinformation", "or", "not", "the", "answer", "be", "definitely", "yes", "but", "that", "s", "just", "a", "byproduct", "of", "FB", "s", "confusing", "license", "NUMBER", "Folks", "need", "to", "focus", "on", "the", "cause", "not", "the", "symptom", "NUMBER", "I", "ve", "sold", "a", "NUMBER", "B", "consulting", "firm", "NUMBER", "largest", "in", "US", "on", "GraphQL", "and", "I", "was", "almost", "going", "to", "have", "major", "US", "retailers", "adopt", "it", "NUMBER", "This", "won", "t", "derail", "my", "plan", "until", "the", "plot", "goes", "wrong", "NUMBER", "What", "I", "expect", "be", "for", "FB", "to", "immediately", "change", "the", "license", "and", "sort", "stuff", "out", "NUMBER", "as", "oppose", "to", "let", "it", "linger", "and", "affect", "so", "many", "companies", "and", "themselves", "in", "the", "process", "NUMBER", "In", "other", "words", "lock", "the", "tread", "or", "whatever", "but", "do", "take", "immediate", "action", "NUMBER", "This", "be", "not", "a", "small", "issue", "NUMBER", "Fingers", "crossed", "NUMBER", "Disclaimer", "not", "a", "lawyer", "not", "affiliated", "with", "FB", "just", "a", "user", "of", "FB", "OSS", "NUMBER", "I", "think", "FB", "wants", "to", "see", "this", "litigated", "NUMBER", "Some", "very", "popular", "licenses", "I", "m", "looking", "at", "you", "GPL", "don", "t", "seem", "to", "be", "grounded", "by", "in", "legal", "precedent", "NUMBER", "FB", "wants", "BSD", "to", "be", "legally", "test", "so", "that", "OSS", "licenses", "carry", "more", "legal", "weight", "NUMBER", "Many", "people", "assumed", "that", "the", "BSD", "license", "was", "tantamount", "to", "a", "patent", "license", "that", "couldn", "t", "be", "selectively", "revoked", "based", "on", "litigation", "and", "while", "that", "be", "a", "reasonable", "assumption", "IMO", "there", "isn", "t", "much", "in", "the", "way", "of", "precedent", "to", "back", "it", "up", "NUMBER", "FB", "and", "other", "large", "companies", "would", "rather", "trust", "the", "mutually", "assured", "destruction", "of", "patent", "trolling", "than", "the", "mutual", "benevolence", "of", "companies", "use", "OSS", "NUMBER", "OSS", "licenses", "exist", "in", "parallel", "to", "the", "patent", "system", "and", "while", "the", "intuition", "of", "devs", "myself", "include", "be", "that", "permissions", "granted", "by", "the", "OSS", "license", "overrule", "restrictions", "imposed", "by", "the", "patent", "the", "fact", "that", "there", "be", "far", "more", "case", "law", "surrounding", "patent", "enforcement", "makes", "the", "opposite", "the", "likelier", "scenario", "namely", "that", "the", "patent", "overrides", "the", "OSS", "license", "NUMBER", "Typed", "on", "my", "phone", "sorry", "for", "error", "or", "rambling", "NUMBER", "As", "someone", "subscribed", "to", "this", "issue", "to", "keep", "update", "about", "the", "issue", "Can", "I", "second", "the", "request", "to", "keep", "speculation", "legal", "and", "otherwise", "to", "a", "minimum", "There", "be", "lots", "of", "forums", "to", "discuss", "this", "or", "speculate", "about", "it", "HN", "reddit", "NUMBER", "I", "at", "least", "be", "here", "waiting", "for", "update", "from", "FB", "and", "or", "actual", "experts", "NUMBER", "Speculation", "doesn", "t", "really", "help", "and", "just", "takes", "up", "attention", "NUMBER", "Facebook", "announced", "they", "will", "relicense", "React", "under", "MIT", "Expat", "LINK", "Awesome", "I", "encourage", "FB", "to", "consider", "transferring", "GraphQL", "to", "a", "formal", "standards", "body", "or", "at", "least", "laying", "out", "a", "roadmap", "to", "doing", "so", "dosire", "That", "s", "great", "NUMBER", "But", "what", "about", "their", "patent", "on", "GraphQL", "technologies", "That", "s", "what", "get", "this", "thread", "start", "NUMBER", "As", "I", "see", "it", "FB", "either", "needs", "to", "grant", "a", "patent", "license", "for", "anyone", "doing", "GraphQL", "and", "add", "the", "patent", "clause", "only", "for", "those", "suing", "them", "due", "to", "GraphQL", "technology", "patent", "infringements", "or", "they", "could", "drop", "the", "GraphQL", "patent", "and", "add", "a", "clause", "that", "GraphQL", "technology", "cannot", "be", "patented", "by", "anyone", "else", "NUMBER", "If", "you", "ask", "me", "a", "clause", "avoiding", "patents", "be", "actually", "miss", "in", "the", "MIT", "license", "NUMBER", "Something", "like", "No", "patents", "may", "be", "made", "from", "this", "software", "or", "its", "concepts", "or", "any", "derivative", "software", "use", "this", "software", "NUMBER", "NUMBER", "That", "maybe", "not", "the", "proper", "legal", "way", "to", "formulate", "it", "but", "you", "get", "the", "drift", "NUMBER", "OSS", "needs", "to", "fight", "against", "software", "patenting", "because", "they", "and", "those", "trying", "to", "take", "advantage", "of", "them", "in", "unethical", "ways", "be", "the", "evil", "in", "this", "game", "NUMBER", "FB", "be", "only", "trying", "to", "protect", "themselves", "from", "these", "people", "in", "the", "end", "and", "I", "can", "understand", "that", "NUMBER", "But", "it", "derails", "their", "projects", "from", "the", "OSS", "community", "spirit", "unfortunately", "NUMBER", "And", "as", "you", "can", "see", "from", "the", "React", "announcement", "Facebook", "gets", "it", "which", "be", "totally", "cool", "Now", "to", "solve", "GraphQL", "s", "OSS", "community", "and", "patent", "issue", "Scott", "grahamegrieve", "leebyron", "I", "completely", "agree", "NUMBER", "GraphQL", "be", "be", "hailed", "by", "many", "developers", "as", "a", "replacement", "for", "REST", "NUMBER", "Please", "allow", "it", "to", "become", "this", "and", "not", "limit", "its", "potential", "impact", "with", "licensing", "issue", "NUMBER", "GraphQL", "needs", "a", "formal", "standards", "body", "NUMBER", "That", "s", "great", "Thank", "you", "Facebook", "for", "push", "the", "web", "towards", "open", "and", "accessible", "standards", "Incredible", "work", "leebyron", "NUMBER", "I", "ve", "read", "the", "OWF", "v", "NUMBER", "and", "think", "it", "s", "entirely", "appropriate", "for", "GraphQL", "and", "should", "put", "the", "legal", "issue", "to", "bed", "NUMBER", "I", "sent", "up", "another", "Medium", "post", "that", "Facebook", "needs", "to", "go", "on", "record", "stating", "there", "be", "no", "patents", "protecting", "their", "MIT", "licensed", "software", "NUMBER", "But", "as", "far", "as", "GraphQL", "let", "s", "close", "this", "issue", "and", "move", "on", "to", "bigger", "and", "better", "things", "Thank", "you", "contributors", "for", "enriching", "my", "life", "NUMBER", "and", "allowing", "me", "to", "never", "write", "another", "forsaken", "REST", "endpoint", "NUMBER", "Thanks", "so", "much", "leebyron", "NUMBER", "This", "be", "big", "from", "a", "higher", "standpoint", "to", "me", "because", "it", "shows", "that", "even", "big", "corporations", "can", "show", "true", "heart", "community", "spirit", "and", "do", "what", "be", "best", "for", "everyone", "in", "the", "end", "NUMBER", "Way", "to", "go", "Scott", "leebyron", "this", "be", "great", "news", "well", "do", "on", "advocating", "for", "this", "internally", "NUMBER", "I", "have", "an", "implementation", "question", "that", "perhaps", "you", "can", "pass", "back", "to", "your", "legal", "team", "how", "should", "we", "ensure", "that", "a", "NUMBER", "party", "implementation", "such", "as", "LINK", "php", "links", "back", "to", "the", "OWFa", "licensed", "specification", "to", "clarify", "that", "it", "be", "covered", "by", "its", "patent", "grants", "NUMBER", "For", "example", "should", "there", "be", "some", "kind", "of", "reference", "sentence", "in", "the", "LICENSE", "of", "graphql", "php", "Are", "you", "planning", "on", "make", "some", "relevant", "reference", "in", "graphql", "js", "as", "a", "guide", "I", "understand", "of", "course", "that", "anyone", "who", "be", "particularly", "nervous", "about", "such", "things", "should", "seek", "their", "own", "legal", "advice", "but", "I", "thought", "it", "would", "be", "better", "to", "start", "with", "a", "Facebook", "recommended", "model", "to", "apply", "in", "such", "situations", "rather", "than", "every", "project", "get", "something", "draft", "by", "their", "own", "lawyer", "NUMBER", "Thanks", "again", "for", "your", "work", "on", "this", "Sam", "leebyron", "be", "you", "able", "to", "comment", "on", "the", "above", "Please", "add", "scope", "directive", "to", "be", "possible", "to", "mark", "what", "permissions", "roles", "should", "have", "user", "in", "order", "to", "be", "able", "to", "fetch", "data", "NUMBER", "Example", "type", "Post", "id", "ID", "comments", "Comment", "scope", "authenticated", "Yeah", "it", "can", "be", "enable", "without", "a", "change", "to", "GraphQL", "but", "be", "it", "a", "very", "common", "one", "so", "will", "be", "better", "to", "be", "in", "core", "I", "think", "NUMBER", "Thanks", "NUMBER", "this", "should", "be", "in", "user", "land", "permissions", "be", "very", "specific", "for", "an", "application", "context", "Currently", "the", "GraphQL", "spec", "at", "LINK", "sec", "Field", "Selection", "Merging", "only", "mention", "conditions", "that", "have", "to", "apply", "in", "order", "for", "field", "in", "a", "selection", "to", "merge", "NUMBER", "While", "discussing", "a", "fix", "to", "an", "issue", "Youshido", "GraphQL", "NUMBER", "the", "specification", "was", "brought", "up", "NUMBER", "It", "be", "pretty", "confusing", "to", "infer", "how", "to", "actually", "merge", "field", "in", "a", "selection", "just", "from", "the", "specs", "alone", "because", "they", "only", "seem", "to", "be", "talking", "about", "how", "to", "know", "when", "multiple", "field", "can", "merge", "and", "not", "about", "how", "to", "actually", "do", "the", "merge", "NUMBER", "Can", "we", "get", "some", "more", "specific", "documentation", "on", "how", "to", "merge", "field", "Can", "we", "get", "some", "examples", "of", "how", "to", "merge", "field", "of", "object", "types", "and", "array", "types", "fix", "copy", "paste", "error", "in", "the", "same", "way", "as", "LINK", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "mailto", "cla", "fb", "NUMBER", "com", "subject", "CLA", "NUMBER", "for", "NUMBER", "facebook", "NUMBER", "Fgraphql", "NUMBER", "NUMBER", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "LINK", "was", "against", "the", "wrong", "branch", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "mailto", "cla", "fb", "NUMBER", "com", "subject", "CLA", "NUMBER", "for", "NUMBER", "facebook", "NUMBER", "Fgraphql", "NUMBER", "NUMBER", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "wincent", "nice", "spec", "glad", "to", "help", "Hi", "GraphQLers", "I", "d", "like", "feedback", "on", "an", "idea", "to", "spec", "the", "NUMBER", "graphql", "file", "format", "and", "within", "that", "to", "spec", "a", "syntax", "for", "importing", "fragment", "from", "other", "file", "inspired", "by", "LINK", "tag", "pull", "NUMBER", "by", "Poincare", "and", "stubailo", "NUMBER", "I", "would", "like", "to", "see", "this", "specced", "so", "developers", "can", "store", "their", "application", "s", "queries", "in", "file", "co", "located", "with", "the", "associated", "application", "code", "that", "can", "be", "consumed", "by", "tooling", "in", "multiple", "languages", "platforms", "NUMBER", "TAG", "TAG", "A", "little", "aside", "NUMBER", "TAG", "It", "s", "particularly", "useful", "for", "us", "because", "our", "migration", "strategy", "from", "REST", "to", "GraphQL", "be", "to", "replace", "exist", "network", "request", "with", "GraphQL", "queries", "and", "we", "use", "a", "stored", "operation", "persisted", "query", "system", "so", "the", "queries", "have", "to", "be", "build", "and", "submitted", "before", "reaching", "prod", "NUMBER", "The", "queries", "should", "be", "stored", "with", "the", "code", "in", "a", "way", "that", "can", "be", "statically", "build", "and", "uploaded", "with", "a", "standalone", "tool", "NUMBER", "TAG", "Specifically", "I", "want", "to", "avoid", "requiring", "developers", "to", "maintain", "massive", "file", "that", "contain", "single", "queries", "duplication", "of", "identical", "fragment", "within", "those", "queries", "for", "standard", "objects", "that", "never", "change", "across", "the", "API", "In", "my", "mind", "the", "file", "format", "spec", "be", "relatively", "simple", "requiring", "extension", "NUMBER", "graphql", "character", "encoding", "Unicode", "I", "m", "not", "a", "specialist", "here", "unsure", "of", "nuance", "MIME", "type", "text", "graphql", "To", "avoid", "fragment", "duplication", "I", "would", "also", "like", "to", "spec", "the", "_import_", "syntax", "for", "fragment", "NUMBER", "The", "goal", "of", "this", "syntax", "be", "that", "large", "query", "file", "can", "be", "split", "into", "fragment", "and", "the", "composite", "query", "NUMBER", "graphql", "file", "be", "transferable", "between", "platforms", "eg", "NUMBER", "write", "for", "Android", "but", "parsed", "by", "Scala", "be", "completely", "opt", "in", "and", "not", "break", "exist", "GraphQL", "file", "Feature", "wise", "imports", "would", "support", "direct", "import", "fragment", "can", "be", "imported", "from", "another", "file", "support", "transitive", "import", "dependencies", "of", "a", "dependency", "be", "imported", "too", "not", "support", "circular", "imports", "only", "support", "relative", "path", "imports", "no", "URLs", "or", "absolute", "paths", "Fragments", "would", "be", "imported", "in", "their", "entirety", "you", "_cannot_", "import", "by", "name", "and", "you", "_cannot_", "alias", "NUMBER", "This", "be", "to", "simplify", "implementation", "and", "to", "dodge", "the", "namespacing", "problem", "YAGNI", "NUMBER", "Put", "another", "way", "avoiding", "fragment", "name", "clashes", "be", "a", "user", "land", "problem", "NUMBER", "Regarding", "circular", "imports", "they", "should", "be", "considered", "invalid", "if", "fragment", "file", "a", "imports", "fragment", "file", "b", "which", "imports", "a", "the", "latter", "a", "would", "be", "invalid", "and", "should", "cause", "an", "error", "in", "the", "implementation", "NUMBER", "In", "terms", "of", "syntax", "there", "be", "some", "more", "goal", "look", "GraphQL", "ish", "support", "future", "extension", "if", "named", "imports", "proves", "useful", "achievable", "I", "suggest", "inspired", "by", "JavaScript", "and", "poincare", "s", "work", "LINK", "tag", "pull", "NUMBER", "graphql", "file", "my_user", "NUMBER", "graphql", "import", "NUMBER", "basic_user", "NUMBER", "graphql", "query", "id", "ID", "user", "id", "id", "NUMBER", "BasicUser", "my_field", "graphql", "file", "basic_user", "NUMBER", "graphql", "fragment", "BasicUser", "on", "User", "id", "name", "Thoughts", "Initially", "please", "give", "me", "a", "sense", "of", "something", "you", "need", "yes", "no", "something", "you", "can", "forsee", "needing", "yes", "no", "be", "there", "a", "viable", "alternative", "to", "this", "given", "the", "goal", "above", "YAGNI", "be", "there", "more", "prior", "art", "here", "I", "have", "also", "see", "it", "mention", "here", "intellij", "plugin", "NUMBER", "_Please_", "let", "s", "avoid", "bikeshedding", "on", "the", "import", "syntax", "that", "can", "come", "later", "NUMBER", "intellij", "plugin", "LINK", "graphql", "intellij", "plugin", "issue", "NUMBER", "issuecomment", "NUMBER", "Unless", "I", "be", "reading", "this", "wrong", "we", "be", "saying", "we", "will", "need", "to", "design", "all", "the", "queries", "we", "wish", "the", "client", "to", "use", "prior", "to", "release", "This", "be", "Imo", "the", "opposite", "of", "flexibility", "NUMBER", "Its", "a", "view", "that", "cannot", "be", "extend", "in", "RDBMs", "land", "This", "would", "not", "work", "for", "me", "as", "I", "particularly", "fell", "for", "QueryQL", "because", "my", "users", "generate", "their", "query", "on", "the", "fly", "through", "and", "interface", "its", "a", "management", "tool", "for", "their", "data", "NUMBER", "I", "think", "its", "a", "nice", "add", "on", "for", "queries", "often", "use", "just", "as", "Views", "be", "a", "nice", "add", "on", "if", "you", "can", "extend", "P", "If", "I", "mis", "read", "please", "let", "me", "know", "if", "now", "I", "better", "fork", "now", "brokenpeace", "Don", "t", "worry", "this", "idea", "be", "opt", "in", "as", "be", "persisted", "queries", "NUMBER", "You", "can", "keep", "use", "GraphQL", "the", "way", "you", "be", "How", "about", "ability", "as", "second", "part", "mention", "utilizing", "both", "If", "it", "do", "provide", "benefit", "for", "a", "lot", "of", "use", "cases", "just", "my", "few", "particular", "ones", "NUMBER", "I", "do", "like", "the", "concept", "NUMBER", "Actually", "looking", "at", "the", "esparse", "library", "we", "can", "just", "add", "optionals", "in", "this", "case", "perhaps", "we", "use", "the", "template", "name", "hash", "of", "the", "field", "in", "a", "cached", "persisted", "folder", "I", "dig", "the", "idea", "completely", "but", "I", "be", "just", "trying", "to", "figure", "out", "how", "to", "keep", "it", "simple", "yet", "flexible", "which", "be", "what", "I", "love", "about", "it", "It", "would", "be", "great", "to", "see", "some", "form", "of", "this", "incorporated", "within", "relay", "compiler", "NUMBER", "Seems", "like", "a", "great", "way", "avoid", "issue", "with", "more", "than", "one", "file", "containing", "fragment", "with", "the", "same", "name", "e", "NUMBER", "g", "NUMBER", "a", "Foo", "NUMBER", "js", "and", "b", "Foo", "NUMBER", "js", "both", "contain", "a", "Foo_viewer", "fragment", "NUMBER", "See", "LINK", "Yep", "one", "reason", "we", "didn", "t", "go", "with", "the", "Relay", "Modern", "approach", "for", "fragment", "in", "Apollo", "be", "to", "avoid", "having", "a", "global", "namespace", "where", "you", "could", "run", "into", "naming", "conflict", "NUMBER", "It", "would", "be", "nice", "to", "have", "a", "module", "like", "approach", "NUMBER", "One", "cute", "thing", "suggested", "by", "calebmer", "once", "was", "graphql", "query", "me", "firstName", "NUMBER", "userDetails", "import", "from", "NUMBER", "UserDetails", "I", "think", "all", "tooling", "should", "be", "build", "to", "work", "equally", "well", "with", "queries", "in", "JS", "code", "and", "queries", "in", "standalone", "file", "NUMBER", "For", "example", "both", "Apollo", "and", "Relay", "persisted", "queries", "work", "fine", "with", "queries", "write", "as", "part", "of", "JS", "code", "but", "require", "unique", "fragment", "names", "NUMBER", "stubailo", "Do", "you", "have", "specific", "feedback", "on", "the", "proposal", "It", "seems", "you", "re", "saying", "that", "you", "_don", "t_", "like", "that", "fragment", "would", "exist", "in", "a", "global", "namespace", "Avoiding", "the", "global", "import", "add", "a", "lot", "of", "complexity", "to", "the", "spec", "tooling", "that", "we", "might", "not", "want", "to", "incur", "how", "be", "fragment", "namespaced", "do", "you", "import", "them", "by", "name", "can", "you", "alias", "if", "you", "import", "a", "fragment", "by", "name", "what", "happens", "to", "_its_", "dependencies", "what", "if", "a", "transitive", "dependency", "has", "a", "name", "clash", "do", "you", "auto", "namespace", "transitive", "dependencies", "I", "m", "keen", "to", "get", "a", "_simple_", "version", "specced", "soon", "as", "the", "community", "be", "already", "run", "into", "this", "problem", "and", "solving", "it", "ad", "hoc", "NUMBER", "We", "can", "leave", "the", "door", "open", "to", "improvement", "like", "namespacing", "in", "the", "future", "NUMBER", "The", "way", "Apollo", "do", "persisted", "queries", "which", "I", "haven", "t", "use", "so", "my", "understanding", "be", "based", "on", "this", "persisted", "seems", "to", "be", "compatible", "with", "this", "proposal", "NUMBER", "persisted", "LINK", "blog", "NUMBER", "apollodata", "NUMBER", "com", "persisted", "graphql", "queries", "with", "apollo", "client", "NUMBER", "fd", "NUMBER", "e", "NUMBER", "bba", "NUMBER", "Here", "s", "my", "current", "set", "of", "opinions", "NUMBER", "Having", "imports", "be", "valuable", "NUMBER", "I", "really", "like", "the", "ES", "NUMBER", "module", "system", "stuff", "like", "circular", "dependencies", "and", "be", "able", "to", "import", "just", "one", "fragment", "from", "a", "document", "be", "really", "useful", "like", "having", "a", "fragment", "NUMBER", "graphql", "and", "importing", "individual", "fragment", "from", "there", "seems", "like", "a", "pretty", "good", "pattern", "NUMBER", "We", "should", "definitely", "follow", "dependencies", "this", "should", "be", "simple", "because", "GraphQL", "as", "a", "language", "be", "quite", "simple", "NUMBER", "Things", "that", "break", "the", "GraphQL", "parser", "AST", "be", "harder", "to", "test", "out", "quickly", "so", "a", "short", "term", "solution", "based", "on", "directives", "or", "comments", "be", "desirable", "Regarding", "circular", "imports", "they", "should", "be", "considered", "invalid", "I", "don", "t", "think", "this", "should", "be", "the", "case", "since", "in", "GraphQL", "it", "should", "be", "pretty", "easy", "to", "resolve", "any", "dependencies", "like", "that", "NUMBER", "So", "basically", "graphql", "PersonFragments", "NUMBER", "graphql", "fragment", "PersonBasicInfo", "on", "Person", "firstName", "lastName", "avatar", "small", "fragment", "PersonDetails", "on", "Person", "NUMBER", "PersonBasicInfo", "address", "street", "state", "zipCode", "Then", "you", "can", "import", "graphql", "import", "PersonDetails", "from", "NUMBER", "PersonFragments", "query", "CurrentUserDetails", "currentUser", "NUMBER", "PersonDetails", "Maybe", "you", "can", "rename", "to", "avoid", "name", "collisions", "graphql", "import", "PersonDetails", "from", "NUMBER", "PersonFragments", "import", "PersonDetails", "as", "AvatarPersonDetails", "from", "NUMBER", "AvatarFragments", "query", "CurrentUserDetails", "currentUser", "NUMBER", "PersonDetails", "NUMBER", "AvatarPersonDetails", "So", "the", "name", "collision", "thing", "be", "interesting", "NUMBER", "One", "situation", "I", "m", "worried", "about", "be", "where", "you", "have", "two", "parts", "of", "your", "app", "you", "use", "to", "use", "separately", "but", "then", "you", "want", "to", "use", "a", "fragment", "across", "that", "boundary", "NUMBER", "You", "might", "have", "a", "whole", "world", "of", "duplicate", "fragment", "names", "and", "renaming", "them", "all", "be", "not", "feasible", "NUMBER", "That", "seems", "to", "imply", "that", "it", "would", "be", "valuable", "to", "have", "some", "way", "to", "import", "two", "fragment", "with", "the", "same", "name", "and", "have", "it", "still", "work", "NUMBER", "However", "there", "s", "no", "scoping", "in", "GraphQL", "all", "fragment", "names", "be", "totally", "global", "NUMBER", "So", "either", "we", "need", "to", "assign", "that", "fragment", "a", "unique", "name", "as", "part", "of", "the", "import", "evaluation", "not", "ideal", "or", "convert", "it", "to", "an", "inline", "fragment", "also", "not", "ideal", "NUMBER", "I", "m", "keen", "to", "get", "a", "simple", "version", "specced", "soon", "as", "the", "community", "be", "already", "run", "into", "this", "problem", "and", "solving", "it", "ad", "hoc", "NUMBER", "We", "can", "leave", "the", "door", "open", "to", "improvement", "like", "namespacing", "in", "the", "future", "NUMBER", "Is", "there", "a", "disadvantage", "to", "use", "the", "current", "experimental", "approach", "with", "comments", "until", "a", "good", "spec", "be", "finalized", "Something", "like", "a", "module", "system", "probably", "shouldn", "t", "be", "add", "lightly", "NUMBER", "I", "don", "t", "think", "this", "should", "be", "the", "case", "since", "in", "GraphQL", "it", "should", "be", "pretty", "easy", "to", "resolve", "any", "dependencies", "like", "that", "NUMBER", "Maybe", "NUMBER", "I", "don", "t", "think", "circular", "dependencies", "be", "that", "simple", "NUMBER", "It", "s", "certainly", "more", "simple", "than", "in", "an", "imperative", "language", "but", "you", "still", "have", "to", "worry", "about", "ordering", "do", "you", "hoist", "the", "import", "statements", "if", "not", "what", "be", "the", "implications", "NUMBER", "I", "need", "to", "think", "more", "about", "edge", "cases", "of", "circular", "imports", "NUMBER", "So", "either", "we", "need", "to", "assign", "that", "fragment", "a", "unique", "name", "as", "part", "of", "the", "import", "evaluation", "not", "ideal", "or", "convert", "it", "to", "an", "inline", "fragment", "also", "not", "ideal", "NUMBER", "This", "be", "the", "transitive", "problem", "I", "mention", "NUMBER", "As", "soon", "as", "imports", "become", "more", "advance", "than", "a", "literal", "file", "contents", "copy", "it", "become", "an", "issue", "that", "needs", "specification", "NUMBER", "That", "makes", "the", "spec", "more", "complex", "which", "be", "generally", "undesirable", "NUMBER", "It", "s", "preferable", "in", "this", "case", "to", "see", "how", "developers", "solve", "that", "problem", "automatic", "renaming", "fail", "the", "build", "and", "perhaps", "later", "encode", "it", "in", "the", "spec", "NUMBER", "Is", "there", "a", "disadvantage", "to", "use", "the", "current", "experimental", "approach", "with", "comments", "until", "a", "good", "spec", "be", "finalized", "Something", "like", "a", "module", "system", "probably", "shouldn", "t", "be", "add", "lightly", "NUMBER", "No", "it", "s", "fine", "but", "implementations", "will", "diverge", "and", "may", "become", "incompatible", "NUMBER", "It", "will", "be", "painful", "to", "walk", "back", "from", "that", "for", "everyone", "NUMBER", "A", "little", "bit", "of", "experimentation", "in", "the", "community", "be", "great", "and", "be", "what", "inspired", "file", "this", "issue", "but", "you", "still", "have", "to", "worry", "about", "ordering", "That", "s", "one", "nice", "thing", "ordering", "doesn", "t", "matter", "in", "GraphQL", "so", "I", "think", "the", "issue", "becomes", "much", "simpler", "NUMBER", "As", "soon", "as", "imports", "become", "more", "advance", "than", "a", "literal", "file", "contents", "copy", "So", "the", "current", "comment", "based", "approach", "as", "you", "ve", "seen", "be", "a", "straight", "copy", "NUMBER", "I", "think", "if", "we", "decide", "that", "approach", "be", "fine", "it", "doesn", "t", "need", "to", "be", "in", "the", "language", "spec", "IMO", "NUMBER", "Then", "it", "s", "more", "like", "a", "preprocessor", "I", "guess", "I", "m", "not", "clear", "on", "how", "preprocessor", "stuff", "works", "in", "C", "for", "example", "be", "it", "part", "of", "the", "language", "spec", "Just", "wanted", "to", "say", "NUMBER", "on", "experimentation", "for", "the", "time", "be", "NUMBER", "I", "just", "recently", "learned", "graphql", "tag", "s", "approach", "which", "be", "great", "also", "github", "graphql", "client", "uses", "Ruby", "constants", "to", "import", "GraphQL", "fragment", "NUMBER", "Kind", "of", "crazy", "but", "just", "thought", "I", "d", "share", "another", "example", "I", "think", "if", "we", "decide", "that", "approach", "be", "fine", "it", "doesn", "t", "need", "to", "be", "in", "the", "language", "spec", "IMO", "NUMBER", "I", "think", "it", "s", "worth", "having", "something", "specced", "so", "you", "can", "be", "reasonably", "sure", "you", "have", "compatible", "implementations", "NUMBER", "Perhaps", "if", "not", "in", "this", "spec", "it", "would", "be", "worth", "write", "down", "the", "rules", "somewhere", "NUMBER", "I", "thought", "in", "more", "depth", "about", "a", "more", "complex", "import", "syntax", "support", "import", "by", "name", "and", "aliasing", "and", "I", "think", "you", "re", "right", "it", "s", "useful", "enough", "that", "it", "might", "be", "worth", "talking", "through", "in", "detail", "NUMBER", "If", "the", "features", "were", "support", "direct", "import", "fragment", "be", "imported", "from", "another", "file", "by", "name", "support", "aliasing", "fragment", "can", "be", "renamed", "during", "import", "support", "transitive", "import", "dependencies", "of", "a", "dependency", "be", "imported", "too", "circular", "imports", "allow", "with", "cycle", "detection", "only", "support", "relative", "path", "imports", "no", "URLs", "or", "absolute", "paths", "Then", "we", "could", "look", "at", "the", "syntax", "you", "describe", "taken", "from", "JS", "graphql", "import", "User", "as", "MyUser", "from", "NUMBER", "user", "However", "before", "we", "get", "there", "I", "want", "to", "discuss", "be", "there", "a", "way", "to", "achieve", "the", "goal", "stated", "above", "without", "introduce", "new", "syntax", "If", "we", "can", "then", "it", "s", "the", "preferable", "option", "I", "think", "NUMBER", "I", "think", "a", "directive", "based", "approach", "would", "work", "to", "satisfy", "all", "of", "the", "above", "cases", "without", "new", "syntax", "graphql", "query", "me", "firstName", "NUMBER", "userDetails", "import", "name", "specificUserDetails", "from", "NUMBER", "UserDetails", "Without", "get", "too", "much", "into", "syntax", "I", "m", "really", "keen", "to", "address", "the", "question", "at", "the", "bottom", "of", "my", "comment", "be", "there", "a", "way", "to", "achieve", "the", "goal", "stated", "above", "without", "introduce", "new", "syntax", "Are", "there", "any", "alternatives", "I", "do", "think", "this", "be", "one", "case", "though", "where", "the", "existence", "of", "a", "system", "where", "imports", "weren", "t", "use", "doesn", "t", "mean", "they", "be", "never", "going", "to", "be", "valuable", "NUMBER", "Sure", "it", "s", "possible", "to", "get", "by", "without", "them", "but", "it", "s", "also", "possible", "to", "use", "programming", "languages", "without", "any", "module", "system", "NUMBER", "I", "think", "imports", "be", "valuable", "to", "NUMBER", "Integrate", "with", "module", "based", "systems", "like", "JavaScript", "frontends", "NUMBER", "Avoid", "the", "necessity", "for", "globally", "unique", "fragment", "names", "which", "can", "become", "a", "hassle", "if", "you", "develop", "two", "code", "bases", "in", "isolation", "and", "then", "need", "to", "combine", "them", "into", "one", "app", "NUMBER", "Identify", "where", "fragment", "be", "come", "from", "in", "a", "large", "codebase", "without", "specialized", "tooling", "I", "certainly", "didn", "t", "make", "that", "claim", "NUMBER", "Where", "did", "you", "see", "me", "make", "it", "I", "didn", "t", "say", "you", "made", "it", "sorry", "if", "it", "seem", "that", "way", "I", "can", "understand", "how", "it", "s", "easy", "to", "get", "by", "without", "imports", "when", "the", "following", "restrictions", "be", "in", "place", "which", "to", "the", "best", "of", "my", "understanding", "be", "the", "case", "at", "Facebook", "NUMBER", "Unique", "file", "names", "LINK", "overview", "NUMBER", "html", "custom", "module", "system", "monorepo", "Fragment", "naming", "convention", "based", "on", "file", "names", "It", "s", "much", "more", "awkward", "when", "you", "try", "to", "adopt", "it", "to", "an", "exist", "code", "base", "with", "a", "nested", "directory", "structure", "non", "unique", "file", "names", "and", "fragment", "in", "modules", "that", "be", "shared", "via", "a", "packaging", "system", "like", "npm", "NUMBER", "I", "ve", "be", "work", "on", "a", "proof", "of", "concept", "of", "stubailo", "s", "directive", "based", "proposal", "in", "relay", "compiler", "LINK", "wincent", "Thanks", "for", "your", "input", "here", "NUMBER", "I", "have", "some", "follow", "up", "question", "NUMBER", "How", "be", "full", "queries", "constructed", "at", "Facebook", "From", "what", "I", "gather", "you", "have", "a", "collection", "of", "named", "queries", "and", "fragment", "NUMBER", "Looking", "at", "Relay", "they", "re", "write", "in", "code", "directly", "not", "file", "be", "this", "also", "true", "for", "your", "native", "clients", "Do", "you", "have", "equivalents", "to", "the", "Relay", "compiler", "for", "Android", "and", "iOS", "queries", "This", "PR", "be", "a", "follow", "up", "WG", "discussion", "about", "defining", "stages", "for", "change", "to", "GraphQL", "specification", "NUMBER", "I", "copied", "stage", "descriptions", "from", "my", "slides", "LINK", "sharing", "as", "an", "early", "draft", "to", "keep", "momentum", "and", "continue", "the", "conversation", "NUMBER", "wincent", "Thank", "you", "for", "proofreading", "I", "think", "the", "one", "thing", "that", "be", "miss", "here", "be", "a", "framing", "statement", "at", "the", "top", "to", "provide", "a", "little", "more", "context", "I", "ve", "add", "an", "one", "based", "on", "the", "text", "from", "your", "commit", "NUMBER", "What", "do", "you", "think", "What", "do", "you", "have", "in", "mind", "for", "the", "checklist", "I", "think", "Lee", "s", "list", "LINK", "NUMBER", "m", "NUMBER", "s", "from", "GraphQL", "Europe", "talk", "can", "serve", "as", "a", "basis", "NUMBER", "So", "in", "theory", "it", "will", "stimulate", "PR", "author", "to", "answer", "basic", "question", "before", "make", "PR", "and", "thus", "save", "reviewer", "time", "and", "improve", "quality", "of", "PRs", "NUMBER", "But", "before", "add", "something", "concrete", "I", "want", "to", "make", "small", "research", "and", "see", "how", "it", "s", "do", "in", "other", "WG", "committee", "etc", "NUMBER", "I", "add", "TBD", "not", "to", "block", "discussion", "of", "stages", "since", "I", "think", "we", "can", "define", "checklist", "afterward", "NUMBER", "wincent", "Great", "idea", "Done", "My", "inclination", "be", "to", "merge", "this", "as", "be", "but", "add", "a", "Draft", "label", "and", "iterate", "from", "there", "NUMBER", "wincent", "I", "suggest", "we", "proceed", "toward", "Candidate", "stage", "by", "Notify", "all", "members", "of", "GraphQL", "WG", "LINK", "wg", "Community", "consent", "on", "the", "propose", "change", "NUMBER", "If", "it", "s", "hard", "to", "achieve", "add", "it", "to", "agenda", "of", "the", "next", "WG", "meeting", "NUMBER", "No", "change", "to", "the", "graphql", "PR", "for", "at", "least", "last", "NUMBER", "days", "What", "do", "you", "think", "wincent", "Make", "sense", "Should", "I", "add", "something", "to", "the", "document", "itself", "For", "example", "Draft", "document", "discussion", "here", "LINK", "NUMBER", "wincent", "Done", "type", "Person", "firstName", "String", "lastName", "String", "age", "Int", "How", "to", "query", "all", "people", "what", "be", "older", "than", "NUMBER", "That", "s", "not", "part", "of", "the", "graphql", "specification", "you", "need", "to", "add", "argument", "to", "your", "field", "for", "all", "of", "the", "filters", "you", "would", "like", "to", "support", "NUMBER", "To", "clarify", "the", "answer", "you", "would", "pass", "the", "argument", "to", "yoir", "resolvers", "and", "deal", "with", "it", "at", "the", "API", "or", "db", "query", "level", "wherever", "you", "re", "get", "your", "data", "from", "NUMBER", "Is", "there", "a", "specification", "about", "error", "responses", "what", "status", "should", "be", "what", "field", "it", "should", "contains", "graphql", "js", "respond", "with", "status", "NUMBER", "on", "invalid", "query", "Github", "LINK", "respond", "with", "status", "NUMBER", "on", "invalid", "query", "Is", "it", "possible", "to", "mark", "show", "that", "some", "collections", "can", "be", "accessed", "only", "by", "user", "which", "has", "same", "permissions", "roles", "This", "would", "be", "do", "in", "the", "Access", "Control", "Layer", "of", "your", "application", "NUMBER", "In", "this", "context", "the", "modeling", "of", "your", "data", "it", "would", "not", "know", "what", "roles", "should", "have", "access", "not", "to", "mention", "that", "would", "add", "a", "real", "burden", "to", "maintain", "NUMBER", "I", "do", "not", "know", "your", "setup", "but", "I", "would", "highly", "recommend", "looking", "into", "ACL", "middleware", "to", "restrict", "this", "NUMBER", "I", "thought", "on", "this", "more", "and", "watched", "GitHub", "release", "of", "Graphql", "implement", "hidden", "field", "for", "roles", "NUMBER", "Itypically", "she", "ick", "by", "my", "initial", "thought", "but", "it", "did", "make", "sense", "if", "it", "s", "NUMBER", "Ring", "locked", "down", "record", "level", "to", "hold", "that", "meta", "on", "the", "model", "NUMBER", "I", "still", "think", "the", "enforcement", "would", "need", "a", "special", "middle", "layer", "to", "ensure", "the", "users", "request", "be", "acceptable", "before", "ever", "querying", "NUMBER", "just", "my", "thight", "NUMBER", "On", "Wed", "Aug", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "Greg", "Hurrell", "TAG", "write", "Closed", "NUMBER", "TAG", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "At", "the", "begining", "we", "have", "schema", "type", "User", "id", "ID", "name", "String", "birthday", "String", "After", "some", "time", "it", "was", "decided", "that", "birthday", "be", "not", "mandatory", "for", "new", "users", "so", "the", "schema", "should", "change", "to", "type", "User", "id", "ID", "name", "String", "birthday", "String", "This", "be", "breaking", "change", "NUMBER", "Old", "clients", "can", "crash", "they", "know", "that", "this", "field", "be", "not", "nullable", "but", "we", "will", "send", "null", "because", "we", "don", "t", "have", "birthday", "of", "all", "users", "NUMBER", "How", "to", "version", "case", "like", "this", "in", "GraphQL", "Thanks", "NUMBER", "Verbal", "number", "must", "agree", "with", "subject", "NUMBER", "Just", "to", "be", "clear", "this", "be", "for", "translating", "the", "_specification_", "right", "Not", "for", "add", "a", "i", "NUMBER", "n", "strategy", "_to_", "GraphQL", "hi", "wincent", "sorry", "if", "bothered", "I", "ve", "already", "translated", "one", "version", "of", "the", "spec", "into", "Chinese", "and", "be", "looking", "for", "the", "translation", "team", "where", "I", "be", "in", "to", "proofread", "NUMBER", "be", "there", "any", "guide", "to", "contribute", "to", "the", "spec", "translation", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "may", "not", "be", "sufficient", "and", "your", "employer", "may", "need", "the", "corporate", "CLA", "sign", "NUMBER", "If", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "contact", "us", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "do", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "i", "be", "keenly", "looking", "for", "others", "contribute", "to", "translation", "and", "disseminate", "graphQL", "Because", "someone", "has", "to", "Good", "point", "Regarding", "the", "practice", "of", "setting", "the", "end", "of", "the", "range", "to", "present", "be", "this", "something", "that", "Facebook", "lawyers", "have", "okayed", "or", "was", "that", "something", "developers", "came", "up", "with", "IMO", "it", "s", "unfortunate", "for", "a", "project", "to", "be", "use", "present", "because", "it", "makes", "it", "more", "difficult", "to", "determine", "in", "the", "future", "what", "years", "apply", "to", "a", "full", "or", "partial", "snapshot", "of", "some", "project", "e", "NUMBER", "g", "NUMBER", "if", "a", "file", "from", "one", "project", "be", "copied", "into", "another", "project", "in", "accordance", "with", "the", "terms", "of", "the", "license", "of", "the", "originating", "project", "NUMBER", "Thanks", "marktani", "Moved", "the", "PR", "onto", "this", "branch", "NUMBER", "robzhu", "IvanGoncharov", "I", "update", "the", "PR", "here", "NUMBER", "Can", "you", "please", "post", "a", "screenshot", "of", "the", "rendered", "spec", "document", "Also", "please", "don", "t", "forget", "to", "update", "the", "language", "grammar", "appendix", "TAG", "Thanks", "As", "I", "expected", "it", "s", "not", "rendering", "correctly", "NUMBER", "Notice", "other", "optional", "tokens", "have", "an", "TAG", "opt", "TAG", "subtext", "after", "them", "NUMBER", "This", "appears", "to", "require", "the", "literal", "character", "NUMBER", "Do", "you", "think", "this", "form", "be", "weird", "or", "challenging", "to", "read", "open", "to", "advice", "UnionMembers", "LeadingPipe", "NamedType", "UnionMembers", "NamedType", "LeadingPipe", "Otherwise", "a", "change", "to", "spec", "md", "will", "be", "required", "to", "allow", "for", "optional", "terminals", "leebyron", "I", "m", "already", "work", "on", "a", "PR", "on", "spec", "md", "I", "think", "it", "will", "be", "a", "lot", "more", "readable", "to", "have", "TAG", "opt", "TAG", "As", "it", "stands", "the", "spec", "be", "unclear", "on", "what", "to", "do", "when", "an", "Non", "Null", "element", "of", "a", "list", "resolve", "to", "null", "NUMBER", "These", "change", "clarify", "that", "the", "entire", "list", "should", "resolve", "to", "null", "and", "to", "propagate", "the", "error", "upwards", "Thank", "you", "for", "this", "clarification", "NUMBER", "I", "agree", "this", "be", "a", "helpful", "addition", "Minor", "typo", "fix", "NUMBER", "Thanks", "iamaldi", "NUMBER", "FWIW", "I", "think", "the", "original", "word", "was", "intentional", "and", "not", "a", "typo", "it", "s", "grammatically", "valid", "but", "your", "word", "be", "nicer", "so", "let", "s", "go", "with", "it", "wincent", "That", "s", "my", "first", "pull", "request", "so", "I", "m", "happy", "with", "that", "NUMBER", "Per", "NUMBER", "Superb", "Thanks", "a", "lot", "gtod", "NUMBER", "Based", "on", "LINK", "js", "issue", "NUMBER", "Thanks", "xpepermint", "NUMBER", "With", "pleasure", "NUMBER", "Updated", "two", "Star", "Wars", "sentences", "that", "ended", "in", "a", "preposition", "and", "capitalized", "Episode", "V", "NUMBER", "Thanks", "NUMBER", "This", "proposal", "expands", "upon", "the", "ideas", "describe", "in", "NUMBER", "which", "ended", "up", "already", "be", "implement", "NUMBER", "I", "d", "like", "to", "suggest", "that", "GraphQL", "be", "expanded", "to", "allow", "an", "interface", "to", "implement", "another", "interface", "NUMBER", "This", "would", "allow", "for", "higher", "order", "interfaces", "and", "open", "the", "door", "for", "frameworks", "and", "tooling", "to", "describe", "their", "requirements", "in", "GraphQL", "which", "would", "be", "implement", "in", "userland", "interfaces", "and", "types", "NUMBER", "Here", "s", "a", "very", "contrived", "example", "borrowed", "from", "NUMBER", "and", "expanded", "upon", "to", "show", "how", "hierarchies", "would", "exist", "graphql", "interface", "Pet", "id", "ID", "sex", "Sex", "name", "String", "mother", "Pet", "father", "Pet", "interface", "Equine", "implement", "Pet", "id", "ID", "sex", "Sex", "name", "String", "mother", "Pet", "father", "Pet", "hands", "Float", "type", "Horse", "implement", "Equine", "id", "ID", "sex", "Sex", "name", "String", "mother", "Horse", "father", "Horse", "hands", "Float", "type", "Donkey", "implement", "Equine", "id", "ID", "sex", "Sex", "name", "String", "mother", "Donkey", "father", "Donkey", "hands", "Float", "type", "Mule", "implement", "Equine", "id", "ID", "sex", "Sex", "name", "String", "mother", "Equine", "father", "Equine", "hands", "Float", "What", "s", "important", "here", "be", "that", "in", "a", "context", "where", "we", "generically", "have", "Pet", "s", "each", "pet", "s", "father", "be", "only", "guaranteed", "to", "be", "a", "Pet", "NUMBER", "When", "we", "know", "we", "have", "a", "Mule", "though", "we", "know", "that", "its", "father", "be", "an", "Equine", "NUMBER", "With", "these", "two", "features", "tool", "which", "currently", "depend", "on", "schema", "conventions", "like", "the", "Relay", "specs", "could", "codify", "their", "requirements", "with", "GraphQL", "NUMBER", "A", "Real", "World", "Case", "I", "have", "be", "work", "on", "a", "system", "which", "allows", "offline", "concurrent", "modifications", "to", "version", "documents", "NUMBER", "The", "problem", "and", "solution", "be", "very", "generic", "but", "the", "current", "state", "of", "the", "GraphQL", "type", "system", "doesn", "t", "allow", "me", "to", "describe", "these", "general", "purpose", "shapes", "NUMBER", "Much", "like", "the", "Relay", "team", "had", "to", "define", "a", "convention", "for", "any", "type", "ending", "in", "Connection", "I", "have", "an", "internal", "spec", "describing", "any", "type", "with", "a", "name", "ending", "in", "Object", "Entity", "and", "Change", "NUMBER", "So", "for", "example", "I", "have", "a", "HikeObject", "HikeEntity", "and", "HikeChange", "I", "also", "have", "a", "ClimbObject", "ClimbEntity", "and", "ClimbChange", "NUMBER", "I", "ve", "find", "myself", "wishing", "I", "could", "use", "the", "GraphQL", "type", "system", "to", "describe", "these", "requirements", "and", "because", "the", "current", "spec", "be", "so", "close", "I", "find", "myself", "thinking", "of", "the", "schema", "in", "these", "terms", "NUMBER", "This", "would", "make", "that", "possible", "and", "bring", "GraphQL", "s", "type", "safety", "to", "tool", "that", "solve", "generic", "problem", "with", "GraphQL", "NUMBER", "As", "I", "ve", "continued", "the", "think", "about", "this", "I", "wanted", "to", "clarify", "a", "point", "If", "an", "interface", "implement", "another", "interface", "it", "MUST", "specify", "compatible", "field", "in", "its", "own", "field", "list", "NUMBER", "This", "keep", "all", "the", "simplicity", "of", "the", "current", "system", "with", "the", "total", "absence", "of", "inheritance", "and", "a", "flat", "interface", "implementation", "strategy", "while", "add", "the", "functionality", "of", "chained", "interfaces", "NUMBER", "I", "also", "have", "a", "real", "world", "use", "case", "for", "this", "and", "would", "love", "to", "see", "this", "add", "to", "the", "spec", "NUMBER", "What", "be", "the", "concerns", "mike", "marcacci", "only", "a", "suggestion", "would", "it", "be", "possible", "to", "consider", "use", "extend", "instead", "of", "implement", "I", "be", "relatively", "new", "to", "graphql", "but", "I", "find", "that", "most", "devs", "come", "from", "any", "language", "or", "environment", "think", "of", "interfaces", "extending", "other", "interfaces", "while", "types", "and", "classes", "implement", "interfaces", "NUMBER", "I", "think", "this", "would", "apply", "even", "in", "the", "scenario", "above", "where", "you", "mention", "that", "interfaces", "down", "the", "chain", "MUST", "specify", "all", "field", "in", "their", "own", "field", "list", "NUMBER", "Hi", "stanishev", "Thanks", "for", "the", "comment", "I", "definitely", "thought", "about", "use", "this", "terminology", "and", "considered", "how", "it", "might", "be", "interpreted", "by", "programmers", "of", "various", "languages", "NUMBER", "When", "write", "this", "issue", "I", "decided", "against", "extend", "to", "avoid", "the", "misconception", "that", "I", "was", "advocating", "for", "inheritance", "NUMBER", "In", "fact", "it", "s", "quite", "possible", "that", "there", "be", "a", "use", "case", "for", "true", "inheritance", "by", "which", "I", "mean", "applying", "the", "field", "definitions", "of", "one", "or", "more", "parents", "while", "my", "use", "case", "simply", "needs", "the", "ability", "to", "describe", "a", "hierarchy", "NUMBER", "I", "would", "argue", "that", "extend", "be", "a", "different", "potentially", "useful", "feature", "in", "which", "a", "concrete", "type", "might", "define", "its", "field", "by", "reference", "to", "other", "concrete", "types", "NUMBER", "I", "wanted", "to", "avoid", "misappropriating", "this", "word", "to", "describe", "a", "concept", "that", "s", "already", "fully", "contained", "by", "the", "implement", "keyword", "in", "GraphQL", "albeit", "currently", "only", "for", "concrete", "types", "NUMBER", "Also", "I", "wanted", "to", "avoid", "bringing", "into", "the", "discussion", "the", "complexities", "of", "inference", "in", "general", "In", "what", "order", "of", "precedence", "might", "a", "multi", "parent", "inheritance", "effected", "What", "happens", "when", "parents", "have", "non", "identical", "but", "potentially", "compatible", "field", "types", "type", "variance", "Can", "I", "sub", "class", "a", "parent", "to", "have", "a", "non", "compatible", "field", "type", "etc", "NUMBER", "All", "that", "said", "if", "the", "GraphQL", "team", "chose", "to", "add", "this", "to", "the", "spec", "under", "the", "keyword", "extend", "I", "would", "be", "more", "than", "happy", "to", "have", "it", "NUMBER", "I", "do", "think", "though", "that", "reusing", "implement", "here", "be", "a", "bit", "smaller", "of", "a", "request", "Not", "sure", "how", "mixins", "inheritance", "get", "involved", "but", "could", "that", "discussion", "happen", "in", "a", "new", "thread", "if", "you", "d", "like", "to", "advocate", "for", "it", "Either", "of", "those", "concepts", "would", "be", "more", "complicated", "than", "what", "this", "issue", "proposes", "and", "I", "m", "very", "interesting", "in", "seeing", "this", "proposal", "add", "so", "would", "rather", "not", "see", "the", "discussion", "veer", "off", "NUMBER", "Mixins", "sound", "interesting", "but", "the", "GraphQL", "team", "seems", "acutely", "interested", "in", "keep", "the", "spec", "as", "simple", "as", "it", "can", "possibly", "be", "and", "IMHO", "mixins", "be", "not", "simple", "NUMBER", "Any", "thoughts", "from", "the", "core", "team", "on", "this", "Would", "you", "be", "open", "to", "a", "PR", "I", "d", "love", "to", "help", "mike", "marcacci", "out", "with", "this", "but", "wouldn", "t", "want", "to", "waste", "the", "effort", "if", "you", "think", "it", "s", "unlikely", "to", "be", "accepted", "NUMBER", "While", "this", "be", "be", "discussed", "do", "anyone", "have", "a", "clean", "workaround", "that", "they", "be", "use", "I", "would", "also", "make", "use", "of", "this", "at", "Zillow", "where", "our", "type", "system", "include", "a", "hierarchy", "of", "property", "records", "in", "which", "the", "most", "basic", "type", "be", "a", "PublicRecord", "which", "be", "extend", "by", "a", "PropertyRecord", "include", "attributes", "add", "by", "Zillow", "systems", "which", "in", "turn", "be", "extend", "by", "a", "PropertyListing", "include", "attributes", "add", "by", "an", "agent", "or", "owner", "NUMBER", "Is", "anyone", "already", "work", "on", "a", "PR", "to", "incorporate", "this", "proposal", "into", "the", "spec", "MatthewHerbst", "jwb", "While", "I", "don", "t", "want", "to", "reintroduce", "mixins", "partials", "as", "a", "solution", "to", "this", "issue", "I", "do", "wanted", "to", "point", "you", "to", "LINK", "js", "issue", "NUMBER", "issuecomment", "NUMBER", "and", "the", "solution", "I", "outlined", "there", "and", "the", "transpiler", "polyfill", "I", "created", "to", "solve", "my", "need", "for", "make", "my", "schema", "more", "DRY", "by", "add", "mixins", "partials", "LINK", "graphql", "partials", "It", "s", "a", "solution", "that", "would", "also", "help", "in", "make", "heavy", "usage", "of", "interfaces", "manageable", "ensuring", "all", "implementations", "be", "in", "sync", "with", "the", "field", "defined", "tylercrompton", "Did", "you", "create", "another", "issue", "for", "the", "mixin", "case", "Would", "be", "good", "to", "link", "LINK", "js", "issue", "NUMBER", "to", "that", "one", "if", "so", "If", "mixin", "support", "were", "add", "I", "would", "make", "use", "of", "it", "NUMBER", "I", "feel", "that", "enabling", "inheritance", "of", "interfaces", "be", "a", "basic", "feature", "of", "a", "type", "system", "and", "I", "need", "it", "more", "than", "I", "need", "mixins", "since", "I", "can", "accomplish", "what", "I", "would", "use", "from", "mixins", "minus", "inheritance", "with", "code", "generation", "NUMBER", "For", "anybody", "following", "along", "I", "went", "ahead", "and", "made", "a", "PR", "to", "add", "this", "to", "the", "spec", "NUMBER", "If", "I", "can", "get", "some", "kind", "of", "indication", "from", "the", "GraphQL", "WG", "that", "this", "would", "be", "considered", "I", "ll", "go", "ahead", "and", "implement", "it", "in", "graphql", "js", "LINK", "js", "NUMBER", "leebyron", "thanks", "so", "much", "for", "the", "very", "thoughtful", "response", "I", "ll", "definitely", "join", "the", "next", "WG", "meeting", "if", "that", "would", "be", "helpful", "I", "just", "subscribed", "to", "the", "wg", "repo", "so", "I", "can", "add", "myself", "once", "the", "agenda", "be", "up", "NUMBER", "TAG", "It", "s", "just", "much", "simpler", "to", "have", "Object", "types", "describe", "all", "the", "interfaces", "they", "implement", "directly", "rather", "than", "having", "to", "walk", "a", "hierarchy", "NUMBER", "I", "thought", "about", "requiring", "implement", "types", "to", "re", "declare", "indirectly", "implement", "interfaces", "NUMBER", "In", "the", "toy", "example", "above", "then", "Horse", "Donkey", "and", "Mule", "would", "all", "need", "to", "specify", "implement", "Equine", "Pet", "NUMBER", "I", "decided", "against", "this", "though", "since", "there", "be", "an", "ergonomic", "cost", "when", "write", "maintaining", "a", "schema", "and", "wouldn", "t", "make", "improvement", "on", "the", "change", "cost", "NUMBER", "TAG", "So", "we", "should", "just", "ensure", "the", "value", "it", "provides", "would", "be", "worth", "that", "cost", "NUMBER", "I", "definitely", "understand", "the", "resulting", "change", "cost", "here", "NUMBER", "I", "skimmed", "through", "the", "WG", "note", "and", "CONTRIBUTING", "NUMBER", "md", "but", "didn", "t", "see", "any", "formal", "policy", "on", "how", "when", "breaking", "change", "be", "applied", "to", "the", "spec", "NUMBER", "I", "ll", "work", "on", "a", "companion", "PR", "to", "graphql", "js", "and", "dive", "into", "relay", "to", "get", "a", "better", "understanding", "of", "what", "kind", "of", "change", "this", "would", "require", "NUMBER", "This", "be", "implement", "in", "graphql", "graphql", "js", "NUMBER", "Per", "discussion", "at", "this", "week", "s", "WG", "meeting", "I", "set", "out", "to", "better", "describe", "my", "real", "world", "case", "here", "as", "a", "justification", "for", "this", "feature", "as", "oppose", "to", "the", "highly", "contrived", "example", "from", "this", "issue", "NUMBER", "Here", "s", "the", "essence", "of", "my", "use", "case", "but", "use", "Connection", "LINK", "terminology", "to", "avoid", "having", "to", "explain", "the", "intricacies", "of", "my", "system", "graphql", "interface", "Node", "id", "ID", "interface", "Edge", "cursor", "String", "node", "Node", "interface", "Connection", "pageInfo", "PageInfo", "edges", "Edge", "type", "PageInfo", "hasPreviousPage", "Boolean", "hasNextPage", "Boolean", "startCursor", "String", "endCursor", "String", "interface", "NamedNode", "id", "ID", "name", "String", "type", "NamedEdge", "implement", "Edge", "cursor", "String", "node", "NamedNode", "type", "NamedConnection", "implement", "Connection", "pageInfo", "PageInfo", "edges", "NamedEdge", "type", "SomeNamedThing", "implement", "NamedNode", "Node", "id", "ID", "name", "String", "type", "Query", "someQuery", "NamedConnection", "Note", "that", "this", "schema", "fail", "validation", "with", "js", "locations", "column", "NUMBER", "line", "NUMBER", "column", "NUMBER", "line", "NUMBER", "message", "Interface", "field", "Edge", "NUMBER", "node", "expects", "type", "Node", "but", "NamedEdge", "NUMBER", "node", "be", "type", "NamedNode", "NUMBER", "path", "undefined", "the", "solution", "be", "simply", "to", "allow", "NamedNode", "to", "declare", "that", "it", "implement", "Node", "graphql", "interface", "NamedNode", "implement", "Node", "id", "ID", "name", "String", "Using", "this", "update", "schema", "in", "the", "proposal", "s", "branch", "of", "graphql", "js", "LINK", "js", "pull", "NUMBER", "works", "exactly", "as", "expected", "and", "be", "able", "to", "simultaneously", "communicate", "that", "NUMBER", "NamedConnection", "be", "intended", "to", "be", "use", "as", "a", "Connection", "by", "the", "generic", "pagination", "code", "NUMBER", "Any", "NamedConnection", "will", "only", "have", "NamedNode", "results", "and", "can", "be", "queried", "without", "having", "to", "use", "fragment", "type", "conditions", "graphql", "query", "someQuery", "edges", "node", "name", "TAG", "Now", "for", "the", "twist", "NUMBER", "TAG", "TAG", "After", "the", "WG", "meeting", "I", "set", "out", "to", "show", "how", "my", "problem", "could", "not", "be", "solve", "with", "the", "current", "spec", "but", "instead", "I", "find", "another", "way", "to", "accomplish", "my", "goal", "NUMBER", "Armed", "with", "a", "much", "better", "understanding", "of", "introspection", "thanks", "ironically", "to", "implement", "this", "feature", "in", "graphql", "js", "I", "realized", "that", "it", "be", "quite", "trivial", "to", "determine", "all", "the", "possible", "types", "of", "a", "field", "and", "inject", "the", "appropriate", "type", "conditional", "fragment", "which", "was", "essentially", "my", "use", "case", "NUMBER", "Given", "the", "allegory", "above", "I", "essentially", "decided", "that", "I", "didn", "t", "really", "need", "the", "Connection", "or", "Edge", "interfaces", "at", "all", "NUMBER", "TAG", "TAG", "The", "one", "remaining", "itch", "for", "me", "be", "that", "there", "be", "currently", "no", "way", "to", "indicate", "within", "the", "schema", "that", "a", "type", "be", "intended", "to", "be", "use", "in", "a", "generic", "capacity", "apart", "from", "naming", "conventions", "NUMBER", "This", "however", "could", "be", "solve", "by", "exposing", "type", "level", "metadata", "which", "be", "a", "feature", "that", "appears", "to", "enjoy", "wide", "support", "from", "the", "WG", "NUMBER", "TAG", "EDIT", "I", "ve", "circled", "back", "to", "this", "proposal", "NUMBER", "While", "queries", "can", "be", "generate", "without", "this", "you", "lose", "out", "on", "the", "expressiveness", "and", "type", "guarantees", "that", "graphql", "provides", "natively", "NUMBER", "Hierarchal", "interfaces", "would", "cause", "compile", "time", "validation", "error", "for", "invalid", "schemas", "which", "be", "far", "preferable", "to", "runtime", "bug", "NUMBER", "So", "while", "I", "do", "believe", "this", "proposal", "generally", "improves", "the", "expressiveness", "of", "GraphQL", "and", "I", "think", "the", "example", "above", "clearly", "demonstrates", "a", "limitation", "of", "the", "current", "spec", "I", "be", "going", "to", "ease", "off", "my", "campaign", "for", "it", "NUMBER", "I", "d", "like", "to", "leave", "these", "issue", "PRs", "open", "until", "the", "next", "WG", "meeting", "to", "allow", "anybody", "else", "with", "a", "real", "world", "use", "case", "to", "chime", "in", "NUMBER", "I", "d", "also", "really", "be", "interested", "in", "any", "estimations", "of", "change", "cost", "particularly", "from", "the", "perspective", "of", "tooling", "maintainers", "NUMBER", "If", "we", "don", "t", "have", "a", "compelling", "case", "for", "this", "change", "at", "the", "next", "meeting", "I", "ll", "happily", "close", "these", "issue", "mike", "marcacci", "Great", "post", "NUMBER", "Can", "you", "please", "show", "any", "of", "the", "code", "you", "use", "to", "achieve", "the", "workaround", "Hey", "MatthewHerbst", "I", "m", "not", "actually", "use", "this", "for", "connections", "I", "let", "relay", "handle", "that", "but", "instead", "custom", "wrapper", "types", "for", "revision", "control", "offline", "support", "so", "none", "of", "my", "code", "be", "going", "to", "make", "sense", "without", "a", "lot", "of", "explaining", "NUMBER", "However", "I", "can", "tell", "you", "that", "I", "essentially", "keep", "a", "list", "of", "Entity", "types", "analogous", "to", "Connection", "implementations", "above", "that", "should", "support", "offline", "behavior", "NUMBER", "I", "then", "traverse", "the", "introspection", "looking", "at", "all", "the", "possibleTypes", "for", "instances", "of", "these", "NUMBER", "Then", "when", "proxying", "queries", "I", "inject", "type", "conditional", "fragment", "where", "applicable", "NUMBER", "This", "has", "several", "drawbacks", "I", "might", "have", "to", "inject", "several", "type", "specific", "fragment", "instead", "of", "NUMBER", "interface", "specific", "fragment", "which", "would", "be", "fix", "by", "this", "issue", "but", "I", "also", "run", "the", "risk", "of", "cause", "field", "merge", "issue", "see", "NUMBER", "NUMBER", "I", "m", "not", "particularly", "happy", "with", "my", "solution", "anymore", "to", "be", "honest", "so", "when", "I", "have", "time", "to", "revisit", "it", "I", "m", "going", "to", "look", "at", "doing", "things", "at", "compile", "time", "a", "la", "Relay", "NUMBER", "Another", "use", "also", "tied", "with", "pagination", "be", "when", "different", "interfaces", "need", "to", "be", "paginated", "NUMBER", "Suppose", "we", "have", "an", "interface", "Profile", "and", "two", "implementations", "UserProfile", "and", "TeamProfile", "Within", "the", "current", "featureset", "I", "cannot", "see", "a", "solution", "to", "be", "able", "to", "deduct", "that", "UserProfilePagnated", "and", "TeamProfilePaginated", "can", "be", "supplied", "where", "we", "be", "expecting", "PaginedProfiles", "NUMBER", "My", "first", "thought", "was", "generics", "and", "covariance", "With", "generics", "although", "not", "trivial", "one", "can", "make", "a", "complex", "analyzer", "that", "understands", "the", "notion", "of", "co", "and", "contravariance", "and", "can", "deduct", "that", "PaginatedProfiles", "be", "an", "interface", "of", "UserPaginatedProfiles", "although", "one", "might", "need", "to", "signal", "this", "somehow", "NUMBER", "But", "mike", "marcacci", "s", "interface", "extensions", "could", "also", "be", "a", "solution", "if", "the", "interfaces", "redefined", "the", "pagination", "field", "Github", "GraphQL", "API", "uses", "interfaces", "LINK", "I", "m", "sorry", "that", "I", "can", "t", "point", "at", "code", "but", "I", "really", "want", "to", "my", "schema", "to", "express", "the", "relationship", "location", "TAG", "I", "want", "to", "use", "for", "each", "separate", "model", "GraphQLObjectType", "My", "understanding", "be", "that", "nikitamarcius", "wants", "to", "have", "separate", "mutation", "GraphQL", "Object", "Types", "for", "each", "kind", "of", "data", "NUMBER", "To", "me", "that", "sounds", "the", "same", "as", "be", "able", "to", "mark", "arbitrary", "GraphQL", "Object", "Types", "as", "a", "mutation", "type", "which", "be", "what", "NUMBER", "be", "about", "NUMBER", "Note", "that", "AFAIK", "the", "mutation", "type", "can", "already", "appear", "anywhere", "if", "you", "just", "return", "it", "from", "a", "field", "type", "Query", "mutation", "Mutation", "I", "think", "in", "many", "cases", "developers", "use", "subscriptions", "to", "approximate", "live", "queries", "but", "subscriptions", "be", "more", "powerful", "and", "easier", "to", "implement", "NUMBER", "For", "example", "in", "my", "case", "where", "I", "have", "many", "microservices", "on", "my", "backend", "where", "some", "nested", "field", "go", "to", "other", "services", "it", "s", "not", "really", "straightforward", "to", "define", "how", "live", "queries", "would", "work", "and", "I", "ve", "chosen", "explicitly", "to", "model", "things", "as", "event", "streams", "NUMBER", "Live", "queries", "would", "be", "a", "nice", "abstraction", "on", "top", "but", "it", "s", "only", "that", "it", "s", "not", "in", "the", "general", "case", "a", "great", "backend", "build", "block", "NUMBER", "I", "don", "t", "think", "this", "discussion", "should", "be", "judging", "about", "whether", "or", "not", "live", "queries", "be", "better", "than", "subscriptions", "just", "whether", "they", "be", "different", "enough", "that", "they", "should", "be", "considered", "independently", "NUMBER", "I", "think", "build", "block", "be", "a", "great", "way", "to", "look", "at", "it", "though", "subscriptions", "be", "a", "great", "well", "specified", "unit", "of", "realtime", "data", "push", "that", "can", "be", "use", "to", "build", "a", "lot", "of", "other", "cool", "stuff", "NUMBER", "The", "fact", "that", "it", "s", "very", "easy", "to", "implement", "a", "spec", "compliant", "subscription", "on", "the", "server", "side", "be", "pretty", "awesome", "even", "if", "it", "s", "not", "always", "the", "thing", "you", "want", "as", "a", "client", "side", "developer", "NUMBER", "I", "d", "like", "to", "know", "first", "what", "people", "consider", "live", "queries", "to", "be", "NUMBER", "What", "be", "the", "definition", "I", "ask", "because", "I", "think", "there", "be", "different", "perspectives", "or", "ideas", "in", "play", "here", "and", "thus", "the", "discussion", "can", "run", "in", "unnecessary", "tangents", "NUMBER", "So", "what", "be", "a", "live", "query", "Scott", "Here", "s", "my", "impression", "of", "a", "live", "query", "in", "one", "sentence", "A", "live", "query", "be", "a", "query", "where", "some", "or", "all", "of", "the", "parts", "can", "be", "marked", "as", "live", "and", "the", "client", "expects", "to", "receive", "update", "whenever", "any", "of", "those", "parts", "would", "have", "ended", "up", "with", "a", "different", "result", "if", "refetched", "again", "NUMBER", "In", "short", "they", "should", "be", "a", "drop", "in", "replacement", "for", "polling", "NUMBER", "Here", "be", "my", "definition", "NUMBER", "A", "live", "query", "be", "a", "query", "which", "be", "designated", "by", "the", "client", "as", "live", "NUMBER", "This", "designation", "be", "pass", "on", "to", "the", "GraphQL", "server", "one", "could", "say", "it", "be", "a", "subscription", "NUMBER", "The", "server", "then", "observes", "for", "triggers", "or", "data", "input", "from", "the", "underlying", "data", "sources", "needed", "to", "fulfill", "any", "part", "of", "the", "query", "NUMBER", "This", "in", "turn", "means", "any", "update", "from", "the", "underlying", "data", "sources", "will", "be", "pass", "to", "the", "client", "automatically", "via", "bi", "directional", "communication", "NUMBER", "Scott", "If", "you", "want", "a", "demo", "of", "a", "live", "query", "complete", "with", "a", "GraphiQL", "editor", "see", "LINK", "Live", "queries", "be", "infinitely", "more", "powerful", "than", "subscriptions", "because", "you", "can", "model", "live", "reactive", "data", "in", "a", "way", "that", "efficiently", "encodes", "change", "all", "the", "way", "from", "the", "data", "source", "to", "the", "browser", "into", "something", "like", "react", "and", "angular", "NUMBER", "And", "it", "s", "not", "true", "that", "they", "cannot", "be", "do", "at", "scale", "be", "definitely", "possible", "with", "a", "good", "enough", "scheduler", "balancer", "NUMBER", "Live", "queries", "be", "infinitely", "more", "powerful", "than", "subscriptions", "I", "agree", "with", "this", "NUMBER", "And", "it", "s", "not", "true", "that", "they", "cannot", "be", "do", "at", "scale", "be", "definitely", "possible", "with", "a", "good", "enough", "scheduler", "balancer", "NUMBER", "I", "also", "agree", "with", "this", "NUMBER", "However", "I", "think", "they", "be", "significantly", "different", "from", "subscriptions", "nonetheless", "and", "both", "have", "their", "place", "in", "the", "GraphQL", "ecosystem", "NUMBER", "However", "I", "think", "they", "be", "significantly", "different", "from", "subscriptions", "nonetheless", "and", "both", "have", "their", "place", "in", "the", "GraphQL", "ecosystem", "NUMBER", "Agreed", "NUMBER", "I", "don", "t", "think", "live", "queries", "be", "necessarily", "difficult", "to", "do", "though", "either", "the", "argument", "I", "m", "arguing", "against", "be", "live", "queries", "at", "scale", "isn", "t", "a", "solve", "science", "so", "we", "re", "going", "to", "ignore", "the", "concept", "entirely", "NUMBER", "Yeah", "I", "think", "it", "s", "important", "that", "the", "spec", "proposal", "doesn", "t", "say", "this", "be", "the", "only", "thing", "we", "will", "ever", "do", "for", "realtime", "data", "or", "even", "this", "be", "the", "best", "way", "to", "do", "realtime", "data", "it", "should", "just", "say", "this", "be", "the", "way", "of", "doing", "realtime", "data", "that", "be", "understood", "clearly", "enough", "to", "specify", "That", "be", "a", "great", "question", "but", "it", "blows", "my", "definition", "of", "live", "queries", "out", "of", "the", "water", "NUMBER", "Doesn", "t", "it", "Hehehe", "NUMBER", "LOL", "If", "I", "may", "answer", "too", "NUMBER", "I", "think", "with", "Christian", "s", "paralin", "rqraphql", "system", "live", "queries", "be", "a", "server", "side", "and", "domain", "specific", "decision", "NUMBER", "From", "what", "I", "understand", "from", "the", "rgraphql", "docs", "if", "you", "want", "a", "live", "query", "the", "ability", "to", "observe", "for", "update", "be", "baked", "into", "one", "or", "more", "resolvers", "for", "that", "query", "NUMBER", "And", "I", "believe", "this", "be", "where", "this", "concept", "has", "a", "general", "concern", "and", "something", "still", "miss", "in", "the", "spec", "too", "NUMBER", "It", "requires", "a", "front", "end", "dev", "to", "have", "intimate", "knowledge", "of", "the", "back", "end", "decisions", "as", "the", "type", "of", "query", "live", "or", "not", "cannot", "be", "directly", "seen", "through", "introspection", "whereas", "it", "should", "be", "NUMBER", "Sure", "one", "could", "add", "some", "type", "of", "comment", "but", "be", "that", "really", "a", "good", "solution", "for", "flagging", "queries", "as", "potentially", "live", "with", "introspection", "The", "other", "question", "that", "burns", "in", "my", "mind", "be", "how", "do", "the", "server", "know", "who", "to", "broadcast", "these", "update", "to", "The", "docs", "mention", "killing", "long", "run", "processes", "NUMBER", "That", "be", "only", "scratching", "the", "scaling", "issue", "NUMBER", "I", "guess", "I", "be", "the", "stupid", "guy", "on", "the", "fence", "between", "these", "two", "solutions", "NUMBER", "I", "don", "t", "think", "GraphQL", "should", "be", "work", "with", "events", "internally", "NUMBER", "They", "aren", "t", "needed", "as", "Christians", "s", "rgraphql", "system", "proves", "NUMBER", "Yet", "I", "don", "t", "think", "pure", "live", "queries", "without", "some", "sort", "of", "subscription", "system", "be", "also", "the", "right", "solution", "either", "NUMBER", "Oh", "NUMBER", "And", "just", "because", "a", "live", "query", "has", "a", "subscription", "system", "tag", "to", "it", "doesn", "t", "mean", "it", "can", "t", "be", "call", "a", "live", "query", "NUMBER", "Scott", "robzhu", "I", "do", "think", "of", "them", "as", "semantically", "different", "NUMBER", "It", "would", "be", "awkward", "to", "do", "a", "toast", "notification", "with", "a", "live", "query", "rather", "than", "an", "event", "based", "subscription", "stream", "for", "example", "NUMBER", "That", "said", "I", "be", "mostly", "use", "subscriptions", "as", "a", "poor", "man", "s", "live", "query", "system", "with", "easier", "to", "understand", "semantics", "on", "the", "backend", "NUMBER", "If", "I", "had", "a", "reactive", "backend", "that", "support", "live", "queries", "I", "would", "mostly", "move", "to", "use", "live", "queries", "but", "I", "don", "t", "and", "I", "decided", "it", "wasn", "t", "worth", "the", "architectural", "trade", "offs", "required", "to", "do", "so", "NUMBER", "Additionally", "I", "expect", "the", "majority", "of", "users", "of", "GraphQL", "subscriptions", "as", "be", "to", "use", "them", "to", "do", "something", "somewhat", "similar", "to", "my", "use", "case", "of", "emulating", "live", "queries", "in", "an", "easier", "to", "implement", "manner", "for", "complex", "back", "end", "systems", "NUMBER", "smolinari", "don", "t", "you", "mean", "my", "system", "paralin", "Sorry", "about", "that", "NUMBER", "You", "be", "right", "NUMBER", "Me", "goes", "correcting", "Scott", "So", "be", "we", "saying", "that", "the", "difference", "between", "a", "Live", "Query", "and", "a", "Subscription", "be", "essentially", "how", "the", "update", "be", "push", "A", "LQ", "will", "send", "you", "any", "update", "automatically", "that", "effect", "the", "original", "query", "whether", "it", "be", "an", "add", "remove", "update", "a", "Subscription", "needs", "a", "manual", "push", "of", "new", "data", "allowing", "the", "programmer", "to", "be", "selective", "about", "_what_", "update", "be", "sent", "siyfion", "in", "rgraphql", "at", "least", "the", "developer", "still", "has", "fine", "control", "over", "what", "gets", "sent", "to", "the", "client", "the", "system", "just", "manages", "get", "those", "change", "to", "the", "client", "and", "applying", "them", "properly", "NUMBER", "The", "only", "difference", "I", "can", "see", "really", "be", "that", "subscriptions", "be", "limited", "to", "the", "root", "level", "of", "the", "query", "only", "and", "cannot", "be", "update", "after", "they", "have", "begun", "NUMBER", "These", "properties", "be", "probably", "good", "for", "when", "you", "re", "subscribing", "to", "general", "streams", "of", "events", "NUMBER", "I", "wouldn", "t", "use", "it", "for", "live", "data", "though", "NUMBER", "Imagine", "you", "re", "trying", "to", "build", "a", "news", "feed", "with", "comments", "NUMBER", "What", "happens", "if", "someone", "edits", "a", "comment", "Do", "you", "just", "push", "a", "event", "saying", "it", "was", "edit", "via", "a", "subscription", "But", "then", "all", "of", "the", "logic", "to", "apply", "the", "update", "has", "to", "be", "hand", "build", "separately", "for", "each", "of", "the", "types", "of", "things", "you", "might", "want", "to", "update", "NUMBER", "That", "seems", "wrong", "to", "me", "NUMBER", "Instead", "you", "can", "just", "subscribe", "to", "the", "same", "streams", "of", "data", "on", "the", "server", "interpret", "them", "correctly", "and", "then", "send", "back", "update", "to", "the", "client", "tailored", "to", "the", "data", "they", "already", "have", "NUMBER", "paralin", "How", "do", "your", "system", "know", "when", "to", "send", "the", "news", "feed", "update", "or", "rather", "to", "which", "clients", "Scott", "smolinari", "that", "s", "up", "to", "the", "developer", "to", "decide", "NUMBER", "In", "Go", "we", "have", "strong", "concurrency", "patterns", "around", "streams", "of", "data", "and", "Magellan", "support", "all", "of", "those", "patterns", "when", "resolving", "field", "NUMBER", "When", "a", "user", "subscribes", "to", "some", "live", "query", "the", "server", "decides", "how", "it", "will", "fill", "that", "query", "and", "the", "developers", "code", "can", "return", "many", "different", "permutations", "of", "result", "representations", "including", "ones", "that", "change", "over", "time", "NUMBER", "When", "a", "user", "subscribes", "to", "some", "live", "query", "I", "miss", "how", "this", "can", "be", "do", "with", "rgraphql", "NUMBER", "Can", "you", "point", "me", "to", "the", "docs", "or", "code", "where", "this", "be", "explained", "do", "Scott", "smolinari", "LINK", "Not", "much", "in", "the", "way", "of", "docs", "yet", "mostly", "focusing", "on", "optimizing", "and", "get", "in", "mutations", "right", "now", "NUMBER", "But", "the", "interface", "be", "the", "same", "as", "in", "Apollo", "NUMBER", "Call", "query", "returns", "an", "observable", "subscribing", "to", "the", "observable", "triggers", "the", "query", "to", "actually", "be", "applied", "NUMBER", "The", "system", "merge", "together", "the", "entire", "tree", "of", "active", "queries", "into", "one", "query", "object", "and", "keep", "that", "in", "sync", "with", "the", "server", "NUMBER", "There", "be", "a", "lot", "of", "information", "on", "how", "it", "works", "in", "the", "protocol", "NUMBER", "md", "doc", "under", "I", "think", "Magellan", "I", "m", "on", "my", "phone", "right", "now", "apologies", "for", "the", "lack", "of", "a", "link", "What", "happens", "if", "someone", "edits", "a", "comment", "Do", "you", "just", "push", "a", "event", "saying", "it", "was", "edit", "via", "a", "subscription", "Yup", "that", "s", "how", "we", "would", "do", "it", "NUMBER", "But", "then", "all", "of", "the", "logic", "to", "apply", "the", "update", "has", "to", "be", "hand", "build", "separately", "for", "each", "of", "the", "types", "of", "things", "you", "might", "want", "to", "update", "NUMBER", "That", "seems", "wrong", "to", "me", "NUMBER", "For", "us", "the", "subscription", "payload", "that", "gets", "push", "to", "the", "client", "be", "the", "same", "type", "as", "a", "comment_edit", "mutation", "payload", "and", "the", "client", "already", "has", "logic", "for", "update", "the", "comments", "UI", "in", "response", "to", "a", "comment_edit", "mutation", "response", "NUMBER", "In", "general", "on", "our", "native", "clients", "and", "in", "Relay", "we", "have", "client", "side", "infra", "that", "be", "smart", "about", "taking", "GraphQL", "responses", "sticking", "them", "into", "a", "GraphQL", "cache", "and", "update", "the", "UIs", "accordingly", "so", "it", "s", "not", "actually", "as", "bad", "as", "you", "make", "it", "sound", "to", "add", "logic", "to", "handle", "a", "subscription", "response", "NUMBER", "And", "yet", "you", "have", "to", "base", "every", "change", "on", "mutations", "NUMBER", "I", "m", "build", "a", "app", "right", "now", "that", "be", "extremely", "reliant", "on", "outside", "data", "that", "be", "sensor", "data", "position", "data", "connectivity", "etc", "from", "a", "large", "number", "of", "sources", "NUMBER", "To", "make", "a", "mutation", "to", "affect", "every", "little", "change", "to", "this", "data", "would", "be", "impossible", "NUMBER", "This", "type", "of", "live", "data", "be", "something", "well", "suited", "to", "GraphQL", "because", "the", "client", "can", "subscribe", "to", "only", "what", "it", "needs", "NUMBER", "It", "s", "also", "something", "that", "cannot", "be", "do", "with", "subscriptions", "in", "any", "tractable", "way", "NUMBER", "This", "example", "I", "believe", "reveals", "that", "there", "be", "actually", "two", "types", "of", "live", "data", "that", "a", "GraphQL", "user", "might", "want", "to", "have", "streams", "of", "update", "to", "individual", "field", "along", "with", "batch", "update", "as", "a", "result", "of", "measurable", "transactions", "NUMBER", "I", "believe", "this", "be", "the", "best", "argument", "yet", "for", "build", "two", "different", "live", "mechanisms", "into", "GraphQL", "NUMBER", "Just", "catching", "up", "on", "everything", "in", "this", "thread", "NUMBER", "I", "m", "seeing", "two", "general", "question", "be", "discussed", "here", "NUMBER", "How", "hard", "be", "it", "to", "implement", "live", "queries", "NUMBER", "Are", "GraphQL", "subscriptions", "useful", "in", "their", "own", "right", "even", "in", "a", "world", "with", "work", "live", "queries", "Re", "NUMBER", "we", "believe", "based", "on", "experience", "at", "Facebook", "and", "discussions", "with", "other", "folks", "that", "the", "general", "problem", "of", "implement", "live", "queries", "at", "scale", "be", "not", "easy", "NUMBER", "This", "doesn", "t", "mean", "that", "it", "be", "always", "hard", "with", "an", "efficient", "reactive", "backend", "implement", "live", "queries", "becomes", "fairly", "straightforward", "NUMBER", "As", "taion", "mention", "though", "some", "folks", "might", "have", "many", "microservices", "on", "the", "backend", "NUMBER", "Some", "might", "have", "tens", "or", "even", "hundreds", "of", "different", "DBs", "and", "services", "backing", "the", "data", "in", "their", "GraphQL", "schema", "NUMBER", "The", "general", "problem", "of", "moving", "all", "of", "the", "backing", "data", "for", "a", "GraphQL", "schema", "to", "a", "reactive", "backend", "be", "quite", "challenging", "NUMBER", "However", "I", "think", "we", "re", "get", "off", "topic", "by", "focusing", "on", "question", "NUMBER", "NUMBER", "The", "more", "relevant", "question", "for", "this", "RFC", "be", "NUMBER", "NUMBER", "Based", "on", "my", "experience", "work", "with", "a", "bunch", "of", "Facebook", "product", "teams", "build", "real", "time", "features", "and", "rolling", "out", "GraphQL", "Subscriptions", "at", "scale", "over", "the", "past", "two", "years", "I", "believe", "that", "the", "answer", "to", "question", "NUMBER", "be", "yes", "NUMBER", "We", "ve", "seen", "cases", "where", "product", "folks", "explicitly", "design", "their", "real", "time", "experience", "around", "events", "NUMBER", "They", "need", "control", "over", "things", "like", "which", "specific", "events", "get", "priority", "when", "the", "rate", "be", "too", "high", "to", "deliver", "all", "update", "NUMBER", "paralin", "said", "previously", "that", "Live", "queries", "be", "infinitely", "more", "powerful", "than", "subscriptions", "NUMBER", "I", "m", "not", "sure", "if", "I", "agree", "with", "this", "and", "I", "m", "also", "not", "sure", "that", "it", "s", "useful", "to", "debate", "the", "meaning", "of", "powerful", "super", "relevant", "talk", "LINK", "mVVNJKv", "NUMBER", "esE", "but", "one", "thing", "I", "will", "say", "about", "subscriptions", "be", "that", "they", "put", "more", "control", "into", "the", "hands", "of", "the", "product", "developers", "over", "which", "update", "they", "ll", "receive", "NUMBER", "We", "have", "also", "seen", "examples", "that", "lend", "themselves", "nicely", "to", "live", "queries", "and", "some", "people", "in", "this", "thread", "have", "mention", "examples", "of", "that", "sort", "NUMBER", "Internally", "we", "be", "still", "experimenting", "and", "work", "with", "product", "teams", "to", "arrive", "at", "a", "general", "understanding", "of", "which", "use", "cases", "be", "better", "served", "by", "subscriptions", "and", "which", "be", "better", "served", "by", "live", "queries", "but", "we", "be", "confident", "that", "the", "former", "be", "not", "an", "empty", "set", "NUMBER", "laneyk", "Agreed", "in", "full", "NUMBER", "I", "don", "t", "dispute", "that", "I", "ve", "be", "overstating", "the", "worth", "of", "live", "queries", "a", "bit", "primarily", "because", "I", "m", "passionate", "about", "seeing", "them", "considered", "due", "to", "their", "value", "in", "my", "particular", "niche", "applications", "NUMBER", "I", "don", "t", "believe", "that", "live", "queries", "be", "the", "only", "way", "to", "do", "it", "just", "that", "they", "be", "an", "effective", "mechanism", "in", "a", "lot", "of", "small", "to", "mid", "scale", "applications", "NUMBER", "It", "makes", "sense", "that", "live", "data", "and", "events", "would", "have", "very", "different", "mechanisms", "NUMBER", "One", "thing", "I", "will", "say", "about", "subscriptions", "be", "that", "they", "put", "more", "control", "into", "the", "hands", "of", "the", "product", "developers", "over", "which", "update", "they", "ll", "receive", "NUMBER", "This", "be", "one", "thing", "that", "I", "see", "consistently", "in", "the", "design", "of", "GraphQL", "NUMBER", "Besides", "the", "debate", "between", "live", "queries", "vs", "NUMBER", "subscriptions", "it", "may", "be", "worth", "thinking", "about", "this", "client", "developer", "control", "as", "a", "key", "design", "point", "of", "GraphQL", "NUMBER", "If", "you", "think", "about", "mutations", "they", "require", "a", "lot", "of", "work", "on", "the", "client", "developer", "s", "side", "to", "update", "the", "cache", "NUMBER", "This", "be", "a", "problem", "that", "Apollo", "Client", "Relay", "and", "any", "future", "GraphQL", "clients", "will", "struggle", "with", "NUMBER", "A", "lot", "of", "GraphQL", "beginners", "really", "want", "mutations", "to", "be", "magical", "NUMBER", "They", "want", "to", "send", "a", "mutation", "to", "submit", "a", "comment", "and", "have", "that", "comment", "be", "automagically", "inserted", "into", "their", "pre", "exist", "list", "with", "zero", "boilerplate", "but", "GraphQL", "wasn", "t", "designed", "to", "be", "magical", "it", "was", "designed", "to", "be", "practical", "NUMBER", "In", "its", "practicality", "GraphQL", "try", "to", "enable", "both", "the", "server", "and", "the", "client", "developer", "as", "much", "freedom", "and", "flexibility", "to", "work", "in", "and", "around", "the", "query", "language", "without", "over", "prescribing", "NUMBER", "The", "server", "developer", "may", "require", "a", "token", "in", "an", "HTTP", "header", "or", "return", "a", "JSON", "blob", "as", "a", "scalar", "field", "NUMBER", "The", "client", "developer", "may", "implement", "super", "custom", "update", "to", "their", "data", "based", "on", "a", "mutation", "or", "subscription", "which", "takes", "into", "account", "variables", "only", "the", "client", "knows", "like", "a", "local", "priority", "based", "on", "what", "screen", "the", "user", "be", "on", "NUMBER", "However", "this", "practicality", "comes", "at", "the", "cost", "of", "some", "higher", "level", "magic", "features", "that", "would", "make", "development", "much", "faster", "such", "as", "live", "queries", "or", "zero", "boilerplate", "mutations", "on", "the", "client", "NUMBER", "I", "like", "that", "GraphQL", "has", "chosen", "to", "be", "practical", "NUMBER", "It", "s", "the", "same", "choice", "React", "has", "made", "whereas", "Angular", "has", "chosen", "the", "magic", "route", "NUMBER", "If", "you", "want", "magic", "in", "the", "data", "API", "space", "I", "heavily", "encourage", "you", "to", "check", "out", "Falcor", "LINK", "NUMBER", "Unlike", "GraphQL", "Falcor", "s", "design", "be", "optimized", "for", "some", "of", "these", "magic", "features", "like", "live", "queries", "and", "simple", "mutations", "that", "people", "would", "like", "to", "see", "Albeit", "you", "probably", "won", "t", "get", "any", "magic", "from", "Falcor", "in", "its", "current", "form", "but", "I", "think", "the", "design", "be", "there", "NUMBER", "Also", "forget", "about", "the", "fact", "that", "Falcor", "doesn", "t", "have", "a", "schema", "You", "could", "easily", "write", "a", "version", "of", "Falcor", "with", "static", "types", "and", "get", "the", "same", "GraphiQL", "experience", "NUMBER", "What", "do", "you", "think", "Do", "you", "see", "the", "same", "consistent", "choice", "in", "design", "decisions", "Do", "you", "agree", "that", "live", "queries", "be", "a", "magical", "feature", "My", "point", "isn", "t", "so", "much", "to", "argue", "for", "or", "against", "live", "queries", "or", "even", "for", "or", "against", "magic", "I", "just", "wanted", "to", "make", "an", "observation", "about", "the", "design", "of", "GraphQL", "that", "I", "ve", "notice", "from", "time", "to", "time", "since", "it", "was", "mention", "this", "talk", "be", "amazing", "LINK", "and", "its", "concepts", "apply", "to", "this", "observation", "as", "well", "calebmer", "You", "don", "t", "need", "to", "have", "a", "feature", "in", "the", "spec", "to", "build", "it", "NUMBER", "Projects", "like", "mine", "that", "add", "real", "time", "to", "GraphQL", "operate", "with", "GraphQL", "in", "its", "current", "form", "and", "declare", "their", "own", "rules", "as", "to", "how", "data", "be", "handle", "NUMBER", "Therefore", "they", "be", "derivative", "of", "GraphQL", "and", "perhaps", "compatible", "while", "not", "GraphQL", "in", "their", "own", "sense", "NUMBER", "GraphQL", "definitely", "can", "support", "these", "types", "of", "things", "and", "I", "believe", "it", "s", "productive", "to", "at", "least", "discuss", "inside", "the", "bounds", "of", "GraphQL", "without", "deferring", "to", "other", "products", "entirely", "NUMBER", "Your", "point", "absolutely", "holds", "GraphQL", "s", "spec", "doesn", "t", "really", "need", "to", "have", "real", "time", "build", "in", "NUMBER", "It", "would", "be", "nice", "but", "it", "would", "always", "be", "labeled", "as", "an", "optional", "feature", "anyway", "NUMBER", "Maybe", "it", "s", "best", "to", "leave", "these", "features", "to", "derivative", "projects", "to", "define", "with", "loose", "guidelines", "in", "the", "spec", "I", "believe", "subscriptions", "should", "be", "in", "the", "spec", "for", "sure", "but", "real", "time", "maybe", "not", "NUMBER", "That", "talk", "LINK", "mVVNJKv", "NUMBER", "esE", "s", "really", "good", "and", "definitely", "applies", "here", "thanks", "for", "the", "link", "It", "seems", "like", "a", "lot", "of", "the", "discussion", "has", "be", "about", "things", "outside", "of", "graphql", "how", "upstream", "implement", "events", "as", "per", "laneyk", "but", "also", "the", "semantics", "encoded", "within", "events", "eg", "update", "vs", "new", "state", "NUMBER", "Is", "there", "any", "difference", "in", "the", "external", "behavior", "between", "what", "has", "be", "propose", "and", "live", "queries", "beyond", "how", "the", "request", "be", "interpreted", "As", "best", "I", "can", "tell", "subscriptions", "with", "a", "bit", "of", "hand", "waving", "represent", "a", "subset", "of", "one", "or", "more", "possible", "live", "query", "specs", "in", "that", "subscription", "be", "based", "solely", "on", "the", "argument", "pass", "to", "the", "root", "whereas", "a", "live", "query", "will", "use", "the", "whole", "query", "NUMBER", "NUMBER", "Everything", "else", "be", "either", "transport", "level", "stuff", "subscription", "error", "etc", "and", "so", "common", "between", "the", "two", "or", "event", "semantics", "new", "state", "update", "etc", "and", "opaque", "to", "graphql", "NUMBER", "NUMBER", "I", "m", "cheating", "by", "ignoring", "any", "details", "how", "to", "design", "a", "specific", "live", "query", "syntax", "complexity", "of", "implementation", "etc", "since", "it", "s", "moot", "to", "my", "point", "as", "well", "as", "anything", "about", "the", "client", "update", "their", "query", "As", "best", "I", "can", "tell", "subscriptions", "with", "a", "bit", "of", "hand", "waving", "represent", "a", "subset", "of", "one", "or", "more", "possible", "live", "query", "specs", "in", "that", "subscription", "be", "based", "solely", "on", "the", "argument", "pass", "to", "the", "root", "whereas", "a", "live", "query", "will", "use", "the", "whole", "query", "NUMBER", "NUMBER", "Everything", "else", "be", "either", "transport", "level", "stuff", "subscription", "error", "etc", "and", "so", "common", "between", "the", "two", "or", "event", "semantics", "new", "state", "update", "etc", "and", "opaque", "to", "graphql", "NUMBER", "This", "be", "incorrect", "NUMBER", "A", "subscription", "doesn", "t", "have", "to", "correspond", "to", "anything", "in", "your", "query", "proper", "NUMBER", "It", "can", "be", "a", "pure", "event", "only", "stream", "NUMBER", "A", "subscription", "doesn", "t", "have", "to", "correspond", "to", "anything", "in", "your", "query", "proper", "NUMBER", "It", "can", "be", "a", "pure", "event", "only", "stream", "NUMBER", "Not", "sure", "I", "follow", "this", "NUMBER", "I", "be", "under", "the", "impression", "that", "to", "subscribe", "you", "have", "to", "make", "a", "query", "NUMBER", "The", "root", "of", "this", "may", "contain", "zero", "or", "more", "argument", "that", "the", "subscription", "resolver", "would", "use", "to", "determine", "what", "to", "send", "and", "when", "NUMBER", "The", "query", "object", "below", "the", "root", "would", "then", "be", "use", "to", "filter", "the", "response", "NUMBER", "jamesgorman", "NUMBER", "Yeah", "but", "the", "data", "returned", "from", "the", "subscription", "doesn", "t", "necessarily", "conform", "to", "the", "selections", "in", "the", "query", "be", "what", "he", "s", "saying", "I", "think", "NUMBER", "Although", "that", "wouldn", "t", "make", "much", "sense", "NUMBER", "Why", "have", "a", "query", "body", "if", "you", "re", "not", "going", "to", "respect", "it", "Edit", "see", "taion", "clarification", "below", "makes", "sense", "NUMBER", "I", "m", "saying", "that", "the", "data", "in", "the", "subscription", "doesn", "t", "have", "to", "be", "something", "that", "can", "be", "grabbed", "from", "a", "normal", "query", "NUMBER", "Imagine", "something", "correspondingly", "purely", "to", "a", "transient", "event", "stream", "NUMBER", "Ah", "looks", "like", "we", "re", "talking", "at", "cross", "purposes", "then", "NUMBER", "I", "m", "use", "query", "in", "the", "sense", "of", "the", "message", "that", "be", "sent", "by", "the", "client", "to", "the", "graphql", "server", "during", "subscription", "eg", "subscription", "foo", "bar", "baz", "stuff", "here", "There", "be", "a", "subscription", "mechanism", "and", "transport", "protocol", "from", "client", "to", "server", "over", "which", "this", "be", "sent", "NUMBER", "There", "be", "also", "an", "event", "generating", "mechanism", "between", "the", "server", "and", "upstream", "that", "be", "opaque", "to", "a", "graphql", "server", "framework", "NUMBER", "The", "graphql", "server", "framework", "s", "job", "be", "to", "render", "the", "subscription", "query", "readable", "to", "the", "subscription", "resolver", "then", "convert", "the", "events", "returned", "from", "upstream", "and", "emitted", "by", "the", "resolver", "into", "the", "correct", "graphql", "response", "object", "NUMBER", "jamesgorman", "NUMBER", "I", "had", "considered", "wrapping", "my", "live", "queries", "in", "the", "subscription", "tag", "but", "I", "find", "it", "s", "more", "flexible", "to", "blend", "regular", "and", "live", "data", "together", "side", "by", "side", "NUMBER", "As", "someone", "browses", "through", "an", "app", "the", "app", "will", "constantly", "be", "subscribing", "and", "unsubscribing", "from", "just", "the", "field", "it", "needs", "NUMBER", "This", "be", "the", "powerful", "part", "of", "live", "data", "my", "frontend", "can", "pull", "literally", "exactly", "what", "it", "needs", "at", "any", "given", "time", "nothing", "more", "nothing", "less", "NUMBER", "In", "terms", "of", "limiting", "what", "be", "live", "from", "a", "developer", "s", "perspective", "NUMBER", "I", "will", "probably", "add", "a", "live", "directive", "that", "turns", "on", "live", "field", "for", "all", "subfields", "NUMBER", "In", "rgraphql", "at", "least", "defer", "and", "stream", "be", "implicit", "results", "be", "streamed", "back", "as", "they", "be", "resolve", "and", "because", "of", "this", "every", "field", "be", "deferred", "and", "every", "array", "be", "streamed", "NUMBER", "However", "live", "could", "be", "use", "to", "turn", "on", "and", "off", "live", "update", "for", "a", "query", "tree", "and", "or", "its", "sub", "trees", "NUMBER", "paralin", "you", "have", "me", "sold", "now", "NUMBER", "Live", "queries", "with", "the", "live", "directive", "to", "subscribe", "to", "them", "for", "the", "win", "However", "I", "be", "still", "not", "clear", "on", "how", "you", "d", "turn", "off", "the", "query", "subscription", "NUMBER", "How", "would", "that", "work", "And", "how", "do", "the", "server", "know", "who", "to", "send", "the", "update", "data", "from", "a", "live", "query", "to", "There", "could", "be", "NUMBER", "clients", "waiting", "and", "listening", "yet", "let", "s", "say", "only", "NUMBER", "subscribed", "to", "get", "the", "update", "data", "not", "all", "NUMBER", "How", "can", "that", "be", "controlled", "I", "can", "t", "imagine", "we", "d", "want", "to", "simply", "broadcast", "any", "and", "all", "update", "NUMBER", "I", "guess", "I", "be", "wondering", "if", "GraphQL", "should", "even", "be", "considered", "a", "gateway", "in", "this", "fashion", "use", "live", "queries", "NUMBER", "It", "seems", "to", "me", "there", "needs", "to", "be", "a", "subscription", "system", "in", "front", "of", "GraphQL", "no", "matter", "what", "NUMBER", "The", "subscription", "system", "would", "control", "who", "gets", "what", "when", "and", "to", "whom", "and", "GraphQL", "would", "only", "concerns", "itself", "with", "the", "feeding", "the", "subscription", "system", "with", "the", "what", "NUMBER", "This", "also", "might", "be", "showing", "my", "lack", "of", "knowledge", "in", "terms", "of", "a", "websocket", "kind", "of", "communication", "and", "exchange", "of", "message", "NUMBER", "So", "go", "easy", "on", "me", "NUMBER", "Edit", "also", "thanks", "for", "that", "link", "to", "the", "talk", "NUMBER", "Very", "interesting", "take", "on", "abstraction", "NUMBER", "Scott", "The", "client", "NUMBER", "query", "TAG", "options", "function", "returns", "an", "Observable", "NUMBER", "The", "system", "subscribes", "to", "the", "query", "field", "when", "at", "least", "NUMBER", "subscriber", "be", "viewing", "them", "NUMBER", "It", "keep", "a", "refcount", "so", "if", "your", "app", "request", "the", "same", "thing", "NUMBER", "places", "it", "will", "only", "actually", "send", "a", "single", "field", "subscription", "NUMBER", "Every", "client", "run", "a", "query", "gets", "its", "own", "resolver", "function", "call", "for", "each", "field", "NUMBER", "The", "Go", "server", "do", "these", "in", "parallel", "so", "they", "re", "extremely", "fast", "in", "general", "NUMBER", "You", "could", "return", "an", "exist", "Go", "channel", "from", "these", "function", "for", "example", "to", "direct", "the", "system", "to", "subscribe", "to", "a", "stream", "of", "values", "come", "from", "elsewhere", "and", "send", "them", "to", "the", "client", "until", "the", "client", "unsubscribes", "NUMBER", "Or", "you", "could", "manage", "the", "stream", "of", "data", "more", "tightly", "use", "a", "live", "function", "that", "terminates", "the", "field", "when", "it", "returns", "NUMBER", "The", "system", "adapts", "to", "your", "code", "AST", "dynamically", "at", "runtime", "NUMBER", "I", "suppose", "the", "general", "answer", "to", "this", "thread", "be", "no", "the", "two", "be", "NOT", "the", "same", "thing", "NUMBER", "A", "good", "follow", "up", "would", "be", "Live", "Queries", "do", "they", "belong", "in", "the", "spec", "Well", "if", "you", "add", "subscriptions", "as", "a", "necessary", "part", "of", "live", "queries", "which", "I", "think", "we", "can", "all", "agree", "on", "they", "be", "then", "we", "be", "still", "talking", "about", "a", "subscription", "system", "in", "general", "which", "would", "be", "the", "same", "thing", "NUMBER", "However", "if", "we", "be", "talking", "about", "how", "to", "resolve", "those", "subscriptions", "either", "with", "active", "push", "of", "update", "in", "live", "queries", "or", "with", "an", "elaborate", "pub", "sub", "event", "system", "then", "we", "be", "talking", "about", "two", "different", "things", "NUMBER", "So", "I", "think", "the", "better", "question", "be", "what", "be", "the", "best", "solution", "for", "subscribing", "to", "change", "in", "data", "and", "get", "the", "results", "of", "those", "subscriptions", "Scott", "Subscriptions", "as", "they", "be", "defined", "in", "GraphQL", "be", "not", "necessary", "for", "live", "queries", "NUMBER", "Furthermore", "resolving", "subscriptions", "be", "going", "to", "be", "part", "of", "the", "spec", "and", "be", "designed", "around", "a", "very", "different", "use", "case", "from", "live", "queries", "NUMBER", "My", "previous", "suggestion", "still", "stands", "NUMBER", "Subscriptions", "as", "they", "be", "defined", "in", "GraphQL", "be", "not", "necessary", "for", "live", "queries", "NUMBER", "I", "thought", "subscriptions", "in", "general", "be", "necessary", "for", "live", "queries", "in", "order", "for", "them", "to", "scale", "well", "NUMBER", "I", "realize", "the", "subscription", "system", "defined", "here", "doesn", "t", "match", "a", "live", "query", "subscription", "system", "NUMBER", "That", "be", "beside", "the", "point", "NUMBER", "Edit", "or", "maybe", "it", "be", "the", "point", "Actually", "my", "main", "concern", "be", "the", "definition", "of", "an", "event", "system", "out", "of", "the", "domain", "layer", "to", "trigger", "the", "GraphQL", "subscription", "system", "NUMBER", "I", "just", "don", "t", "think", "that", "should", "be", "necessary", "or", "rather", "an", "event", "system", "should", "be", "a", "domain", "responsibility", "and", "not", "part", "of", "the", "spec", "NUMBER", "Your", "live", "query", "system", "proves", "this", "be", "possible", "paralin", "Christian", "NUMBER", "I", "see", "GraphQL", "subscriptions", "as", "a", "live", "query", "system", "with", "subscriptions", "NUMBER", "How", "the", "data", "be", "force", "fed", "into", "GraphQL", "live", "from", "the", "backend", "data", "sources", "be", "then", "a", "domain", "specific", "concern", "NUMBER", "Right", "now", "as", "I", "understand", "the", "current", "RFC", "we", "be", "going", "from", "a", "bi", "directional", "data", "flow", "to", "the", "client", "to", "a", "request", "response", "data", "flow", "from", "the", "backend", "data", "sources", "plus", "some", "sort", "of", "events", "NUMBER", "But", "what", "if", "I", "can", "connect", "to", "a", "data", "source", "bi", "directionally", "I", "be", "also", "thinking", "about", "bi", "directional", "microservice", "communication", "like", "gRPC", "too", "With", "events", "I", "m", "locked", "into", "work", "with", "or", "around", "a", "prescribed", "triggering", "methodology", "NUMBER", "With", "live", "queries", "I", "be", "not", "NUMBER", "One", "might", "argue", "that", "most", "backend", "data", "sources", "be", "request", "response", "systems", "anyway", "and", "why", "we", "need", "events", "NUMBER", "But", "that", "be", "due", "to", "past", "technologies", "NUMBER", "For", "truly", "reactive", "systems", "live", "queries", "be", "the", "future", "and", "it", "be", "why", "newer", "databases", "and", "data", "storage", "persistence", "technologies", "be", "add", "live", "query", "technology", "in", "their", "systems", "NUMBER", "Live", "queries", "makes", "the", "system", "a", "good", "bit", "more", "efficient", "NUMBER", "I", "can", "understand", "why", "Facebook", "might", "want", "it", "this", "way", "NUMBER", "It", "probably", "fits", "their", "systems", "better", "NUMBER", "I", "just", "think", "that", "be", "a", "bit", "close", "minded", "NUMBER", "Sorry", "if", "I", "step", "on", "toes", "by", "saying", "that", "NUMBER", "I", "actually", "think", "this", "might", "be", "something", "that", "could", "be", "effectively", "big", "in", "savings", "for", "Facebook", "in", "the", "end", "if", "my", "assumptions", "be", "correct", "and", "they", "step", "out", "of", "their", "own", "box", "NUMBER", "I", "certainly", "appreciate", "the", "chance", "to", "try", "and", "make", "that", "happen", "NUMBER", "I", "ll", "bow", "out", "of", "the", "conversation", "now", "unless", "someone", "mentions", "me", "NUMBER", "I", "ve", "said", "what", "I", "wanted", "to", "NUMBER", "Scott", "You", "be", "correct", "in", "that", "the", "concept", "of", "subscriptions", "be", "important", "for", "live", "queries", "for", "example", "you", "would", "subscribe", "to", "the", "result", "of", "a", "query", "on", "the", "client", "to", "inform", "the", "system", "that", "you", "re", "interested", "in", "knowing", "about", "it", "NUMBER", "I", "agree", "with", "all", "of", "your", "other", "points", "as", "well", "particularly", "around", "the", "domain", "level", "implementation", "of", "reactivity", "NUMBER", "Recapping", "summarizing", "now", "GraphQL", "subscriptions", "refer", "to", "the", "subscription", "operation", "as", "oppose", "to", "the", "query", "or", "mutate", "operations", "NUMBER", "They", "be", "tightly", "bound", "by", "the", "spec", "and", "designed", "more", "for", "event", "streams", "than", "live", "update", "NUMBER", "It", "s", "become", "clear", "now", "that", "live", "queries", "be", "still", "a", "query", "operation", "with", "some", "parameters", "or", "directives", "applied", "NUMBER", "The", "actual", "handle", "of", "those", "queries", "be", "do", "at", "a", "framework", "level", "like", "in", "Relay", "or", "Magellan", "or", "Soyuz", "or", "Apollo", "etc", "NUMBER", "As", "of", "now", "the", "spec", "has", "everything", "necessary", "to", "handle", "these", "queries", "directives", "which", "be", "server", "defined", "and", "the", "query", "operation", "NUMBER", "In", "the", "context", "of", "the", "language", "we", "have", "everything", "we", "need", "as", "far", "as", "I", "can", "see", "NUMBER", "Although", "this", "be", "close", "I", "d", "like", "to", "put", "in", "my", "last", "input", "to", "this", "daunting", "question", "NUMBER", "It", "s", "probably", "too", "late", "to", "make", "any", "difference", "but", "here", "goes", "anyway", "NUMBER", "I", "reread", "this", "part", "of", "the", "blog", "post", "about", "the", "subscription", "system", "in", "GraphQL", "and", "Relay", "LINK", "in", "graphql", "and", "relay", "why", "not", "live", "queries", "and", "it", "dawned", "on", "me", "what", "the", "difference", "be", "between", "a", "subscription", "system", "and", "a", "live", "query", "system", "NUMBER", "A", "subscription", "system", "be", "business", "logic", "centric", "NUMBER", "A", "live", "query", "system", "be", "data", "centric", "NUMBER", "If", "you", "read", "that", "article", "please", "do", "if", "not", "again", "it", "s", "reasoning", "for", "not", "use", "live", "queries", "be", "because", "with", "a", "live", "query", "you", "can", "t", "make", "heads", "or", "tails", "of", "which", "business", "logic", "should", "be", "covered", "to", "evoke", "the", "update", "to", "the", "client", "NUMBER", "So", "I", "ask", "two", "question", "NUMBER", "NUMBER", "Who", "care", "s", "what", "the", "business", "logic", "reasons", "be", "to", "update", "the", "client", "NUMBER", "With", "a", "pub", "sub", "event", "based", "solution", "be", "you", "possibly", "actually", "forcing", "these", "business", "logic", "decisions", "to", "be", "made", "in", "order", "to", "update", "the", "client", "properly", "Provocative", "question", "for", "sure", "NUMBER", "And", "I", "d", "love", "to", "hear", "the", "answers", "of", "Dan", "or", "Lany", "or", "anyone", "else", "who", "thinks", "live", "queries", "offer", "the", "stumbling", "block", "of", "not", "knowing", "why", "an", "update", "should", "happen", "NUMBER", "Until", "and", "if", "anyone", "answers", "let", "me", "explain", "why", "I", "think", "the", "reasoning", "in", "that", "article", "be", "a", "bit", "flawed", "and", "that", "this", "stumbling", "block", "isn", "t", "one", "NUMBER", "Let", "s", "look", "at", "the", "example", "fragment", "use", "in", "the", "article", "to", "argue", "against", "live", "queries", "again", "NUMBER", "fragment", "StoryLikeData", "on", "Story", "story", "likers", "count", "likeSentence", "text", "Instead", "of", "worrying", "about", "why", "the", "client", "should", "be", "update", "for", "change", "in", "likes", "or", "the", "likeSentence", "the", "client", "only", "wants", "to", "know", "about", "change", "in", "the", "like", "_count_", "and", "the", "likeSentence", "_text_", "NUMBER", "Right", "The", "query", "or", "request", "itself", "be", "very", "_data", "centric_", "NUMBER", "In", "other", "words", "the", "client", "doesn", "t", "really", "give", "a", "hoot", "about", "why", "these", "things", "change", "from", "a", "business", "logic", "perspective", "because", "the", "client", "only", "wants", "to", "update", "the", "view", "of", "that", "data", "whenever", "it", "change", "NUMBER", "Oh", "and", "by", "the", "way", "aren", "t", "all", "those", "business", "logic", "question", "presented", "in", "the", "blog", "post", "about", "why", "a", "like", "count", "should", "be", "change", "already", "made", "in", "the", "business", "logic", "We", "don", "t", "need", "to", "ask", "them", "again", "answering", "the", "question", "above", "NUMBER", "At", "one", "point", "the", "like", "count", "or", "the", "text", "will", "change", "NUMBER", "All", "the", "client", "cares", "about", "be", "those", "change", "NUMBER", "Also", "if", "the", "client", "be", "going", "to", "request", "that", "some", "data", "be", "update", "automatically", "with", "a", "subscription", "the", "query", "request", "should", "be", "very", "specific", "NUMBER", "It", "shouldn", "t", "cover", "a", "fragment", "with", "multiple", "unrelated", "data", "items", "NUMBER", "It", "should", "only", "cover", "one", "specific", "piece", "of", "information", "or", "very", "much", "relate", "information", "for", "the", "scenario", "where", "there", "be", "an", "insertion", "of", "data", "NUMBER", "Why", "A", "whole", "section", "of", "the", "RFC", "for", "subscriptions", "be", "dedicated", "to", "under", "and", "over", "_pushing_", "NUMBER", "If", "the", "like", "count", "above", "change", "why", "would", "I", "want", "the", "likeSentence", "text", "with", "it", "In", "an", "update", "scenario", "that", "would", "be", "over", "push", "NUMBER", "Right", "Of", "course", "it", "depends", "on", "what", "be", "be", "presented", "but", "I", "don", "t", "see", "any", "correlation", "NUMBER", "The", "better", "solution", "for", "that", "example", "be", "two", "separate", "subscriptions", "One", "on", "the", "likes", "count", "and", "one", "for", "the", "text", "update", "of", "the", "likeSentence", "NUMBER", "So", "now", "the", "only", "need", "to", "make", "this", "happen", "be", "to", "watch", "these", "two", "data", "sources", "NUMBER", "When", "they", "get", "change", "for", "whatever", "reasons", "then", "an", "update", "be", "push", "to", "the", "client", "NUMBER", "This", "might", "be", "a", "watcher", "which", "following", "the", "aggregation", "system", "use", "for", "aggregating", "likes", "and", "also", "the", "update", "channel", "to", "the", "likeSentence", "text", "NUMBER", "That", "be", "live", "querying", "NUMBER", "I", "wonder", "if", "we", "weren", "t", "talking", "in", "circles", "here", "NUMBER", "That", "in", "the", "end", "Facebook", "actually", "has", "build", "a", "live", "query", "system", "but", "be", "use", "an", "event", "based", "pub", "sub", "system", "to", "make", "it", "happen", "and", "thus", "feels", "this", "client", "real", "time", "update", "system", "can", "t", "be", "call", "live", "queries", "NUMBER", "If", "so", "NUMBER", "Great", "But", "let", "s", "do", "call", "it", "a", "live", "query", "subscription", "system", "based", "on", "a", "pub", "sub", "event", "system", "NUMBER", "That", "way", "everyone", "can", "understand", "and", "should", "that", "the", "events", "get", "triggered", "should", "be", "data", "centric", "and", "not", "business", "logic", "centric", "NUMBER", "Scott", "Who", "care", "s", "what", "the", "business", "logic", "reasons", "be", "to", "update", "the", "client", "Have", "you", "watched", "LINK", "ViXL", "NUMBER", "YQnioU", "particularly", "the", "part", "starting", "from", "NUMBER", "NUMBER", "Because", "our", "backends", "at", "FB", "be", "not", "reactive", "which", "be", "also", "the", "case", "for", "many", "other", "folks", "at", "other", "companies", "use", "GraphQL", "we", "had", "the", "idea", "that", "we", "could", "instead", "implement", "live", "queries", "by", "use", "data", "dependencies", "to", "fake", "a", "reactive", "backend", "which", "would", "require", "knowing", "what", "you", "call", "the", "business", "logic", "reasons", "that", "can", "cause", "a", "given", "field", "to", "change", "NUMBER", "The", "blog", "post", "and", "the", "talk", "both", "explain", "why", "this", "was", "ultimately", "not", "possible", "for", "us", "NUMBER", "With", "a", "pub", "sub", "event", "based", "solution", "be", "you", "possibly", "actually", "forcing", "these", "business", "logic", "decisions", "to", "be", "made", "in", "order", "to", "update", "the", "client", "properly", "If", "I", "understand", "this", "question", "correctly", "then", "yes", "we", "re", "putting", "the", "control", "into", "the", "hands", "of", "the", "client", "developer", "to", "decide", "which", "events", "to", "subscribe", "to", "and", "what", "information", "to", "query", "for", "each", "subscription", "NUMBER", "One", "of", "the", "main", "principles", "of", "GraphQL", "be", "that", "the", "client", "should", "have", "control", "over", "decisions", "about", "precisely", "what", "data", "it", "wants", "as", "oppose", "to", "something", "like", "REST", "where", "the", "client", "hits", "an", "endpoint", "on", "the", "server", "which", "decides", "what", "data", "to", "return", "NUMBER", "This", "principle", "also", "holds", "true", "for", "GraphQL", "Subscriptions", "the", "client", "developer", "has", "full", "control", "over", "which", "events", "they", "care", "about", "and", "what", "query", "should", "be", "executed", "when", "those", "events", "happen", "NUMBER", "calebmer", "s", "comment", "above", "has", "some", "good", "insight", "into", "this", "issue", "of", "developer", "control", "versus", "magic", "NUMBER", "And", "I", "d", "love", "to", "hear", "the", "answers", "of", "Dan", "or", "Lany", "or", "anyone", "else", "who", "thinks", "live", "queries", "offer", "the", "stumbling", "block", "of", "not", "knowing", "why", "an", "update", "should", "happen", "NUMBER", "It", "s", "Laney", "To", "be", "clear", "that", "stumbling", "block", "existed", "for", "us", "because", "we", "don", "t", "have", "a", "reactive", "backend", "NUMBER", "From", "my", "previous", "comment", "we", "believe", "based", "on", "experience", "at", "Facebook", "and", "discussions", "with", "other", "folks", "that", "the", "general", "problem", "of", "implement", "live", "queries", "at", "scale", "be", "not", "easy", "NUMBER", "This", "doesn", "t", "mean", "that", "it", "be", "always", "hard", "with", "an", "efficient", "reactive", "backend", "implement", "live", "queries", "becomes", "fairly", "straightforward", "NUMBER", "You", "previously", "commented", "that", "I", "can", "understand", "why", "Facebook", "might", "want", "it", "this", "way", "NUMBER", "It", "probably", "fits", "their", "systems", "better", "NUMBER", "I", "just", "think", "that", "be", "a", "bit", "close", "minded", "NUMBER", "Perhaps", "stubailo", "can", "chime", "in", "here", "with", "examples", "of", "other", "non", "Facebook", "users", "of", "GraphQL", "who", "reached", "the", "same", "conclusion", "about", "live", "queries", "and", "GraphQL", "Subscriptions", "NUMBER", "So", "now", "the", "only", "need", "to", "make", "this", "happen", "be", "to", "watch", "these", "two", "data", "sources", "NUMBER", "Your", "whole", "chain", "of", "reasoning", "rests", "on", "the", "ability", "to", "watch", "these", "two", "data", "sources", "which", "be", "equivalent", "to", "having", "a", "reactive", "backend", "NUMBER", "I", "also", "notice", "that", "you", "previously", "write", "that", "I", "don", "t", "think", "GraphQL", "should", "be", "work", "with", "events", "internally", "NUMBER", "They", "aren", "t", "needed", "as", "Christians", "s", "rgraphql", "system", "proves", "NUMBER", "Again", "the", "confusion", "here", "seems", "to", "center", "around", "the", "assumption", "that", "a", "reactive", "backend", "be", "always", "available", "NUMBER", "A", "live", "query", "demo", "use", "a", "reactive", "backend", "certainly", "do", "not", "prove", "that", "everyone", "use", "GraphQL", "has", "an", "efficient", "reactive", "backend", "NUMBER", "You", "previously", "write", "that", "For", "truly", "reactive", "systems", "live", "queries", "be", "the", "future", "and", "it", "be", "why", "newer", "databases", "and", "data", "storage", "persistence", "technologies", "be", "add", "live", "query", "technology", "in", "their", "systems", "NUMBER", "Live", "queries", "makes", "the", "system", "a", "good", "bit", "more", "efficient", "NUMBER", "If", "you", "have", "a", "reactive", "backend", "that", "s", "efficient", "for", "your", "particular", "application", "or", "use", "case", "that", "s", "great", "NUMBER", "If", "you", "implement", "live", "queries", "use", "a", "directive", "we", "d", "love", "to", "hear", "what", "you", "learn", "NUMBER", "But", "it", "s", "incorrect", "to", "assume", "that", "everyone", "who", "uses", "GraphQL", "either", "start", "with", "such", "a", "backend", "or", "has", "the", "resources", "desire", "to", "convert", "their", "exist", "backends", "to", "reactive", "ones", "NUMBER", "in", "the", "end", "Facebook", "actually", "has", "build", "a", "live", "query", "system", "but", "be", "use", "an", "event", "based", "pub", "sub", "system", "to", "make", "it", "happen", "and", "thus", "feels", "this", "client", "real", "time", "update", "system", "can", "t", "be", "call", "live", "queries", "NUMBER", "If", "so", "NUMBER", "Great", "But", "let", "s", "do", "call", "it", "a", "live", "query", "subscription", "system", "based", "on", "a", "pub", "sub", "event", "system", "NUMBER", "That", "way", "everyone", "can", "understand", "and", "should", "that", "the", "events", "get", "triggered", "should", "be", "data", "centric", "and", "not", "business", "logic", "centric", "NUMBER", "I", "don", "t", "fully", "follow", "this", "reasoning", "NUMBER", "What", "we", "ve", "build", "i", "NUMBER", "e", "NUMBER", "GraphQL", "Subscriptions", "be", "describe", "quite", "clearly", "in", "the", "spec", "from", "robzhu", "and", "in", "the", "blog", "post", "and", "talk", "I", "linked", "earlier", "NUMBER", "I", "certainly", "would", "not", "call", "this", "a", "live", "query", "system", "NUMBER", "To", "be", "more", "concrete", "you", "commented", "on", "March", "NUMBER", "with", "your", "definition", "of", "live", "queries", "what", "we", "build", "and", "what", "we", "describe", "in", "the", "spec", "be", "definitely", "not", "that", "NUMBER", "Finally", "regard", "your", "last", "sentence", "the", "events", "be", "triggered", "in", "GraphQL", "Subscriptions", "be", "not", "data", "centric", "NUMBER", "They", "be", "tied", "to", "conceptual", "events", "such", "as", "a", "post", "be", "liked", "or", "a", "comment", "be", "write", "NUMBER", "smolinari", "Thanks", "a", "bunch", "for", "the", "thoughtful", "comment", "NUMBER", "Your", "post", "be", "quite", "long", "so", "forgive", "me", "if", "I", "be", "over", "simplifying", "it", "if", "I", "try", "to", "summarize", "it", "NUMBER", "I", "get", "the", "sense", "that", "you", "think", "Live", "queries", "and", "subscriptions", "may", "be", "isomorphic", "but", "live", "queries", "be", "intrinsically", "superior", "to", "live", "queries", "because", "they", "more", "naturally", "capture", "the", "desired", "outcome", "of", "up", "to", "date", "ness", "NUMBER", "Subscriptions", "may", "be", "a", "mere", "implementation", "detail", "only", "really", "chosen", "because", "they", "be", "easier", "to", "implement", "and", "scale", "that", "you", "could", "use", "to", "construct", "a", "reactive", "or", "apparently", "reactive", "system", "so", "you", "may", "as", "well", "put", "the", "public", "focus", "on", "reactivity", "and", "keep", "the", "implementation", "details", "private", "NUMBER", "Business", "logic", "be", "in", "a", "way", "an", "implementation", "detail", "so", "why", "would", "clients", "care", "about", "it", "when", "what", "they", "actually", "want", "be", "having", "and", "keep", "data", "up", "to", "date", "NUMBER", "If", "live", "queries", "be", "strictly", "better", "and", "more", "powerful", "than", "subscriptions", "it", "s", "better", "to", "have", "only", "them", "in", "the", "spec", "NUMBER", "Again", "please", "forgive", "me", "if", "I", "ve", "misread", "you", "on", "any", "of", "those", "points", "NUMBER", "Based", "on", "that", "reading", "I", "have", "a", "couple", "of", "comments", "Your", "example", "of", "likers", "count", "and", "likeSentence", "probably", "be", "a", "fine", "use", "case", "for", "live", "queries", "in", "the", "sense", "that", "it", "s", "the", "sort", "of", "thing", "that", "I", "can", "keep", "always", "live", "and", "continuously", "update", "the", "UI", "without", "any", "real", "risk", "of", "disrupting", "a", "user", "interaction", "for", "example", "a", "user", "be", "mostly", "only", "going", "to", "look", "at", "the", "count", "sentence", "and", "not", "interact", "with", "it", "directly", "and", "certainly", "not", "attempt", "to", "mutate", "any", "part", "of", "it", "NUMBER", "Additionally", "I", "evidently", "don", "t", "care", "about", "why", "the", "count", "or", "sentence", "change", "NUMBER", "I", "already", "know", "that", "it", "be", "almost", "invariably", "because", "somebody", "liked", "the", "content", "and", "less", "frequently", "that", "somebody", "unliked", "it", "NUMBER", "Either", "way", "it", "isn", "t", "going", "to", "change", "how", "I", "present", "the", "data", "to", "the", "user", "NUMBER", "There", "may", "not", "be", "a", "huge", "up", "side", "to", "keep", "it", "very", "up", "to", "date", "NUMBER", "For", "example", "a", "very", "popular", "post", "from", "a", "public", "figure", "doesn", "t", "really", "need", "to", "have", "its", "like", "count", "update", "every", "second", "update", "every", "NUMBER", "or", "NUMBER", "or", "NUMBER", "or", "NUMBER", "or", "even", "NUMBER", "seconds", "or", "more", "might", "be", "perfectly", "acceptable", "NUMBER", "As", "such", "get", "a", "periodic", "up", "to", "date", "view", "of", "the", "data", "be", "going", "to", "be", "just", "fine", "I", "don", "t", "need", "to", "know", "about", "any", "of", "the", "individual", "events", "or", "even", "the", "aggregation", "of", "multiple", "events", "that", "led", "to", "the", "update", "state", "NUMBER", "On", "the", "flip", "side", "there", "very", "definitely", "be", "use", "cases", "where", "the", "reason", "why", "something", "change", "be", "just", "as", "useful", "and", "important", "to", "me", "as", "what", "the", "data", "looks", "like", "after", "the", "change", "NUMBER", "An", "example", "of", "this", "might", "be", "a", "list", "of", "chat", "threads", "divided", "into", "online", "and", "offline", "contacts", "when", "somebody", "comes", "online", "I", "might", "want", "to", "animate", "them", "to", "a", "new", "place", "in", "the", "list", "NUMBER", "For", "this", "use", "case", "subscriptions", "may", "be", "exactly", "what", "I", "want", "instead", "of", "comparing", "the", "old", "and", "new", "lists", "and", "trying", "to", "infer", "what", "happened", "in", "order", "to", "present", "it", "to", "the", "user", "I", "can", "just", "rely", "on", "the", "server", "to", "tell", "me", "that", "a", "specific", "event", "occur", "NUMBER", "Note", "here", "that", "the", "event", "be", "driven", "by", "the", "business", "logic", "but", "the", "logic", "be", "not", "an", "implementation", "detail", "it", "actually", "has", "valuable", "semantic", "content", "NUMBER", "So", "despite", "the", "isomorphism", "I", "m", "actually", "going", "to", "prefer", "subscriptions", "whenever", "the", "reason", "for", "the", "change", "be", "relevant", "to", "my", "product", "NUMBER", "Another", "use", "case", "where", "I", "ll", "prefer", "subscriptions", "be", "when", "update", "data", "that", "the", "user", "may", "wish", "to", "mutate", "NUMBER", "Go", "back", "to", "our", "contact", "list", "example", "say", "my", "mouse", "be", "hovering", "over", "one", "of", "the", "items", "or", "I", "have", "right", "clicked", "on", "it", "to", "show", "a", "menu", "and", "I", "m", "about", "to", "perform", "an", "operation", "on", "it", "either", "re", "ordering", "it", "within", "the", "list", "or", "assigning", "it", "to", "a", "category", "etc", "NUMBER", "In", "this", "case", "too", "I", "don", "t", "want", "the", "data", "to", "be", "continuously", "live", "and", "update", "with", "the", "UI", "because", "that", "s", "going", "to", "be", "a", "very", "unpleasant", "UX", "for", "somebody", "who", "s", "actively", "trying", "to", "manipulate", "the", "data", "at", "the", "same", "time", "NUMBER", "For", "these", "use", "cases", "it", "will", "be", "better", "for", "me", "to", "enqueue", "subscription", "update", "that", "arrive", "during", "interaction", "and", "then", "apply", "them", "once", "the", "interaction", "be", "finished", "NUMBER", "So", "the", "tl", "dr", "be", "Live", "queries", "and", "subscriptions", "be", "isomorphic", "but", "differently", "suited", "to", "meet", "product", "specific", "circumstances", "NUMBER", "Any", "time", "you", "care", "about", "why", "something", "change", "subscriptions", "be", "a", "natural", "fit", "NUMBER", "Any", "time", "you", "need", "to", "present", "the", "change", "in", "progress", "eg", "NUMBER", "via", "animation", "rather", "than", "just", "the", "final", "result", "of", "the", "change", "subscriptions", "be", "a", "natural", "fit", "NUMBER", "Any", "time", "you", "want", "to", "buffer", "defer", "change", "until", "after", "use", "interaction", "mutation", "be", "complete", "subscriptions", "be", "a", "natural", "fit", "NUMBER", "Any", "time", "that", "none", "of", "the", "above", "apply", "live", "queries", "will", "likely", "be", "a", "natural", "fit", "caveat", "full", "reactivity", "be", "hard", "NUMBER", "Given", "the", "different", "use", "cases", "there", "be", "room", "in", "the", "spec", "for", "both", "live", "queries", "and", "event", "based", "subscriptions", "NUMBER", "I", "hope", "people", "don", "t", "feel", "like", "add", "subscriptions", "be", "closing", "the", "door", "on", "live", "queries", "in", "fact", "I", "think", "once", "people", "get", "use", "to", "subscriptions", "get", "live", "queries", "start", "will", "be", "much", "easier", "because", "a", "lot", "of", "transport", "relate", "question", "will", "already", "be", "validated", "NUMBER", "Wow", "This", "be", "sooo", "cool", "NUMBER", "I", "do", "not", "take", "it", "for", "granted", "that", "I", "be", "get", "this", "attention", "and", "I", "appreciate", "it", "enormously", "NUMBER", "So", "before", "I", "even", "begin", "let", "me", "say", "thank", "you", "so", "much", "for", "your", "time", "and", "effort", "Puh", "NUMBER", "where", "to", "begin", "NUMBER", "Hmm", "NUMBER", "Ok", "NUMBER", "laneyk", "Thanks", "for", "your", "very", "clear", "and", "understood", "response", "and", "the", "link", "to", "the", "video", "NUMBER", "That", "sets", "a", "great", "basis", "to", "this", "continued", "discussion", "NUMBER", "Your", "whole", "chain", "of", "reasoning", "rests", "on", "the", "ability", "to", "watch", "these", "two", "data", "sources", "which", "be", "equivalent", "to", "having", "a", "reactive", "backend", "NUMBER", "I", "also", "notice", "that", "you", "previously", "write", "that", "I", "don", "t", "think", "GraphQL", "should", "be", "work", "with", "events", "internally", "NUMBER", "Let", "me", "clarify", "the", "events", "point", "first", "and", "thanks", "for", "bringing", "it", "up", "NUMBER", "I", "was", "mistaken", "in", "my", "word", "or", "rather", "I", "think", "I", "might", "have", "said", "something", "different", "at", "some", "point", "somewhere", "else", "maybe", "not", "even", "in", "this", "discussion", "but", "elsewhere", "NUMBER", "I", "be", "not", "against", "an", "events", "system", "NUMBER", "My", "thoughts", "on", "the", "event", "based", "pub", "sub", "solution", "be", "as", "you", "even", "say", "in", "the", "video", "NUMBER", "it", "be", "an", "implementation", "detail", "NUMBER", "The", "whole", "time", "the", "FB", "team", "has", "fought", "against", "add", "implementation", "details", "into", "the", "spec", "and", "I", "believe", "this", "be", "also", "one", "NUMBER", "I", "ll", "leave", "it", "at", "that", "because", "the", "rest", "of", "my", "argumentation", "and", "question", "will", "hopefully", "clarify", "the", "reasoning", "to", "why", "I", "say", "that", "NUMBER", "Let", "s", "put", "it", "another", "way", "NUMBER", "Adding", "the", "event", "based", "pub", "sub", "solution", "makes", "the", "FB", "GraphQL", "system", "reactive", "NUMBER", "wincent", "made", "a", "point", "which", "might", "be", "the", "core", "to", "our", "sort", "of", "tangential", "discussion", "NUMBER", "Any", "time", "you", "care", "about", "why", "something", "change", "subscriptions", "be", "a", "natural", "fit", "NUMBER", "My", "question", "to", "that", "be", "how", "can", "client", "devs", "use", "GraphQL", "care", "about", "why", "something", "change", "I", "don", "t", "see", "how", "they", "can", "NUMBER", "They", "have", "pieces", "of", "data", "or", "certain", "activities", "which", "they", "want", "news", "about", "NUMBER", "They", "be", "simply", "ask", "the", "question", "Are", "there", "newly", "created", "data", "Or", "be", "there", "new", "update", "to", "change", "of", "that", "data", "Or", "be", "there", "activities", "going", "on", "which", "I", "want", "to", "be", "aware", "of", "If", "the", "answer", "be", "yes", "let", "me", "know", "about", "them", "without", "me", "ask", "again", "NUMBER", "None", "of", "that", "has", "anything", "to", "do", "with", "why", "the", "request", "data", "change", "but", "rather", "did", "something", "change", "NUMBER", "This", "be", "the", "big", "difference", "and", "to", "me", "it", "be", "the", "definition", "of", "a", "live", "query", "NUMBER", "laneyk", "also", "write", "NUMBER", "If", "I", "understand", "this", "question", "correctly", "then", "yes", "we", "re", "putting", "the", "control", "into", "the", "hands", "of", "the", "client", "developer", "to", "decide", "which", "events", "to", "subscribe", "to", "and", "what", "information", "to", "query", "for", "each", "subscription", "NUMBER", "How", "do", "a", "client", "define", "the", "event", "She", "be", "work", "with", "GraphQL", "and", "data", "NUMBER", "There", "be", "no", "event", "definitions", "available", "NUMBER", "Are", "there", "This", "be", "the", "open", "question", "in", "my", "mind", "which", "isn", "t", "make", "the", "click", "NUMBER", "To", "me", "there", "be", "only", "a", "flow", "of", "data", "NUMBER", "So", "when", "you", "say", "it", "s", "in", "the", "hands", "of", "the", "client", "developer", "to", "decide", "what", "events", "he", "or", "she", "should", "be", "subscribing", "to", "I", "don", "t", "see", "it", "NUMBER", "I", "see", "the", "client", "developer", "ask", "for", "update", "on", "single", "or", "multiple", "pieces", "of", "data", "or", "certain", "activities", "which", "yes", "might", "be", "events", "but", "they", "aren", "t", "defined", "as", "events", "NUMBER", "At", "least", "I", "have", "yet", "to", "see", "a", "good", "example", "of", "this", "NUMBER", "The", "only", "thing", "that", "comes", "to", "mind", "be", "the", "Someone", "be", "typing", "a", "reply", "display", "in", "FB", "comments", "NUMBER", "That", "be", "an", "event", "based", "subscription", "NUMBER", "How", "be", "that", "set", "up", "It", "be", "a", "rare", "example", "of", "something", "that", "isn", "t", "a", "live", "query", "because", "nothing", "be", "persisted", "NUMBER", "Well", "not", "unless", "FB", "be", "logging", "our", "typing", "prowess", "NUMBER", "LOL", "smile", "Btw", "Laney", "you", "said", "there", "were", "data", "dependencies", "that", "cause", "a", "lot", "of", "reasons", "for", "the", "like", "count", "to", "change", "the", "video", "NUMBER", "I", "call", "them", "business", "decisions", "NUMBER", "All", "the", "reasons", "you", "noted", "as", "to", "why", "a", "like", "count", "might", "grow", "or", "drop", "in", "number", "be", "decisions", "or", "processes", "made", "by", "the", "business", "NUMBER", "And", "again", "the", "client", "dev", "be", "not", "at", "all", "interested", "in", "these", "decisions", "or", "the", "events", "that", "cause", "a", "like", "count", "to", "increase", "or", "decrease", "and", "cannot", "be", "bothered", "by", "them", "NUMBER", "Can", "we", "agree", "on", "that", "The", "client", "dev", "only", "cares", "about", "the", "change", "happening", "NUMBER", "Her", "reasons", "for", "subscribing", "to", "the", "like", "count", "change", "be", "purely", "data", "centric", "NUMBER", "So", "again", "I", "feel", "Facebook", "has", "build", "a", "pub", "sub", "event", "based", "live", "query", "system", "for", "the", "client", "developer", "because", "it", "be", "NUMBER", "data", "centric", "NUMBER", "It", "has", "to", "be", "because", "the", "client", "dev", "really", "_can", "t_", "be", "involved", "in", "all", "of", "the", "business", "decisions", "or", "events", "made", "available", "as", "to", "why", "a", "piece", "or", "multiple", "pieces", "of", "data", "change", "NUMBER", "They", "only", "want", "to", "display", "the", "change", "NUMBER", "All", "the", "logic", "as", "to", "why", "the", "data", "change", "be", "hidden", "in", "the", "server", "and", "be", "business", "logic", "which", "the", "client", "dev", "has", "no", "clue", "about", "nor", "wants", "to", "know", "about", "NUMBER", "She", "or", "he", "just", "gets", "the", "live", "update", "NUMBER", "Or", "maybe", "it", "could", "be", "call", "Reactive", "Subscriptions", "In", "other", "words", "because", "there", "be", "the", "pub", "sub", "event", "based", "system", "behind", "Facebook", "s", "GraphQL", "subscription", "system", "it", "doesn", "t", "mean", "it", "be", "not", "a", "live", "query", "system", "NUMBER", "And", "as", "stubailo", "mention", "how", "others", "get", "those", "update", "through", "to", "the", "client", "can", "be", "pub", "sub", "event", "based", "or", "could", "also", "be", "do", "with", "a", "purely", "reactive", "systems", "which", "was", "also", "noted", "FB", "be", "also", "work", "towards", "right", "NUMBER", "The", "one", "solution", "for", "get", "reactivity", "in", "the", "data", "doesn", "t", "exclude", "the", "other", "NUMBER", "The", "way", "the", "update", "be", "push", "to", "the", "GraphQL", "API", "be", "an", "implementation", "detail", "and", "doesn", "t", "matter", "to", "the", "client", "or", "even", "the", "person", "responsible", "for", "the", "API", "NUMBER", "The", "response", "be", "always", "the", "same", "NUMBER", "The", "client", "and", "the", "API", "itself", "gets", "a", "response", "to", "a", "data", "centric", "and", "not", "business", "decision", "event", "based", "request", "for", "update", "NUMBER", "They", "be", "live", "queries", "at", "least", "from", "the", "client", "s", "and", "API", "perspective", "NUMBER", "I", "hope", "that", "all", "makes", "sense", "NUMBER", "It", "s", "all", "just", "a", "matter", "of", "semantics", "I", "guess", "NUMBER", "I", "feel", "the", "query", "subscription", "that", "be", "be", "created", "by", "the", "client", "be", "a", "live", "query", "NUMBER", "I", "be", "certain", "the", "client", "dev", "has", "should", "have", "no", "clue", "as", "to", "why", "he", "or", "she", "gets", "the", "update", "and", "in", "the", "end", "really", "doesn", "t", "care", "NUMBER", "Any", "subscription", "request", "be", "purely", "data", "centric", "in", "nature", "as", "be", "the", "response", "NUMBER", "It", "s", "just", "that", "now", "the", "query", "be", "reactive", "NUMBER", "It", "be", "live", "NUMBER", "How", "that", "reactiveness", "happens", "in", "the", "backend", "be", "unimportant", "for", "the", "API", "or", "at", "least", "it", "should", "be", "NUMBER", "Maybe", "that", "be", "the", "issue", "for", "this", "whole", "discussion", "from", "the", "beginning", "I", "ve", "be", "thinking", "in", "terms", "of", "the", "client", "and", "everyone", "else", "was", "thinking", "in", "terms", "of", "the", "implementation", "in", "the", "server", "Hmmmm", "NUMBER", "At", "any", "rate", "NUMBER", "Thanks", "again", "for", "everyone", "s", "time", "and", "also", "efforts", "and", "make", "all", "this", "possible", "to", "begin", "with", "NUMBER", "I", "see", "huge", "potential", "with", "GraphQL", "and", "this", "discussion", "really", "be", "peanuts", "in", "comparison", "NUMBER", "I", "be", "honored", "to", "even", "have", "the", "chance", "to", "be", "the", "small", "thorn", "in", "everyone", "s", "side", "here", "NUMBER", "I", "certainly", "don", "t", "want", "to", "waste", "anyone", "s", "time", "so", "I", "hope", "at", "least", "I", "could", "offer", "a", "different", "perspective", "and", "we", "could", "agree", "on", "it", "and", "maybe", "Facebook", "can", "now", "sell", "the", "subscription", "system", "as", "Live", "Query", "Subscriptions", "NUMBER", "Scott", "Hey", "Scott", "They", "have", "pieces", "of", "data", "or", "certain", "activities", "which", "they", "want", "news", "about", "NUMBER", "None", "of", "that", "has", "anything", "to", "do", "with", "why", "the", "request", "data", "change", "but", "rather", "did", "something", "change", "NUMBER", "This", "be", "the", "big", "difference", "and", "to", "me", "it", "be", "the", "definition", "of", "a", "live", "query", "NUMBER", "How", "do", "a", "client", "define", "the", "event", "She", "be", "work", "with", "GraphQL", "and", "data", "NUMBER", "There", "be", "no", "event", "definitions", "available", "NUMBER", "Are", "there", "This", "be", "the", "open", "question", "in", "my", "mind", "which", "isn", "t", "make", "the", "click", "NUMBER", "Yes", "the", "event", "corresponds", "to", "the", "GraphQL", "Subscription", "that", "the", "developer", "chooses", "to", "subscribe", "to", "NUMBER", "She", "may", "subscribe", "to", "comment", "creations", "or", "likes", "on", "a", "post", "or", "event", "RSVPs", "or", "someone", "starting", "to", "type", "for", "example", "NUMBER", "These", "be", "all", "events", "that", "happen", "in", "the", "world", "of", "FB", "NUMBER", "She", "be", "not", "ask", "for", "any", "arbitrary", "update", "about", "some", "piece", "of", "data", "rather", "by", "choosing", "a", "subscription", "to", "conceptual", "event", "X", "she", "be", "saying", "that", "she", "wants", "to", "get", "update", "push", "to", "her", "when", "and", "only", "when", "event", "X", "happens", "NUMBER", "In", "our", "system", "we", "trigger", "publishes", "to", "each", "subscription", "event", "stream", "when", "the", "conceptual", "event", "happens", "i", "NUMBER", "e", "NUMBER", "when", "someone", "starts", "typing", "or", "when", "someone", "creates", "a", "comment", "NUMBER", "I", "don", "t", "see", "it", "NUMBER", "I", "see", "the", "client", "developer", "ask", "for", "update", "on", "single", "or", "multiple", "pieces", "of", "data", "or", "certain", "activities", "which", "yes", "might", "be", "events", "but", "they", "aren", "t", "defined", "as", "events", "NUMBER", "They", "be", "events", "and", "they", "be", "defined", "as", "events", "NUMBER", "We", "have", "about", "NUMBER", "subscriptions", "in", "Facebook", "which", "correspond", "to", "conceptual", "events", "NUMBER", "The", "typing", "subscription", "which", "you", "mention", "be", "one", "example", "NUMBER", "To", "give", "another", "example", "when", "someone", "subscribe", "to", "comment", "creations", "they", "be", "not", "ask", "for", "any", "update", "to", "the", "relevant", "data", "the", "list", "of", "comments", "NUMBER", "If", "the", "list", "of", "comments", "change", "because", "someone", "who", "had", "previously", "write", "a", "comment", "un", "blocks", "the", "subscriber", "so", "the", "comment", "suddenly", "appears", "in", "the", "list", "the", "subscriber", "will", "not", "get", "an", "update", "NUMBER", "The", "data", "has", "change", "but", "the", "subscribed", "event", "has", "not", "happened", "NUMBER", "The", "subscriber", "will", "only", "get", "an", "update", "when", "the", "subscribed", "event", "happens", "that", "be", "when", "someone", "comments", "the", "post", "NUMBER", "I", "think", "that", "wincent", "explained", "this", "really", "well", "NUMBER", "Note", "here", "that", "the", "event", "be", "driven", "by", "the", "business", "logic", "but", "the", "logic", "be", "not", "an", "implementation", "detail", "it", "actually", "has", "valuable", "semantic", "content", "NUMBER", "And", "again", "the", "client", "dev", "be", "not", "at", "all", "interested", "in", "these", "decisions", "or", "the", "events", "that", "cause", "a", "like", "count", "to", "increase", "or", "decrease", "and", "cannot", "be", "bothered", "by", "them", "NUMBER", "Can", "we", "agree", "on", "that", "The", "client", "dev", "only", "cares", "about", "the", "change", "happening", "NUMBER", "Her", "reasons", "for", "subscribing", "to", "the", "like", "count", "change", "be", "purely", "data", "centric", "NUMBER", "No", "I", "don", "t", "agree", "on", "that", "and", "I", "think", "this", "be", "the", "central", "point", "of", "misunderstanding", "NUMBER", "In", "the", "subscriptions", "system", "that", "we", "ve", "build", "the", "client", "developer", "thinks", "in", "terms", "of", "actions", "or", "events", "NUMBER", "There", "s", "no", "way", "in", "our", "subscription", "system", "to", "say", "tell", "me", "when", "any", "of", "this", "data", "has", "change", "for", "any", "reason", "NUMBER", "There", "s", "only", "a", "way", "to", "say", "tell", "me", "when", "this", "conceptual", "event", "has", "occur", "and", "return", "the", "result", "of", "this", "subscription", "query", "to", "me", "when", "that", "happens", "NUMBER", "All", "the", "logic", "as", "to", "why", "the", "data", "change", "be", "hidden", "in", "the", "server", "and", "be", "business", "logic", "which", "the", "client", "dev", "has", "no", "clue", "about", "nor", "wants", "to", "know", "about", "NUMBER", "She", "or", "he", "just", "gets", "the", "live", "update", "NUMBER", "What", "you", "re", "describing", "be", "not", "what", "we", "ve", "build", "and", "not", "what", "we", "be", "describing", "in", "this", "GraphQL", "Subscriptions", "spec", "NUMBER", "The", "system", "you", "ve", "describe", "be", "much", "more", "in", "line", "with", "what", "we", "call", "live", "queries", "which", "be", "in", "a", "significantly", "earlier", "stage", "of", "investigation", "at", "Facebook", "with", "a", "lot", "of", "unanswered", "question", "NUMBER", "I", "m", "not", "sure", "that", "I", "can", "put", "it", "any", "better", "differently", "than", "wincent", "did", "above", "but", "my", "one", "sentence", "summary", "be", "that", "live", "queries", "let", "you", "say", "when", "any", "of", "the", "data", "in", "this", "query", "has", "change", "for", "any", "reason", "tell", "me", "the", "new", "result", "of", "the", "query", "whereas", "GraphQL", "Subscriptions", "let", "you", "say", "when", "this", "particular", "event", "has", "happened", "tell", "me", "the", "result", "of", "my", "subscription", "query", "NUMBER", "I", "hope", "that", "makes", "the", "distinction", "more", "clear", "NUMBER", "I", "recommend", "checking", "out", "the", "reference", "implementation", "when", "it", "s", "ready", "and", "playing", "around", "with", "that", "it", "may", "help", "make", "some", "of", "these", "question", "more", "concrete", "NUMBER", "Ok", "NUMBER", "I", "guess", "I", "ll", "have", "to", "NUMBER", "But", "I", "must", "ask", "these", "last", "question", "NUMBER", "From", "the", "video", "you", "linked", "to", "what", "delivers", "the", "pub", "signal", "that", "triggers", "the", "update", "on", "subscriptions", "to", "a", "like", "count", "Where", "do", "the", "event", "come", "from", "and", "what", "be", "it", "call", "Is", "there", "an", "aggregation", "system", "business", "logic", "which", "sends", "that", "pub", "event", "If", "yes", "be", "it", "the", "same", "logic", "that", "update", "the", "persistence", "layer", "to", "store", "the", "new", "like", "value", "too", "Scott", "First", "I", "would", "recommend", "thinking", "about", "the", "likes", "example", "as", "a", "subscription", "to", "likes", "events", "rather", "than", "a", "subscription", "to", "the", "like", "count", "data", "NUMBER", "In", "our", "system", "when", "someone", "add", "a", "new", "GraphQL", "subscription", "they", "also", "add", "logic", "to", "publish", "to", "that", "subscription", "NUMBER", "These", "publish", "events", "live", "in", "the", "same", "codebase", "as", "the", "business", "logic", "NUMBER", "They", "be", "manually", "add", "for", "each", "new", "subscription", "NUMBER", "The", "events", "be", "call", "whatever", "the", "developer", "named", "them", "like", "comment_create", "or", "story_like", "NUMBER", "For", "a", "system", "that", "uses", "GraphQL", "mutations", "for", "its", "writes", "you", "could", "imagine", "the", "subscription", "publish", "would", "happen", "in", "the", "mutation", "execution", "code", "NUMBER", "For", "the", "example", "of", "the", "like", "subscription", "there", "s", "a", "common", "codepath", "that", "gets", "executed", "every", "time", "anyone", "likes", "or", "unlikes", "a", "post", "NUMBER", "This", "be", "where", "the", "subscription", "publish", "happens", "NUMBER", "This", "be", "also", "where", "we", "update", "our", "database", "to", "indicate", "that", "person", "X", "has", "liked", "or", "no", "longer", "likes", "post", "Y", "NUMBER", "The", "reason", "that", "subscribing", "to", "likes", "be", "not", "equivalent", "to", "subscribing", "to", "like", "count", "data", "be", "that", "there", "be", "ways", "that", "the", "like", "count", "can", "change", "that", "will", "not", "trigger", "publishes", "to", "the", "like", "subscription", "NUMBER", "For", "instance", "if", "Alice", "had", "previously", "liked", "the", "post", "but", "then", "she", "deletes", "her", "FB", "account", "the", "like", "count", "will", "go", "down", "by", "one", "NUMBER", "This", "action", "do", "not", "go", "through", "the", "like", "unlike", "post", "codepath", "so", "it", "do", "not", "trigger", "the", "like", "subscription", "although", "the", "like", "count", "data", "has", "change", "NUMBER", "Ahhhhh", "NUMBER", "Very", "interesting", "NUMBER", "The", "logic", "to", "show", "a", "different", "value", "than", "what", "be", "persisted", "sort", "of", "eludes", "me", "NUMBER", "I", "guess", "I", "can", "t", "question", "FB", "s", "business", "decisions", "in", "the", "end", "NUMBER", "So", "I", "won", "t", "NUMBER", "I", "also", "still", "say", "the", "event", "based", "solution", "be", "an", "implementation", "detail", "on", "how", "to", "make", "data", "change", "events", "reactive", "NUMBER", "But", "I", "digress", "on", "that", "too", "NUMBER", "Thank", "you", "so", "much", "for", "your", "patience", "NUMBER", "I", "ll", "be", "very", "much", "looking", "forward", "to", "the", "reference", "implementation", "and", "learning", "and", "hopefully", "also", "helping", "a", "whole", "lot", "more", "in", "the", "future", "NUMBER", "Scott", "Maybe", "another", "way", "to", "think", "about", "it", "be", "that", "event", "based", "subscriptions", "be", "one", "option", "for", "live", "query", "implementation", "but", "in", "that", "context", "they", "re", "a", "_transport_", "level", "concern", "NUMBER", "By", "contrast", "for", "an", "event", "stream", "the", "subscriptions", "actually", "do", "map", "to", "what", "s", "logically", "happening", "NUMBER", "The", "like", "count", "thing", "be", "an", "interesting", "example", "because", "visually", "it", "resembles", "live", "queries", "so", "I", "d", "argue", "that", "it", "s", "closer", "to", "a", "workaround", "over", "real", "reactivity", "there", "be", "really", "really", "hard", "but", "having", "tried", "to", "build", "conceptually", "similar", "things", "on", "our", "end", "with", "subscriptions", "it", "s", "a", "very", "defensible", "one", "NUMBER", "taion", "I", "agree", "that", "likes", "be", "not", "the", "best", "example", "to", "talk", "about", "subscriptions", "in", "this", "particular", "discussion", "since", "it", "s", "something", "that", "be", "probably", "a", "better", "fit", "for", "a", "live", "query", "assuming", "both", "options", "exist", "NUMBER", "One", "example", "where", "product", "requirements", "might", "specifically", "dictate", "events", "over", "live", "queries", "be", "something", "like", "Twitter", "s", "timeline", "which", "shows", "a", "badge", "for", "new", "update", "rather", "than", "immediately", "display", "new", "update", "if", "the", "user", "s", "about", "to", "interact", "with", "a", "timeline", "entry", "you", "don", "t", "want", "to", "bump", "the", "timeline", "down", "in", "an", "unsolicited", "manner", "and", "make", "the", "poor", "user", "retweet", "the", "wrong", "thing", "or", "something", "like", "that", "NUMBER", "taion", "live", "queries", "still", "apply", "there", "you", "would", "just", "restrict", "the", "query", "to", "never", "add", "new", "entries", "without", "an", "explicit", "argument", "change", "NUMBER", "What", "s", "funny", "be", "that", "the", "same", "argument", "plays", "out", "over", "and", "over", "again", "NUMBER", "For", "example", "Redux", "at", "its", "core", "be", "event", "driven", "although", "they", "call", "them", "actions", "NUMBER", "It", "gives", "you", "a", "structure", "for", "producing", "a", "live", "view", "of", "your", "state", "in", "the", "form", "of", "its", "reducers", "and", "selectors", "NUMBER", "MobX", "has", "you", "mutate", "your", "live", "model", "directly", "and", "to", "the", "extent", "that", "events", "need", "to", "trigger", "processes", "you", "need", "to", "handle", "that", "in", "your", "mutation", "logic", "NUMBER", "There", "be", "strong", "reasons", "to", "build", "systems", "around", "the", "change", "data", "itself", "NUMBER", "You", "don", "t", "have", "to", "worry", "about", "accounting", "for", "all", "the", "causes", "NUMBER", "There", "be", "strong", "reasons", "to", "build", "systems", "around", "events", "NUMBER", "Sometimes", "user", "experience", "_does_", "care", "about", "the", "causes", "NUMBER", "Events", "can", "be", "depicted", "in", "a", "live", "query", "model", "by", "having", "field", "that", "will", "be", "the", "most", "recent", "event", "or", "null", "NUMBER", "After", "all", "the", "schema", "need", "not", "restrict", "itself", "to", "depicting", "only", "things", "that", "be", "literally", "persisted", "NUMBER", "Clients", "then", "would", "be", "responsible", "for", "queuing", "up", "any", "events", "that", "happen", "to", "appear", "NUMBER", "It", "would", "be", "awkward", "but", "possible", "NUMBER", "Likewise", "subscriptions", "can", "support", "live", "queries", "by", "push", "the", "full", "state", "or", "change", "thereof", "in", "every", "event", "NUMBER", "The", "event", "becomes", "your", "data", "has", "change", "NUMBER", "Also", "awkward", "to", "set", "up", "use", "and", "optimize", "NUMBER", "I", "think", "it", "s", "probably", "a", "good", "idea", "to", "have", "first", "class", "approaches", "to", "both", "paradigms", "even", "in", "the", "same", "application", "NUMBER", "acjay", "I", "think", "we", "re", "in", "general", "agreement", "there", "and", "most", "of", "us", "be", "targeting", "live", "queries", "NUMBER", "The", "core", "issue", "be", "just", "that", "live", "queries", "even", "at", "a", "schema", "level", "require", "make", "more", "decisions", "e", "NUMBER", "g", "NUMBER", "do", "you", "use", "something", "like", "JSON", "patch", "to", "communicate", "the", "update", "Or", "if", "not", "what", "do", "you", "use", "Right", "now", "a", "number", "of", "implementations", "mock", "live", "queries", "with", "polling", "but", "I", "think", "a", "general", "solution", "requires", "the", "kind", "of", "general", "consensus", "on", "how", "to", "push", "live", "query", "update", "that", "do", "not", "yet", "exist", "NUMBER", "What", "events", "can", "happen", "that", "aren", "t", "persisted", "If", "they", "aren", "t", "persisted", "can", "they", "be", "If", "they", "can", "be", "and", "I", "know", "they", "can", "be", "then", "those", "events", "can", "be", "triggered", "over", "live", "queries", "NUMBER", "Right", "Can", "every", "live", "query", "be", "modeled", "into", "an", "event", "system", "Sure", "they", "can", "NUMBER", "But", "then", "you", "d", "be", "build", "another", "separate", "system", "NUMBER", "I", "ve", "seen", "this", "do", "for", "MongoDB", "in", "many", "ways", "for", "example", "NUMBER", "So", "it", "be", "clear", "the", "want", "for", "live", "querying", "be", "relatively", "large", "NUMBER", "Why", "be", "that", "Obviously", "too", "only", "databases", "that", "can", "send", "live", "query", "message", "can", "be", "use", "in", "a", "proper", "live", "query", "system", "NUMBER", "Otherwise", "you", "be", "back", "again", "to", "needing", "a", "messaging", "queuing", "events", "system", "bus", "etc", "NUMBER", "I", "can", "understand", "why", "FB", "went", "with", "events", "NUMBER", "AFAIK", "they", "don", "t", "have", "databases", "that", "support", "live", "queries", "NUMBER", "But", "maybe", "they", "should", "If", "they", "did", "I", "bet", "this", "whole", "discussion", "and", "any", "solutions", "would", "get", "a", "whole", "lot", "easier", "NUMBER", "Scott", "Any", "sort", "of", "stream", "data", "trades", "clickstream", "c", "NUMBER", "aren", "t", "nicely", "modeled", "by", "live", "queries", "and", "would", "have", "to", "be", "emulated", "there", "NUMBER", "smolinari", "If", "you", "have", "a", "NUMBER", "minutes", "check", "out", "the", "other", "issue", "I", "made", "above", "your", "comment", "NUMBER", "I", "m", "increasingly", "convinced", "that", "all", "the", "pieces", "needed", "for", "a", "live", "query", "system", "more", "or", "less", "already", "exist", "in", "today", "s", "subscriptions", "NUMBER", "Although", "since", "it", "s", "so", "far", "just", "be", "a", "big", "thought", "experiment", "some", "details", "might", "be", "miss", "NUMBER", "There", "was", "a", "recent", "talk", "on", "Live", "Queries", "at", "GraphQL", "Summit", "by", "rodmk", "one", "of", "the", "engineers", "who", "works", "on", "the", "Live", "Query", "system", "at", "Facebook", "NUMBER", "I", "think", "it", "address", "several", "of", "the", "recurring", "question", "in", "this", "thread", "NUMBER", "LINK", "BSw", "NUMBER", "rJaCpA", "NUMBER", "acjay", "Absolutely", "NUMBER", "I", "never", "doubted", "GraphQL", "s", "capabilities", "to", "accommodate", "Live", "Queries", "NUMBER", "My", "whole", "argumentation", "here", "was", "to", "say", "that", "the", "add", "event", "driven", "system", "to", "make", "subscriptions", "work", "be", "basically", "unnecessary", "for", "proper", "GraphQL", "because", "it", "can", "and", "should", "support", "live", "queries", "and", "that", "be", "the", "better", "answer", "to", "subscriptions", "and", "state", "management", "NUMBER", "Maybe", "my", "thinking", "was", "a", "bit", "ahead", "of", "its", "time", "robzhu", "Hah", "Wow", "Excellent", "video", "Rodrigo", "demonstrates", "everything", "I", "ve", "be", "trying", "to", "get", "across", "here", "NUMBER", "I", "m", "all", "giddy", "now", "NUMBER", "And", "no", "I", "don", "t", "mean", "to", "say", "I", "told", "you", "so", "NUMBER", "NUMBER", "I", "do", "still", "get", "FB", "s", "need", "to", "not", "go", "straight", "away", "with", "a", "live", "query", "solution", "because", "of", "FB", "s", "legacy", "systems", "which", "Rodrigo", "also", "mentions", "NUMBER", "i", "NUMBER", "e", "NUMBER", "you", "can", "t", "rewrite", "all", "of", "the", "PHP", "code", "NUMBER", "It", "demonstrates", "how", "FB", "s", "own", "internal", "issue", "drive", "directions", "in", "its", "open", "source", "projects", "and", "that", "be", "all", "fine", "and", "dandy", "as", "a", "lot", "of", "dev", "shops", "out", "there", "will", "have", "those", "same", "kinds", "of", "issue", "NUMBER", "But", "there", "be", "also", "those", "who", "be", "starting", "anew", "and", "want", "the", "best", "they", "can", "get", "too", "and", "Live", "Queries", "be", "the", "better", "simpler", "solution", "granted", "only", "with", "a", "true", "reactive", "data", "store", "NUMBER", "I", "ve", "enjoyed", "this", "whole", "discussion", "and", "I", "d", "like", "to", "thank", "you", "all", "again", "for", "the", "opportunity", "NUMBER", "Scott", "taion", "I", "just", "re", "read", "LINK", "issuecomment", "NUMBER", "and", "now", "I", "think", "I", "get", "exactly", "what", "you", "mean", "NUMBER", "And", "from", "my", "side", "thread", "my", "conclusion", "to", "the", "title", "question", "Are", "Subscriptions", "and", "Live", "Queries", "the", "same", "thing", "be", "now", "yes", "qualified", "only", "by", "the", "need", "to", "answer", "the", "question", "of", "how", "to", "send", "update", "NUMBER", "In", "the", "best", "case", "scenario", "those", "semantics", "can", "be", "defined", "at", "the", "spec", "level", "leaving", "very", "little", "to", "be", "decided", "by", "library", "and", "application", "developers", "NUMBER", "But", "what", "if", "there", "s", "no", "natural", "_one", "size", "fits", "all_", "solution", "to", "describing", "update", "Much", "as", "scalar", "leaves", "basically", "every", "aspect", "of", "implementation", "to", "the", "client", "and", "server", "could", "something", "similar", "be", "do", "for", "the", "concept", "of", "update", "If", "so", "I", "think", "there", "s", "one", "major", "advantage", "to", "implement", "live", "queries", "within", "subscription", "you", "can", "subscribe", "to", "_both_", "new", "events", "and", "the", "change", "state", "NUMBER", "robzhu", "since", "you", "close", "this", "ticket", "with", "the", "opposite", "conclusion", "namely", "that", "live", "queries", "should", "be", "something", "_separate_", "from", "subscriptions", "I", "m", "curious", "whether", "this", "would", "address", "your", "concerns", "NUMBER", "The", "spec", "thing", "sort", "of", "_is_", "the", "thing", "though", "NUMBER", "We", "were", "more", "or", "less", "able", "to", "ship", "subscriptions", "as", "of", "v", "NUMBER", "that", "add", "support", "at", "a", "parsing", "level", "NUMBER", "The", "v", "NUMBER", "release", "that", "change", "the", "API", "to", "add", "first", "class", "support", "that", "was", "very", "very", "nice", "from", "an", "API", "perspective", "but", "ultimately", "didn", "t", "amount", "to", "much", "more", "than", "a", "minor", "API", "refactor", "LINK", "subscriptions", "pull", "NUMBER", "file", "By", "contrast", "contra", "rodmk", "I", "can", "t", "see", "how", "to", "nicely", "implement", "live", "queries", "in", "a", "way", "that", "lets", "me", "handle", "lists", "efficiently", "without", "push", "down", "the", "entire", "list", "every", "time", "the", "query", "update", "without", "some", "additional", "spec", "level", "support", "NUMBER", "A", "subscription", "be", "so", "similar", "to", "a", "mutation", "from", "the", "schema", "perspective", "NUMBER", "A", "mutation", "isn", "t", "NUMBER", "There", "be", "another", "distinction", "too", "NUMBER", "Ultimately", "it", "s", "not", "_that_", "awkward", "to", "subscribe", "to", "add", "delete", "and", "change", "events", "NUMBER", "Doing", "something", "like", "Twitter", "s", "new", "tweets", "alert", "instead", "of", "reactively", "showing", "new", "tweets", "with", "subscriptions", "be", "NUMBER", "possible", "but", "extremely", "annoying", "NUMBER", "And", "there", "be", "cases", "where", "you", "either", "want", "to", "or", "have", "to", "ship", "update", "in", "that", "manner", "e", "NUMBER", "g", "NUMBER", "we", "re", "doing", "HIPAA", "relate", "stuff", "we", "may", "want", "to", "only", "indicate", "the", "availability", "of", "new", "data", "rather", "than", "push", "down", "new", "private", "ish", "data", "to", "the", "client", "NUMBER", "NUMBER", "I", "can", "t", "see", "how", "to", "nicely", "implement", "live", "queries", "in", "a", "way", "that", "lets", "me", "handle", "lists", "efficiently", "without", "push", "down", "the", "entire", "list", "every", "time", "the", "query", "update", "without", "some", "additional", "spec", "level", "support", "NUMBER", "I", "m", "not", "sure", "if", "my", "point", "isn", "t", "clear", "or", "if", "I", "m", "miss", "something", "you", "re", "saying", "NUMBER", "I", "think", "we", "agree", "that", "lists", "would", "seem", "to", "be", "the", "trickiest", "data", "type", "for", "come", "up", "with", "a", "globally", "accpetable", "scheme", "of", "representing", "update", "NUMBER", "But", "do", "you", "get", "my", "point", "in", "analogizing", "that", "with", "the", "scalar", "situation", "The", "handle", "of", "custom", "scalars", "be", "one", "of", "the", "more", "interesting", "and", "initially", "confusing", "parts", "of", "GraphQL", "to", "me", "NUMBER", "The", "spec", "basically", "completely", "punts", "on", "anything", "having", "to", "do", "with", "how", "they", "re", "represented", "NUMBER", "They", "re", "just", "dumb", "leaf", "data", "NUMBER", "It", "s", "up", "to", "the", "client", "and", "server", "to", "determine", "the", "convention", "for", "their", "representation", "NUMBER", "This", "be", "_great_", "because", "it", "avoids", "clogging", "up", "the", "spec", "with", "arbitrary", "choices", "for", "things", "like", "dates", "and", "times", "NUMBER", "Can", "t", "the", "same", "approach", "be", "use", "for", "the", "representation", "of", "update", "since", "there", "be", "several", "reasonable", "approaches", "On", "a", "really", "simplified", "level", "the", "server", "needs", "to", "implement", "some", "function", "lastState", "newState", "changeRepresentation", "for", "each", "type", "and", "the", "client", "needs", "a", "corresponding", "set", "of", "function", "lastState", "changeRepresentation", "newState", "NUMBER", "For", "argument", "s", "sake", "let", "s", "just", "say", "the", "reference", "server", "implementation", "provides", "a", "default", "for", "all", "types", "could", "just", "be", "just", "send", "newState", "directly", "ignoring", "lastState", "NUMBER", "Presumably", "the", "reference", "server", "implementation", "would", "allow", "this", "default", "to", "be", "overriden", "by", "something", "more", "optimized", "NUMBER", "There", "be", "another", "distinction", "too", "NUMBER", "Ultimately", "it", "s", "not", "that", "awkward", "to", "subscribe", "to", "add", "delete", "and", "change", "events", "NUMBER", "Yeah", "I", "get", "that", "but", "for", "reasons", "I", "think", "everyone", "agrees", "with", "the", "event", "approach", "just", "isn", "t", "a", "great", "fit", "for", "every", "application", "NUMBER", "I", "m", "just", "trying", "to", "say", "I", "don", "t", "think", "it", "s", "actually", "that", "much", "more", "complex", "to", "do", "live", "queries", "use", "the", "exact", "same", "mechanism", "as", "has", "be", "build", "for", "events", "with", "really", "just", "one", "additional", "concept", "of", "what", "I", "might", "call", "modular", "update", "representation", "NUMBER", "I", "hope", "this", "makes", "my", "point", "clearer", "and", "sorry", "if", "I", "ve", "misunderstood", "what", "you", "re", "trying", "to", "say", "NUMBER", "acjay", "What", "you", "re", "saying", "makes", "sense", "NUMBER", "The", "distinction", "I", "was", "drawing", "was", "that", "with", "subscriptions", "there", "was", "an", "obvious", "choice", "of", "the", "semantic", "GraphQL", "payload", "to", "send", "back", "to", "the", "client", "that", "exactly", "matches", "what", "things", "look", "like", "with", "a", "mutation", "NUMBER", "The", "issue", "with", "live", "queries", "esp", "NUMBER", "lists", "be", "exactly", "as", "you", "say", "the", "specific", "implementation", "needs", "to", "define", "its", "_own_", "format", "to", "use", "for", "encoding", "deltas", "which", "be", "a", "problem", "that", "didn", "t", "arise", "with", "event", "subscriptions", "NUMBER", "It", "s", "just", "more", "stuff", "to", "decide", "for", "the", "app", "developer", "NUMBER", "Just", "to", "throw", "in", "what", "I", "ve", "be", "understanding", "as", "a", "live", "query", "which", "seems", "to", "be", "different", "to", "the", "discussion", "here", "and", "even", "a", "bit", "to", "what", "Rodrigo", "explained", "too", "but", "I", "believe", "live", "queries", "shouldn", "t", "return", "whole", "datasets", "or", "deltas", "of", "the", "change", "data", "but", "rather", "only", "send", "a", "trigger", "to", "the", "client", "to", "re", "request", "its", "affected", "query", "again", "NUMBER", "That", "way", "the", "back", "end", "can", "stay", "fairly", "dumb", "because", "the", "client", "be", "the", "one", "ask", "for", "the", "new", "data", "through", "the", "particular", "query", "and", "only", "the", "update", "data", "gets", "pull", "back", "into", "the", "client", "NUMBER", "Does", "that", "make", "any", "sense", "Scott", "That", "sucks", "because", "the", "server", "has", "to", "look", "everything", "up", "again", "and", "can", "t", "keep", "any", "context", "in", "memory", "NUMBER", "You", "re", "get", "caught", "up", "in", "the", "implementation", "details", "NUMBER", "There", "be", "a", "lot", "of", "ways", "of", "accomplishing", "this", "NUMBER", "Two", "way", "socket", "pub", "sub", "change", "notification", "channel", "long", "polling", "merkle", "tree", "data", "hash", "comparison", "and", "state", "sync", "server", "side", "in", "memory", "meekle", "tree", "result", "caches", "NUMBER", "taion", "I", "just", "re", "read", "NUMBER", "comment", "and", "now", "I", "think", "I", "get", "exactly", "what", "you", "mean", "NUMBER", "And", "from", "my", "side", "thread", "my", "conclusion", "to", "the", "title", "question", "Are", "Subscriptions", "and", "Live", "Queries", "the", "same", "thing", "be", "now", "yes", "qualified", "only", "by", "the", "need", "to", "answer", "the", "question", "of", "how", "to", "send", "update", "NUMBER", "since", "you", "close", "this", "ticket", "with", "the", "opposite", "conclusion", "namely", "that", "live", "queries", "should", "be", "something", "separate", "from", "subscriptions", "I", "m", "curious", "whether", "this", "would", "address", "your", "concerns", "NUMBER", "Re", "reading", "the", "thread", "now", "I", "have", "not", "find", "compelling", "argument", "for", "why", "the", "answer", "to", "this", "question", "be", "yes", "NUMBER", "To", "quote", "from", "Rodrigo", "s", "presentation", "at", "GraphQL", "Summit", "Live", "Queries", "observe", "data", "subscriptions", "observe", "events", "For", "example", "suppose", "you", "had", "a", "server", "side", "clock", "that", "tracks", "the", "current", "time", "NUMBER", "The", "current", "time", "has", "two", "interesting", "properties", "the", "value", "itself", "and", "when", "it", "ticks", "NUMBER", "If", "you", "want", "to", "observe", "the", "current", "time", "use", "a", "Live", "Query", "NUMBER", "If", "you", "want", "to", "observe", "the", "tick", "event", "use", "a", "Subscription", "NUMBER", "These", "be", "awkwardly", "isomorphic", "because", "you", "can", "always", "record", "the", "set", "of", "events", "in", "a", "list", "and", "observe", "that", "list", "NUMBER", "For", "example", "you", "can", "use", "a", "CQRS", "style", "log", "but", "it", "seems", "silly", "to", "have", "a", "CQRS", "log", "for", "seconds", "in", "the", "day", "NUMBER", "Another", "angle", "a", "Live", "Query", "be", "essentially", "a", "Query", "NUMBER", "You", "can", "poll", "any", "Query", "to", "simulate", "its", "behavior", "as", "a", "Live", "Query", "NUMBER", "By", "contrast", "polling", "a", "Subscription", "where", "the", "subscription", "do", "not", "have", "a", "stateful", "channel", "between", "polls", "doesn", "t", "make", "sense", "NUMBER", "Hope", "that", "communicates", "my", "current", "thinking", "NUMBER", "I", "m", "not", "seeing", "the", "recent", "argument", "cover", "new", "ground", "so", "I", "m", "inclined", "to", "keep", "the", "issue", "close", "but", "please", "let", "me", "know", "if", "I", "m", "miss", "some", "context", "NUMBER", "robzhu", "summarizes", "it", "nicely", "NUMBER", "It", "s", "easily", "possible", "to", "add", "an", "events", "subscriptions", "implementation", "on", "top", "of", "whatever", "live", "query", "system", "and", "it", "s", "also", "probably", "possible", "to", "make", "a", "live", "query", "system", "use", "subscriptions", "as", "some", "kind", "of", "awkward", "transport", "NUMBER", "At", "the", "end", "of", "the", "day", "data", "be", "data", "and", "the", "way", "you", "transfer", "it", "depends", "on", "what", "you", "want", "to", "do", "with", "it", "and", "how", "often", "it", "change", "NUMBER", "paralin", "But", "the", "point", "I", "m", "trying", "to", "make", "be", "that", "if", "we", "can", "forget", "for", "a", "minute", "that", "subscription", "was", "created", "with", "an", "event", "paradigm", "in", "mind", "it", "s", "actually", "_very_", "close", "to", "be", "suitable", "for", "live", "queries", "as", "well", "NUMBER", "What", "seems", "to", "be", "miss", "be", "simply", "a", "concept", "of", "a", "difference", "between", "the", "intial", "response", "and", "the", "stream", "of", "update", "and", "a", "modular", "scheme", "for", "representing", "those", "update", "NUMBER", "Not", "to", "minimize", "those", "issue", "but", "it", "feels", "like", "a", "manageable", "hump", "NUMBER", "Which", "be", "also", "why", "I", "m", "thrilled", "the", "answer", "has", "be", "revised", "to", "yes", "D", "acjay", "Those", "two", "things", "that", "you", "just", "describe", "including", "modular", "scheme", "for", "representing", "those", "update", "be", "a", "live", "queries", "system", "NUMBER", "There", "s", "no", "reason", "to", "use", "a", "subscription", "channel", "as", "your", "transport", "for", "a", "live", "queries", "system", "NUMBER", "It", "add", "nothing", "over", "just", "a", "websocket", "transport", "NUMBER", "Therefore", "a", "subscription", "channel", "be", "not", "suitable", "for", "live", "queries", "as", "well", "NUMBER", "It", "s", "suitable", "for", "the", "event", "based", "paradigm", "which", "was", "what", "it", "was", "designed", "for", "NUMBER", "I", "build", "a", "prototype", "of", "an", "efficient", "live", "queries", "system", "with", "magellan", "LINK", "and", "it", "doesn", "t", "look", "anything", "similar", "to", "the", "subscriptions", "system", "for", "performance", "I", "binary", "encode", "and", "batch", "change", "to", "different", "parts", "of", "the", "result", "tree", "which", "wouldn", "t", "be", "possible", "via", "a", "subscriptions", "channel", "anyway", "NUMBER", "paralin", "Maybe", "I", "m", "miss", "something", "but", "if", "the", "assumption", "be", "that", "a", "web", "socket", "server", "_could_", "simply", "choose", "to", "interpret", "a", "vanilla", "query", "as", "be", "a", "subscription", "for", "live", "query", "update", "why", "wouldn", "t", "the", "exact", "same", "thing", "work", "for", "events", "It", "s", "just", "a", "single", "query", "that", "s", "responded", "to", "multiple", "times", "when", "the", "server", "deems", "it", "appropriate", "NUMBER", "acjay", "I", "think", "that", "s", "exactly", "right", "NUMBER", "A", "minimum", "not", "especially", "efficient", "implementation", "could", "just", "hold", "onto", "the", "full", "query", "and", "re", "run", "the", "entire", "thing", "and", "push", "the", "results", "down", "to", "the", "client", "every", "time", "it", "gets", "an", "update", "NUMBER", "That", "s", "in", "fact", "how", "I", "read", "the", "call", "to", "make", "a", "prototype", "bit", "at", "the", "end", "of", "rodmk", "s", "talk", "NUMBER", "taion", "acjay", "I", "would", "struggle", "to", "call", "that", "a", "live", "query", "system", "at", "all", "NUMBER", "As", "we", "re", "discussing", "what", "a", "real", "implementation", "of", "something", "like", "that", "would", "look", "like", "or", "in", "essence", "trying", "to", "figure", "out", "what", "the", "best", "approach", "would", "be", "I", "m", "not", "really", "considering", "hacks", "like", "sending", "the", "entire", "state", "over", "a", "subscription", "channel", "as", "a", "live", "query", "system", "NUMBER", "You", "can", "do", "the", "exact", "same", "thing", "with", "just", "a", "websocket", "and", "a", "server", "side", "polling", "run", "query", "check", "if", "change", "happened", "wait", "NUMBER", "seconds", "loop", "and", "remove", "the", "entire", "graphql", "stack", "NUMBER", "In", "that", "way", "it", "s", "not", "useful", "to", "have", "the", "subscriptions", "stack", "in", "the", "mix", "at", "all", "for", "something", "like", "this", "NUMBER", "It", "be", "for", "this", "reason", "that", "I", "would", "say", "that", "the", "two", "things", "be", "entirely", "separate", "and", "should", "be", "treated", "as", "such", "NUMBER", "I", "went", "and", "watched", "Rodrigo", "s", "talk", "LINK", "BSw", "NUMBER", "rJaCpA", "and", "while", "I", "would", "argue", "that", "saying", "Subscriptions", "and", "Live", "Queries", "be", "interchangeable", "be", "misleading", "he", "be", "right", "in", "that", "you", "can", "build", "almost", "any", "application", "with", "either", "approach", "NUMBER", "One", "approach", "will", "just", "be", "better", "for", "certain", "types", "of", "things", "than", "the", "other", "NUMBER", "paralin", "Let", "s", "move", "this", "discussion", "to", "NUMBER", "instead", "of", "continuing", "to", "comment", "on", "a", "close", "issue", "NUMBER", "Live", "Queries", "observe", "data", "subscriptions", "observe", "events", "Live", "Queries", "observe", "data", "store", "events", "i", "NUMBER", "e", "NUMBER", "record", "creations", "update", "and", "deletes", "NUMBER", "Also", "those", "data", "store", "events", "could", "be", "due", "to", "other", "events", "NUMBER", "Scott", "From", "my", "response", "on", "NUMBER", "I", "think", "this", "be", "an", "application", "level", "thing", "NUMBER", "State", "be", "not", "a", "concept", "that", "be", "inherent", "to", "GraphQL", "NUMBER", "Subscribing", "to", "e", "NUMBER", "g", "NUMBER", "streams", "of", "newly", "created", "items", "also", "doesn", "t", "necessarily", "admit", "an", "easy", "representation", "of", "current", "state", "NUMBER", "Imagine", "subscription", "update", "that", "don", "t", "reflect", "idempotent", "operations", "in", "such", "cases", "there", "isn", "t", "really", "a", "coherent", "initial", "state", "NUMBER", "Agreed", "there", "should", "be", "no", "concept", "of", "initial", "state", "NUMBER", "If", "the", "backend", "implementation", "wants", "to", "send", "something", "back", "right", "away", "then", "it", "s", "free", "to", "do", "so", "though", "NUMBER", "I", "also", "agree", "with", "others", "an", "initial", "state", "may", "or", "may", "not", "be", "present", "NUMBER", "I", "can", "imagine", "that", "some", "implementations", "may", "client", "decide", "what", "data", "to", "emit", "based", "on", "root", "field", "argument", "like", "lastSeenEventId", "or", "something", "along", "these", "lines", "Oh", "now", "I", "see", "how", "I", "could", "get", "an", "atomic", "subscription", "request", "graphql", "subscription", "commentCreated", "postId", "NUMBER", "null", "on", "first", "request", "but", "present", "in", "later", "update", "comment", "body", "present", "on", "first", "request", "but", "null", "in", "later", "update", "initialPost", "title", "comments", "body", "Does", "that", "sound", "like", "it", "d", "be", "within", "spec", "The", "server", "_may_", "respond", "to", "a", "subscription", "operation", "with", "a", "response", "rmosolgo", "Exactly", "Ooh", "I", "really", "like", "that", "idea", "NUMBER", "Could", "be", "a", "clever", "way", "for", "the", "server", "to", "handle", "this", "kind", "of", "guarantee", "NUMBER", "I", "m", "not", "sure", "there", "s", "a", "need", "to", "merge", "those", "NUMBER", "Thinking", "about", "Relay", "for", "the", "moment", "I", "might", "want", "the", "subscription", "active", "thing", "to", "be", "entirely", "delegated", "to", "my", "transport", "layer", "really", "just", "a", "Socket", "NUMBER", "IO", "ack", "on", "my", "subscribe", "request", "while", "the", "initial", "message", "should", "be", "expose", "to", "e", "NUMBER", "g", "NUMBER", "the", "Relay", "network", "layer", "NUMBER", "Maybe", "it", "s", "a", "bit", "of", "an", "implementation", "detail", "at", "that", "point", "NUMBER", "You", "can", "imagine", "with", "something", "SSE", "based", "that", "the", "subscription", "active", "bit", "could", "just", "be", "implicit", "anyway", "NUMBER", "This", "response", "can", "be", "useful", "for", "returning", "initial", "data", "or", "indicating", "whether", "the", "operation", "was", "successful", "NUMBER", "as", "per", "taion", "assuming", "operation", "was", "successful", "refers", "to", "subscription", "active", "you", "want", "to", "keep", "these", "on", "different", "layers", "NUMBER", "Any", "ACK", "message", "could", "go", "in", "the", "graphql", "bytestream", "ie", "bytes", "handed", "to", "graphql", "from", "the", "underlying", "transport", "layer", "but", "not", "be", "part", "of", "the", "message", "stream", "NUMBER", "Extending", "what", "Jimmy", "said", "this", "should", "be", "delegated", "to", "the", "transport", "layer", "until", "a", "reason", "to", "bring", "it", "into", "the", "graphql", "layer", "since", "most", "sane", "transport", "layers", "will", "give", "us", "enough", "for", "core", "subscribe", "and", "unsubscribe", "semantics", "NUMBER", "NUMBER", "NUMBER", "it", "may", "be", "desirable", "to", "propagate", "error", "message", "differently", "when", "they", "be", "graphql", "error", "eg", "bad", "upstream", "data", "NUMBER", "rmosolgo", "I", "d", "imagine", "you", "would", "want", "to", "use", "a", "union", "to", "make", "this", "type", "safe", "and", "since", "you", "re", "muxing", "state", "and", "update", "but", "only", "want", "one", "of", "each", "type", "per", "message", "NUMBER", "type", "Comment", "author", "Person", "body", "String", "type", "Post", "author", "Person", "title", "String", "body", "String", "comments", "Comment", "subscription", "postWithComments", "postId", "Int", "Post", "Comment", "This", "now", "says", "I", "will", "always", "send", "you", "either", "a", "post", "or", "a", "comment", "NUMBER", "subscription", "commentCreated", "postId", "NUMBER", "later", "responses", "NUMBER", "on", "Comment", "body", "the", "on", "first", "response", "NUMBER", "on", "Post", "title", "comments", "body", "Yeah", "I", "definitely", "think", "the", "ACK", "should", "just", "be", "on", "the", "level", "of", "checking", "whether", "the", "connection", "be", "successful", "or", "not", "NUMBER", "Depending", "on", "the", "resulution", "of", "NUMBER", "subscriptions", "vs", "NUMBER", "live", "queries", "I", "think", "only", "allowing", "the", "event", "stream", "to", "be", "derived", "from", "the", "root", "field", "parameters", "would", "be", "an", "important", "way", "to", "make", "the", "distinction", "NUMBER", "Knowing", "that", "you", "be", "going", "to", "get", "the", "same", "set", "of", "events", "regardless", "of", "the", "query", "pass", "in", "allows", "you", "to", "have", "more", "understanding", "of", "the", "system", "you", "re", "calling", "into", "and", "means", "you", "can", "refactor", "your", "client", "code", "at", "will", "for", "example", "by", "moving", "some", "of", "the", "field", "into", "a", "follow", "up", "query", "NUMBER", "Most", "argument", "for", "including", "information", "about", "the", "whole", "query", "selection", "set", "I", "ve", "seen", "so", "far", "involve", "build", "a", "live", "query", "like", "system", "on", "top", "of", "subscriptions", "people", "be", "suggesting", "that", "you", "might", "want", "to", "receive", "update", "based", "on", "the", "field", "you", "asked", "for", "which", "seems", "to", "break", "my", "understanding", "of", "the", "fundamentals", "of", "the", "system", "NUMBER", "IMO", "the", "nicest", "way", "to", "write", "the", "spec", "has", "things", "just", "work", "out", "this", "way", "NUMBER", "I", "take", "back", "what", "I", "said", "about", "live", "queries", "NUMBER", "A", "worthwhile", "detail", "from", "dshafer", "s", "comment", "root", "subscription", "field", "__", "and", "its", "argument", "__", "emphasis", "mine", "In", "light", "of", "that", "these", "two", "subscriptions", "may", "receive", "_different_", "events", "graphql", "Pushed", "only", "when", "a", "new", "comment", "be", "left", "on", "Post", "NUMBER", "subscription", "commentCreated", "postId", "NUMBER", "NUMBER", "graphql", "Pushed", "only", "when", "a", "new", "comment", "be", "left", "on", "Post", "NUMBER", "subscription", "commentCreated", "postId", "NUMBER", "NUMBER", "I", "this", "be", "quite", "an", "import", "aspect", "as", "dshafer", "point", "in", "in", "his", "comment", "NUMBER", "Given", "this", "schema", "graphql", "type", "Subscription", "a", "A", "b", "B", "c", "d", "D", "Int", "and", "following", "query", "graphql", "subscription", "a", "a", "NUMBER", "a", "NUMBER", "b", "b", "NUMBER", "b", "NUMBER", "c", "d", "foo", "BAR", "Here", "be", "several", "question", "I", "was", "struggling", "with", "NUMBER", "Do", "a", "b", "and", "c", "relate", "to", "each", "other", "in", "some", "ways", "or", "represent", "something", "special", "just", "like", "mutation", "field", "represent", "mutations", "effect", "thus", "must", "be", "executed", "sequentially", "NUMBER", "Should", "c", "allow", "to", "be", "a", "scalar", "type", "NUMBER", "Are", "there", "other", "restrictions", "on", "an", "output", "type", "of", "a", "root", "field", "NUMBER", "Can", "it", "be", "not", "null", "NUMBER", "What", "be", "semantic", "difference", "between", "nullable", "and", "not", "null", "field", "NUMBER", "Can", "it", "be", "an", "abstract", "type", "union", "or", "interface", "Previously", "I", "experimented", "with", "NUMBER", "ways", "of", "representing", "events", "in", "subscriptions", "and", "both", "work", "quite", "well", "as", "hierarchies", "graphql", "interface", "A", "eventId", "ID", "type", "UserCreated", "implement", "A", "eventId", "ID", "userId", "ID", "userName", "String", "email", "String", "type", "UserNameChanged", "implement", "A", "eventId", "ID", "userId", "ID", "userName", "String", "and", "a", "concrete", "types", "every", "root", "field", "represents", "individual", "event", "graphql", "type", "A", "eventId", "ID", "userId", "ID", "userName", "String", "email", "String", "type", "B", "eventId", "ID", "userId", "ID", "userName", "String", "should", "both", "approaches", "be", "allow", "NUMBER", "Should", "we", "prefer", "one", "approach", "over", "the", "other", "NUMBER", "Does", "execution", "of", "types", "A", "B", "and", "C", "follow", "normal", "parallel", "query", "execution", "rules", "should", "a", "NUMBER", "and", "a", "NUMBER", "be", "allow", "to", "execute", "in", "parallel", "NUMBER", "If", "I", "have", "NUMBER", "incoming", "event", "of", "type", "A", "what", "be", "the", "right", "result", "format", "NUMBER", "all", "field", "be", "always", "present", "json", "data", "a", "a", "NUMBER", "foo", "a", "NUMBER", "bar", "b", "null", "c", "NUMBER", "only", "relevant", "field", "be", "returned", "json", "data", "a", "a", "NUMBER", "foo", "a", "NUMBER", "bar", "NUMBER", "If", "I", "have", "NUMBER", "incoming", "events", "or", "pieces", "of", "information", "of", "type", "A", "and", "B", "what", "be", "the", "right", "result", "format", "NUMBER", "all", "field", "be", "emitted", "as", "a", "single", "result", "json", "data", "a", "a", "NUMBER", "foo", "a", "NUMBER", "bar", "b", "b", "NUMBER", "baz", "b", "NUMBER", "null", "NUMBER", "every", "field", "be", "emitted", "as", "a", "single", "result", "json", "data", "a", "a", "NUMBER", "foo", "a", "NUMBER", "bar", "NUMBER", "data", "b", "b", "NUMBER", "baz", "b", "NUMBER", "null", "NUMBER", "Should", "it", "be", "allow", "to", "have", "NUMBER", "root", "field", "simultaneously", "in", "a", "single", "emitted", "result", "NUMBER", "Can", "emitted", "result", "contain", "null", "values", "in", "root", "field", "e", "NUMBER", "g", "NUMBER", "json", "data", "a", "null", "My", "personal", "take", "on", "it", "NUMBER", "a", "b", "and", "c", "conceptually", "represents", "an", "event", "message", "fact", "NUMBER", "It", "can", "as", "well", "represent", "a", "chunk", "of", "information", "that", "be", "delivered", "in", "several", "emitted", "results", "NUMBER", "yes", "scalar", "types", "should", "be", "allow", "NUMBER", "I", "would", "allow", "abstract", "types", "but", "I", "would", "disallow", "not", "null", "types", "NUMBER", "It", "be", "not", "yet", "clear", "for", "me", "how", "it", "should", "mechanically", "work", "NUMBER", "I", "think", "both", "approaches", "from", "NUMBER", "ii", "be", "valid", "without", "any", "particular", "preference", "NUMBER", "NUMBER", "yes", "all", "execution", "below", "root", "field", "should", "inherit", "normal", "query", "execution", "semantics", "NUMBER", "I", "think", "NUMBER", "ii", "makes", "the", "most", "sense", "NUMBER", "Though", "if", "not", "null", "result", "types", "be", "not", "allow", "then", "both", "variations", "would", "be", "valid", "but", "I", "still", "prefer", "NUMBER", "ii", "NUMBER", "I", "think", "NUMBER", "ii", "makes", "the", "most", "sense", "NUMBER", "NUMBER", "I", "would", "not", "allow", "this", "NUMBER", "I", "would", "allow", "it", "only", "in", "case", "of", "an", "error", "NUMBER", "E", "NUMBER", "g", "NUMBER", "json", "data", "a", "null", "error", "message", "something", "went", "terribly", "wrong", "path", "a", "What", "do", "you", "think", "Might", "be", "useful", "to", "generate", "some", "marble", "diagrams", "for", "some", "of", "these", "or", "in", "the", "short", "term", "repurpose", "exist", "ones", "NUMBER", "Re", "NUMBER", "NUMBER", "the", "choice", "can", "be", "rendered", "as", "the", "distinction", "between", "merge", "LINK", "merge", "and", "combineLatest", "LINK", "combineLatest", "NUMBER", "Is", "subscription", "muxing", "and", "demuxing", "cf", "queries", "in", "relay", "and", "apollo", "important", "at", "this", "layer", "I", "imagine", "it", "should", "be", "an", "overlay", "to", "the", "base", "subscription", "mechanism", "NUMBER", "OlegIlyenko", "I", "differ", "on", "some", "of", "these", "points", "NUMBER", "Mainly", "the", "null", "not", "null", "stuff", "NUMBER", "NUMBER", "No", "NUMBER", "They", "represent", "different", "event", "types", "a", "user", "wants", "to", "receive", "NUMBER", "NUMBER", "Yes", "NUMBER", "Nullable", "values", "scalar", "or", "object", "should", "also", "be", "allow", "which", "gets", "brought", "up", "in", "NUMBER", "NUMBER", "Abstract", "and", "not", "null", "types", "should", "be", "allow", "NUMBER", "I", "don", "t", "think", "there", "should", "be", "any", "restriction", "on", "what", "gets", "returned", "NUMBER", "What", "a", "not", "null", "type", "means", "be", "that", "whenever", "an", "event", "be", "received", "for", "a", "given", "root", "field", "there", "_must_", "also", "be", "a", "value", "NUMBER", "The", "only", "concession", "the", "spec", "may", "want", "to", "make", "be", "that", "a", "null", "be", "allow", "for", "a", "not", "null", "subscription", "field", "type", "only", "if", "there", "was", "an", "error", "NUMBER", "This", "differs", "from", "queries", "where", "if", "a", "not", "null", "root", "field", "be", "null", "the", "null", "propagates", "up", "to", "the", "root", "level", "NUMBER", "In", "the", "subscription", "case", "nulls", "should", "only", "propagate", "to", "root", "level", "subscription", "field", "NUMBER", "NUMBER", "Yes", "NUMBER", "NUMBER", "This", "be", "an", "implementation", "detail", "that", "shouldn", "t", "need", "to", "be", "specified", "NUMBER", "I", "do", "prefer", "NUMBER", "ii", "as", "well", "for", "what", "it", "s", "worth", "NUMBER", "This", "be", "also", "an", "implementation", "detail", "which", "may", "differ", "between", "servers", "NUMBER", "I", "think", "NUMBER", "i", "be", "fine", "and", "clients", "should", "probably", "support", "that", "format", "NUMBER", "Servers", "may", "then", "choose", "between", "which", "format", "it", "actually", "wants", "to", "send", "NUMBER", "NUMBER", "I", "think", "this", "be", "an", "implementation", "detail", "The", "spec", "should", "perhaps", "only", "care", "about", "the", "fact", "that", "each", "root", "field", "has", "an", "event", "stream", "NUMBER", "The", "timing", "of", "event", "emits", "be", "determined", "by", "the", "server", "NUMBER", "My", "position", "on", "how", "this", "should", "be", "implement", "be", "reflected", "in", "by", "answer", "to", "NUMBER", "NUMBER", "Yes", "NUMBER", "Saying", "no", "to", "null", "values", "be", "not", "a", "restriction", "I", "think", "we", "need", "NUMBER", "Although", "I", "be", "curious", "your", "position", "in", "NUMBER", "be", "that", "we", "should", "not", "allow", "root", "non", "null", "types", "but", "your", "position", "in", "NUMBER", "be", "that", "we", "should", "not", "allow", "root", "nulls", "NUMBER", "No", "NUMBER", "They", "represent", "different", "event", "types", "a", "user", "wants", "to", "receive", "NUMBER", "So", "I", "guess", "it", "s", "actually", "yes", "since", "they", "share", "a", "common", "property", "they", "represent", "event", "types", "Do", "I", "understand", "it", "correctly", "The", "question", "was", "more", "about", "semantic", "similarities", "rather", "than", "a", "relation", "between", "values", "during", "the", "runtime", "NUMBER", "Although", "I", "be", "curious", "your", "position", "in", "NUMBER", "be", "that", "we", "should", "not", "allow", "root", "non", "null", "types", "but", "your", "position", "in", "NUMBER", "be", "that", "we", "should", "not", "allow", "root", "nulls", "NUMBER", "a", "very", "good", "point", "I", "guess", "I", "get", "a", "bit", "confused", "along", "the", "way", "I", "add", "NUMBER", "in", "an", "edit", "mostly", "because", "I", "thought", "that", "data", "a", "null", "do", "not", "hold", "much", "of", "a", "useful", "information", "NUMBER", "Regarding", "nullable", "vs", "not", "null", "NUMBER", "I", "don", "t", "hold", "a", "strong", "opinion", "on", "this", "one", "per", "se", "NUMBER", "I", "just", "wonder", "how", "it", "will", "interact", "with", "the", "fact", "that", "we", "now", "have", "NUMBER", "sources", "of", "field", "omission", "null", "value", "event", "stream", "emitted", "null", "for", "particular", "event", "other", "field", "assuming", "that", "they", "represent", "different", "event", "types", "have", "not", "emitted", "any", "value", "I", "think", "I", "m", "also", "ok", "with", "defining", "it", "like", "this", "both", "nullable", "and", "not", "null", "field", "be", "allow", "at", "the", "root", "level", "undefined", "means", "that", "event", "be", "not", "emitted", "null", "means", "that", "event", "type", "be", "emitted", "but", "an", "event", "value", "be", "null", "Though", "it", "would", "look", "a", "bit", "strange", "when", "a", "be", "emitted", "but", "c", "which", "be", "defined", "as", "not", "null", "has", "undefined", "null", "value", "NUMBER", "NUMBER", "NUMBER", "I", "think", "this", "be", "an", "implementation", "detail", "I", "m", "not", "sure", "about", "this", "one", "NUMBER", "I", "feel", "that", "this", "aspect", "has", "deeper", "implications", "on", "subscription", "semantics", "NUMBER", "I", "think", "this", "conversation", "about", "multiple", "root", "field", "and", "null", "should", "happen", "on", "a", "separate", "issue", "IMO", "OlegIlyenko", "NUMBER", "No", "NUMBER", "They", "represent", "different", "event", "types", "a", "user", "wants", "to", "receive", "NUMBER", "So", "I", "guess", "it", "s", "actually", "yes", "since", "they", "share", "a", "common", "property", "they", "represent", "event", "types", "Do", "I", "understand", "it", "correctly", "The", "question", "was", "more", "about", "semantic", "similarities", "rather", "than", "a", "relation", "between", "values", "during", "the", "runtime", "NUMBER", "The", "no", "was", "mostly", "directed", "at", "the", "serial", "execution", "bit", "at", "the", "end", "of", "point", "NUMBER", "both", "nullable", "and", "not", "null", "field", "be", "allow", "at", "the", "root", "level", "undefined", "means", "that", "event", "be", "not", "emitted", "null", "means", "that", "event", "type", "be", "emitted", "by", "the", "event", "value", "be", "null", "I", "like", "this", "as", "well", "NUMBER", "NUMBER", "I", "think", "this", "be", "an", "implementation", "detail", "I", "m", "not", "sure", "about", "this", "one", "NUMBER", "I", "feel", "that", "this", "aspect", "has", "deeper", "implications", "on", "subscription", "semantics", "NUMBER", "Yeah", "you", "re", "right", "NUMBER", "I", "saw", "JSON", "and", "immediately", "jumped", "to", "the", "conclusion", "that", "it", "be", "a", "serialization", "concern", "I", "think", "it", "s", "limiting", "to", "think", "about", "subscription", "responses", "purely", "in", "the", "context", "of", "the", "current", "response", "format", "NUMBER", "Let", "s", "see", "if", "we", "can", "think", "of", "something", "else", "that", "better", "fits", "the", "subscription", "case", "NUMBER", "I", "m", "not", "sure", "that", "I", "like", "NUMBER", "ii", "when", "data", "continues", "to", "be", "a", "map", "that", "conforms", "to", "the", "shape", "of", "the", "selection", "set", "NUMBER", "The", "restriction", "to", "a", "single", "key", "value", "pair", "in", "the", "data", "map", "feels", "arbitrary", "NUMBER", "What", "if", "instead", "the", "event", "response", "was", "json", "event", "a", "data", "a", "NUMBER", "foo", "a", "NUMBER", "bar", "json", "event", "b", "data", "b", "NUMBER", "baz", "b", "NUMBER", "null", "This", "enforces", "only", "one", "event", "per", "message", "NUMBER", "Another", "thought", "be", "that", "the", "subscriptions", "grammar", "should", "be", "customized", "to", "_only_", "allow", "field", "and", "not", "other", "selections", "like", "inline", "fragment", "or", "fragment", "spreads", "NUMBER", "For", "example", "SubscriptionSelectionSet", "Field", "list", "caabernathy", "The", "no", "was", "mostly", "directed", "at", "the", "serial", "execution", "bit", "at", "the", "end", "of", "point", "NUMBER", "Ah", "I", "see", "NUMBER", "Sorry", "I", "was", "more", "focused", "on", "meaning", "of", "the", "field", "rather", "them", "execution", "characteristics", "event", "NUMBER", "approach", "sounds", "quite", "interesting", "I", "need", "to", "think", "about", "it", "NUMBER", "Another", "thought", "be", "that", "the", "subscriptions", "grammar", "should", "be", "customized", "to", "only", "allow", "field", "and", "not", "other", "selections", "like", "inline", "fragment", "or", "fragment", "spreads", "NUMBER", "I", "haven", "t", "thought", "about", "it", "NUMBER", "It", "s", "definitely", "something", "worth", "considering", "NUMBER", "What", "be", "your", "reasoning", "for", "disallowing", "inline", "fragment", "and", "fragment", "spreads", "stubailo", "Indeed", "I", "agree", "NUMBER", "It", "looks", "like", "these", "two", "points", "be", "relatively", "independent", "and", "can", "be", "discussed", "separately", "NUMBER", "What", "be", "your", "reasoning", "for", "disallowing", "inline", "fragment", "and", "fragment", "spreads", "It", "would", "enforce", "a", "few", "properties", "about", "subscriptions", "NUMBER", "The", "subscription", "event", "types", "will", "always", "be", "present", "in", "the", "subscription", "definition", "NUMBER", "Any", "tooling", "may", "then", "easily", "know", "what", "to", "expect", "without", "resolving", "fragment", "NUMBER", "NUMBER", "The", "user", "could", "not", "create", "a", "fragment", "with", "any", "special", "behavior", "like", "they", "may", "now", "for", "mutations", "NUMBER", "A", "fragment", "on", "the", "mutation", "root", "type", "may", "sometimes", "execute", "serially", "if", "spread", "on", "a", "mutation", "or", "in", "parallel", "in", "the", "rare", "case", "that", "a", "user", "recursively", "references", "the", "mutation", "type", "somewhere", "in", "their", "tree", "NUMBER", "NUMBER", "The", "main", "use", "for", "inline", "fragment", "be", "type", "checking", "NUMBER", "On", "a", "root", "mutation", "or", "subscription", "type", "this", "be", "unnecessary", "most", "of", "the", "time", "NUMBER", "Unless", "the", "root", "mutation", "or", "subscription", "implement", "an", "interface", "but", "be", "there", "a", "convincing", "reason", "to", "do", "this", "It", "may", "even", "be", "worth", "extending", "this", "argument", "for", "mutations", "as", "well", "NUMBER", "A", "more", "thorough", "approach", "then", "only", "allowing", "Field", "s", "in", "a", "subscription", "s", "SelectionSet", "would", "be", "to", "only", "allow", "field", "on", "root", "mutations", "and", "subscriptions", "instead", "of", "object", "types", "NUMBER", "This", "provides", "more", "guarantees", "to", "the", "ecosystem", "and", "provides", "more", "flexibility", "to", "specification", "authors", "instead", "of", "retrofitting", "a", "current", "concept", "NUMBER", "What", "do", "you", "think", "I", "haven", "t", "thought", "much", "about", "this", "idea", "either", "so", "I", "m", "developing", "it", "on", "the", "fly", "That", "s", "a", "good", "point", "as", "well", "that", "it", "might", "be", "worth", "specify", "that", "no", "field", "can", "return", "the", "Subscription", "type", "NUMBER", "calebmer", "Thanks", "a", "lot", "for", "detailed", "explanation", "And", "I", "m", "sorry", "for", "the", "late", "reply", "NUMBER", "I", "definitely", "don", "t", "want", "to", "discard", "this", "idea", "but", "I", "have", "some", "concerns", "Introducing", "a", "special", "rules", "or", "exception", "from", "general", "rule", "has", "it", "s", "own", "price", "NUMBER", "I", "think", "one", "of", "the", "nice", "things", "about", "GraphQL", "be", "that", "it", "do", "have", "many", "rules", "to", "begin", "with", "NUMBER", "The", "only", "exception", "from", "a", "general", "rule", "i", "could", "find", "be", "an", "execution", "order", "of", "mutation", "field", "NUMBER", "In", "this", "case", "I", "think", "it", "s", "kind", "of", "essential", "so", "it", "definitely", "worth", "of", "inclusion", "NUMBER", "I", "guess", "something", "similar", "would", "be", "introduce", "for", "subscriptions", "as", "well", "NUMBER", "Disallowing", "fragment", "in", "subscription", "queries", "can", "add", "complexity", "in", "the", "language", "and", "and", "make", "it", "less", "uniform", "which", "may", "be", "a", "disadvantageous", "for", "people", "who", "be", "just", "start", "to", "learn", "GraphQL", "or", "tool", "that", "relay", "on", "specific", "uniform", "structure", "and", "features", "so", "I", "wonder", "whether", "gained", "benefits", "would", "be", "worth", "it", "NUMBER", "Fragments", "also", "serve", "as", "a", "unit", "of", "decomposition", "NUMBER", "Event", "though", "query", "and", "mutation", "types", "be", "also", "object", "types", "so", "there", "be", "no", "polymorphism", "involved", "still", "libraries", "like", "relay", "take", "advantage", "of", "them", "to", "compose", "queries", "provide", "by", "different", "components", "NUMBER", "E", "NUMBER", "g", "NUMBER", "graphql", "query", "Foo", "NUMBER", "ComponentA", "NUMBER", "ComponentB", "I", "wonder", "whether", "this", "property", "of", "fragment", "can", "be", "beneficial", "for", "subscriptions", "as", "well", "NUMBER", "I", "feel", "that", "it", "can", "be", "quite", "beneficial", "NUMBER", "That", "s", "a", "good", "point", "as", "well", "that", "it", "might", "be", "worth", "specify", "that", "no", "field", "can", "return", "the", "Subscription", "type", "NUMBER", "stubailo", "calebmer", "Indeed", "It", "s", "good", "point", "NUMBER", "I", "feel", "that", "may", "be", "even", "necessary", "for", "subscription", "type", "since", "it", "s", "semantics", "be", "quite", "different", "from", "anything", "else", "NUMBER", "Maybe", "it", "would", "be", "an", "option", "to", "introduce", "it", "for", "mutations", "as", "well", "though", "I", "wonder", "whether", "it", "can", "be", "just", "a", "linting", "optional", "validation", "rule", "in", "case", "of", "mutations", "NUMBER", "I", "wonder", "what", "be", "the", "use", "cases", "for", "mutation", "query", "subscription", "type", "as", "a", "return", "type", "of", "a", "field", "OlegIlyenko", "I", "don", "t", "feel", "super", "strong", "on", "the", "mutation", "and", "subscriptions", "be", "not", "root", "objects", "point", "and", "it", "kind", "of", "derails", "from", "the", "original", "discussion", "NUMBER", "We", "may", "want", "to", "separate", "into", "another", "own", "issue", "if", "the", "idea", "be", "worth", "exploring", "NUMBER", "At", "a", "high", "level", "I", "do", "agree", "though", "that", "the", "simplicity", "of", "the", "language", "be", "incredibly", "important", "but", "it", "may", "actually", "be", "simpler", "to", "add", "special", "semantics", "for", "root", "mutations", "and", "subscriptions", "instead", "of", "add", "special", "cases", "to", "object", "types", "which", "people", "may", "want", "to", "extend", "to", "other", "object", "types", "that", "be", "not", "root", "mutations", "or", "subscriptions", "see", "LINK", "NUMBER", "Instead", "of", "change", "GraphQL", "syntax", "we", "should", "just", "be", "able", "to", "do", "this", "with", "a", "validation", "rule", "NUMBER", "As", "for", "the", "original", "question", "I", "don", "t", "think", "there", "be", "any", "disagreement", "that", "the", "specification", "should", "require", "subscription", "events", "to", "be", "exclusively", "derived", "from", "the", "root", "field", "NUMBER", "Correct", "robzhu", "Updated", "the", "RFC", "text", "to", "describe", "this", "more", "clearly", "LINK", "I", "think", "it", "might", "be", "nice", "to", "make", "the", "title", "a", "bit", "more", "generic", "I", "think", "it", "might", "be", "better", "to", "structure", "it", "as", "a", "callback", "that", "can", "be", "fired", "in", "response", "to", "anything", "including", "events", "NUMBER", "In", "terms", "of", "a", "JavaScript", "API", "it", "would", "basically", "be", "like", "pending", "the", "resolution", "of", "LINK", "the", "argument", "can", "be", "different", "function", "subscriptionSetup", "rootFieldName", "rootFieldArgs", "callback", "hook", "up", "to", "pubsub", "system", "const", "subscription", "pubsub", "NUMBER", "subscribe", "my_event_name", "subscription", "NUMBER", "on", "data", "data", "callback", "data", "formatData", "data", "subscription", "NUMBER", "on", "error", "error", "callback", "error", "This", "could", "be", "located", "in", "the", "subscriptions", "system", "or", "perhaps", "next", "to", "the", "subscription", "field", "resolver", "NUMBER", "Modeling", "subscription", "payloads", "as", "a", "form", "of", "iterator", "or", "in", "the", "case", "of", "future", "ES", "features", "an", "AsyncIterators", "be", "another", "viable", "alternative", "to", "pubsub", "NUMBER", "I", "think", "this", "most", "closely", "fits", "the", "definition", "of", "event", "stream", "you", "describe", "Specifying", "that", "subscription", "payload", "receipt", "and", "most", "likely", "unsubscription", "operations", "be", "required", "allows", "a", "client", "to", "model", "data", "flow", "use", "either", "paradigm", "NUMBER", "If", "this", "meets", "the", "criteria", "leebyron", "was", "exploring", "in", "NUMBER", "we", "should", "reword", "the", "specification", "to", "be", "generic", "enough", "to", "accommodate", "both", "the", "type", "of", "API", "stubailo", "describes", "above", "as", "well", "as", "a", "generic", "push", "model", "like", "SSE", "asynchronous", "iteration", "etc", "NUMBER", "NUMBER", "The", "RFC", "text", "has", "be", "update", "to", "describe", "a", "generic", "event", "stream", "as", "oppose", "to", "specific", "events", "LINK", "So", "here", "be", "some", "options", "NUMBER", "As", "parent", "root", "object", "NUMBER", "As", "an", "extra", "fake", "argument", "in", "the", "same", "place", "as", "query", "args", "NUMBER", "Attached", "to", "context", "NUMBER", "As", "a", "new", "argument", "to", "the", "resolver", "signature", "I", "think", "NUMBER", "wouldn", "t", "be", "great", "because", "I", "don", "t", "think", "non", "root", "resolvers", "should", "have", "access", "to", "the", "payload", "NUMBER", "NUMBER", "also", "seems", "weird", "although", "it", "s", "the", "least", "breaking", "of", "these", "options", "NUMBER", "That", "seems", "to", "leave", "us", "with", "NUMBER", "Pass", "the", "payload", "as", "the", "root", "object", "which", "might", "conflict", "with", "some", "other", "ways", "people", "be", "use", "this", "object", "today", "and", "NUMBER", "Introduce", "a", "new", "argument", "to", "the", "resolver", "signature", "and", "make", "it", "resolve", "parent", "args", "context", "payload", "info", "which", "be", "a", "big", "change", "For", "passing", "as", "the", "root", "object", "the", "extra", "information", "we", "want", "to", "gather", "be", "how", "people", "be", "use", "this", "parameter", "today", "NUMBER", "For", "myself", "personally", "I", "put", "everything", "on", "the", "context", "but", "I", "ve", "heard", "some", "people", "have", "opinions", "about", "how", "some", "common", "data", "should", "go", "on", "rootValue", "instead", "NUMBER", "So", "in", "my", "world", "passing", "as", "rootValue", "be", "just", "fine", "but", "if", "people", "be", "already", "use", "that", "for", "something", "important", "then", "it", "might", "not", "be", "great", "NUMBER", "Passing", "as", "an", "extra", "parameter", "also", "comes", "with", "some", "question", "NUMBER", "Does", "every", "resolver", "get", "this", "extra", "argument", "or", "do", "subscription", "resolvers", "get", "a", "different", "number", "of", "argument", "than", "others", "Also", "this", "could", "end", "up", "be", "a", "pretty", "big", "breaking", "change", "for", "the", "GraphQL", "execution", "libraries", "since", "the", "argument", "will", "end", "up", "moving", "around", "NUMBER", "I", "suppose", "there", "be", "another", "option", "the", "spec", "says", "it", "s", "an", "extra", "parameter", "but", "the", "actual", "implementations", "put", "it", "somewhere", "implementation", "specific", "for", "example", "as", "a", "property", "on", "info", "in", "graphql", "NUMBER", "js", "NUMBER", "Then", "we", "could", "avoid", "the", "breaking", "aspects", "of", "change", "rootValue", "but", "at", "the", "expense", "of", "make", "the", "spec", "a", "little", "less", "descriptive", "and", "open", "up", "to", "differences", "in", "language", "implementations", "NUMBER", "I", "d", "prefer", "rootValue", "because", "I", "think", "for", "modern", "GraphQL", "NUMBER", "js", "use", "rootValue", "instead", "of", "context", "for", "context", "seems", "like", "an", "anti", "pattern", "NUMBER", "But", "I", "think", "this", "be", "entirely", "an", "implementation", "level", "question", "NUMBER", "The", "GraphQL", "spec", "doesn", "t", "talk", "about", "things", "like", "context", "for", "example", "NUMBER", "I", "see", "the", "tradeoff", "similar", "to", "how", "taion", "describes", "it", "NUMBER", "While", "NUMBER", "LINK", "issuecomment", "NUMBER", "appropriately", "calls", "out", "that", "this", "can", "be", "confusing", "if", "resolvers", "be", "relying", "on", "rootValue", "to", "be", "consistent", "in", "my", "experience", "so", "far", "work", "with", "subscriptions", "this", "isn", "t", "an", "issue", "that", "you", "make", "once", "or", "more", "than", "once", "NUMBER", "Let", "s", "ensure", "the", "RFC", "doesn", "t", "conflict", "with", "implementations", "which", "chose", "to", "do", "this", "NUMBER", "I", "don", "t", "think", "this", "matters", "for", "the", "spec", "NUMBER", "Implementation", "wise", "I", "think", "it", "d", "be", "neater", "to", "have", "the", "state", "live", "outside", "GraphQL", "NUMBER", "js", "though", "NUMBER", "NUMBER", "Agreed", "that", "it", "should", "be", "basically", "excluded", "from", "the", "spec", "NUMBER", "In", "the", "same", "way", "that", "storage", "and", "transport", "be", "application", "specific", "subscription", "management", "should", "also", "be", "application", "specific", "NUMBER", "For", "example", "one", "application", "may", "push", "update", "over", "a", "websocket", "connection", "and", "consider", "a", "client", "unsubscribed", "when", "the", "connection", "be", "close", "while", "another", "application", "may", "respond", "to", "subscriptions", "by", "creating", "webhooks", "and", "push", "update", "by", "hitting", "a", "client", "supplied", "URL", "NUMBER", "Ideally", "the", "spec", "would", "be", "flexible", "enough", "to", "accommodate", "either", "case", "without", "prescribing", "one", "or", "the", "other", "NUMBER", "Personally", "if", "I", "set", "up", "GraphQL", "subscriptions", "it", "would", "probably", "be", "based", "on", "Pusher", "which", "be", "neither", "here", "nor", "there", "Copying", "over", "my", "response", "from", "NUMBER", "The", "use", "of", "SSE", "v", "WS", "be", "an", "application", "level", "implementation", "detail", "NUMBER", "All", "that", "s", "needed", "be", "the", "server", "be", "able", "to", "push", "message", "to", "the", "client", "somehow", "which", "distinguishes", "this", "from", "request", "response", "NUMBER", "The", "communication", "isn", "t", "really", "bi", "di", "anyway", "it", "s", "a", "request", "to", "make", "a", "subscription", "then", "a", "stream", "from", "the", "server", "for", "subscription", "update", "NUMBER", "SSE", "be", "perfectly", "fine", "for", "this", "assuming", "other", "technical", "concerns", "permit", "its", "use", "NUMBER", "You", "could", "picture", "an", "SSE", "only", "approach", "where", "each", "new", "subscription", "be", "a", "request", "to", "an", "HTTP", "endpoint", "with", "SSE", "NUMBER", "This", "wouldn", "t", "necessarily", "be", "a", "great", "way", "to", "implement", "things", "but", "there", "s", "nothing", "that", "would", "prevent", "it", "from", "work", "NUMBER", "The", "question", "here", "be", "do", "subscriptions", "require", "a", "concept", "of", "unsubscribing", "If", "so", "then", "that", "implies", "that", "there", "be", "some", "state", "that", "tells", "the", "server", "whether", "or", "not", "there", "be", "a", "client", "to", "send", "events", "to", "NUMBER", "That", "s", "my", "mental", "model", "of", "what", "bidirectional", "communication", "means", "the", "server", "be", "aware", "of", "whether", "someone", "be", "listening", "NUMBER", "We", "re", "probably", "get", "into", "hermeneutics", "a", "bit", "then", "NUMBER", "From", "OlegIlyenko", "s", "initial", "post", "there", "s", "no", "reason", "GraphQL", "subscriptions", "can", "t", "work", "over", "SSE", "instead", "of", "over", "WebSockets", "NUMBER", "If", "that", "s", "the", "only", "question", "then", "I", "think", "we", "re", "on", "the", "same", "page", "here", "NUMBER", "I", "think", "bi", "directional", "be", "a", "quite", "broad", "term", "NUMBER", "For", "instance", "I", "consider", "UDP", "to", "be", "uni", "directional", "NUMBER", "My", "server", "can", "make", "a", "broadcast", "of", "data", "based", "on", "a", "subscription", "query", "NUMBER", "But", "as", "soon", "as", "client", "somehow", "tells", "a", "server", "the", "subscription", "query", "which", "may", "also", "be", "a", "human", "communication", "the", "overall", "communication", "flow", "can", "be", "considered", "bi", "directional", "IMO", "NUMBER", "In", "my", "opinion", "this", "be", "a", "transport", "concern", "so", "it", "would", "not", "be", "right", "to", "overspecify", "it", "in", "GraphQL", "spec", "NUMBER", "I", "would", "suggest", "to", "introduce", "an", "abstract", "notion", "of", "infinite", "result", "stream", "or", "result", "observable", "with", "following", "properties", "This", "result", "observable", "be", "the", "result", "of", "execution", "of", "subscription", "query", "in", "contrast", "to", "a", "single", "result", "of", "normal", "and", "mutation", "queries", "Observable", "results", "be", "non", "deterministically", "distributed", "in", "time", "NUMBER", "This", "means", "that", "they", "may", "not", "necessarily", "be", "emitted", "at", "the", "same", "time", "NUMBER", "Result", "stream", "be", "infinite", "so", "it", "may", "never", "naturally", "complete", "NUMBER", "Stream", "may", "become", "exhausted", "NUMBER", "In", "this", "case", "it", "be", "considered", "completed", "and", "it", "will", "not", "emit", "further", "results", "GraphQL", "execution", "engine", "may", "experience", "an", "unrecoverable", "error", "NUMBER", "This", "will", "complete", "stream", "as", "well", "NUMBER", "Consumer", "of", "the", "stream", "must", "be", "able", "to", "perform", "NUMBER", "operations", "on", "it", "subscribe", "to", "results", "emitted", "by", "the", "stream", "NUMBER", "Results", "will", "come", "one", "at", "a", "time", "NUMBER", "Prematurely", "complete", "the", "stream", "It", "s", "just", "some", "basic", "properties", "of", "observables", "as", "seen", "in", "ReactiveX", "reactive", "streams", "etc", "NUMBER", "I", "think", "this", "can", "be", "the", "right", "abstraction", "level", "that", "describes", "a", "semantics", "of", "interaction", "with", "GraphQL", "execution", "engine", "but", "do", "not", "imply", "any", "particular", "transport", "or", "client", "server", "interaction", "mechanism", "NUMBER", "If", "we", "would", "like", "to", "capture", "the", "semantics", "and", "protocol", "of", "subscriptions", "transport", "ws", "or", "similar", "implementations", "I", "feel", "it", "would", "be", "better", "to", "tackle", "it", "as", "a", "separate", "specification", "just", "like", "relay", "LINK", "relay", "specification", "NUMBER", "html", "content", "NUMBER", "I", "think", "it", "s", "a", "higher", "level", "abstraction", "and", "it", "should", "be", "possible", "to", "express", "it", "on", "top", "of", "the", "primitives", "I", "describe", "above", "NUMBER", "What", "do", "you", "think", "about", "it", "None", "from", "me", "I", "think", "the", "point", "be", "that", "the", "communication", "system", "should", "in", "some", "manner", "enable", "the", "server", "to", "push", "message", "to", "the", "clients", "NUMBER", "Whether", "we", "call", "that", "bidirectional", "be", "unimportant", "NUMBER", "I", "like", "OlegIlyenko", "s", "break", "down", "though", "I", "think", "Result", "stream", "be", "infinite", "so", "it", "may", "never", "naturally", "complete", "NUMBER", "Stream", "may", "become", "exhausted", "NUMBER", "In", "this", "case", "it", "be", "considered", "completed", "and", "it", "will", "not", "emit", "further", "results", "GraphQL", "execution", "engine", "may", "experience", "an", "unrecoverable", "error", "NUMBER", "This", "will", "complete", "stream", "as", "well", "NUMBER", "be", "a", "little", "unclear", "NUMBER", "My", "preference", "would", "be", "for", "upstream", "to", "be", "able", "signal", "no", "more", "data", "so", "we", "can", "close", "redundant", "connections", "if", "possible", "and", "for", "downstream", "to", "do", "the", "same", "NUMBER", "It", "seems", "like", "that", "this", "the", "intent", "here", "so", "maybe", "just", "a", "language", "use", "issue", "NUMBER", "Cognate", "events", "from", "Rx", "be", "complete", "error", "and", "unsubscribe", "which", "be", "a", "nice", "symmetry", "NUMBER", "jamesgorman", "NUMBER", "yes", "I", "generally", "mean", "the", "same", "thing", "NUMBER", "The", "completion", "of", "a", "stream", "be", "propagated", "to", "both", "the", "producer", "and", "consumer", "depending", "on", "who", "initiated", "it", "NUMBER", "So", "that", "they", "can", "do", "proper", "cleanup", "if", "necessary", "Hello", "In", "section", "All", "Variables", "Used", "LINK", "sec", "All", "Variables", "Used", "NUMBER", "Current", "example", "graphql", "query", "variableNotUsedWithinFragment", "atOtherHomes", "Boolean", "NUMBER", "isHousetrainedWithoutVariableFragment", "fragment", "isHousetrainedWithoutVariableFragment", "on", "Dog", "isHousetrained", "I", "believe", "it", "should", "query", "on", "Dog", "first", "NUMBER", "so", "it", "should", "be", "update", "to", "graphql", "query", "variableNotUsedWithinFragment", "atOtherHomes", "Boolean", "dog", "NUMBER", "isHousetrainedWithoutVariableFragment", "fragment", "isHousetrainedWithoutVariableFragment", "on", "Dog", "isHousetrained", "Thank", "you", "for", "all", "the", "test", "examples", "in", "the", "document", "It", "makes", "my", "life", "much", "easier", "Barret", "Let", "s", "add", "GraphQL", "Subscriptions", "to", "the", "Spec", "This", "be", "really", "great", "It", "was", "awesome", "that", "this", "took", "into", "account", "feedback", "from", "a", "variety", "of", "sources", "NUMBER", "I", "think", "this", "sketch", "of", "the", "subscriptions", "lifecycle", "be", "compatible", "with", "the", "one", "currently", "implement", "in", "our", "graphql", "subscriptions", "package", "here", "which", "can", "be", "a", "nice", "way", "to", "test", "drive", "some", "of", "the", "concepts", "LINK", "subscriptions", "We", "ve", "designed", "it", "in", "such", "a", "way", "that", "anyone", "currently", "use", "GraphQL", "NUMBER", "js", "can", "just", "drop", "it", "in", "and", "start", "use", "subscriptions", "right", "away", "and", "we", "have", "some", "adapters", "for", "Redis", "MQTT", "etc", "NUMBER", "We", "ll", "make", "sure", "that", "implementation", "be", "always", "up", "to", "date", "as", "new", "conclusions", "be", "reached", "in", "the", "discussion", "NUMBER", "After", "all", "this", "RFC", "be", "just", "the", "beginning", "not", "something", "set", "in", "stone", "NUMBER", "There", "s", "also", "a", "transport", "protocol", "over", "websockets", "something", "that", "shouldn", "t", "be", "covered", "in", "a", "spec", "but", "you", "need", "a", "transport", "to", "use", "it", "which", "we", "be", "currently", "use", "in", "production", "NUMBER", "It", "isn", "t", "coupled", "to", "any", "particular", "client", "or", "web", "server", "package", "and", "implement", "all", "of", "the", "important", "lifecycle", "events", "necessary", "LINK", "transport", "ws", "I", "encourage", "people", "interested", "in", "this", "proposal", "to", "try", "out", "those", "package", "with", "their", "exist", "server", "and", "experiment", "with", "GraphQL", "subscriptions", "today", "I", "think", "that", "s", "going", "to", "be", "a", "great", "way", "to", "collect", "more", "feedback", "about", "this", "design", "NUMBER", "Awesome", "Here", "s", "a", "rough", "schedule", "of", "what", "happens", "next", "This", "be", "a", "really", "well", "write", "RFC", "but", "this", "should", "not", "deter", "anyone", "from", "ask", "question", "both", "get", "into", "the", "weeds", "and", "challenging", "core", "assumptions", "and", "aspects", "of", "the", "proposal", "NUMBER", "An", "RFC", "be", "the", "beginning", "of", "a", "discussion", "NUMBER", "Let", "s", "leave", "this", "PR", "open", "as", "a", "place", "for", "discussion", "for", "the", "time", "be", "NUMBER", "Really", "happy", "to", "see", "progress", "on", "subscriptions", "Good", "job", "it", "looks", "great", "so", "far", "the", "input", "query", "and", "variables", "be", "mapped", "to", "a", "set", "of", "events", "It", "would", "be", "interesting", "to", "see", "the", "semantics", "of", "this", "mapping", "NUMBER", "In", "particular", "do", "the", "root", "subscription", "field", "have", "any", "special", "semantics", "or", "the", "interpretation", "of", "the", "root", "field", "semantics", "can", "be", "defined", "by", "a", "GraphQL", "server", "for", "example", "do", "every", "root", "field", "represents", "specific", "type", "of", "event", "like", "commentCreated", "or", "topic", "comments", "or", "something", "else", "Also", "another", "remark", "NUMBER", "The", "RFC", "assumes", "and", "emphasizes", "that", "subscription", "communication", "be", "bi", "directional", "NUMBER", "I", "wonder", "whether", "this", "restriction", "be", "necessary", "or", "required", "NUMBER", "I", "definitely", "see", "appeal", "of", "having", "bi", "directional", "communication", "NUMBER", "For", "instance", "it", "can", "multiplex", "several", "subscriptions", "in", "a", "single", "WebSocket", "connection", "and", "provide", "extend", "life", "cycle", "phases", "for", "further", "optimizations", "NUMBER", "But", "in", "the", "most", "basic", "form", "uni", "directional", "communication", "server", "client", "can", "be", "sufficient", "to", "implement", "semantics", "describe", "in", "the", "RFC", "NUMBER", "A", "while", "back", "I", "implement", "an", "example", "GraphQL", "subscription", "service", "that", "be", "based", "on", "SSE", "which", "be", "uni", "directional", "LINK", "graphql", "sangria", "subscriptions", "example", "NUMBER", "As", "far", "as", "I", "can", "tell", "it", "satisfies", "the", "semantics", "describe", "in", "this", "RFC", "but", "simplifies", "life", "cycle", "a", "bit", "Subscribe", "client", "server", "represented", "by", "server", "receiving", "a", "client", "request", "with", "subscription", "query", "Subscription", "active", "server", "client", "absent", "implicit", "Unsubscribe", "client", "server", "client", "just", "close", "the", "connection", "Would", "love", "to", "hear", "your", "thoughts", "on", "this", "aspect", "of", "the", "RFC", "Also", "regard", "bi", "directional", "communication", "NUMBER", "As", "far", "as", "I", "can", "tell", "it", "defines", "a", "small", "protocol", "something", "similar", "to", "apollo", "WS", "transport", "protocol", "LINK", "transport", "ws", "client", "server", "communication", "NUMBER", "Does", "this", "mean", "that", "in", "future", "we", "will", "have", "additional", "specification", "alongside", "of", "GraphQL", "that", "will", "define", "and", "standardize", "this", "bi", "directional", "communication", "protocol", "life", "cycle", "phases", "data", "format", "command", "types", "like", "SUBSCRIPTION_START", "SUBSCRIPTION_FAIL", "UNSUBSCRIBE", "etc", "NUMBER", "OlegIlyenko", "my", "interpretation", "be", "that", "bidirectional", "means", "that", "in", "your", "description", "there", "be", "arrows", "that", "go", "from", "client", "server", "and", "also", "server", "client", "NUMBER", "Aren", "t", "any", "client", "server", "legs", "just", "mutations", "This", "looks", "consistent", "with", "what", "s", "implement", "between", "relay", "subscriptions", "LINK", "subscriptions", "and", "graphql", "relay", "subscription", "LINK", "relay", "subscription", "as", "well", "NUMBER", "A", "few", "comments", "An", "explicit", "subscription", "active", "message", "may", "not", "be", "necessary", "NUMBER", "I", "don", "t", "use", "one", "anyway", "NUMBER", "LINK", "_", "NUMBER", "png", "might", "be", "clearer", "if", "there", "were", "a", "box", "for", "other", "backend", "components", "that", "domain", "layer", "and", "event", "B", "connect", "to", "We", "start", "our", "implementation", "without", "a", "subscription", "active", "notification", "but", "later", "had", "to", "add", "it", "NUMBER", "Because", "the", "first", "result", "from", "your", "subscription", "could", "arrive", "a", "long", "time", "after", "the", "initial", "request", "you", "don", "t", "know", "if", "you", "re", "actually", "receiving", "those", "update", "NUMBER", "In", "some", "cases", "you", "want", "to", "be", "able", "to", "look", "at", "the", "state", "of", "the", "subscription", "to", "decide", "if", "you", "should", "be", "polling", "for", "data", "or", "simply", "waiting", "for", "events", "to", "arrive", "especially", "if", "you", "don", "t", "want", "to", "miss", "some", "crucial", "update", "to", "the", "information", "you", "re", "looking", "for", "NUMBER", "Essentially", "it", "can", "be", "very", "hard", "to", "know", "what", "happened", "if", "you", "subscribe", "and", "get", "back", "total", "silence", "did", "the", "subscription", "somehow", "fail", "or", "stall", "or", "did", "it", "successfully", "start", "and", "you", "should", "expect", "to", "get", "results", "in", "the", "future", "taion", "I", "think", "you", "re", "use", "socket", "NUMBER", "io", "right", "Maybe", "they", "have", "a", "system", "that", "checks", "if", "the", "subscription", "be", "successful", "under", "the", "hood", "stubailo", "To", "clarify", "I", "m", "saying", "that", "subscription", "active", "notifications", "aren", "t", "required", "in", "all", "cases", "NUMBER", "It", "really", "depends", "on", "the", "app", "NUMBER", "If", "it", "s", "something", "like", "chat", "then", "subscriptions", "be", "down", "be", "a", "big", "deal", "and", "you", "want", "to", "show", "some", "user", "feedback", "NUMBER", "For", "something", "like", "say", "showing", "new", "comment", "prompts", "on", "a", "GitHub", "issue", "page", "you", "don", "t", "really", "care", "NUMBER", "A", "general", "purpose", "subscription", "layer", "probably", "wants", "to", "expose", "something", "like", "those", "subscription", "active", "notifications", "to", "handle", "all", "uses", "cases", "but", "they", "re", "not", "always", "necessary", "in", "more", "specialized", "cases", "NUMBER", "Good", "call", "I", "agree", "that", "it", "be", "not", "necessary", "in", "cases", "where", "the", "subscription", "be", "not", "provide", "critical", "functionality", "NUMBER", "I", "think", "one", "other", "factor", "to", "consider", "be", "that", "returning", "an", "error", "about", "the", "initial", "subscription", "definitely", "be", "necessary", "for", "example", "if", "the", "query", "be", "not", "valid", "at", "all", "you", "want", "to", "receive", "some", "validation", "error", "in", "response", "to", "your", "initial", "subscription", "NUMBER", "Without", "a", "message", "that", "there", "was", "a", "successful", "subscription", "essentially", "it", "just", "tells", "you", "the", "query", "validated", "etc", "there", "s", "this", "time", "when", "you", "re", "not", "sure", "if", "there", "will", "be", "an", "initial", "error", "or", "not", "NUMBER", "Yup", "error", "handle", "be", "necessary", "in", "general", "NUMBER", "I", "guess", "it", "depends", "how", "in", "detail", "this", "spec", "wants", "to", "go", "on", "what", "the", "network", "layer", "should", "do", "NUMBER", "Questions", "like", "whether", "a", "subscription", "can", "do", "events", "singly", "or", "must", "be", "multiple", "as", "asked", "in", "the", "blog", "post", "point", "to", "the", "possbible", "usefulness", "of", "an", "abstraction", "like", "Observable", "which", "be", "not", "inherently", "tied", "to", "multiplicity", "of", "responses", "NUMBER", "Also", "that", "it", "be", "moving", "through", "standardization", "in", "the", "language", "would", "be", "helpful", "too", "NUMBER", "I", "m", "also", "a", "fan", "of", "the", "DDP", "ready", "event", "that", "announces", "the", "change", "from", "serving", "up", "exist", "old", "data", "to", "serving", "up", "new", "responses", "NUMBER", "While", "not", "strictly", "necessary", "it", "lets", "you", "do", "things", "like", "remove", "loading", "graphics", "as", "you", "already", "know", "quite", "well", "stubailo", "My", "NUMBER", "c", "on", "unsubscribe", "be", "it", "should", "be", "a", "message", "as", "well", "as", "in", "DDP", "but", "obviously", "the", "server", "should", "do", "the", "right", "thing", "if", "a", "connection", "goes", "stale", "and", "no", "unsubscribe", "was", "received", "NUMBER", "PS", "I", "m", "in", "the", "category", "of", "someone", "whose", "org", "may", "adopt", "GraphQL", "if", "it", "had", "subscriptions", "NUMBER", "Right", "now", "we", "re", "rolling", "something", "on", "Meteor", "DDP", "until", "we", "see", "if", "Apollo", "could", "give", "us", "a", "compatible", "enough", "experience", "NUMBER", "Observable", "be", "really", "a", "JS", "level", "implementation", "detail", "no", "I", "don", "t", "think", "it", "s", "pertinent", "at", "the", "level", "of", "this", "spec", "NUMBER", "Thanks", "for", "write", "this", "up", "I", "m", "looking", "forward", "to", "seeing", "how", "it", "evolves", "I", "had", "a", "couple", "question", "Somehow", "I", "was", "previously", "under", "the", "impression", "that", "subscription", "request", "_also_", "returned", "an", "immediate", "result", "as", "if", "they", "were", "queries", "NUMBER", "That", "s", "not", "mention", "here", "right", "So", "I", "was", "mistaken", "about", "that", "Would", "it", "make", "sense", "to", "add", "one", "more", "arrow", "to", "this", "diagram", "I", "thought", "there", "might", "be", "one", "like", "this", "image", "LINK", "f", "NUMBER", "NUMBER", "e", "NUMBER", "NUMBER", "eaf", "d", "NUMBER", "f", "NUMBER", "c", "NUMBER", "f", "NUMBER", "png", "After", "the", "subscription", "system", "be", "notified", "of", "an", "event", "it", "tells", "the", "GraphQL", "server", "to", "re", "evaluate", "the", "query", "and", "the", "GraphQL", "server", "gives", "a", "new", "response", "in", "magenta", "to", "the", "subscription", "system", "NUMBER", "Then", "the", "subscription", "system", "sends", "it", "to", "the", "client", "over", "the", "particular", "transport", "layer", "NUMBER", "Did", "I", "understand", "correctly", "That", "s", "how", "I", "made", "sense", "of", "this", "arrow", "in", "the", "later", "diagram", "image", "LINK", "f", "NUMBER", "a", "NUMBER", "e", "NUMBER", "NUMBER", "b", "NUMBER", "NUMBER", "f", "NUMBER", "c", "NUMBER", "f", "NUMBER", "df", "NUMBER", "png", "I", "don", "t", "think", "in", "general", "subscription", "queries", "should", "return", "an", "immediate", "result", "NUMBER", "If", "I", "have", "a", "subscription", "on", "e", "NUMBER", "g", "NUMBER", "items", "be", "add", "what", "would", "that", "result", "be", "taion", "The", "point", "of", "it", "wasn", "t", "to", "prescribe", "an", "implementation", "but", "to", "convey", "semantics", "by", "referring", "to", "an", "exist", "spec", "to", "broaden", "the", "discussion", "NUMBER", "The", "contract", "covers", "issue", "like", "you", "mention", "above", "such", "as", "whether", "you", "get", "a", "result", "upon", "subscribe", "NUMBER", "LINK", "Whatever", "the", "solution", "may", "be", "NUMBER", "I", "the", "addition", "to", "the", "spec", "because", "without", "a", "subscription", "system", "GraphQL", "can", "hardly", "be", "considered", "as", "state", "of", "the", "art", "when", "if", "fact", "it", "really", "should", "be", "NUMBER", "Edit", "Had", "to", "also", "link", "to", "Sashko", "s", "great", "blog", "post", "NUMBER", "LINK", "blog", "NUMBER", "apollodata", "NUMBER", "com", "the", "next", "step", "for", "realtime", "data", "in", "graphql", "b", "NUMBER", "b", "NUMBER", "eb", "NUMBER", "b", "NUMBER", "yrfdrlel", "Scott", "One", "thing", "that", "s", "not", "necessarily", "clear", "to", "me", "and", "to", "be", "honest", "I", "haven", "t", "be", "down", "in", "the", "trenches", "with", "subscriptions", "unlike", "others", "commenting", "here", "be", "this", "When", "the", "client", "wants", "to", "create", "a", "subscription", "be", "it", "just", "executing", "a", "GraphQL", "query", "with", "a", "special", "operation", "Or", "be", "it", "sending", "a", "package", "of", "something", "_including_", "a", "GraphQL", "query", "variables", "etc", "to", "something", "else", "and", "then", "that", "something", "else", "be", "interacting", "with", "GraphQL", "I", "was", "previously", "under", "the", "impression", "that", "if", "I", "sent", "this", "query", "to", "my", "GraphQL", "server", "use", "the", "exact", "same", "transport", "etc", "mechanics", "as", "any", "other", "query", "that", "it", "was", "creating", "a", "subscription", "graphql", "subscription", "someField", "sub", "selections", "In", "this", "scenario", "the", "GraphQL", "library", "graphql", "ruby", "github", "NUMBER", "com", "rmosolgo", "graphql", "ruby", "in", "my", "case", "be", "handle", "the", "book", "keep", "of", "the", "subscription", "and", "somehow", "I", "m", "plugging", "in", "Events", "A", "special", "network", "layer", "But", "after", "reading", "this", "spec", "it", "sounds", "like", "I", "m", "instead", "directing", "this", "to", "something", "_other_", "than", "my", "GraphQL", "library", "handle", "the", "book", "keep", "myself", "and", "periodically", "run", "a", "not", "so", "special", "query", "and", "sending", "the", "black", "box", "payload", "to", "the", "client", "NUMBER", "Essentially", "what", "I", "m", "get", "at", "be", "should", "we", "expect", "authors", "of", "GraphQL", "frameworks", "to", "be", "provide", "the", "book", "keep", "for", "subscriptions", "etc", "and", "then", "exposing", "some", "fancy", "integration", "points", "events", "and", "networking", "Or", "should", "we", "expect", "a", "new", "eco", "system", "of", "subscription", "frameworks", "to", "grow", "up", "alongside", "exist", "GraphQL", "frameworks", "I", "imagine", "implementation", "wise", "there", "s", "not", "much", "actual", "change", "right", "As", "set", "up", "right", "now", "GraphQL", "NUMBER", "js", "can", "execute", "a", "subscription", "query", "but", "the", "actual", "semantics", "of", "the", "full", "request", "live", "outside", "NUMBER", "It", "s", "like", "the", "split", "between", "graphql", "and", "express", "graphql", "for", "the", "standard", "query", "mutation", "side", "NUMBER", "Or", "be", "it", "sending", "a", "package", "of", "something", "including", "a", "GraphQL", "query", "variables", "etc", "to", "something", "else", "and", "then", "that", "something", "else", "be", "interacting", "with", "GraphQL", "Yes", "the", "idea", "be", "that", "you", "can", "add", "subscriptions", "on", "top", "of", "the", "exist", "GraphQL", "execution", "libraries", "by", "add", "a", "subscription", "manager", "or", "subscription", "gateway", "NUMBER", "And", "that", "thing", "s", "job", "be", "to", "re", "execute", "the", "subscription", "query", "against", "the", "GraphQL", "server", "in", "response", "to", "the", "event", "NUMBER", "I", "imagine", "implementation", "wise", "there", "s", "not", "much", "actual", "change", "right", "As", "set", "up", "right", "now", "GraphQL", "NUMBER", "js", "can", "execute", "a", "subscription", "query", "but", "the", "actual", "semantics", "of", "the", "full", "request", "live", "outside", "NUMBER", "I", "think", "that", "s", "about", "right", "in", "terms", "of", "a", "library", "like", "GraphQL", "NUMBER", "js", "I", "think", "the", "one", "thing", "that", "could", "be", "add", "be", "a", "way", "to", "map", "the", "subscriptions", "field", "to", "events", "NUMBER", "I", "think", "there", "would", "be", "a", "lot", "of", "value", "in", "putting", "that", "right", "next", "to", "the", "resolver", "code", "NUMBER", "Oh", "and", "one", "more", "thing", "the", "resolver", "for", "a", "subscription", "field", "has", "one", "more", "parameter", "now", "which", "be", "the", "payload", "so", "now", "that", "resolver", "takes", "in", "rootValue", "args", "context", "and", "payload", "NUMBER", "That", "could", "come", "in", "three", "different", "places", "NUMBER", "The", "payload", "could", "be", "pass", "as", "the", "root", "value", "that", "would", "be", "consistent", "with", "looking", "at", "the", "subscription", "as", "a", "continuation", "of", "the", "mutation", "so", "the", "mutation", "can", "push", "its", "result", "over", "the", "message", "system", "and", "the", "subscription", "field", "pick", "up", "where", "it", "left", "off", "NUMBER", "But", "that", "could", "be", "confusing", "given", "that", "root", "values", "be", "use", "for", "other", "stuff", "as", "well", "NUMBER", "NUMBER", "The", "payload", "be", "attached", "to", "context", "but", "that", "feels", "like", "a", "bit", "of", "a", "hack", "to", "me", "especially", "since", "it", "means", "_all_", "field", "will", "be", "able", "to", "access", "it", "NUMBER", "NUMBER", "There", "s", "a", "new", "parameter", "that", "only", "subscriptions", "field", "resolvers", "get", "access", "to", "NUMBER", "I", "think", "I", "m", "in", "favor", "of", "NUMBER", "which", "requires", "a", "change", "to", "GraphQL", "NUMBER", "js", "to", "have", "the", "execution", "function", "take", "an", "extra", "subscriptionPayload", "parameter", "or", "similar", "NUMBER", "It", "d", "be", "great", "if", "run", "a", "subscription", "could", "return", "some", "description", "of", "the", "relevant", "event", "set", "as", "a", "first", "order", "concern", "though", "the", "current", "workarounds", "aren", "t", "too", "bad", "NUMBER", "I", "d", "prefer", "subscription", "payload", "come", "through", "as", "rootValue", "for", "consistency", "NUMBER", "I", "d", "prefer", "subscription", "payload", "come", "through", "as", "rootValue", "for", "consistency", "NUMBER", "That", "s", "what", "the", "graphql", "subscriptions", "npm", "package", "do", "right", "now", "and", "it", "s", "not", "too", "bad", "NUMBER", "But", "we", "don", "t", "really", "use", "rootValue", "for", "anything", "else", "since", "we", "basically", "put", "everything", "on", "context", "NUMBER", "Yeah", "I", "think", "that", "s", "the", "right", "thing", "no", "Now", "that", "context", "exists", "rootValue", "be", "exactly", "just", "for", "injecting", "payload", "in", "that", "manner", "I", "think", "NUMBER", "I", "ve", "read", "through", "everything", "once", "more", "and", "I", "think", "I", "might", "be", "miss", "something", "probably", "general", "understanding", "NUMBER", "But", "how", "do", "or", "should", "the", "subscription", "system", "fit", "in", "with", "Introspection", "Could", "someone", "also", "run", "through", "the", "subscription", "lifecycle", "with", "a", "use", "case", "I", "be", "understanding", "two", "things", "here", "and", "I", "be", "not", "sure", "which", "one", "be", "right", "NUMBER", "Either", "the", "the", "event", "on", "the", "server", "triggers", "a", "requerying", "of", "a", "specific", "GraphQL", "query", "from", "the", "client", "or", "the", "event", "on", "the", "server", "pushes", "the", "new", "results", "of", "a", "specific", "query", "automatically", "to", "the", "client", "NUMBER", "I", "d", "like", "to", "understand", "which", "one", "it", "be", "through", "a", "use", "case", "NUMBER", "Or", "can", "both", "happen", "And", "a", "general", "comment", "NUMBER", "To", "me", "the", "argumentation", "against", "a", "live", "query", "system", "referenced", "in", "the", "RFC", "be", "assuming", "that", "any", "standard", "GraphQL", "query", "should", "be", "subscribable", "as", "a", "live", "query", "NUMBER", "I", "d", "suggest", "this", "be", "an", "incorrect", "assumption", "NUMBER", "Instead", "of", "any", "query", "be", "subscribable", "there", "should", "only", "be", "specific", "extra", "queries", "that", "be", "subscribable", "NUMBER", "This", "should", "allow", "for", "a", "much", "finer", "control", "over", "what", "needs", "to", "be", "update", "NUMBER", "It", "also", "simplifies", "the", "GraphQL", "subscription", "system", "enormously", "NUMBER", "You", "must", "admit", "the", "event", "based", "system", "in", "this", "proposal", "be", "quite", "complex", "NUMBER", "The", "RFC", "even", "says", "it", "be", "the", "most", "complex", "way", "to", "go", "NUMBER", "To", "me", "live", "queries", "be", "all", "GraphQL", "should", "be", "worried", "about", "NUMBER", "An", "events", "system", "or", "a", "database", "that", "allows", "for", "live", "queries", "itself", "or", "whatever", "else", "userland", "can", "come", "up", "with", "to", "feed", "the", "live", "queries", "should", "be", "business", "domain", "specifics", "IMHO", "NUMBER", "Scott", "Great", "to", "see", "this", "add", "to", "the", "spec", "We", "have", "be", "use", "relay", "subscriptions", "for", "the", "last", "few", "months", "at", "Mainframe", "and", "I", "wonder", "how", "much", "of", "this", "spec", "differs", "from", "relay", "subscriptions", "implementation", "In", "our", "case", "with", "the", "only", "exception", "of", "handle", "notifications", "all", "our", "subscriptions", "be", "linked", "to", "queries", "so", "they", "notably", "use", "the", "same", "fragment", "as", "in", "relay", "subscriptions", "example", "LINK", "subscriptions", "blob", "b", "NUMBER", "edefeb", "NUMBER", "dff", "NUMBER", "ba", "NUMBER", "dea", "NUMBER", "fe", "NUMBER", "a", "NUMBER", "d", "NUMBER", "c", "NUMBER", "examples", "todo", "js", "subscriptions", "AddTodoSubscription", "NUMBER", "js", "L", "NUMBER", "NUMBER", "One", "issue", "we", "needed", "to", "address", "was", "the", "possibility", "to", "miss", "relevant", "events", "between", "the", "time", "a", "query", "be", "resolve", "and", "the", "subscription", "be", "created", "on", "the", "server", "as", "the", "current", "flow", "use", "relay", "subscriptions", "be", "client", "queries", "server", "responds", "client", "creates", "subscription", "use", "response", "payload", "server", "receives", "subscription", "request", "server", "publishes", "subscription", "events", "when", "receiving", "internal", "events", "NUMBER", "Our", "current", "workaround", "be", "to", "have", "the", "server", "provide", "a", "version", "opaque", "string", "for", "the", "client", "when", "responding", "to", "any", "query", "that", "the", "client", "sends", "along", "with", "the", "subscription", "request", "relate", "to", "the", "query", "allowing", "the", "server", "to", "look", "back", "at", "the", "events", "log", "and", "publish", "the", "needed", "subscription", "events", "to", "the", "client", "so", "it", "can", "catch", "up", "on", "any", "change", "NUMBER", "We", "implement", "this", "logic", "in", "our", "custom", "network", "layer", "but", "considering", "it", "be", "affected", "by", "the", "relations", "between", "queries", "and", "subscriptions", "I", "wonder", "if", "it", "be", "something", "that", "could", "be", "part", "of", "this", "spec", "Again", "I", "think", "that", "s", "the", "sort", "of", "thing", "that", "really", "depends", "NUMBER", "In", "many", "cases", "I", "think", "that", "s", "just", "not", "required", "and", "would", "instead", "just", "be", "extra", "overhead", "NUMBER", "That", "s", "interesting", "it", "s", "actually", "a", "case", "where", "my", "_misunderstanding_", "of", "subscriptions", "would", "come", "in", "handy", "NUMBER", "In", "that", "scenario", "a", "subscription", "request", "also", "returned", "an", "immediate", "response", "so", "you", "could", "get", "the", "current", "server", "state", "_and_", "make", "a", "subscription", "in", "a", "single", "operation", "NUMBER", "However", "I", "m", "not", "sure", "how", "you", "d", "sort", "it", "out", "in", "a", "case", "like", "this", "graphql", "subscription", "getNewComment", "postId", "ID", "commentAdded", "postId", "postId", "newComment", "author", "name", "message", "post", "title", "comments", "message", "In", "that", "case", "the", "first", "response", "comes", "with", "newComment", "null", "but", "post", "NUMBER", "be", "present", "so", "you", "can", "initialize", "the", "UI", "with", "that", "state", "NUMBER", "The", "problem", "be", "on", "later", "request", "you", "d", "_still_", "get", "post", "NUMBER", "which", "be", "overfetching", "NUMBER", "So", "I", "don", "t", "think", "it", "s", "much", "of", "an", "answer", "but", "I", "thought", "I", "d", "share", "anyways", "Presumably", "at", "the", "implementation", "level", "you", "can", "put", "something", "on", "context", "indicating", "whether", "this", "be", "the", "initial", "subscription", "request", "then", "do", "whatever", "be", "appropriate", "in", "the", "resolver", "NUMBER", "There", "s", "nothing", "that", "_prevents_", "an", "implementation", "from", "immediately", "firing", "an", "update", "corresponding", "to", "the", "current", "state", "I", "just", "don", "t", "think", "it", "s", "required", "in", "the", "general", "case", "NUMBER", "I", "m", "going", "to", "just", "drop", "a", "link", "to", "my", "Real", "Time", "GraphQL", "Project", "here", "LINK", "where", "I", "define", "a", "protocol", "and", "proof", "of", "concept", "implementation", "for", "two", "way", "communication", "between", "a", "GraphQL", "client", "and", "server", "including", "real", "time", "update", "to", "results", "and", "queries", "NUMBER", "Subscriptions", "seem", "like", "an", "inelegant", "solution", "to", "me", "NUMBER", "They", "be", "extremely", "limited", "one", "way", "one", "time", "subscribe", "unable", "to", "update", "query", "parameters", "after", "the", "subscription", "has", "start", "etc", "NUMBER", "As", "you", "re", "finding", "now", "in", "this", "thread", "these", "limitations", "make", "use", "and", "implement", "subscriptions", "a", "muddy", "deal", "NUMBER", "If", "something", "s", "not", "simple", "it", "s", "probably", "wrong", "NUMBER", "And", "subscriptions", "to", "me", "seem", "to", "have", "a", "lot", "of", "cludginess", "as", "a", "result", "of", "jerry", "rigging", "them", "in", "to", "an", "exist", "one", "way", "one", "off", "GraphQL", "spec", "NUMBER", "With", "the", "assumption", "that", "we", "have", "a", "two", "way", "communication", "path", "with", "the", "server", "a", "lot", "of", "optimizations", "and", "improvement", "can", "be", "made", "NUMBER", "I", "ve", "write", "a", "proof", "of", "concept", "of", "this", "at", "the", "rgraphql", "repo", "I", "linked", "above", "NUMBER", "A", "demo", "be", "also", "available", "here", "LINK", "Curious", "to", "hear", "your", "opinions", "on", "this", "NUMBER", "Liking", "the", "looks", "of", "the", "RFC", "so", "far", "One", "thing", "that", "s", "not", "in", "the", "RFC", "right", "now", "but", "that", "might", "be", "valuable", "do", "we", "want", "to", "require", "that", "the", "sequence", "of", "payloads", "sent", "to", "the", "subscriber", "be", "determined", "only", "by", "the", "root", "subscription", "field", "and", "its", "argument", "and", "that", "in", "particular", "the", "fieldset", "of", "that", "subscription", "field", "do", "not", "affect", "the", "sequence", "of", "payloads", "I", "think", "a", "concrete", "example", "probably", "demonstrates", "the", "value", "of", "this", "best", "I", "imagine", "a", "developer", "on", "the", "client", "write", "graphql", "subscription", "DeveloperSubscription", "commentCreate", "postId", "NUMBER", "comment", "text", "timeCreated", "author", "NUMBER", "CommentAuthorFragment", "This", "be", "a", "pretty", "basic", "subscription", "every", "time", "there", "s", "a", "new", "comment", "push", "a", "payload", "that", "include", "the", "text", "of", "the", "comment", "time", "created", "and", "the", "author", "information", "where", "that", "s", "delegated", "to", "another", "fragment", "one", "that", "presumably", "defined", "by", "CommentAuthorView", "or", "something", "NUMBER", "Now", "I", "imagine", "use", "a", "client", "side", "GraphQL", "framework", "to", "issue", "that", "subscription", "if", "that", "framework", "has", "a", "normalized", "cache", "it", "might", "want", "to", "augment", "the", "subscription", "to", "fetch", "IDs", "for", "some", "of", "the", "objects", "so", "that", "it", "can", "update", "the", "cache", "NUMBER", "So", "rather", "than", "issue", "DeveloperSubscription", "it", "would", "instead", "issue", "graphql", "subscription", "FrameworkAugmentedSubscription", "commentCreate", "postId", "NUMBER", "comment", "id", "Added", "by", "framework", "text", "timeCreated", "author", "id", "Added", "by", "framework", "NUMBER", "CommentAuthorFragment", "Meanwhile", "our", "developer", "wants", "to", "debug", "this", "and", "opens", "up", "Graphiql", "NUMBER", "The", "whole", "author", "fragment", "might", "be", "big", "and", "unwieldy", "and", "all", "the", "developer", "wants", "to", "do", "be", "verify", "that", "the", "subscription", "be", "work", "as", "expected", "so", "the", "developer", "might", "issue", "the", "following", "in", "Graphiql", "graphql", "subscription", "DebuggingSubscription", "commentCreate", "postId", "NUMBER", "comment", "text", "Of", "course", "the", "payloads", "received", "by", "these", "three", "subscriptions", "will", "be", "different", "between", "the", "three", "since", "the", "field", "sets", "be", "different", "NUMBER", "But", "because", "the", "root", "subscription", "field", "on", "all", "three", "was", "the", "same", "commentCreate", "postId", "NUMBER", "it", "feels", "like", "we", "should", "be", "able", "to", "guarantee", "the", "sequence", "be", "the", "same", "if", "one", "subscription", "receives", "a", "payload", "the", "other", "two", "should", "as", "well", "NUMBER", "It", "seems", "like", "without", "the", "guarantee", "we", "might", "have", "three", "potential", "issue", "NUMBER", "A", "client", "side", "framework", "can", "t", "safely", "modify", "the", "field", "set", "without", "risking", "change", "the", "functionality", "of", "the", "subscription", "NUMBER", "A", "debugging", "developer", "can", "t", "reduce", "the", "size", "of", "the", "field", "set", "in", "Graphiql", "while", "guaranteeing", "that", "they", "be", "still", "seeing", "the", "same", "sequence", "as", "the", "client", "they", "be", "debugging", "NUMBER", "We", "kinda", "break", "encapsulation", "in", "the", "DeveloperSubscription", "example", "the", "developer", "s", "intention", "be", "to", "subscribe", "to", "all", "comments", "created", "NUMBER", "but", "if", "the", "field", "set", "can", "alter", "the", "sequence", "then", "change", "to", "CommentAuthorFragment", "can", "alter", "the", "sequence", "NUMBER", "This", "feels", "kind", "of", "weird", "the", "developer", "only", "spread", "in", "CommentAuthorFragment", "to", "ensure", "it", "fetched", "the", "right", "field", "in", "the", "payload", "to", "render", "the", "comment", "author", "the", "idea", "that", "a", "change", "to", "CommentAuthorFragment", "could", "alter", "the", "functionality", "of", "DeveloperSubscription", "feels", "odd", "NUMBER", "Thoughts", "dschafer", "The", "spec", "contains", "special", "rules", "for", "root", "field", "on", "a", "Mutation", "type", "NUMBER", "It", "sounds", "like", "you", "re", "suggesting", "that", "the", "root", "field", "of", "Subscription", "type", "have", "a", "special", "property", "also", "_only_", "the", "root", "field", "determine", "how", "a", "client", "be", "subscribed", "so", "if", "two", "queries", "have", "the", "same", "root", "field", "they", "result", "in", "the", "same", "subscribed", "state", "regardless", "of", "any", "child", "selections", "NUMBER", "Is", "that", "correct", "If", "so", "big", "NUMBER", "from", "me", "NUMBER", "I", "somehow", "had", "that", "assumption", "but", "I", "didn", "t", "notice", "it", "was", "miss", "from", "this", "RFC", "I", "wonder", "if", "that", "might", "not", "be", "better", "as", "a", "best", "practice", "type", "thing", "for", "typical", "use", "cases", "rather", "than", "a", "part", "of", "the", "spec", "Imagine", "a", "subscription", "like", "graphql", "subscription", "commentUpdate", "commentId", "NUMBER", "author", "karma", "With", "my", "current", "implementation", "if", "I", "care", "about", "author", "karma", "change", "here", "I", "would", "just", "create", "a", "new", "subscription", "but", "it", "seems", "like", "it", "d", "be", "odd", "to", "prohibit", "this", "subscription", "from", "firing", "on", "e", "NUMBER", "g", "NUMBER", "author", "karma", "change", "or", "else", "force", "something", "like", "graphql", "subscription", "commentUpdate", "commentId", "NUMBER", "score", "to", "also", "fire", "when", "this", "sort", "of", "thing", "happens", "NUMBER", "And", "what", "about", "optimizations", "e", "NUMBER", "g", "NUMBER", "for", "a", "partial", "update", "if", "none", "of", "the", "field", "on", "a", "given", "subscription", "have", "change", "in", "that", "partial", "update", "dschafer", "This", "sounds", "great", "NUMBER", "This", "be", "precisely", "what", "I", "mean", "in", "my", "question", "It", "would", "be", "interesting", "to", "see", "the", "semantics", "of", "this", "mapping", "NUMBER", "In", "particular", "do", "the", "root", "subscription", "field", "have", "any", "special", "semantics", "or", "the", "interpretation", "of", "the", "root", "field", "semantics", "can", "be", "defined", "by", "a", "GraphQL", "server", "for", "example", "do", "every", "root", "field", "represents", "specific", "type", "of", "event", "like", "commentCreated", "or", "topic", "comments", "or", "something", "else", "This", "definitely", "helps", "to", "make", "the", "subscription", "semantics", "a", "bit", "more", "clear", "as", "you", "mention", "it", "has", "a", "big", "advantage", "for", "generic", "tool", "NUMBER", "In", "my", "experiments", "I", "also", "find", "that", "this", "semantics", "for", "root", "subscription", "field", "makes", "it", "quite", "easy", "to", "use", "Observable", "s", "instead", "of", "Promise", "s", "for", "root", "query", "field", "NUMBER", "dschafer", "The", "spec", "contains", "special", "rules", "for", "root", "field", "on", "a", "Mutation", "type", "NUMBER", "It", "sounds", "like", "you", "re", "suggesting", "that", "the", "root", "field", "of", "Subscription", "type", "have", "a", "special", "property", "also", "only", "the", "root", "field", "determine", "how", "a", "client", "be", "subscribed", "so", "if", "two", "queries", "have", "the", "same", "root", "field", "they", "result", "in", "the", "same", "subscribed", "state", "regardless", "of", "any", "child", "selections", "NUMBER", "So", "subscription", "root", "field", "will", "end", "up", "be", "special", "no", "matter", "what", "since", "they", "both", "end", "up", "resolving", "to", "a", "value", "and", "identifying", "a", "sequence", "of", "payload", "events", "which", "query", "mutation", "root", "field", "don", "t", "do", "NUMBER", "I", "guess", "my", "claim", "be", "that", "the", "sequencer", "should", "obey", "similar", "constraints", "to", "the", "resolver", "in", "particular", "in", "the", "spec", "the", "field", "resolver", "looks", "like", "ResolveFieldValue", "objectType", "objectValue", "fieldName", "argumentValues", "Notably", "fieldSet", "be", "not", "a", "parameter", "there", "it", "s", "provide", "in", "graphql", "js", "and", "other", "implementations", "to", "allow", "for", "reasonable", "optimizations", "so", "you", "can", "do", "SELECT", "name", "FROM", "users", "WHERE", "id", "NUMBER", "if", "they", "only", "asked", "for", "name", "but", "the", "field", "value", "itself", "shouldn", "t", "change", "based", "on", "the", "field", "set", "NUMBER", "It", "would", "be", "very", "strange", "if", "user", "id", "NUMBER", "name", "returned", "name", "Dan", "Schafer", "but", "user", "id", "NUMBER", "name", "firstName", "returned", "name", "Lee", "Byron", "firstName", "Lee", "and", "I", "d", "argue", "that", "would", "be", "spec", "non", "compliant", "NUMBER", "I", "d", "envision", "the", "sequencer", "acting", "the", "same", "way", "the", "sequence", "of", "payload", "events", "that", "it", "identifies", "should", "only", "vary", "depending", "on", "those", "four", "values", "objectType", "objectValue", "fieldName", "argumentValues", "and", "not", "on", "the", "field", "set", "NUMBER", "So", "in", "some", "ways", "I", "think", "this", "makes", "subscription", "field", "less", "special", "since", "it", "increases", "the", "parallelism", "between", "how", "they", "sequence", "and", "how", "all", "other", "field", "resolve", "NUMBER", "I", "wonder", "if", "that", "might", "not", "be", "better", "as", "a", "best", "practice", "type", "thing", "for", "typical", "use", "cases", "rather", "than", "a", "part", "of", "the", "spec", "I", "think", "the", "primary", "benefit", "to", "having", "it", "be", "in", "the", "spec", "be", "for", "client", "tooling", "NUMBER", "If", "this", "guarantee", "isn", "t", "in", "the", "spec", "then", "a", "client", "can", "t", "safely", "add", "a", "field", "to", "any", "subscription", "and", "by", "extension", "it", "can", "t", "really", "add", "a", "field", "to", "any", "fragment", "because", "the", "fragment", "could", "be", "use", "in", "the", "subscription", "NUMBER", "I", "guess", "it", "feels", "like", "there", "s", "a", "pretty", "important", "guarantee", "that", "exists", "today", "in", "GraphQL", "you", "can", "always", "safely", "add", "a", "field", "and", "know", "the", "only", "thing", "that", "will", "change", "about", "the", "response", "be", "that", "there", "will", "be", "a", "corresponding", "key", "value", "pair", "in", "the", "response", "for", "your", "field", "the", "rest", "of", "the", "response", "will", "be", "the", "same", "NUMBER", "So", "while", "add", "this", "guarantee", "in", "the", "subscriptions", "spec", "add", "a", "restriction", "on", "subscriptions", "it", "more", "importantly", "maintains", "an", "exist", "guarantee", "about", "field", "sets", "NUMBER", "With", "my", "current", "implementation", "if", "I", "care", "about", "author", "karma", "change", "here", "I", "would", "just", "create", "a", "new", "subscription", "but", "it", "seems", "like", "it", "d", "be", "odd", "to", "prohibit", "this", "subscription", "from", "firing", "on", "e", "NUMBER", "g", "NUMBER", "author", "karma", "change", "And", "what", "about", "optimizations", "e", "NUMBER", "g", "NUMBER", "for", "a", "partial", "update", "if", "none", "of", "the", "field", "on", "a", "given", "subscription", "have", "change", "in", "that", "partial", "update", "So", "because", "there", "s", "a", "lot", "of", "freedom", "in", "how", "we", "define", "the", "subscription", "root", "type", "it", "feels", "like", "all", "of", "these", "possibilities", "optimizations", "would", "still", "be", "available", "they", "would", "just", "have", "to", "be", "more", "explicit", "NUMBER", "The", "intent", "would", "be", "that", "this", "change", "would", "just", "prevent", "the", "field", "set", "from", "be", "use", "as", "the", "trigger", "for", "a", "behavior", "change", "instead", "the", "behavior", "change", "would", "have", "to", "be", "made", "by", "calling", "a", "different", "subscription", "field", "provide", "a", "different", "set", "of", "argument", "to", "the", "subscription", "field", "or", "use", "a", "directive", "which", "feels", "like", "a", "reasonable", "tradeoff", "to", "me", "NUMBER", "The", "downside", "be", "that", "the", "field", "set", "cannot", "change", "the", "behavior", "so", "we", "have", "to", "be", "explicit", "if", "we", "want", "to", "change", "behavior", "but", "the", "upside", "be", "that", "the", "field", "set", "cannot", "change", "the", "behavior", "so", "users", "tool", "can", "safely", "manipulate", "the", "field", "set", "without", "worrying", "that", "we", "ve", "change", "something", "NUMBER", "Thinking", "a", "bit", "more", "on", "something", "like", "the", "empty", "partial", "update", "case", "even", "if", "the", "GraphQL", "subscription", "itself", "uniquely", "identifies", "a", "sequence", "of", "events", "would", "the", "network", "layer", "be", "required", "to", "not", "apply", "optimizations", "like", "not", "sending", "empty", "update", "Contra", "request", "response", "semantics", "on", "typical", "GraphQL", "operations", "it", "seems", "like", "there", "s", "more", "scope", "for", "the", "network", "layer", "on", "the", "server", "side", "to", "do", "particular", "things", "here", "such", "that", "spec", "guarantees", "aren", "t", "the", "final", "word", "for", "behavior", "in", "practice", "with", "an", "actual", "server", "NUMBER", "I", "think", "it", "would", "be", "very", "useful", "to", "recommend", "that", "the", "subscriptions", "system", "doesn", "t", "even", "know", "about", "anything", "other", "than", "the", "root", "subscription", "field", "because", "it", "would", "be", "pretty", "unfortunate", "to", "have", "the", "server", "return", "different", "events", "based", "on", "the", "selection", "set", "NUMBER", "That", "would", "be", "like", "a", "mutation", "make", "a", "different", "change", "to", "the", "server", "based", "on", "the", "field", "fetched", "afterwards", "NUMBER", "However", "I", "think", "it", "s", "accurate", "that", "some", "subscriptions", "implementations", "would", "want", "to", "do", "throttling", "or", "batching", "of", "some", "kind", "which", "means", "you", "don", "t", "get", "exactly", "one", "result", "for", "one", "event", "fired", "NUMBER", "So", "I", "m", "not", "sure", "how", "the", "specification", "could", "have", "an", "opinion", "on", "how", "many", "message", "be", "delivered", "even", "though", "it", "would", "be", "very", "nice", "to", "have", "the", "re", "run", "be", "independent", "of", "the", "selection", "set", "NUMBER", "For", "your", "case", "taion", "I", "think", "commentAuthorKarmaUpdated", "would", "be", "good", "to", "be", "a", "separate", "subscription", "from", "commentScoreUpdated", "NUMBER", "Or", "even", "something", "like", "commentUpdated", "events", "SCORE", "AUTHOR_KARMA", "NUMBER", "To", "be", "clear", "I", "m", "just", "trying", "to", "work", "through", "hypotheticals", "here", "NUMBER", "stubailo", "you", "d", "have", "a", "better", "answer", "for", "this", "than", "me", "what", "would", "it", "look", "like", "to", "build", "something", "like", "a", "live", "query", "on", "top", "of", "GraphQL", "subscriptions", "Naively", "I", "d", "have", "imagined", "that", "it", "would", "require", "subscriptions", "with", "events", "that", "be", "payload", "dependent", "NUMBER", "stubailo", "my", "argumentation", "exactly", "Live", "queries", "would", "need", "to", "be", "specialized", "queries", "and", "contrary", "to", "the", "Facebook", "argumentation", "not", "the", "standard", "read", "queries", "set", "to", "live", "NUMBER", "That", "would", "be", "very", "problematic", "NUMBER", "Live", "queries", "should", "be", "specific", "to", "the", "data", "needing", "update", "and", "it", "will", "be", "that", "way", "NUMBER", "NUMBER", "of", "the", "time", "NUMBER", "It", "seems", "like", "the", "live", "query", "idea", "was", "only", "half", "way", "thought", "through", "NUMBER", "taion", "My", "words", "However", "let", "s", "have", "GraphQL", "subscriptions", "BE", "a", "live", "query", "system", "NUMBER", "How", "userland", "gets", "the", "data", "to", "be", "live", "should", "be", "up", "to", "them", "NUMBER", "It", "be", "a", "userland", "concern", "whether", "it", "be", "events", "databases", "that", "do", "live", "queries", "themselves", "polling", "some", "other", "API", "which", "defeats", "the", "purpose", "of", "live", "queries", "but", "sometimes", "it", "just", "isn", "t", "possible", "otherwise", "NUMBER", "There", "be", "a", "myriad", "of", "possibilities", "and", "now", "GraphQL", "be", "forcing", "something", "on", "its", "users", "with", "this", "self", "admitted", "difficult", "events", "system", "NUMBER", "KISS", "Scott", "smolinari", "taion", "this", "be", "exactly", "what", "I", "have", "build", "in", "rGraphQL", "LINK", "live", "data", "NUMBER", "Users", "decide", "how", "to", "feed", "data", "into", "the", "resolver", "system", "NUMBER", "It", "adjusts", "automatically", "to", "your", "code", "via", "reflection", "NUMBER", "Then", "query", "change", "and", "result", "change", "be", "streamed", "over", "a", "two", "way", "connection", "NUMBER", "It", "would", "not", "be", "appropriate", "for", "GraphQL", "subscriptions", "to", "mandate", "live", "queries", "NUMBER", "In", "general", "doing", "live", "queries", "in", "a", "scalable", "manner", "be", "an", "unsolved", "problem", "and", "it", "s", "not", "in", "general", "the", "correct", "solution", "for", "all", "use", "cases", "anyway", "NUMBER", "taion", "It", "would", "be", "just", "as", "appropriate", "as", "the", "event", "system", "be", "possibly", "mandated", "except", "considerably", "simpler", "NUMBER", "I", "also", "don", "t", "understand", "your", "comment", "about", "live", "queries", "be", "an", "unsolved", "problem", "in", "terms", "of", "scaling", "NUMBER", "What", "problem", "be", "there", "Scott", "It", "would", "not", "be", "appropriate", "for", "GraphQL", "subscriptions", "to", "mandate", "live", "queries", "NUMBER", "I", "cannot", "agree", "with", "this", "enough", "we", "re", "talking", "about", "two", "vastly", "different", "things", "here", "smolinari", "live", "queries", "trigger", "on", "any", "update", "NUMBER", "Subscriptions", "be", "fine", "grained", "and", "specific", "NUMBER", "Also", "live", "queries", "involve", "a", "lot", "of", "backend", "logic", "in", "order", "to", "support", "them", "something", "GraphQL", "has", "managed", "to", "stay", "away", "from", "as", "yet", "NUMBER", "Siyfion", "maybe", "my", "definition", "of", "a", "live", "query", "be", "different", "then", "because", "in", "my", "book", "a", "live", "query", "be", "a", "particular", "query", "that", "be", "deemed", "live", "NUMBER", "In", "other", "words", "you", "call", "certain", "queries", "as", "live", "through", "a", "different", "subscription", "method", "NUMBER", "You", "could", "say", "it", "be", "like", "a", "subscription", "system", "but", "without", "all", "the", "event", "stuff", "NUMBER", "How", "update", "be", "fed", "back", "to", "the", "GraphQL", "server", "be", "domain", "specific", "and", "yes", "it", "could", "get", "hairy", "as", "we", "can", "see", "from", "the", "solution", "offered", "here", "NUMBER", "This", "be", "an", "example", "of", "something", "similar", "to", "what", "I", "have", "in", "mind", "LINK", "server", "goes", "realtime", "with", "live", "queries", "To", "use", "live", "queries", "you", "just", "construct", "a", "Query", "like", "you", "normally", "would", "and", "call", "subscribe", "instead", "of", "find", "NUMBER", "Scott", "Awesome", "conversation", "around", "this", "so", "far", "NUMBER", "One", "concern", "I", "wanted", "to", "throw", "in", "which", "I", "ve", "discussed", "with", "dschafer", "and", "robzhu", "offline", "about", "be", "what", "the", "right", "abstraction", "should", "be", "for", "the", "source", "of", "triggering", "the", "execution", "of", "payloads", "NUMBER", "Right", "now", "the", "RFC", "suggests", "When", "the", "Subscription", "be", "created", "the", "input", "query", "and", "variables", "be", "mapped", "to", "a", "set", "of", "events", "to", "which", "the", "Subscription", "listens", "NUMBER", "I", "think", "this", "actually", "exposes", "too", "much", "about", "the", "implementation", "details", "of", "a", "subscription", "and", "makes", "too", "strong", "of", "an", "assumption", "that", "a", "Pub", "Sub", "system", "be", "the", "only", "way", "rather", "than", "the", "primary", "way", "to", "implement", "subscriptions", "NUMBER", "The", "word", "be", "actually", "pretty", "close", "to", "what", "I", "would", "recommend", "but", "how", "we", "read", "it", "be", "importantly", "different", "NUMBER", "I", "think", "the", "appropriate", "abstraction", "requires", "two", "things", "NUMBER", "A", "relationship", "between", "a", "client", "and", "service", "must", "be", "bidirectional", "NUMBER", "That", "be", "in", "addition", "to", "a", "client", "be", "able", "to", "initiate", "connection", "with", "a", "service", "the", "service", "must", "also", "be", "able", "to", "communicate", "directly", "to", "the", "client", "NUMBER", "This", "differs", "from", "a", "request", "response", "model", "where", "a", "service", "can", "only", "speak", "when", "spoken", "to", "NUMBER", "NUMBER", "Each", "subscription", "instance", "corresponds", "to", "a", "single", "sequence", "of", "notifications", "emitted", "over", "time", "e", "NUMBER", "g", "NUMBER", "a", "single", "Observable", "NUMBER", "Each", "emit", "from", "the", "Observable", "must", "result", "in", "a", "GraphQL", "Subscription", "payload", "NUMBER", "A", "PubSub", "system", "can", "pretty", "clearly", "satisfy", "both", "of", "these", "Pub", "be", "the", "reverse", "direction", "of", "Sub", "fulfilling", "bidirectional", "and", "if", "more", "than", "one", "events", "or", "topics", "be", "relevant", "this", "can", "still", "be", "modeled", "from", "GraphQL", "s", "point", "of", "view", "as", "a", "single", "merge", "Observable", "NUMBER", "Importantly", "service", "statefulness", "be", "not", "required", "NUMBER", "Webhook", "APIs", "can", "also", "satisfy", "these", "statelessly", "NUMBER", "Webhooks", "include", "a", "URL", "to", "POST", "payloads", "to", "fulfilling", "bidirection", "and", "the", "Observable", "exists", "only", "abstractly", "via", "some", "other", "part", "of", "the", "service", "that", "s", "run", "repeatedly", "over", "time", "as", "a", "result", "of", "some", "other", "incoming", "request", "i", "NUMBER", "e", "NUMBER", "GitHub", "post", "receive", "git", "hook", "NUMBER", "Following", "up", "on", "that", "this", "different", "framing", "of", "the", "base", "abstraction", "still", "captures", "dschafer", "s", "concerns", "above", "May", "a", "change", "in", "selected", "field", "result", "in", "a", "different", "sequence", "of", "payloads", "leebyron", "I", "agree", "that", "it", "might", "be", "better", "to", "avoid", "mentioning", "events", "explicitly", "NUMBER", "In", "the", "proposal", "I", "shared", "with", "you", "guys", "before", "I", "had", "framed", "it", "as", "a", "callback", "provide", "to", "the", "application", "code", "by", "the", "subscriptions", "system", "where", "the", "callback", "can", "be", "call", "as", "many", "times", "as", "desired", "with", "payload", "objects", "NUMBER", "Perhaps", "observable", "could", "be", "use", "as", "a", "term", "but", "I", "find", "that", "term", "pretty", "heavily", "overloaded", "by", "specific", "implementations", "like", "RxJS", "that", "bring", "a", "lot", "of", "baggage", "NUMBER", "the", "input", "query", "and", "variables", "be", "mapped", "I", "d", "also", "propose", "this", "word", "could", "be", "change", "to", "root", "subscription", "field", "and", "argument", "to", "suggest", "that", "implementations", "should", "avoid", "depending", "on", "parts", "of", "the", "query", "other", "than", "the", "root", "field", "NUMBER", "smolinari", "Subscriptions", "as", "propose", "here", "IMO", "should", "almost", "never", "be", "use", "as", "a", "live", "query", "because", "they", "don", "t", "provide", "some", "relevant", "guarantees", "and", "I", "think", "it", "might", "be", "good", "to", "ensure", "that", "there", "s", "a", "very", "clear", "distinction", "NUMBER", "Live", "queries", "would", "be", "a", "great", "feature", "to", "have", "in", "GraphQL", "but", "I", "don", "t", "think", "this", "proposal", "should", "be", "expanded", "to", "also", "include", "that", "separate", "concept", "NUMBER", "leebyron", "stubailo", "To", "what", "extent", "be", "it", "actually", "necessary", "to", "codify", "the", "behavior", "of", "the", "subscription", "system", "At", "a", "minimum", "GraphQL", "itself", "only", "needs", "to", "deal", "with", "two", "cases", "no", "On", "a", "subscription", "be", "received", "given", "the", "subscription", "query", "produce", "some", "sort", "of", "NewSubscriptionResult", "e", "NUMBER", "g", "NUMBER", "for", "the", "subscription", "to", "use", "to", "identify", "a", "set", "of", "events", "At", "future", "points", "in", "time", "given", "the", "same", "subscription", "query", "produce", "some", "sort", "of", "SubscriptionUpdateResult", "e", "NUMBER", "g", "NUMBER", "to", "send", "on", "to", "the", "subscriber", "Does", "the", "GraphQL", "spec", "need", "to", "outline", "what", "the", "subscription", "system", "do", "For", "example", "the", "guarantee", "mention", "above", "can", "just", "be", "stated", "as", "the", "NewSubscriptionResult", "be", "only", "a", "function", "of", "the", "root", "query", "further", "semantics", "don", "t", "concern", "the", "GraphQL", "engine", "directly", "NUMBER", "stubailo", "I", "think", "the", "best", "scenario", "would", "be", "that", "the", "subscription", "support", "be", "event", "based", "but", "that", "it", "would", "be", "possible", "to", "use", "it", "as", "a", "lower", "level", "build", "block", "for", "a", "live", "query", "system", "NUMBER", "Do", "you", "think", "this", "be", "impractical", "To", "what", "extent", "be", "it", "actually", "necessary", "to", "codify", "the", "behavior", "of", "the", "subscription", "system", "I", "think", "the", "value", "of", "specify", "some", "part", "of", "GraphQL", "be", "to", "make", "it", "predictable", "NUMBER", "You", "want", "to", "know", "what", "the", "life", "cycle", "of", "a", "subscription", "looks", "like", "how", "it", "might", "change", "when", "request", "different", "field", "etc", "NUMBER", "Do", "you", "think", "this", "be", "impractical", "Live", "query", "systems", "can", "easily", "be", "build", "as", "extensions", "to", "GraphQL", "completely", "independent", "of", "subscriptions", "NUMBER", "Do", "you", "think", "some", "part", "of", "the", "current", "proposal", "makes", "live", "queries", "harder", "to", "implement", "than", "they", "were", "before", "Hi", "I", "implement", "a", "naive", "and", "simple", "GQL", "Subscription", "implementation", "use", "EventSource", "and", "rmosolgo", "s", "graphql", "ruby", "LINK", "ruby", "NUMBER", "js", "var", "source", "new", "EventSource", "graphql", "query", "subscription", "id", "ID", "todoAdded", "id", "id", "id", "text", "todoUpdated", "id", "id", "id", "isCompleted", "todoRemoved", "id", "id", "id", "source", "NUMBER", "addEventListener", "graphql", "NUMBER", "todoAdded", "function", "message", "todoAdded", "field", "resolve", "NUMBER", "source", "NUMBER", "addEventListener", "graphql", "NUMBER", "todoRemoved", "function", "message", "todoRemoved", "field", "resolve", "NUMBER", "source", "NUMBER", "addEventListener", "graphql", "NUMBER", "todoUpdated", "function", "message", "todoUpdated", "field", "resolve", "NUMBER", "The", "problem", "here", "which", "be", "not", "a", "problem", "for", "implementation", "but", "the", "RFC", "be", "it", "s", "executing", "queries", "lazily", "with", "back", "end", "generate", "variables", "publisher", "at", "back", "end", "sets", "the", "variables", "NUMBER", "Since", "this", "approach", "works", "on", "this", "example", "I", "have", "no", "experiment", "on", "a", "more", "complex", "application", "NUMBER", "This", "be", "the", "work", "demo", "Gif", "LINK", "demo", "raw", "master", "demo", "NUMBER", "gif", "I", "know", "this", "approach", "has", "some", "pitfalls", "NUMBER", "E", "NUMBER", "g", "NUMBER", "I", "cannot", "subscribe", "to", "an", "individual", "field", "at", "back", "end", "since", "I", "m", "listening", "to", "back", "end", "publisher", "to", "take", "the", "variables", "and", "execute", "the", "query", "comes", "from", "client", "NUMBER", "And", "it", "s", "not", "very", "intuitive", "NUMBER", "But", "works", "exactly", "how", "I", "need", "NUMBER", "Here", "be", "the", "link", "you", "can", "try", "out", "LINK", "demo", "LINK", "demo", "I", "ve", "read", "the", "RFC", "excellent", "job", "robzhu", "and", "all", "of", "the", "insightful", "comments", "NUMBER", "I", "want", "to", "understand", "if", "GraphQL", "Subscriptions", "can", "be", "use", "for", "implement", "hot", "cold", "observables", "where", "a", "user", "first", "gets", "the", "initial", "state", "cold", "observable", "and", "then", "receives", "subsequent", "change", "hot", "observable", "In", "such", "a", "system", "the", "hot", "observable", "subscription", "payload", "must", "be", "combine", "able", "with", "the", "current", "client", "state", "NUMBER", "NUMBER", "Should", "the", "RFC", "include", "details", "about", "behavior", "regard", "the", "first", "payload", "vs", "all", "subsequent", "payloads", "NUMBER", "For", "example", "the", "initial", "state", "cold", "observable", "must", "be", "sent", "as", "the", "first", "payload", "if", "the", "value", "be", "present", "and", "the", "context", "makes", "sense", "NUMBER", "Should", "the", "RFC", "include", "details", "about", "the", "order", "of", "subscription", "payloads", "as", "they", "relate", "to", "the", "firing", "order", "of", "the", "underlying", "events", "NUMBER", "NUMBER", "Should", "the", "RFC", "propose", "a", "special", "metadata", "field", "in", "a", "subscription", "payload", "to", "serve", "as", "place", "for", "data", "like", "eventIds", "that", "triggered", "the", "subscription", "payload", "a", "sequential", "payload", "id", "to", "serve", "as", "a", "data", "anchor", "to", "detect", "payload", "loss", "when", "use", "non", "reliable", "transport", "libraries", "like", "socket", "NUMBER", "io", "where", "loss", "can", "occur", "when", "protocol", "switching", "stubailo", "On", "live", "queries", "that", "makes", "sense", "thanks", "NUMBER", "romandvoskin", "To", "me", "NUMBER", "seems", "application", "specific", "while", "NUMBER", "and", "NUMBER", "seem", "transport", "specific", "NUMBER", "To", "e", "NUMBER", "g", "NUMBER", "the", "points", "earlier", "these", "don", "t", "seem", "like", "things", "that", "should", "be", "specified", "at", "the", "level", "of", "the", "query", "language", "as", "they", "relate", "to", "properties", "that", "you", "may", "or", "may", "not", "want", "in", "a", "specific", "implementation", "in", "an", "application", "specific", "manner", "NUMBER", "I", "write", "some", "feedback", "to", "robzhu", "privately", "which", "he", "asked", "me", "to", "share", "here", "NUMBER", "I", "will", "NUMBER", "I", "think", "this", "proposal", "will", "enable", "a", "useful", "subset", "of", "realtime", "reactive", "use", "cases", "NUMBER", "I", "see", "the", "subset", "as", "event", "triggered", "schema", "projection", "NUMBER", "Whenever", "one", "of", "a", "specified", "set", "of", "underlying", "events", "happens", "run", "a", "user", "specified", "projection", "of", "the", "GraphQL", "schema", "NUMBER", "Imagine", "we", "have", "event", "sources", "IObservable", "TAG", "xs", "IObservable", "TAG", "ys", "IObservable", "TAG", "zs", "NUMBER", "a", "GraphQL", "schema", "plus", "a", "function", "that", "maps", "from", "TSchema", "the", "GraphQL", "schema", "to", "TPayload", "the", "user", "specified", "subset", "of", "the", "schema", "NUMBER", "We", "could", "model", "the", "proposal", "as", "an", "Rx", "Observable", "query", "NUMBER", "public", "IObservable", "TAG", "GraphQLObservable", "TAG", "IObservable", "TAG", "xs", "IObservable", "TAG", "ys", "IObservable", "TAG", "zs", "NUMBER", "TSchema", "schema", "Func", "TAG", "query", "var", "xSignals", "xs", "NUMBER", "Select", "_", "Unit", "NUMBER", "Default", "var", "ySignals", "ys", "NUMBER", "Select", "_", "Unit", "NUMBER", "Default", "var", "zSignals", "zs", "NUMBER", "Select", "_", "Unit", "NUMBER", "Default", "return", "Observable", "NUMBER", "Merge", "xSignals", "ySignals", "zSignals", "NUMBER", "Select", "_", "query", "schema", "This", "Observable", "query", "be", "quite", "general", "as", "the", "user", "may", "specify", "whatever", "query", "he", "wants", "and", "we", "can", "select", "any", "list", "of", "underlying", "events", "as", "triggers", "NUMBER", "However", "for", "some", "use", "cases", "this", "approach", "may", "not", "be", "significantly", "more", "efficient", "than", "polling", "NUMBER", "Consider", "the", "following", "case", "NUMBER", "Let", "s", "say", "I", "want", "to", "produce", "a", "trending", "topics", "live", "dashboard", "NUMBER", "This", "dashboard", "will", "show", "me", "a", "top", "NUMBER", "list", "of", "the", "most", "popular", "Twitter", "hashtags", "in", "the", "last", "NUMBER", "hours", "NUMBER", "There", "be", "one", "underlying", "event", "stream", "Tweets", "NUMBER", "One", "approach", "which", "could", "be", "implement", "with", "GraphQL", "subscriptions", "would", "be", "to", "trigger", "a", "re", "query", "across", "all", "the", "tweets", "for", "the", "past", "NUMBER", "hours", "every", "time", "a", "new", "tweet", "occur", "NUMBER", "A", "more", "efficient", "approach", "would", "be", "to", "set", "up", "a", "stream", "processing", "pipeline", "say", "with", "Apache", "Storm", "that", "processed", "the", "tweet", "stream", "through", "a", "directed", "graph", "of", "computation", "NUMBER", "Spout", "Tweet", "stream", "Edge", "Random", "partitioning", "load", "balancing", "Bolt", "Type", "NUMBER", "Parse", "hashtags", "from", "tweets", "stateless", "Edge", "Partition", "by", "hashtag", "Bolt", "Type", "NUMBER", "Perform", "NUMBER", "hour", "rolling", "counts", "of", "hashtags", "maintain", "intermediate", "state", "Edge", "Partition", "by", "count", "object", "Bolt", "Type", "NUMBER", "Intermediate", "rankings", "of", "counts", "maintain", "intermediate", "state", "Edge", "Global", "grouping", "Bolt", "Type", "NUMBER", "singleton", "Total", "rankings", "of", "counts", "maintain", "intermediate", "state", "Edge", "Random", "partitioning", "Bolt", "Type", "NUMBER", "Publish", "stateless", "Here", "s", "a", "post", "that", "details", "how", "to", "implement", "this", "stream", "processing", "pipeline", "in", "Storm", "NUMBER", "LINK", "noll", "NUMBER", "com", "blog", "NUMBER", "NUMBER", "NUMBER", "implement", "real", "time", "trending", "topics", "in", "storm", "Here", "we", "set", "up", "the", "processing", "pipeline", "once", "at", "the", "dawn", "of", "time", "or", "when", "a", "user", "expresses", "interest", "NUMBER", "Once", "we", "set", "up", "the", "processing", "pipeline", "there", "s", "no", "querying", "required", "when", "an", "event", "happens", "NUMBER", "We", "take", "an", "underlying", "event", "stream", "and", "transform", "it", "into", "a", "more", "interesting", "stream", "which", "pushes", "data", "at", "the", "user", "NUMBER", "It", "s", "all", "reactive", "NUMBER", "I", "guess", "the", "distinction", "be", "push", "versus", "pull", "NUMBER", "Querying", "be", "a", "pull", "activity", "NUMBER", "In", "the", "propose", "RFC", "model", "we", "pull", "at", "sources", "not", "on", "a", "fix", "interval", "trigger", "like", "polling", "but", "on", "an", "event", "based", "trigger", "NUMBER", "That", "s", "a", "possible", "and", "useful", "approach", "to", "solving", "realtime", "use", "cases", "but", "it", "may", "not", "be", "practical", "efficient", "for", "some", "applications", "NUMBER", "All", "that", "said", "I", "still", "think", "the", "propose", "spec", "covers", "a", "useful", "subset", "of", "cases", "NUMBER", "It", "will", "be", "wonderful", "to", "avoid", "under", "push", "over", "push", "in", "those", "cases", "NUMBER", "rzachariah", "This", "be", "an", "interesting", "observation", "NUMBER", "I", "wonder", "if", "the", "feature", "you", "re", "get", "with", "Storm", "be", "possible", "here", "by", "creating", "an", "event", "becoming", "an", "event", "source", "as", "a", "consumer", "of", "a", "subscription", "NUMBER", "To", "use", "your", "use", "case", "an", "initial", "subscription", "to", "tweets", "be", "consumed", "by", "an", "aggregator", "which", "as", "an", "event", "source", "publishes", "an", "event", "whenever", "the", "result", "top", "x", "tweets", "change", "NUMBER", "What", "do", "you", "think", "romandvoskin", "I", "think", "that", "s", "right", "NUMBER", "I", "could", "create", "a", "GraphQL", "Subscription", "server", "that", "offered", "both", "a", "Tweets", "subscription", "based", "on", "raw", "tweet", "events", "and", "a", "Trends", "subscription", "based", "on", "manufactured", "top", "x", "rankings", "events", "NUMBER", "There", "be", "a", "relationship", "between", "these", "event", "streams", "but", "perhaps", "those", "be", "implementation", "details", "of", "the", "server", "NUMBER", "Perhaps", "the", "GraphQL", "Subscription", "spec", "should", "be", "ignorant", "of", "any", "distinction", "between", "raw", "and", "manufactured", "events", "NUMBER", "rzachariah", "Correct", "me", "if", "I", "be", "wrong", "but", "your", "example", "be", "one", "where", "a", "polling", "type", "push", "of", "data", "the", "event", "to", "GraphQL", "be", "going", "to", "be", "the", "result", "of", "the", "aggregation", "of", "top", "tweets", "NUMBER", "In", "other", "words", "you", "wouldn", "t", "want", "to", "push", "data", "for", "each", "tweet", "but", "rather", "only", "every", "minute", "or", "NUMBER", "seconds", "or", "whatever", "be", "smart", "for", "your", "users", "and", "your", "system", "NUMBER", "It", "be", "a", "great", "example", "of", "how", "diverse", "the", "events", "could", "be", "which", "trigger", "publishing", "data", "to", "subscribers", "NUMBER", "On", "a", "side", "note", "The", "more", "I", "read", "and", "learn", "the", "more", "I", "see", "that", "the", "pub", "sub", "system", "which", "be", "put", "forward", "in", "this", "RFC", "be", "actually", "what", "I", "consider", "a", "live", "query", "system", "NUMBER", "So", "I", "apologize", "for", "my", "ramblings", "NUMBER", "I", "ve", "also", "notice", "that", "live", "query", "has", "be", "defined", "in", "different", "ways", "for", "different", "technologies", "from", "databases", "to", "jQuery", "to", "Meteor", "NUMBER", "So", "seeing", "as", "there", "be", "no", "one", "clear", "standard", "for", "what", "a", "live", "query", "be", "I", "d", "like", "to", "also", "suggest", "we", "call", "this", "system", "GraphQL", "Live", "Query", "simply", "because", "that", "name", "be", "a", "lot", "sexier", "than", "pub", "sub", "or", "GraphQL", "Subscriptions", "NUMBER", "Or", "be", "there", "a", "clear", "definition", "of", "what", "a", "live", "query", "be", "Let", "s", "forget", "what", "was", "put", "forward", "as", "a", "live", "query", "in", "this", "RFC", "as", "it", "also", "isn", "t", "a", "standard", "either", "NUMBER", "How", "about", "it", "Scott", "Hi", "smolinari", "NUMBER", "Yes", "in", "my", "example", "the", "top", "trends", "event", "stream", "be", "a", "streaming", "aggregation", "of", "the", "tweet", "stream", "NUMBER", "The", "throughput", "events", "second", "of", "this", "derived", "event", "stream", "would", "be", "much", "lower", "than", "the", "raw", "event", "stream", "that", "produced", "it", "NUMBER", "There", "s", "some", "natural", "filtering", "as", "a", "result", "of", "the", "top", "x", "operation", "NUMBER", "In", "addition", "yes", "it", "would", "be", "reasonable", "to", "introduce", "additional", "delays", "batching", "to", "reduce", "the", "computational", "load", "NUMBER", "A", "top", "NUMBER", "trends", "dashboard", "that", "s", "live", "as", "of", "a", "few", "seconds", "ago", "or", "even", "a", "minute", "ago", "seems", "reasonable", "NUMBER", "I", "was", "also", "trying", "to", "suggest", "a", "more", "efficient", "alternative", "to", "simply", "iterating", "over", "the", "last", "NUMBER", "hours", "of", "tweet", "data", "every", "time", "you", "re", "interested", "in", "update", "the", "trends", "dashboard", "NUMBER", "I", "propose", "a", "storm", "topology", "as", "an", "approach", "that", "maintains", "intermediate", "state", "about", "the", "computation", "sliding", "window", "counts", "by", "topic", "current", "rankings", "so", "there", "s", "very", "little", "work", "to", "do", "whenever", "it", "s", "time", "to", "process", "a", "new", "tweet", "NUMBER", "It", "s", "an", "event", "processing", "pipeline", "made", "up", "of", "a", "chain", "of", "subscriptions", "NUMBER", "An", "Rx", "query", "would", "be", "another", "example", "of", "an", "event", "processing", "pipeline", "made", "up", "of", "a", "chain", "of", "subscriptions", "and", "it", "s", "possible", "to", "write", "one", "for", "this", "example", "though", "the", "Rx", "version", "would", "not", "be", "as", "scalable", "NUMBER", "One", "could", "think", "of", "a", "storm", "topology", "or", "an", "Rx", "query", "as", "a", "live", "query", "NUMBER", "It", "s", "a", "query", "that", "once", "deployed", "or", "subscribed", "to", "be", "always", "run", "and", "automatically", "pushes", "update", "in", "reaction", "to", "new", "input", "events", "NUMBER", "Some", "thoughts", "on", "this", "I", "ve", "had", "reading", "the", "RFC", "and", "this", "thread", "in", "no", "particular", "order", "the", "case", "for", "subscriptions", "_inside_", "graphql", "needs", "to", "be", "made", "more", "strongly", "NUMBER", "Ah", "well", "you", "can", "just", "implement", "that", "in", "your", "transport", "layer", "seems", "to", "have", "come", "up", "a", "few", "times", "NUMBER", "in", "img_", "NUMBER", "why", "do", "the", "subscription", "layer", "talk", "directly", "to", "graphql", "This", "feels", "like", "a", "break", "in", "the", "abstraction", "NUMBER", "there", "feels", "like", "there", "be", "a", "gap", "between", "Data", "transform", "pipelines", "and", "Live", "Queries", "for", "entity", "state", "update", "NUMBER", "The", "main", "problem", "with", "live", "queries", "be", "not", "business", "logic", "decisions", "NUMBER", "but", "computation", "and", "dependency", "complexity", "NUMBER", "If", "I", "have", "an", "_n_", "depth", "query", "I", "be", "subscribed", "and", "an", "object", "at", "depth", "_n_", "change", "propagating", "this", "back", "down", "to", "the", "root", "subscriptions", "be", "difficult", "not", "impossible", "but", "I", "d", "rather", "not", "have", "to", "think", "about", "how", "to", "get", "it", "to", "wire", "up", "NUMBER", "Comments", "by", "leebyron", "rmosolgo", "and", "stubailo", "about", "restricting", "subscription", "semantics", "to", "the", "root", "parameters", "all", "speak", "to", "this", "NUMBER", "I", "think", "restricting", "subscription", "semantics", "to", "the", "root", "parameters", "be", "generally", "a", "good", "restriction", "to", "make", "but", "it", "needs", "to", "be", "made", "clearly", "and", "with", "reasons", "given", "if", "it", "be", "to", "be", "more", "than", "a", "recommendation", "talking", "about", "live", "queries", "be", "unclear", "and", "has", "already", "cause", "some", "confusion", "NUMBER", "This", "seems", "to", "be", "a", "DB", "land", "phrase", "originally", "but", "it", "do", "appear", "to", "be", "cause", "confusion", "NUMBER", "It", "would", "be", "better", "to", "frame", "everything", "in", "terms", "of", "the", "construction", "of", "graphql", "queries", "and", "their", "result", "sets", "NUMBER", "distinguishing", "between", "events", "state", "mutation", "events", "actions", "commands", "not", "in", "here", "yet", "but", "closely", "relate", "in", "the", "eventing", "world", "and", "whole", "state", "objects", "be", "immaterial", "given", "the", "above", "particularly", "since", "they", "be", "all", "types", "of", "event", "and", "the", "distinction", "be", "unenforceable", "NUMBER", "in", "img_", "NUMBER", "most", "the", "green", "subscription", "layer", "seems", "unnecessary", "NUMBER", "A", "graphql", "subscription", "would", "work", "without", "any", "bi", "directional", "traffic", "from", "downstream", "NUMBER", "Leaving", "this", "in", "may", "reduce", "the", "clarity", "of", "the", "message", "it", "could", "perhaps", "go", "in", "an", "addendum", "to", "describe", "a", "more", "complex", "system", "NUMBER", "there", "be", "definitely", "room", "for", "best", "practice", "stuff", "around", "designing", "events", "but", "this", "should", "be", "demarcated", "as", "best", "practice", "since", "it", "s", "stuff", "that", "be", "contingently", "true", "NUMBER", "NUMBER", "here", "I", "disagree", "with", "Dan", "Schafer", "and", "Laney", "Kuenzel", "s", "assessment", "of", "Live", "Queries", "in", "Relay", "though", "not", "their", "decision", "NUMBER", "I", "think", "their", "domain", "problem", "ie", "when", "do", "I", "update", "be", "technically", "solve", "eg", "use", "some", "sort", "of", "buffer", "aggregation", "or", "debouncing", "ignoring", "the", "computational", "cost", "aspect", "but", "requires", "a", "product", "decision", "as", "to", "what", "should", "update", "be", "seen", "when", "NUMBER", "Their", "second", "point", "about", "computational", "complexity", "speaks", "only", "to", "that", "specific", "use", "case", "not", "all", "use", "cases", "NUMBER", "FWIW", "I", "d", "strongly", "recommend", "taking", "a", "look", "at", "graphql", "subscriptions", "LINK", "subscriptions", "and", "graphql", "relay", "subscription", "LINK", "relay", "subscription", "with", "relay", "subscriptions", "LINK", "subscriptions", "if", "you", "haven", "t", "already", "NUMBER", "I", "think", "there", "already", "_are_", "implementations", "that", "hew", "quite", "closely", "to", "what", "s", "in", "the", "proposal", "NUMBER", "Some", "of", "these", "be", "even", "already", "live", "NUMBER", "Those", "systems", "their", "relevant", "API", "warts", "and", "the", "current", "GraphQL", "reference", "implementation", "which", "has", "already", "moved", "ahead", "of", "the", "spec", "here", "be", "in", "some", "sense", "existence", "proofs", "for", "what", "makes", "sense", "engineering", "wise", "to", "split", "between", "core", "and", "transport", "layers", "NUMBER", "Thanks", "Jimmy", "NUMBER", "While", "I", "ve", "read", "around", "them", "I", "haven", "t", "looked", "at", "them", "in", "detail", "yet", "NUMBER", "My", "main", "goal", "wasn", "t", "to", "dispute", "that", "subscription", "be", "useful", "or", "even", "that", "this", "be", "heading", "in", "the", "right", "direction", "NUMBER", "but", "to", "improve", "the", "clarity", "of", "the", "whys", "NUMBER", "Once", "this", "be", "tighter", "it", "be", "easier", "to", "debate", "be", "this", "the", "problem", "we", "want", "to", "solve", "and", "be", "this", "a", "solution", "to", "the", "problem", "separately", "NUMBER", "NUMBER", "except", "maybe", "the", "definition", "of", "events", "rzachariah", "It", "s", "a", "query", "that", "once", "deployed", "or", "subscribed", "to", "be", "always", "run", "and", "automatically", "pushes", "update", "in", "reaction", "to", "new", "input", "events", "NUMBER", "That", "sounds", "like", "exactly", "what", "the", "one", "sentence", "definition", "of", "GraphQL", "Subscriptions", "or", "ehem", "NUMBER", "Live", "Query", "should", "be", "NUMBER", "Scott", "smolinari", "I", "hate", "to", "keep", "mentioning", "it", "but", "I", "have", "actually", "proven", "in", "rgraphql", "that", "live", "Graphql", "queries", "with", "arbitrary", "data", "sources", "no", "DB", "relate", "logic", "and", "mixes", "of", "static", "and", "dynamic", "data", "be", "easily", "possible", "without", "change", "the", "current", "spec", "at", "all", "NUMBER", "What", "these", "guys", "be", "work", "on", "be", "a", "extension", "to", "the", "spec", "that", "works", "around", "the", "cludge", "of", "typical", "one", "way", "data", "sources", "like", "Pub", "Sub", "or", "long", "polling", "on", "request", "NUMBER", "Otherwise", "there", "s", "no", "advantage", "to", "the", "flat", "limited", "subscription", "model", "when", "compared", "to", "a", "streaming", "system", "NUMBER", "Ok", "NUMBER", "paralin", "Still", "I", "be", "a", "bit", "confused", "NUMBER", "Are", "you", "make", "that", "point", "for", "me", "because", "I", "be", "misunderstanding", "something", "or", "be", "you", "make", "that", "point", "to", "everyone", "else", "to", "say", "all", "this", "isn", "t", "really", "necessary", "to", "make", "a", "live", "query", "system", "within", "the", "spec", "Or", "maybe", "even", "both", "LOL", "Scott", "The", "spec", "already", "covers", "everything", "for", "live", "queries", "other", "than", "I", "suppose", "directives", "to", "control", "the", "execution", "NUMBER", "But", "that", "s", "more", "of", "a", "server", "specific", "thing", "anyway", "NUMBER", "What", "s", "the", "difference", "of", "a", "live", "query", "to", "the", "spec", "You", "re", "still", "specify", "what", "data", "be", "required", "in", "the", "same", "syntax", "NUMBER", "Hey", "all", "amazing", "feedback", "and", "discussion", "so", "far", "but", "it", "s", "clear", "the", "github", "PR", "single", "comment", "thread", "feedback", "format", "be", "not", "suited", "for", "hosting", "multiple", "conversations", "at", "once", "NUMBER", "I", "m", "going", "to", "go", "through", "the", "feedback", "and", "organize", "everything", "into", "open", "and", "close", "topics", "NUMBER", "Closed", "topics", "be", "either", "obvious", "or", "have", "clear", "consensus", "and", "will", "be", "merge", "into", "the", "proposal", "in", "the", "next", "edit", "NUMBER", "Open", "topics", "be", "still", "be", "discussed", "I", "will", "try", "to", "tag", "everyone", "who", "s", "be", "involved", "interested", "on", "each", "topic", "NUMBER", "Once", "I", "ve", "organized", "this", "list", "I", "ll", "need", "everyone", "s", "help", "Make", "sure", "the", "list", "be", "complete", "and", "the", "categorization", "of", "open", "close", "topics", "be", "accurate", "Make", "sure", "your", "name", "be", "tag", "on", "the", "topics", "you", "care", "about", "NUMBER", "After", "that", "I", "ll", "merge", "this", "PR", "clearly", "marked", "as", "WIP", "and", "open", "issue", "for", "each", "of", "the", "open", "topics", "so", "that", "we", "can", "have", "a", "more", "focused", "conversation", "NUMBER", "As", "each", "open", "topic", "be", "resolve", "we", "will", "make", "the", "appropriate", "edits", "as", "part", "of", "a", "new", "PR", "NUMBER", "My", "main", "goal", "be", "to", "make", "sure", "all", "the", "great", "conversations", "here", "be", "captured", "without", "competing", "for", "attention", "and", "that", "we", "can", "make", "incremental", "progress", "on", "get", "this", "into", "the", "Spec", "NUMBER", "paralin", "What", "s", "the", "difference", "of", "a", "live", "query", "to", "the", "spec", "You", "re", "still", "specify", "what", "data", "be", "required", "in", "the", "same", "syntax", "NUMBER", "Somehow", "a", "query", "needs", "to", "be", "designated", "as", "live", "by", "the", "client", "NUMBER", "Or", "as", "you", "said", "and", "I", "think", "we", "be", "on", "the", "same", "wavelength", "on", "this", "the", "queries", "that", "can", "be", "call", "as", "live", "need", "to", "be", "defined", "on", "the", "server", "in", "some", "way", "and", "be", "obvious", "findable", "through", "introspection", "NUMBER", "Scott", "Do", "we", "need", "a", "bi", "directional", "channel", "between", "client", "and", "server", "The", "use", "of", "SSE", "v", "WS", "be", "an", "application", "level", "implementation", "detail", "NUMBER", "All", "that", "s", "needed", "be", "the", "server", "be", "able", "to", "push", "message", "to", "the", "client", "somehow", "which", "distinguishes", "this", "from", "request", "response", "NUMBER", "Where", "should", "subscription", "state", "be", "stored", "inside", "GraphQL", "js", "or", "as", "a", "separate", "component", "I", "d", "prefer", "to", "have", "this", "state", "be", "stored", "outside", "of", "GraphQL", "NUMBER", "js", "NUMBER", "I", "want", "to", "e", "NUMBER", "g", "NUMBER", "manage", "my", "own", "Redis", "subscriptions", "backing", "my", "GraphQL", "subscriptions", "and", "I", "feel", "like", "the", "control", "logic", "be", "more", "straightforward", "if", "I", "have", "something", "I", "can", "call", "when", "my", "subscription", "fires", "rather", "than", "passing", "e", "NUMBER", "g", "NUMBER", "an", "observable", "into", "GraphQL", "NUMBER", "js", "NUMBER", "How", "should", "we", "pass", "event", "payloads", "data", "into", "the", "subscription", "resolvers", "This", "be", "a", "framework", "level", "implementation", "question", "NUMBER", "I", "d", "prefer", "GraphQL", "NUMBER", "js", "use", "the", "exist", "rootValue", "field", "here", "NUMBER", "The", "event", "stream", "should", "be", "derived", "purely", "from", "the", "subscription", "root", "field", "and", "ignore", "selection", "set", "NUMBER", "I", "agree", "with", "this", "NUMBER", "It", "s", "the", "natural", "way", "to", "write", "the", "spec", "NUMBER", "Fetching", "initial", "state", "when", "subscribing", "NUMBER", "I", "think", "this", "be", "an", "application", "level", "thing", "NUMBER", "State", "be", "not", "a", "concept", "that", "be", "inherent", "to", "GraphQL", "NUMBER", "Subscribing", "to", "e", "NUMBER", "g", "NUMBER", "streams", "of", "newly", "created", "items", "also", "doesn", "t", "necessarily", "admit", "an", "easy", "representation", "of", "current", "state", "NUMBER", "Imagine", "subscription", "update", "that", "don", "t", "reflect", "idempotent", "operations", "in", "such", "cases", "there", "isn", "t", "really", "a", "coherent", "initial", "state", "NUMBER", "Re", "define", "Live", "Queries", "Can", "Live", "Queries", "make", "Subscriptions", "unnecessary", "stubailo", "s", "point", "be", "exactly", "right", "here", "NUMBER", "Live", "queries", "should", "be", "thought", "of", "separately", "from", "event", "based", "subscriptions", "NUMBER", "They", "can", "be", "use", "to", "solve", "similar", "problem", "NUMBER", "However", "scaling", "event", "stream", "based", "subscription", "systems", "be", "relatively", "well", "understood", "the", "same", "do", "not", "apply", "for", "live", "queries", "and", "for", "anyone", "looking", "to", "ship", "something", "scalable", "now", "live", "queries", "aren", "t", "really", "an", "option", "NUMBER", "Intermediate", "Subscription", "event", "processing", "This", "be", "an", "application", "level", "detail", "NUMBER", "If", "someone", "wants", "to", "subscribe", "to", "e", "NUMBER", "g", "NUMBER", "a", "top", "X", "stream", "but", "not", "re", "process", "that", "stream", "then", "there", "s", "nothing", "at", "the", "framework", "level", "that", "prevents", "e", "NUMBER", "g", "NUMBER", "the", "trending", "tweets", "subscription", "from", "use", "different", "events", "than", "the", "new", "tweet", "subscription", "NUMBER", "taion", "Live", "queries", "certainly", "could", "be", "scalable", "especially", "with", "GraphQL", "s", "emphasis", "on", "separating", "logic", "for", "each", "field", "NUMBER", "I", "m", "looking", "at", "implement", "a", "scheduler", "for", "Magellan", "LINK", "that", "could", "do", "that", "NUMBER", "But", "you", "re", "right", "NUMBER", "Subscriptions", "be", "a", "different", "topic", "from", "live", "queries", "NUMBER", "And", "IMO", "live", "queries", "don", "t", "need", "a", "change", "to", "the", "spec", "to", "be", "implement", "NUMBER", "Directives", "be", "server", "specific", "with", "introspection", "and", "that", "should", "be", "all", "you", "need", "NUMBER", "Just", "to", "clarify", "when", "I", "say", "live", "queries", "I", "mean", "something", "like", "the", "live", "directive", "mention", "in", "talks", "where", "the", "interface", "presented", "to", "the", "client", "be", "one", "where", "the", "client", "can", "request", "a", "particular", "query", "be", "live", "rather", "than", "one", "where", "the", "client", "explicitly", "request", "specific", "streams", "NUMBER", "For", "an", "example", "of", "a", "subscription", "based", "API", "see", "LINK", "subscriptions", "blob", "v", "NUMBER", "examples", "todo", "js", "components", "Todo", "NUMBER", "js", "L", "NUMBER", "L", "NUMBER", "If", "this", "were", "use", "live", "queries", "then", "perhaps", "it", "would", "just", "look", "like", "graphql", "fragment", "on", "Todo", "live", "id", "complete", "text", "NUMBER", "However", "if", "you", "re", "doing", "various", "things", "such", "as", "use", "microservices", "and", "splitting", "up", "GraphQL", "objects", "across", "multiple", "backend", "services", "c", "NUMBER", "how", "to", "efficiently", "implement", "live", "queries", "can", "be", "much", "less", "than", "obvious", "while", "event", "based", "systems", "be", "much", "more", "straightforward", "NUMBER", "Since", "there", "s", "excitement", "and", "support", "for", "the", "direction", "of", "this", "RFC", "I", "m", "going", "to", "commit", "it", "as", "an", "official", "tracked", "RFC", "NUMBER", "robzhu", "just", "opened", "up", "issue", "for", "all", "of", "the", "various", "topics", "still", "under", "discussion", "so", "this", "be", "still", "very", "much", "an", "open", "design", "So", "excited", "Me", "too", "Scott", "AHHHHHHHHHHHHH", "type", "input", "Good", "catch", "NUMBER", "Thanks", "a", "lot", "firede", "NUMBER", "Follow", "up", "to", "NUMBER", "Improved", "the", "note", "on", "input", "coercion", "for", "null", "value", "via", "runtime", "variable", "value", "for", "a", "list", "type", "NUMBER", "The", "previous", "form", "was", "a", "little", "bit", "hard", "to", "read", "NUMBER", "Hopefully", "the", "change", "improve", "its", "readability", "NUMBER", "Thanks", "Minor", "typo", "correction", "from", "interpretted", "to", "interpret", "NUMBER", "For", "further", "consideration", "would", "it", "possible", "to", "re", "consider", "the", "entire", "sentence", "Currently", "it", "be", "not", "easy", "to", "read", "NUMBER", "Current", "with", "typo", "change", "Note", "that", "when", "a", "null", "value", "be", "provide", "via", "a", "runtime", "variable", "value", "for", "a", "list", "type", "that", "it", "be", "interpreted", "as", "no", "list", "be", "provide", "and", "not", "a", "list", "of", "size", "one", "with", "the", "value", "null", "NUMBER", "Possible", "change", "Note", "that", "when", "a", "null", "value", "be", "provide", "via", "a", "runtime", "variable", "value", "for", "a", "list", "type", "the", "value", "be", "interpreted", "as", "no", "list", "be", "provide", "and", "not", "a", "list", "of", "size", "one", "with", "the", "value", "null", "NUMBER", "Open", "to", "discussion", "NUMBER", "Cheers", "Does", "this", "exclude", "the", "possibility", "of", "use", "__id", "for", "IDs", "which", "be", "not", "strictly", "introspection", "or", "will", "that", "involve", "change", "this", "language", "Over", "at", "graphql", "java", "LINK", "java", "graphql", "java", "pull", "NUMBER", "issuecomment", "NUMBER", "we", "ve", "run", "into", "some", "confusion", "regard", "NUMBER", "Float", "Value", "NUMBER", "The", "JS", "implementation", "lets", "you", "have", "an", "empty", "FractonalPart", "even", "though", "it", "s", "not", "marked", "opt", "in", "the", "spec", "NUMBER", "What", "be", "correct", "okorz", "NUMBER", "pcarrier", "LINK", "java", "graphql", "java", "pull", "NUMBER", "with", "reference", "to", "graphql", "js", "implementation", "NUMBER", "I", "m", "only", "semi", "serious", "with", "this", "proposal", "and", "I", "m", "more", "interested", "to", "hear", "a", "defense", "of", "union", "types", "because", "I", "currently", "can", "t", "think", "of", "one", "then", "to", "see", "this", "proposal", "proceed", "NUMBER", "In", "the", "specification", "it", "be", "currently", "write", "that", "An", "Interface", "type", "must", "define", "one", "or", "more", "field", "NUMBER", "LINK", "sec", "Interface", "type", "validation", "NUMBER", "From", "a", "precursory", "glance", "at", "the", "specification", "it", "seems", "like", "that", "limitation", "be", "arbitrary", "NUMBER", "In", "addition", "if", "we", "remove", "that", "validation", "requirement", "and", "perhaps", "change", "some", "other", "spec", "wordings", "an", "interface", "could", "behave", "the", "exact", "same", "as", "a", "union", "and", "perhaps", "be", "strictly", "better", "NUMBER", "An", "interface", "with", "no", "field", "would", "be", "better", "than", "a", "union", "because", "the", "interface", "gives", "the", "schema", "designer", "the", "flexibility", "to", "add", "common", "field", "in", "the", "future", "NUMBER", "Because", "interfaces", "be", "nominal", "and", "not", "structural", "this", "could", "be", "allow", "NUMBER", "A", "major", "benefit", "of", "unions", "in", "functional", "programming", "languages", "be", "that", "pattern", "matching", "statements", "with", "unions", "can", "be", "exhaustive", "NUMBER", "Whenever", "a", "programmer", "add", "a", "new", "variant", "to", "the", "union", "the", "type", "system", "breaks", "and", "requires", "all", "exhaustive", "pattern", "matches", "to", "be", "update", "appropriately", "NUMBER", "In", "GraphQL", "such", "a", "benefit", "be", "not", "realistic", "given", "that", "the", "code", "mobile", "apps", "which", "executes", "against", "a", "GraphQL", "schema", "can", "not", "always", "easily", "be", "update", "when", "add", "a", "new", "variant", "to", "a", "union", "NUMBER", "It", "would", "seem", "that", "the", "spec", "makes", "the", "argument", "that", "unions", "be", "good", "because", "Unions", "also", "differ", "from", "interfaces", "in", "that", "Object", "types", "declare", "what", "interfaces", "they", "implement", "but", "be", "not", "aware", "of", "what", "unions", "contain", "them", "NUMBER", "source", "They", "also", "differ", "from", "interfaces", "in", "that", "Object", "types", "declare", "what", "interfaces", "they", "implement", "but", "be", "not", "aware", "of", "what", "unions", "contain", "them", "NUMBER", "However", "it", "seems", "to", "me", "that", "the", "only", "case", "where", "the", "property", "of", "objects", "not", "declaring", "union", "membership", "be", "useful", "be", "in", "a", "pattern", "matching", "scenario", "which", "I", "think", "we", "can", "agree", "be", "a", "scenario", "that", "doesn", "t", "always", "work", "well", "with", "the", "design", "goal", "of", "GraphQL", "NUMBER", "Furthermore", "if", "we", "make", "this", "change", "remove", "unions", "from", "the", "specification", "and", "allowing", "interface", "types", "with", "no", "field", "it", "wouldn", "t", "be", "a", "breaking", "change", "NUMBER", "The", "access", "patterns", "from", "a", "GraphQL", "client", "that", "assumes", "unions", "exist", "would", "be", "the", "same", "for", "an", "interface", "with", "no", "field", "NUMBER", "So", "I", "think", "it", "s", "plausible", "that", "we", "can", "remove", "unions", "from", "the", "spec", "and", "maintain", "backwards", "compatibility", "I", "d", "love", "to", "be", "proven", "wrong", "That", "s", "what", "this", "issue", "be", "for", "wink", "and", "I", "also", "think", "it", "would", "have", "the", "following", "benefits", "Simplifies", "the", "specification", "without", "breaking", "it", "make", "it", "easier", "to", "learn", "for", "beginners", "and", "easier", "to", "build", "off", "of", "for", "implementors", "both", "on", "the", "client", "and", "server", "side", "NUMBER", "I", "ve", "run", "into", "my", "fair", "share", "of", "Relay", "NUMBER", "union", "type", "bug", "and", "gotchas", "NUMBER", "LINK", "LINK", "No", "more", "union", "type", "relate", "proposals", "which", "may", "or", "may", "not", "actually", "be", "useful", "plausible", "such", "as", "union", "input", "types", "and", "union", "scalar", "types", "NUMBER", "LINK", "LINK", "js", "issue", "NUMBER", "LINK", "js", "issue", "NUMBER", "LINK", "Again", "I", "m", "only", "semi", "serious", "about", "this", "NUMBER", "I", "mostly", "just", "want", "to", "hear", "when", "you", "would", "ever", "need", "a", "union", "type", "NUMBER", "I", "also", "want", "to", "hear", "future", "plan", "for", "how", "the", "union", "type", "will", "evolve", "because", "in", "its", "current", "form", "I", "don", "t", "see", "much", "utility", "asides", "from", "interfaces", "with", "no", "shared", "field", "NUMBER", "At", "a", "minimum", "can", "we", "remove", "the", "requirement", "for", "a", "single", "field", "on", "interfaces", "At", "that", "point", "I", "can", "remove", "union", "types", "from", "my", "projects", "altogether", "wink", "First", "Let", "s", "look", "at", "client", "s", "pattern", "matching", "on", "return", "types", "for", "a", "Union", "in", "my", "client", "code", "pseudo", "code", "switch", "oneOf", "case", "A", "case", "B", "case", "C", "case", "Unknown", "Because", "of", "how", "unions", "must", "be", "queried", "the", "unknown", "type", "be", "the", "empty", "object", "type", "NUMBER", "If", "you", "replace", "the", "word", "union", "with", "interface", "here", "nothing", "else", "change", "NUMBER", "Unions", "and", "interfaces", "even", "match", "against", "the", "same", "__typename", "field", "NUMBER", "Calling", "it", "a", "union", "instead", "of", "an", "interface", "presents", "a", "communication", "challenge", "API", "developers", "must", "make", "sure", "all", "consumers", "know", "that", "a", "union", "may", "have", "more", "less", "variants", "at", "any", "point", "in", "time", "NUMBER", "This", "communication", "must", "be", "made", "because", "in", "other", "languages", "unions", "have", "great", "utility", "by", "be", "exhaustive", "NUMBER", "By", "calling", "it", "an", "interface", "and", "not", "a", "union", "the", "assumption", "that", "the", "type", "be", "not", "fix", "be", "encoded", "in", "the", "dialog", "NUMBER", "A", "Union", "be", "a", "way", "to", "say", "I", "may", "return", "one", "of", "a", "few", "things", "at", "this", "location", "it", "should", "be", "defined", "locally", "to", "the", "field", "NUMBER", "For", "example", "a", "Video", "type", "doesn", "t", "need", "to", "describe", "that", "it", "might", "appear", "alongside", "Photo", "for", "some", "specific", "field", "though", "a", "specific", "field", "needs", "to", "describe", "that", "it", "might", "return", "Video", "Photo", "NUMBER", "An", "Interface", "be", "a", "way", "to", "say", "I", "conform", "to", "this", "contract", "it", "should", "be", "defined", "locally", "to", "the", "thing", "which", "conforms", "the", "Object", "type", "NUMBER", "For", "example", "a", "User", "type", "should", "be", "able", "to", "say", "that", "it", "fulfills", "the", "contract", "of", "Profile", "such", "that", "any", "type", "current", "know", "or", "unknown", "can", "be", "use", "knowing", "that", "it", "fulfills", "the", "contract", "NUMBER", "This", "be", "a", "good", "point", "and", "you", "re", "right", "the", "ergonomics", "of", "unions", "be", "better", "in", "this", "case", "NUMBER", "However", "should", "ergonomics", "alone", "define", "whether", "something", "should", "be", "in", "the", "spec", "Also", "your", "argument", "here", "revolves", "around", "type", "definition", "which", "be", "not", "even", "part", "of", "the", "spec", "NUMBER", "GraphQL", "implementations", "may", "choose", "to", "allow", "users", "to", "define", "an", "interface", "just", "as", "one", "may", "define", "a", "union", "NUMBER", "Also", "what", "if", "an", "implementation", "decided", "to", "make", "types", "open", "ended", "like", "in", "TypeScript", "graphql", "type", "A", "a", "Int", "type", "B", "b", "Int", "type", "C", "c", "Int", "union", "U", "A", "B", "C", "Desugars", "to", "the", "following", "in", "an", "open", "ended", "system", "graphql", "type", "A", "a", "Int", "type", "B", "b", "Int", "type", "C", "c", "Int", "interface", "U", "type", "A", "implement", "U", "type", "B", "implement", "U", "type", "C", "implement", "U", "Here", "you", "get", "the", "same", "benefits", "of", "local", "definition", "with", "interfaces", "NUMBER", "Let", "s", "not", "argue", "about", "whether", "or", "not", "defining", "GraphQL", "in", "an", "open", "ended", "manner", "like", "this", "be", "good", "or", "bad", "the", "point", "of", "the", "demonstration", "be", "to", "show", "that", "it", "be", "up", "to", "the", "GraphQL", "schema", "implementor", "to", "solve", "the", "I", "may", "return", "one", "of", "a", "few", "things", "at", "this", "location", "case", "and", "not", "the", "specification", "NUMBER", "Consumption", "of", "the", "union", "doesn", "t", "change", "for", "the", "client", "whether", "it", "be", "a", "marker", "interface", "or", "a", "union", "NUMBER", "I", "see", "ergonomics", "in", "type", "definition", "which", "be", "not", "even", "specified", "as", "the", "only", "argument", "for", "unions", "NUMBER", "If", "we", "let", "ergonomics", "alone", "define", "whether", "unions", "should", "be", "in", "the", "spec", "that", "sets", "a", "slippery", "slope", "precedent", "NUMBER", "Another", "quick", "note", "in", "the", "case", "of", "union", "SearchResult", "Person", "Post", "NUMBER", "I", "think", "such", "a", "union", "be", "an", "anti", "pattern", "NUMBER", "I", "personally", "think", "the", "better", "schema", "design", "would", "be", "types", "like", "so", "graphql", "interface", "SearchResult", "type", "PersonSearchResult", "implement", "SearchResult", "person", "Person", "type", "PostSearchResult", "implement", "SearchResult", "post", "Post", "As", "in", "the", "future", "this", "allows", "schema", "designers", "to", "add", "new", "field", "without", "make", "breaking", "change", "at", "the", "cost", "of", "one", "inexpensive", "level", "of", "indirection", "NUMBER", "An", "example", "field", "to", "be", "add", "may", "be", "relevance", "NUMBER", "If", "this", "be", "the", "best", "pattern", "then", "these", "pseudo", "unions", "be", "for", "all", "intents", "and", "purposes", "defined", "locally", "anyway", "as", "most", "of", "the", "time", "PersonSearchResult", "and", "PostSearchResult", "will", "generally", "be", "defined", "locally", "or", "at", "least", "near", "SearchResult", "NUMBER", "This", "concept", "of", "contract", "less", "interfaces", "be", "often", "call", "marker", "interfaces", "NUMBER", "They", "re", "typically", "use", "either", "as", "a", "backfill", "for", "languages", "like", "Java", "that", "don", "t", "have", "a", "good", "concept", "of", "Union", "or", "be", "use", "as", "metadata", "annotations", "for", "languages", "that", "don", "t", "have", "metadata", "annotations", "NUMBER", "I", "don", "t", "think", "either", "should", "apply", "to", "GraphQL", "for", "modeling", "data", "domains", "NUMBER", "I", "think", "the", "tradeoff", "between", "the", "bad", "taste", "of", "marker", "interfaces", "and", "simplifying", "the", "spec", "for", "beginners", "and", "tooling", "be", "a", "fine", "one", "to", "make", "blush", "Anyway", "I", "think", "I", "ve", "said", "all", "I", "have", "to", "say", "on", "the", "matter", "NUMBER", "I", "might", "never", "use", "unions", "but", "ultimately", "I", "don", "t", "feel", "too", "strongly", "remove", "them", "for", "everyone", "else", "NUMBER", "In", "my", "opinion", "over", "time", "unions", "be", "only", "going", "to", "make", "the", "spec", "and", "subsequently", "ecosystem", "more", "complicated", "NUMBER", "So", "if", "we", "can", "remove", "them", "now", "without", "breaking", "a", "lot", "of", "things", "why", "not", "If", "you", "haven", "t", "be", "convinced", "by", "any", "of", "the", "argument", "above", "feel", "free", "to", "close", "this", "issue", "Closing", "this", "aging", "issue", "calebmer", "this", "be", "an", "interesting", "idea", "and", "I", "ve", "come", "across", "it", "as", "well", "recently", "NUMBER", "I", "find", "that", "allowing", "interface", "to", "have", "no", "field", "can", "be", "useful", "but", "union", "would", "also", "be", "needed", "in", "some", "scenarios", "NUMBER", "For", "instance", "union", "be", "more", "flexible", "when", "re", "use", "types", "NUMBER", "Here", "s", "my", "two", "cents", "NUMBER", "gql", "type", "ObjA", "type", "ObjB", "type", "ObjC", "union", "U", "NUMBER", "ObjA", "ObjB", "union", "U", "NUMBER", "ObjB", "ObjC", "Without", "union", "you", "ll", "have", "to", "declare", "more", "types", "because", "each", "type", "will", "be", "strictly", "coupled", "with", "only", "one", "interface", "NUMBER", "gql", "interface", "U", "NUMBER", "interface", "U", "NUMBER", "type", "ObjA", "implement", "U", "NUMBER", "type", "ObjB", "implement", "U", "NUMBER", "type", "ObjB", "implement", "U", "NUMBER", "type", "ObjC", "implement", "U", "NUMBER", "Another", "use", "case", "be", "when", "you", "need", "to", "deal", "with", "exist", "types", "interface", "can", "t", "help", "NUMBER", "Say", "I", "need", "to", "define", "a", "field", "in", "a", "type", "that", "could", "be", "String", "Int", "or", "Float", "NUMBER", "With", "union", "I", "can", "easily", "make", "it", "like", "this", "gql", "union", "CustomData", "String", "Int", "Float", "type", "Obj", "cData", "CustomData", "IvanGoncharov", "thanks", "for", "point", "them", "out", "It", "s", "good", "to", "know", "that", "it", "support", "implement", "multiple", "interfaces", "and", "it", "doesn", "t", "support", "scalar", "union", "which", "surprises", "me", "I", "think", "that", "s", "probably", "why", "this", "issue", "NUMBER", "be", "still", "open", "NUMBER", "Hmm", "let", "me", "see", "if", "I", "understand", "correctly", "Validation", "should", "still", "insist", "on", "not", "allowing", "unknown", "field", "to", "an", "input", "object", "NUMBER", "This", "means", "if", "the", "value", "of", "an", "input", "object", "be", "provide", "as", "a", "_literal_", "it", "should", "only", "contain", "input", "field", "defined", "for", "that", "input", "object", "right", "This", "suggestion", "be", "to", "change", "the", "behavior", "when", "the", "value", "be", "provide", "as", "a", "_variable_", "previously", "extra", "field", "should", "have", "resulted", "in", "an", "error", "but", "now", "they", "d", "just", "be", "ignored", "If", "I", "ve", "get", "it", "right", "NUMBER", "from", "me", "NUMBER", "I", "don", "t", "_remember_", "putting", "that", "validation", "in", "graphql", "ruby", "in", "the", "first", "place", "Just", "to", "be", "clear", "suppose", "we", "have", "an", "input", "object", "Contact", "that", "has", "a", "value", "and", "type", "field", "NUMBER", "query", "UserByContact", "user", "contact", "value", "foo", "bar", "NUMBER", "com", "type", "EMAIL", "extraField", "false", "name", "be", "invalid", "but", "query", "UserByContact", "contact", "ContactInput", "user", "contact", "contact", "name", "variables", "contact", "value", "foo", "bar", "NUMBER", "com", "type", "EMAIL", "extraField", "false", "be", "not", "invalid", "Reviving", "this", "again", "because", "not", "sure", "what", "happened", "to", "this", "but", "why", "not", "just", "do", "a", "strict", "input", "validation", "on", "non", "null", "object", "types", "and", "allow", "extra", "unspecified", "field", "I", "know", "the", "reasoning", "behind", "typo", "but", "I", "don", "t", "see", "why", "we", "can", "t", "have", "a", "property", "like", "allow", "unknows", "true", "on", "a", "specific", "object", "input", "type", "NUMBER", "Accepting", "unknown", "field", "allows", "clients", "to", "create", "constraints", "on", "the", "evolution", "of", "the", "schema", "NUMBER", "For", "example", "if", "a", "client", "sends", "an", "extra", "field", "and", "the", "server", "ignores", "it", "then", "the", "server", "later", "add", "that", "field", "it", "can", "retroactively", "break", "the", "clients", "that", "over", "sent", "NUMBER", "If", "the", "client", "be", "important", "enough", "then", "that", "field", "name", "be", "burned", "and", "cannot", "be", "add", "NUMBER", "This", "type", "of", "break", "be", "hard", "to", "detect", "ahead", "of", "time", "and", "the", "names", "most", "logical", "for", "over", "sending", "artifacts", "of", "client", "implementation", "be", "the", "ones", "most", "logical", "to", "be", "add", "to", "the", "schema", "later", "NUMBER", "This", "happened", "to", "me", "maintaining", "a", "public", "api", "over", "the", "course", "of", "many", "years", "NUMBER", "I", "m", "reading", "through", "the", "spec", "on", "GitHub", "at", "the", "moment", "NUMBER", "So", "I", "see", "some", "discrepancy", "in", "GitHub", "render", "output", "NUMBER", "So", "here", "be", "small", "change", "to", "make", "markdown", "more", "GFM", "friendly", "NUMBER", "I", "fix", "some", "inconsistency", "in", "how", "tokens", "be", "defined", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "If", "you", "be", "contribute", "on", "behalf", "of", "someone", "else", "eg", "your", "employer", "the", "individual", "CLA", "be", "not", "sufficient", "use", "LINK", "company", "instead", "NUMBER", "Contact", "cla", "fb", "NUMBER", "com", "if", "you", "have", "any", "question", "NUMBER", "leebyron", "Thank", "you", "for", "incorporating", "format", "change", "into", "spec", "NUMBER", "I", "opened", "NUMBER", "issue", "with", "a", "suggestion", "on", "how", "to", "prevent", "confusion", "about", "lexical", "grammar", "in", "future", "NUMBER", "This", "brings", "together", "many", "of", "the", "considerations", "about", "a", "__id", "unique", "identifier", "field", "into", "one", "document", "NUMBER", "There", "be", "still", "a", "lot", "of", "work", "to", "do", "before", "this", "becomes", "a", "merge", "able", "diff", "on", "the", "spec", "Agree", "on", "field", "semantics", "specified", "in", "this", "PR", "Restructure", "the", "spec", "so", "that", "the", "description", "for", "__id", "can", "live", "next", "to", "__typename", "Write", "the", "change", "to", "the", "spec", "calebmer", "leebyron", "any", "initial", "thoughts", "I", "recall", "seeing", "that", "the", "__", "prefix", "was", "reserved", "for", "introspection", "and", "based", "on", "the", "current", "precedence", "introspection", "be", "really", "around", "the", "type", "system", "NUMBER", "So", "therefore", "it", "feels", "odd", "that", "the", "value", "of", "__id", "would", "change", "for", "different", "instances", "of", "the", "same", "type", "NUMBER", "Which", "means", "would", "this", "not", "be", "instance", "specific", "and", "better", "off", "served", "by", "having", "common", "conventions", "and", "practices", "of", "a", "meaningful", "id", "field", "Another", "piece", "of", "feedback", "be", "just", "at", "a", "high", "level", "why", "should", "we", "be", "including", "this", "in", "the", "spec", "with", "additional", "behavior", "rather", "than", "simply", "make", "an", "id", "ID", "field", "a", "best", "practice", "for", "cacheable", "types", "The", "spec", "should", "be", "as", "small", "as", "possible", "and", "no", "smaller", "so", "we", "should", "ensure", "we", "have", "a", "strong", "argument", "for", "moving", "this", "from", "best", "practice", "to", "spec", "NUMBER", "Specifically", "I", "think", "the", "argument", "client", "caches", "would", "like", "to", "rely", "on", "this", "be", "a", "little", "faulty", "as", "we", "already", "have", "client", "caches", "that", "rely", "on", "different", "form", "of", "pagination", "and", "connection", "models", "with", "those", "as", "best", "practices", "and", "no", "impact", "on", "the", "spec", "NUMBER", "In", "my", "opinion", "the", "specification", "of", "__id", "be", "perhaps", "the", "most", "important", "addition", "to", "the", "spec", "for", "GraphQL", "s", "future", "NUMBER", "Cacheability", "be", "a", "side", "benefit", "of", "what", "an", "__id", "field", "gives", "us", "the", "__id", "field", "gives", "us", "identity", "NUMBER", "Vanilla", "GraphQL", "be", "incredibly", "powerful", "for", "the", "first", "data", "query", "but", "after", "that", "first", "query", "reconciling", "data", "from", "mutations", "subscriptions", "and", "other", "queries", "be", "an", "incredibly", "hard", "problem", "NUMBER", "Falcor", "get", "the", "identity", "story", "right", "with", "paths", "at", "the", "cost", "of", "good", "pagination", "and", "resource", "identity", "was", "a", "fundamental", "principle", "of", "REST", "for", "good", "reasons", "NUMBER", "Being", "able", "to", "identify", "data", "be", "important", "so", "then", "the", "next", "question", "be", "how", "we", "identify", "that", "data", "NUMBER", "Whichever", "approach", "we", "choose", "it", "must", "be", "consistent", "NUMBER", "There", "be", "problem", "with", "id", "ID", "which", "has", "become", "best", "practice", "thanks", "to", "Relay", "NUMBER", "chiefly", "that", "the", "name", "id", "conflict", "with", "SQL", "field", "names", "NUMBER", "So", "then", "we", "need", "an", "alternative", "which", "exists", "in", "renaming", "the", "field", "to", "__id", "NUMBER", "However", "use", "a", "name", "like", "__id", "be", "useless", "unless", "the", "tooling", "agrees", "NUMBER", "In", "my", "opinion", "fragmentation", "be", "not", "worth", "keep", "this", "out", "of", "the", "spec", "NUMBER", "So", "in", "summary", "this", "issue", "in", "my", "opinion", "be", "the", "most", "important", "issue", "to", "resolve", "for", "the", "long", "term", "success", "of", "GraphQL", "and", "since", "there", "be", "problem", "with", "the", "community", "solution", "Relay", "id", "name", "choice", "to", "avoid", "fragmentation", "we", "should", "standardize", "data", "identity", "with", "a", "solution", "which", "be", "both", "agreeable", "by", "the", "community", "and", "will", "help", "to", "build", "much", "better", "developer", "tooling", "NUMBER", "Also", "just", "a", "thought", "if", "instead", "of", "having", "__id", "s", "be", "null", "if", "they", "don", "t", "exist", "on", "the", "type", "then", "they", "be", "a", "base", "NUMBER", "encoding", "of", "a", "path", "to", "the", "data", "from", "the", "last", "__id", "graphql", "__id", "Encoded", "value", "of", "an", "empty", "path", "or", "array", "NUMBER", "a", "__id", "User", "defined", "to", "be", "the", "value", "unique", "id", "NUMBER", "b", "__id", "Encoded", "path", "unique", "id", "b", "NUMBER", "c", "x", "true", "__id", "Encoded", "path", "unique", "id", "b", "c", "alias", "d", "__id", "Encoded", "path", "unique", "id", "b", "c", "alias", "I", "don", "t", "particularly", "like", "this", "idea", "but", "leebyron", "mention", "requiring", "non", "nullable", "ids", "by", "default", "wink", "NUMBER", "Ultimately", "I", "don", "t", "think", "miss", "an", "__id", "on", "a", "user", "would", "be", "a", "huge", "deal", "in", "practice", "it", "just", "wouldn", "t", "be", "normalized", "by", "the", "client", "NUMBER", "calebmer", "coincidentally", "this", "be", "very", "similar", "to", "how", "the", "Apollo", "Client", "cache", "deals", "with", "miss", "IDs", "NUMBER", "In", "a", "final", "decision", "where", "this", "should", "be", "a", "common", "practice", "then", "id", "ID", "would", "be", "the", "recommendation", "NUMBER", "This", "be", "pretty", "inconvenient", "if", "GraphQL", "be", "meant", "as", "a", "thin", "API", "layer", "since", "people", "often", "have", "underlying", "model", "objects", "that", "already", "have", "an", "id", "field", "NUMBER", "__id", "even", "if", "it", "s", "not", "build", "into", "GraphQL", "seems", "like", "a", "reasonable", "recommendation", "because", "it", "s", "something", "everyone", "can", "follow", "even", "if", "they", "already", "have", "a", "pre", "defined", "id", "field", "NUMBER", "Another", "piece", "of", "feedback", "be", "just", "at", "a", "high", "level", "why", "should", "we", "be", "including", "this", "in", "the", "spec", "with", "additional", "behavior", "rather", "than", "simply", "make", "an", "id", "ID", "field", "a", "best", "practice", "for", "cacheable", "types", "The", "spec", "should", "be", "as", "small", "as", "possible", "and", "no", "smaller", "so", "we", "should", "ensure", "we", "have", "a", "strong", "argument", "for", "moving", "this", "from", "best", "practice", "to", "spec", "NUMBER", "There", "s", "one", "big", "argument", "for", "this", "be", "in", "the", "spec", "which", "be", "similar", "to", "calebmer", "s", "this", "gives", "GraphQL", "tool", "services", "and", "libraries", "the", "ability", "to", "reliably", "cache", "data", "come", "from", "any", "GraphQL", "server", "NUMBER", "I", "d", "argue", "that", "be", "a", "much", "more", "fundamental", "requirement", "than", "pagination", "NUMBER", "Given", "that", "having", "the", "__id", "field", "be", "queryable", "on", "every", "single", "object", "even", "if", "the", "server", "doesn", "t", "want", "to", "present", "an", "ID", "for", "that", "field", "be", "important", "for", "tool", "that", "want", "to", "be", "able", "to", "cache", "data", "but", "not", "run", "introspection", "ahead", "of", "time", "NUMBER", "Specifically", "for", "Apollo", "Client", "it", "s", "incredibly", "advantageous", "that", "we", "don", "t", "need", "to", "require", "schema", "knowledge", "to", "do", "many", "useful", "GraphQL", "things", "NUMBER", "Even", "if", "the", "ultimate", "best", "solution", "to", "some", "problem", "requires", "introspection", "caching", "be", "so", "useful", "that", "it", "s", "good", "to", "include", "in", "the", "get", "start", "experience", "NUMBER", "In", "the", "current", "situation", "NUMBER", "id", "can", "t", "be", "turned", "on", "by", "default", "because", "some", "servers", "expose", "a", "field", "call", "id", "that", "isn", "t", "unique", "and", "NUMBER", "Requesting", "the", "id", "from", "the", "client", "requires", "either", "manually", "typing", "that", "field", "in", "the", "query", "or", "doing", "introspection", "so", "it", "requires", "extra", "setup", "and", "work", "This", "means", "that", "people", "get", "start", "with", "GraphQL", "can", "t", "get", "the", "benefits", "of", "caching", "without", "a", "lot", "of", "effort", "and", "makes", "GraphQL", "seem", "less", "powerful", "out", "of", "the", "box", "NUMBER", "If", "this", "proposal", "or", "similar", "could", "be", "include", "in", "the", "spec", "then", "every", "single", "GraphQL", "tool", "could", "have", "caching", "build", "in", "by", "default", "NUMBER", "It", "s", "important", "to", "separate", "aspects", "of", "__id", "that", "would", "be", "convenient", "from", "those", "that", "be", "necessary", "to", "achieve", "certain", "ends", "NUMBER", "It", "s", "already", "possible", "to", "write", "a", "GraphQL", "client", "that", "correctly", "caches", "data", "come", "from", "any", "server", "NUMBER", "This", "can", "be", "achieved", "with", "product", "specific", "configuration", "e", "NUMBER", "g", "NUMBER", "a", "mapping", "of", "type", "names", "to", "the", "identifying", "field", "s", "to", "use", "or", "with", "convention", "as", "in", "Relay", "s", "Object", "Identification", "spec", "NUMBER", "Given", "that", "__id", "be", "primarily", "a", "convenience", "for", "cache", "identification", "NUMBER", "As", "leebyron", "point", "out", "though", "other", "proposals", "may", "require", "something", "like", "__id", "A", "defer", "directive", "that", "cause", "the", "server", "to", "return", "the", "data", "for", "a", "query", "in", "several", "stages", "NUMBER", "Clients", "would", "need", "some", "way", "to", "interpret", "subsequent", "responses", "NUMBER", "This", "may", "or", "may", "not", "be", "feasible", "without", "a", "way", "to", "easily", "identify", "the", "root", "object", "NUMBER", "Pre", "normalized", "responses", "NUMBER", "There", "be", "a", "tradeoff", "between", "response", "size", "and", "response", "processing", "time", "NUMBER", "For", "clients", "that", "normalize", "a", "response", "it", "_may_", "be", "preferable", "to", "receive", "an", "already", "normalized", "response", "NUMBER", "This", "would", "require", "the", "server", "to", "know", "how", "to", "identify", "records", "either", "via", "__id", "or", "some", "other", "mechanism", "NUMBER", "Delta", "payloads", "for", "live", "queries", "and", "or", "subscriptions", "NUMBER", "Informing", "a", "client", "about", "how", "the", "results", "of", "a", "previously", "executed", "query", "has", "change", "could", "take", "several", "form", "returning", "an", "update", "complete", "query", "result", "or", "returning", "a", "partial", "result", "NUMBER", "A", "delta", "payload", "could", "rely", "on", "__id", "NUMBER", "On", "the", "one", "hand", "I", "do", "see", "a", "lot", "of", "value", "in", "__id", "from", "a", "client", "caching", "perspective", "NUMBER", "However", "it", "seems", "more", "relevant", "in", "the", "context", "of", "future", "proposals", "NUMBER", "Would", "it", "make", "sense", "to", "flush", "out", "these", "more", "advance", "use", "cases", "first", "I", "m", "concerned", "that", "nuances", "of", "how", "__id", "would", "work", "could", "make", "these", "features", "more", "challenging", "NUMBER", "As", "an", "example", "should", "defer", "be", "allow", "anywhere", "or", "only", "on", "types", "that", "have", "an", "__id", "If", "it", "s", "allow", "anywhere", "how", "should", "a", "client", "interpret", "a", "deferred", "response", "that", "doesn", "t", "have", "a", "cacheable", "root", "id", "It", "s", "even", "possible", "that", "__id", "isn", "t", "required", "for", "some", "of", "these", "features", "NUMBER", "That", "s", "not", "the", "main", "reason", "I", "m", "interested", "in", "this", "proposal", "NUMBER", "I", "mostly", "just", "think", "it", "s", "unfortunate", "that", "such", "a", "core", "feature", "of", "pretty", "much", "all", "GraphQL", "servers", "and", "clients", "be", "unspecified", "and", "requires", "extra", "configuration", "which", "makes", "it", "harder", "to", "build", "generic", "tool", "NUMBER", "But", "let", "s", "take", "a", "look", "defer", "I", "think", "this", "can", "easily", "be", "implement", "without", "caching", "IDs", "NUMBER", "The", "new", "results", "can", "simply", "have", "a", "JSON", "path", "in", "the", "same", "format", "as", "the", "error", "path", "in", "NUMBER", "which", "will", "allow", "the", "client", "to", "put", "the", "new", "result", "in", "the", "right", "place", "NUMBER", "Of", "course", "that", "requires", "maintaining", "the", "original", "query", "result", "until", "the", "rest", "of", "the", "query", "results", "arrive", "but", "I", "think", "that", "s", "preferable", "to", "_requiring_", "caching", "IDs", "for", "any", "deferred", "field", "NUMBER", "Normalized", "responses", "From", "my", "understanding", "of", "how", "Relay", "and", "Apollo", "work", "a", "normalized", "transport", "wouldn", "t", "help", "either", "one", "NUMBER", "Both", "clients", "have", "different", "opinions", "about", "how", "the", "normalization", "should", "be", "do", "and", "so", "neither", "would", "use", "the", "graphql", "spec", "normalization", "directly", "NUMBER", "Perhaps", "a", "normalized", "transport", "would", "make", "the", "response", "size", "more", "efficient", "but", "in", "that", "case", "it", "might", "be", "able", "to", "use", "something", "like", "JSON", "paths", "Although", "I", "agree", "it", "would", "be", "more", "compelling", "to", "have", "it", "use", "a", "standard", "ID", "especially", "since", "it", "would", "only", "make", "sense", "to", "normalize", "repeated", "objects", "which", "would", "need", "to", "be", "identified", "NUMBER", "Delta", "payloads", "for", "livequeries", "I", "think", "these", "and", "defer", "should", "ideally", "be", "the", "same", "since", "defer", "seems", "like", "just", "a", "special", "case", "of", "sending", "a", "result", "patch", "where", "the", "path", "doesn", "t", "intersect", "with", "already", "received", "data", "NUMBER", "In", "my", "mind", "this", "be", "a", "case", "of", "taking", "something", "that", "be", "very", "clearly", "a", "best", "practice", "in", "GraphQL", "that", "almost", "any", "serious", "tool", "needs", "to", "take", "advantage", "of", "and", "make", "it", "standard", "NUMBER", "I", "think", "almost", "anything", "can", "be", "do", "without", "a", "standardized", "__id", "so", "my", "feeling", "be", "that", "it", "will", "never", "be", "more", "than", "a", "convenience", "NUMBER", "But", "a", "lot", "of", "things", "in", "GraphQL", "be", "a", "convenience", "so", "I", "feel", "like", "that", "shouldn", "t", "disqualify", "this", "proposal", "NUMBER", "Just", "wanted", "to", "add", "my", "NUMBER", "cents", "into", "this", "discussion", "NUMBER", "In", "general", "I", "don", "t", "have", "anything", "against", "a", "build", "in", "concept", "of", "id", "in", "GraphQL", "spec", "NUMBER", "But", "I", "would", "strongly", "agree", "with", "leebyron", "not", "all", "objects", "in", "the", "schema", "have", "an", "ID", "NUMBER", "Some", "of", "them", "do", "in", "this", "case", "the", "id", "field", "must", "be", "not", "null", "NUMBER", "I", "also", "thinking", "about", "implications", "on", "the", "end", "users", "who", "be", "write", "a", "GraphQL", "server", "and", "possible", "complexity", "of", "GraphQL", "server", "implementation", "itself", "NUMBER", "For", "instance", "it", "would", "be", "very", "inconvenient", "if", "I", "need", "to", "explicitly", "define", "an", "ID", "for", "every", "single", "GraphQL", "object", "type", "in", "the", "schema", "especially", "if", "they", "should", "be", "globally", "unique", "NUMBER", "I", "doubt", "that", "it", "would", "be", "even", "possible", "in", "most", "cases", "NUMBER", "I", "also", "not", "very", "optimistic", "about", "generically", "inferring", "constructed", "IDs", "based", "on", "some", "real", "object", "IDs", "NUMBER", "For", "instance", "give", "this", "schema", "graphql", "type", "User", "id", "String", "profilePicture", "size", "Int", "Image", "type", "Image", "width", "Int", "height", "Int", "url", "String", "labels", "ImageLabel", "type", "ImageLabel", "name", "String", "description", "String", "and", "this", "query", "graphql", "query", "AwesomePictures", "user", "id", "NUMBER", "id", "awesomePicture", "profilePicture", "size", "NUMBER", "awesomeLabels", "labels", "description", "According", "to", "the", "semantics", "of", "my", "data", "only", "User", "has", "a", "semantic", "ID", "which", "be", "not", "globally", "unique", "in", "my", "experience", "many", "applications", "model", "data", "in", "this", "way", "everything", "else", "may", "or", "may", "not", "have", "an", "ID", "which", "be", "unique", "within", "particular", "user", "if", "you", "like", "DDD", "then", "the", "Aggregate", "and", "Aggregate", "Root", "would", "be", "a", "good", "analogy", "NUMBER", "What", "would", "be", "the", "ID", "of", "the", "labels", "in", "this", "case", "Something", "like", "user", "NUMBER", "awesomePicture_size_", "NUMBER", "awesomeLabels", "NUMBER", "user", "NUMBER", "awesomePicture_size_", "NUMBER", "awesomeLabels", "NUMBER", "etc", "NUMBER", "Maybe", "instead", "of", "defining", "an", "__id", "field", "in", "the", "spec", "we", "can", "define", "an", "interface", "that", "has", "an", "id", "field", "just", "like", "relay", "do", "graphql", "interface", "__Identifiable", "id", "ID", "With", "this", "interface", "user", "can", "very", "precisely", "identify", "which", "objects", "do", "have", "an", "identifier", "and", "which", "don", "t", "NUMBER", "I", "think", "this", "will", "have", "a", "huge", "advantage", "not", "only", "for", "client", "side", "caching", "but", "also", "for", "normalized", "data", "transfer", "NUMBER", "I", "m", "thinking", "about", "JSON", "Graph", "LINK", "here", "NUMBER", "The", "problem", "be", "that", "we", "can", "t", "really", "unify", "particular", "object", "within", "different", "parts", "of", "the", "query", "because", "the", "same", "field", "name", "may", "have", "very", "different", "semantic", "value", "or", "even", "type", "if", "alias", "be", "use", "NUMBER", "But", "we", "have", "the", "similar", "situation", "with", "fragment", "unification", "NUMBER", "It", "be", "solve", "with", "OverlappingFieldsCanBeMerged", "validation", "rule", "which", "ensures", "that", "fragment", "can", "be", "unified", "NUMBER", "If", "we", "have", "standard", "__Identifiable", "interface", "then", "maybe", "we", "can", "write", "similar", "validation", "thus", "introduce", "additional", "constraint", "for", "identifiable", "types", "that", "must", "be", "merge", "able", "NUMBER", "Just", "a", "brainstorming", "idea", "haven", "t", "put", "too", "much", "though", "into", "it", "yet", "NUMBER", "It", "looks", "there", "s", "a", "consensus", "that", "having", "an", "__id", "field", "that", "be", "guaranteed", "to", "be", "queryable", "on", "every", "type", "but", "be", "sometimes", "null", "isn", "t", "something", "people", "want", "NUMBER", "I", "think", "it", "would", "allow", "great", "improvement", "for", "GraphQL", "clients", "that", "don", "t", "require", "special", "build", "tooling", "but", "perhaps", "that", "isn", "t", "part", "of", "people", "s", "desires", "for", "how", "GraphQL", "should", "be", "use", "NUMBER", "In", "my", "mind", "the", "biggest", "benefit", "would", "come", "from", "allowing", "__id", "to", "be", "queried", "on", "every", "selection", "set", "just", "like", "__typename", "without", "knowing", "whether", "the", "underlying", "type", "actually", "has", "an", "ID", "or", "not", "NUMBER", "Without", "that", "property", "I", "think", "this", "be", "mostly", "indistinguishable", "from", "a", "client", "specific", "convention", "to", "use", "a", "special", "interface", "like", "Node", "which", "could", "be", "discover", "through", "introspection", "as", "usual", "NUMBER", "So", "there", "could", "be", "a", "different", "proposal", "that", "would", "NUMBER", "Add", "a", "special", "interface", "like", "Node", "to", "the", "specification", "and", "NUMBER", "Specify", "the", "semantics", "and", "name", "of", "the", "ID", "field", "like", "__id", "and", "global", "uniqueness", "NUMBER", "I", "also", "not", "very", "optimistic", "about", "generically", "inferring", "constructed", "IDs", "based", "on", "some", "real", "object", "IDs", "NUMBER", "In", "my", "original", "proposal", "they", "would", "simply", "be", "returned", "as", "null", "when", "the", "server", "doesn", "t", "have", "a", "semantic", "ID", "to", "offer", "NUMBER", "I", "agree", "that", "generating", "non", "semantic", "IDs", "on", "the", "server", "be", "not", "a", "good", "idea", "NUMBER", "Now", "that", "I", "think", "about", "it", "given", "this", "build", "in", "Node", "interface", "it", "should", "be", "straightforward", "to", "transparently", "define", "an", "__id", "ID", "nullable", "meta", "field", "in", "terms", "of", "it", "which", "be", "available", "on", "all", "object", "types", "NUMBER", "The", "availability", "of", "__id", "on", "all", "types", "be", "a", "powerful", "property", "for", "simpler", "schemaless", "GraphQL", "clients", "so", "I", "stand", "by", "it", "NUMBER", "However", "I", "would", "rather", "see", "that", "split", "into", "another", "RFC", "and", "just", "define", "the", "global", "identity", "semantics", "of", "an", "__id", "field", "in", "this", "RFC", "if", "we", "could", "more", "easily", "get", "this", "RFC", "through", "NUMBER", "At", "a", "minimum", "we", "should", "standardize", "the", "semantics", "of", "an", "__id", "field", "to", "avoid", "fragmentation", "as", "we", "have", "determined", "object", "identification", "be", "something", "all", "reasonably", "powerful", "GraphQL", "clients", "need", "NUMBER", "Per", "stubailo", "and", "calebmer", "s", "comments", "above", "I", "d", "propose", "that", "we", "separate", "this", "into", "two", "proposals", "defining", "the", "semantics", "of", "the", "__id", "field", "and", "a", "separate", "discussion", "about", "if", "how", "GraphQL", "should", "make", "tradeoffs", "to", "allow", "schema", "less", "clients", "NUMBER", "__id", "Semantics", "I", "would", "argue", "that", "the", "schema", "be", "one", "of", "the", "strengths", "of", "GraphQL", "as", "it", "enable", "build", "client", "tooling", "NUMBER", "As", "such", "the", "introspection", "results", "should", "accurately", "indicate", "the", "full", "list", "of", "field", "that", "be", "selectable", "on", "any", "given", "type", "NUMBER", "This", "suggests", "that", "either", "__id", "should", "be", "selectable", "everywhere", "and", "nullable", "or", "that", "it", "should", "be", "non", "nullable", "and", "only", "selectable", "on", "types", "that", "implement", "it", "NUMBER", "For", "clients", "it", "be", "very", "helpful", "to", "know", "_statically_", "which", "types", "and", "therefore", "which", "field", "in", "a", "query", "be", "identifiable", "NUMBER", "We", "have", "use", "this", "knowledge", "to", "polyfill", "defer", "and", "connection", "edge", "streaming", "in", "Relay", "for", "example", "NUMBER", "If", "the", "introspection", "query", "were", "to", "indicate", "that", "all", "types", "had", "a", "nullable", "__id", "then", "these", "types", "of", "polyfills", "would", "be", "much", "harder", "as", "the", "client", "would", "not", "have", "enough", "information", "to", "know", "how", "to", "split", "up", "a", "query", "NUMBER", "Given", "this", "I", "d", "_strongly_", "prefer", "that", "we", "make", "__id", "non", "nullable", "required", "to", "have", "globally", "unique", "values", "and", "only", "appear", "in", "the", "schema", "introspection", "query", "where", "defined", "by", "the", "user", "for", "a", "given", "type", "NUMBER", "Querying", "__id", "Everywhere", "Schema", "less", "Clients", "This", "leaves", "open", "the", "question", "of", "whether", "it", "should", "be", "allow", "to", "send", "a", "query", "that", "asks", "for", "__id", "everywhere", "even", "on", "field", "whose", "type", "do", "not", "implement", "the", "field", "the", "server", "could", "theoretically", "return", "null", "or", "omit", "the", "field", "for", "those", "types", "that", "don", "t", "implement", "it", "NUMBER", "I", "think", "it", "s", "useful", "to", "separate", "this", "discussion", "from", "this", "__id", "RFC", "the", "two", "be", "only", "tangentially", "relate", "NUMBER", "Stepping", "back", "this", "aspect", "of", "the", "proposal", "be", "really", "about", "whether", "the", "specification", "should", "allow", "clients", "to", "send", "_un_validated", "and", "therefore", "possibly", "_invalid_", "queries", "Selecting", "field", "like", "id", "or", "__id", "that", "may", "not", "exist", "Adding", "fragment", "spreads", "of", "an", "invalid", "type", "Sending", "input", "objects", "with", "additional", "field", "not", "defined", "in", "the", "schema", "Our", "experience", "with", "Relay", "and", "our", "native", "GraphQL", "clients", "has", "shown", "the", "benefits", "of", "_embracing_", "the", "schema", "any", "degree", "to", "which", "it", "may", "be", "inconvenient", "to", "load", "the", "schema", "in", "advance", "has", "be", "offset", "by", "all", "the", "possibilities", "that", "affords", "NUMBER", "That", "said", "this", "be", "definitely", "something", "we", "should", "discuss", "more", "generally", "in", "a", "separate", "RFC", "NUMBER", "Next", "Steps", "stubailo", "Thanks", "again", "for", "kicking", "off", "this", "RFC", "and", "discussion", "NUMBER", "What", "do", "you", "think", "about", "update", "the", "text", "to", "reflect", "the", "above", "Does", "the", "shortened", "proposal", "basically", "come", "down", "to", "NUMBER", "If", "your", "schema", "defines", "globally", "unique", "IDs", "for", "some", "or", "all", "objects", "they", "should", "be", "in", "a", "field", "named", "__id", "NUMBER", "The", "__id", "field", "shouldn", "t", "be", "use", "for", "anything", "else", "NUMBER", "__id", "be", "in", "the", "introspection", "result", "like", "any", "other", "field", "Or", "be", "there", "anything", "else", "And", "yes", "I", "think", "there", "could", "be", "a", "general", "discussion", "to", "be", "had", "about", "the", "benefits", "of", "schema", "less", "GraphQL", "client", "libraries", "and", "tool", "and", "some", "simple", "change", "that", "could", "make", "them", "much", "more", "convenient", "to", "build", "and", "use", "NUMBER", "The", "benefit", "here", "be", "simplifying", "adoption", "of", "GraphQL", "as", "the", "next", "standard", "for", "APIs", "such", "tool", "will", "inherently", "be", "easier", "to", "adopt", "than", "those", "which", "require", "special", "tooling", "or", "schema", "access", "the", "same", "way", "that", "untyped", "languages", "be", "easier", "to", "get", "start", "with", "than", "typed", "ones", "and", "generally", "require", "less", "tooling", "NUMBER", "Where", "would", "be", "the", "best", "place", "to", "have", "that", "discussion", "Or", "be", "there", "anything", "else", "stubailo", "That", "s", "a", "good", "summary", "yup", "And", "yes", "I", "think", "there", "could", "be", "a", "general", "discussion", "to", "be", "had", "about", "the", "benefits", "of", "schema", "less", "GraphQL", "client", "libraries", "and", "tool", "NUMBER", "Where", "would", "be", "the", "best", "place", "to", "have", "that", "discussion", "How", "about", "open", "another", "issue", "for", "this", "topic", "in", "order", "to", "start", "the", "discussion", "and", "get", "more", "input", "It", "would", "be", "good", "to", "clearly", "define", "the", "goal", "first", "in", "order", "to", "ground", "the", "discussion", "and", "_then_", "list", "out", "any", "technical", "challenges", "that", "make", "that", "goal", "harder", "to", "achieve", "under", "the", "current", "spec", "NUMBER", "I", "think", "we", "re", "one", "or", "two", "steps", "away", "from", "a", "RFC", "as", "there", "may", "be", "better", "alternatives", "than", "just", "allowing", "__id", "to", "be", "selectable", "anywhere", "NUMBER", "Looking", "forward", "to", "discussing", "in", "more", "detail", "Easy", "to", "auto", "add", "to", "queries", "for", "schemaless", "clients", "NUMBER", "I", "m", "not", "sure", "this", "be", "a", "factor", "for", "id", "as", "compared", "to", "__id", "NUMBER", "I", "think", "taking", "up", "the", "name", "id", "can", "be", "a", "pretty", "big", "disadvantage", "because", "then", "you", "have", "to", "start", "having", "field", "like", "sqlId", "or", "something", "NUMBER", "I", "could", "also", "argue", "that", "the", "pit", "of", "success", "would", "have", "us", "make", "the", "id", "field", "which", "corresponds", "to", "caching", "and", "occasionally", "refetching", "as", "easy", "to", "guess", "and", "use", "as", "possible", "NUMBER", "Deciding", "the", "GraphQL", "specification", "be", "going", "to", "favor", "one", "path", "or", "put", "of", "success", "over", "another", "the", "specification", "begins", "to", "assume", "a", "certain", "use", "case", "which", "can", "be", "dangerous", "NUMBER", "Naming", "the", "field", "__id", "to", "avoid", "collisions", "be", "not", "just", "about", "preserving", "space", "for", "SQL", "id", "field", "but", "preserving", "space", "for", "new", "innovative", "GraphQL", "designs", "NUMBER", "The", "field", "name", "id", "for", "two", "ridiculous", "examples", "could", "stand", "for", "Indonesian", "the", "language", "code", "of", "which", "be", "id", "LINK", "_language", "or", "Freud", "s", "Id", "LINK", "_ego_and_super", "ego", "part", "of", "his", "psychic", "apparatus", "NUMBER", "More", "realistically", "by", "constraining", "the", "id", "field", "applications", "like", "GatsbyJS", "LINK", "gdom", "LINK", "and", "PostGraphQL", "LINK", "which", "generate", "a", "schema", "from", "the", "file", "system", "XML", "and", "database", "respectively", "must", "design", "workarounds", "to", "avoid", "collisions", "NUMBER", "All", "of", "these", "applications", "may", "be", "able", "to", "make", "use", "of", "identifying", "the", "data", "in", "their", "responses", "but", "not", "all", "may", "appreciate", "the", "naming", "collision", "NUMBER", "Alternative", "proposal", "After", "better", "understanding", "some", "of", "the", "hesitations", "around", "the", "__", "prefix", "and", "gaining", "some", "inspiration", "from", "leebyron", "s", "mention", "of", "an", "identifiable", "directive", "here", "be", "a", "rough", "alternative", "direction", "we", "could", "go", "for", "the", "same", "benefits", "NUMBER", "It", "seems", "as", "if", "the", "name", "of", "the", "unique", "cache", "key", "field", "should", "really", "be", "a", "schema", "designer", "s", "decision", "NUMBER", "We", "can", "hopefully", "agree", "that", "by", "specify", "id", "we", "may", "limit", "creativity", "and", "by", "specify", "the", "name", "__id", "we", "introduce", "confusion", "and", "make", "the", "semantics", "of", "__", "field", "less", "clear", "NUMBER", "Since", "we", "can", "t", "agree", "on", "a", "name", "let", "us", "give", "the", "naming", "power", "to", "schema", "designers", "with", "a", "identifier", "directive", "NUMBER", "It", "may", "look", "as", "follows", "graphql", "type", "Person", "_id", "ID", "identifier", "name", "String", "interface", "Node", "id", "ID", "identifier", "type", "Post", "implement", "Node", "id", "ID", "identifier", "title", "String", "Or", "graphql", "type", "Person", "identifiable", "field", "_id", "_id", "ID", "name", "String", "interface", "Node", "identifiable", "field", "id", "id", "ID", "type", "Post", "implement", "Node", "identifiable", "interface", "Node", "id", "ID", "title", "String", "A", "field", "on", "a", "type", "or", "interface", "may", "be", "marked", "as", "the", "type", "s", "identifier", "field", "NUMBER", "That", "field", "must", "have", "a", "type", "of", "ID", "and", "must", "take", "no", "argument", "NUMBER", "A", "type", "must", "only", "have", "one", "field", "marked", "as", "an", "identifier", "NUMBER", "If", "a", "type", "inherits", "from", "an", "interface", "where", "one", "of", "the", "field", "be", "marked", "as", "an", "identifier", "the", "field", "on", "the", "type", "with", "the", "same", "name", "must", "also", "be", "marked", "as", "an", "identifier", "NUMBER", "What", "the", "identifier", "directive", "means", "semantically", "be", "that", "the", "value", "of", "the", "field", "be", "unique", "for", "all", "values", "of", "that", "type", "NUMBER", "Note", "that", "it", "do", "not", "mean", "the", "field", "be", "globally", "unique", "just", "locally", "unique", "for", "that", "type", "NUMBER", "So", "an", "identifier", "directive", "on", "the", "id", "field", "of", "the", "Relay", "Node", "interface", "would", "mean", "the", "same", "thing", "as", "it", "do", "now", "NUMBER", "The", "id", "must", "be", "unique", "across", "all", "other", "Node", "values", "NUMBER", "In", "clients", "the", "cache", "key", "would", "become", "the", "__typename", "combined", "with", "the", "identifier", "NUMBER", "So", "in", "the", "above", "example", "Person", "value", "NUMBER", "or", "Node", "value", "NUMBER", "would", "be", "the", "key", "NUMBER", "In", "the", "introspection", "query", "if", "we", "wanted", "to", "get", "real", "meta", "the", "__Type", "type", "s", "name", "field", "could", "be", "marked", "as", "an", "identifier", "NUMBER", "Pros", "No", "naming", "collisions", "NUMBER", "Gives", "schema", "designer", "total", "control", "over", "their", "types", "NUMBER", "Backwards", "compatible", "with", "Relay", "NUMBER", "schemas", "NUMBER", "Just", "mark", "id", "as", "an", "identifier", "everywhere", "NUMBER", "Users", "can", "have", "non", "globally", "unique", "identifiers", "NUMBER", "They", "could", "use", "SQL", "serial", "ids", "or", "plain", "UUIDs", "and", "mark", "them", "with", "identifier", "as", "long", "as", "they", "don", "t", "inherit", "from", "an", "interface", "which", "marks", "the", "same", "field", "NUMBER", "Cons", "No", "room", "for", "schemaless", "clients", "may", "actually", "make", "the", "schemaless", "client", "use", "case", "much", "harder", "to", "implement", "NUMBER", "Unless", "we", "also", "wanted", "to", "add", "an", "__id", "or", "__identifierValue", "field", "which", "was", "always", "queryable", "and", "returned", "the", "identifier", "value", "NUMBER", "But", "then", "we", "be", "back", "to", "bikeshedding", "over", "__id", "NUMBER", "More", "API", "configuration", "NUMBER", "Requires", "a", "change", "to", "introspection", "queries", "NUMBER", "Interaction", "between", "interface", "identifiers", "and", "type", "identifiers", "may", "be", "confusing", "NUMBER", "stubailo", "could", "you", "please", "explain", "this", "a", "bit", "more", "in", "detail", "And", "yes", "I", "think", "there", "could", "be", "a", "general", "discussion", "to", "be", "had", "about", "the", "benefits", "of", "schema", "less", "GraphQL", "client", "libraries", "and", "tool", "and", "some", "simple", "change", "that", "could", "make", "them", "much", "more", "convenient", "to", "build", "and", "use", "NUMBER", "I", "don", "t", "mean", "to", "derail", "this", "conversation", "but", "I", "d", "really", "like", "to", "understand", "where", "you", "were", "heading", "with", "this", "because", "if", "it", "be", "what", "I", "think", "it", "be", "you", "get", "a", "from", "me", "NUMBER", "However", "this", "be", "my", "confusion", "NUMBER", "If", "it", "be", "what", "I", "think", "you", "were", "get", "at", "then", "any", "definition", "of", "a", "fix", "field", "type", "even", "an", "ID", "which", "be", "so", "common", "basically", "kills", "my", "understanding", "thus", "my", "ask", "for", "a", "bit", "of", "an", "explanation", "NUMBER", "I", "guess", "this", "be", "my", "question", "NUMBER", "Isn", "t", "the", "notion", "of", "variable", "schema", "I", "don", "t", "like", "the", "term", "schema", "less", "as", "it", "be", "inappropriate", "and", "the", "necessity", "of", "an", "ID", "field", "contradictory", "Scott", "I", "m", "going", "to", "close", "this", "PR", "since", "there", "doesn", "t", "seem", "to", "be", "a", "clear", "consensus", "about", "the", "design", "of", "such", "an", "addition", "to", "the", "spec", "or", "whether", "it", "s", "necessary", "at", "all", "NUMBER", "I", "be", "partial", "to", "Lee", "s", "idea", "in", "LINK", "issuecomment", "NUMBER", "about", "constraining", "any", "field", "named", "id", "to", "be", "unique", "and", "of", "type", "ID", "however", "also", "mindful", "that", "this", "might", "break", "a", "significant", "number", "of", "non", "Relay", "apps", "who", "have", "previously", "not", "be", "constrained", "to", "such", "a", "requirement", "NUMBER", "I", "still", "deeply", "believe", "that", "standardizing", "the", "concept", "of", "an", "identifier", "for", "objects", "will", "make", "GraphQL", "more", "useful", "overall", "and", "reduce", "the", "amount", "of", "boilerplate", "and", "configuration", "most", "developers", "need", "to", "write", "so", "if", "there", "be", "an", "agreement", "on", "how", "that", "can", "happen", "I", "d", "be", "happy", "to", "write", "a", "PR", "for", "the", "spec", "NUMBER", "Thanks", "for", "your", "work", "so", "far", "on", "this", "NUMBER", "I", "m", "still", "interested", "in", "a", "solution", "for", "broad", "identifiability", "NUMBER", "Hopefully", "we", "can", "find", "consensus", "on", "this", "in", "a", "future", "RFC", "Reopening", "from", "LINK", "with", "a", "real", "branch", "NUMBER", "This", "be", "helpful", "for", "clients", "to", "identify", "why", "there", "be", "a", "null", "in", "the", "response", "because", "that", "could", "be", "due", "to", "an", "error", "or", "an", "actual", "null", "result", "NUMBER", "leebyron", "should", "I", "also", "change", "should", "to", "must", "in", "the", "passage", "above", "If", "an", "error", "can", "be", "associated", "to", "a", "particular", "point", "in", "the", "request", "GraphQL", "document", "it", "should", "contain", "an", "entry", "with", "the", "key", "locations", "with", "a", "list", "of", "locations", "where", "each", "location", "be", "a", "map", "with", "the", "keys", "line", "and", "column", "both", "positive", "numbers", "starting", "from", "NUMBER", "which", "describe", "the", "beginning", "of", "an", "associated", "syntax", "element", "NUMBER", "leebyron", "ping", "about", "the", "question", "above", "NUMBER", "leebyron", "anything", "blocking", "this", "PR", "Let", "me", "know", "if", "I", "can", "make", "any", "more", "improvement", "NUMBER", "NUMBER", "for", "this", "NUMBER", "We", "already", "depend", "on", "path", "in", "our", "proxy", "tool", "LINK", "guru", "graphql", "faker", "NUMBER", "It", "be", "critical", "for", "us", "since", "we", "modify", "queries", "inject", "__typename", "remove", "mocked", "field", "NUMBER", "before", "sending", "them", "to", "a", "GraphQL", "server", "NUMBER", "Because", "of", "that", "we", "have", "to", "recalculate", "line", "and", "column", "properties", "of", "locations", "array", "based", "on", "path", "value", "NUMBER", "Super", "excited", "about", "add", "this", "into", "the", "next", "spec", "release", "NUMBER", "We", "ve", "be", "use", "it", "in", "graphql", "js", "experimentally", "for", "a", "while", "and", "it", "s", "quite", "helpful", "This", "do", "not", "explain", "how", "to", "represent", "the", "path", "for", "a", "selection", "that", "uses", "a", "fragment", "NUMBER", "hlship", "path", "represent", "path", "of", "the", "response", "field", "So", "path", "be", "not", "affected", "by", "fragment", "at", "all", "since", "fragment", "doesn", "t", "change", "response", "NUMBER", "Fair", "enough", "I", "was", "focusing", "too", "much", "on", "what", "our", "implementation", "currently", "do", "NUMBER", "On", "Tue", "Jun", "NUMBER", "NUMBER", "at", "NUMBER", "NUMBER", "PM", "Ivan", "Goncharov", "TAG", "write", "hlship", "TAG", "path", "represent", "path", "of", "the", "response", "field", "So", "path", "be", "not", "affected", "by", "fragment", "at", "all", "since", "fragment", "doesn", "t", "change", "response", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "Howard", "M", "NUMBER", "Lewis", "Ship", "Senior", "Mobile", "Developer", "at", "Walmart", "Labs", "Creator", "of", "Apache", "Tapestry", "NUMBER", "NUMBER", "NUMBER", "LINK", "hlship", "hlship", "I", "think", "spec", "will", "benefit", "from", "clarification", "NUMBER", "This", "example", "can", "be", "rewritten", "as", "LINK", "example", "bc", "NUMBER", "graphql", "hero", "episode", "episode", "name", "heroFriends", "friends", "NUMBER", "characterInfo", "fragment", "characterInfo", "on", "Character", "id", "name", "Will", "it", "make", "the", "spec", "more", "clear", "I", "guess", "this", "means", "that", "certain", "directives", "will", "need", "to", "include", "array", "argument", "rather", "than", "having", "one", "argument", "and", "use", "the", "directive", "multiple", "times", "eg", "comments", "refetchOn", "channels", "newComment", "removedComment", "Rather", "than", "comments", "refetchOn", "channel", "newComment", "refetchOn", "channel", "removedComment", "Seems", "reasonable", "to", "require", "the", "directive", "to", "decide", "if", "it", "wants", "to", "accept", "multiple", "inputs", "NUMBER", "Hi", "Setup", "We", "re", "in", "the", "process", "of", "implement", "a", "GraphQL", "server", "for", "the", "programming", "language", "Erlang", "and", "we", "re", "trying", "to", "get", "by", "with", "only", "reading", "the", "specification", "and", "looking", "relatively", "little", "at", "code", "in", "the", "hope", "this", "will", "uncover", "some", "inconsistencies", "in", "the", "spec", "NUMBER", "In", "general", "I", "m", "really", "happy", "with", "the", "specification", "but", "I", "need", "some", "clarification", "on", "the", "combination", "of", "_non", "null_", "when", "it", "be", "combined", "with", "the", "_list_", "type", "NUMBER", "I", "feel", "this", "combination", "be", "part", "of", "the", "dynamic", "semantics", "of", "GraphQL", "which", "be", "execution", "semantics", "NUMBER", "Yet", "the", "only", "section", "in", "the", "draft", "spec", "which", "covers", "this", "be", "section", "NUMBER", "LINK", "sec", "Combining", "List", "and", "Non", "Null", "which", "be", "part", "of", "the", "introspection", "system", "NUMBER", "I", "m", "not", "sure", "why", "it", "be", "there", "and", "not", "in", "the", "execution", "semantics", "of", "the", "spec", "where", "I", "would", "have", "expected", "to", "find", "this", "NUMBER", "Is", "there", "another", "place", "where", "this", "be", "write", "down", "and", "be", "I", "reading", "the", "spec", "with", "too", "much", "skimming", "Also", "I", "m", "not", "sure", "how", "to", "read", "the", "NUMBER", "section", "with", "respect", "to", "evaluation", "semantics", "NUMBER", "In", "order", "to", "be", "able", "to", "ask", "the", "question", "here", "be", "my", "example", "taken", "from", "an", "internal", "test", "schema", "where", "we", "be", "build", "a", "dungeon", "containing", "rooms", "monsters", "and", "so", "on", "type", "Stats", "shellScripting", "Int", "How", "good", "a", "monster", "be", "at", "shell", "scripting", "yell", "String", "type", "Monster", "id", "Id", "name", "String", "statsV", "NUMBER", "Stats", "statsV", "NUMBER", "Stats", "statsV", "NUMBER", "Stats", "statsV", "NUMBER", "Stats", "NUMBER", "As", "you", "can", "see", "we", "have", "monsters", "and", "monsters", "have", "stats", "possibly", "many", "in", "a", "list", "NUMBER", "We", "can", "represent", "a", "monster", "internally", "as", "a", "record", "monster", "id", "NUMBER", "name", "Two", "Headed", "Ogre", "stats", "stats", "shell_scripting", "null", "yell", "I", "m", "Ready", "stats", "shell_scripting", "NUMBER", "yell", "I", "m", "NOT", "Ready", "And", "we", "can", "resolve", "the", "field", "of", "statsV", "NUMBER", "NUMBER", "statsV", "NUMBER", "by", "use", "the", "stats", "field", "of", "that", "record", "NUMBER", "The", "question", "be", "how", "it", "would", "resolve", "NUMBER", "Expectation", "The", "two", "headed", "ogre", "we", "just", "defined", "has", "a", "bug", "when", "rendering", "stats", "for", "the", "two", "heads", "the", "first", "head", "has", "a", "shell", "scripting", "value", "of", "null", "which", "will", "produce", "an", "error", "for", "the", "Stats", "object", "of", "a", "non", "nullable", "shellScripting", "field", "NUMBER", "This", "means", "an", "error", "will", "be", "raise", "for", "the", "first", "head", "while", "the", "second", "head", "will", "render", "okay", "NUMBER", "Lets", "set", "up", "a", "query", "document", "query", "Q", "NUMBER", "monster", "id", "NUMBER", "statsV", "NUMBER", "shellScripting", "yell", "query", "Q", "NUMBER", "monster", "id", "NUMBER", "statsV", "NUMBER", "shellScripting", "yell", "query", "Q", "NUMBER", "monster", "id", "NUMBER", "statsV", "NUMBER", "shellScripting", "yell", "query", "Q", "NUMBER", "monster", "id", "NUMBER", "statsV", "NUMBER", "shellScripting", "yell", "Q", "NUMBER", "In", "this", "case", "I", "think", "the", "output", "would", "be", "data", "monster", "statsV", "NUMBER", "null", "shellScripting", "NUMBER", "yell", "I", "m", "NOT", "Ready", "The", "resolver", "for", "Stats", "will", "return", "null", "for", "the", "shellScripting", "field", "which", "be", "_non", "null_", "and", "thus", "the", "whole", "object", "becomes", "null", "NUMBER", "It", "be", "reflected", "in", "the", "list", "NUMBER", "Q", "NUMBER", "I", "think", "the", "output", "would", "be", "data", "monster", "null", "Since", "the", "null", "NUMBER", "output", "for", "statsV", "NUMBER", "means", "there", "be", "a", "null", "value", "in", "the", "context", "of", "Stats", "and", "this", "be", "not", "allow", "NUMBER", "Thus", "the", "whole", "monster", "becomes", "null", "NUMBER", "Q", "NUMBER", "I", "think", "the", "output", "would", "be", "data", "monster", "statsV", "NUMBER", "shellScripting", "NUMBER", "yell", "I", "m", "NOT", "Ready", "Since", "the", "rule", "be", "that", "null", "entries", "be", "remove", "from", "the", "list", "at", "least", "that", "be", "how", "I", "read", "NUMBER", "in", "this", "case", "NUMBER", "Q", "NUMBER", "Either", "disallowed", "by", "the", "static", "semantics", "or", "it", "essentially", "behaves", "as", "Q", "NUMBER", "Current", "implementation", "I", "have", "I", "run", "this", "by", "a", "recursion", "over", "the", "list", "entry", "NUMBER", "Resolution", "of", "the", "underlying", "objects", "in", "the", "list", "returns", "a", "value", "that", "be", "either", "ok", "or", "an", "error", "ok", "Object", "error", "Reason", "This", "means", "we", "have", "the", "following", "list", "resolve", "in", "the", "execution", "engine", "error", "null_field", "shellScripting", "ok", "SecondHeadObject", "Where", "the", "binding", "of", "SecondHeadObject", "be", "TAG", "NUMBER", "TAG", "TAG", "an", "Erlang", "map", "type", "we", "can", "turn", "into", "a", "JSON", "object", "later", "NUMBER", "We", "can", "now", "scrutinize", "the", "modifiers", "NUMBER", "There", "be", "NUMBER", "cases", "Q", "NUMBER", "Turn", "error", "_", "into", "null", "values", "and", "ok", "_", "into", "normal", "values", "NUMBER", "Easy", "NUMBER", "Q", "NUMBER", "The", "case", "be", "a", "NUMBER", "i", "NUMBER", "e", "NUMBER", "a", "list", "wrapped", "in", "a", "non", "null", "modifier", "NUMBER", "Check", "the", "list", "for", "error", "_", "terms", "NUMBER", "If", "one", "be", "find", "return", "error", "NUMBER", "for", "this", "field", "NUMBER", "Otherwise", "turn", "ok", "_", "into", "normal", "values", "and", "return", "those", "NUMBER", "Q", "NUMBER", "The", "case", "be", "NUMBER", "i", "NUMBER", "e", "NUMBER", "a", "non", "null", "modifier", "wrapped", "in", "a", "list", "NUMBER", "Filter", "the", "list", "and", "pick", "ok", "_", "values", "only", "NUMBER", "Q", "NUMBER", "Handle", "as", "Q", "NUMBER", "What", "I", "don", "t", "particularly", "like", "about", "this", "implementation", "be", "that", "it", "doesn", "t", "compose", "too", "well", "NUMBER", "I", "have", "to", "look", "at", "which", "modifier", "be", "the", "outer", "one", "List", "Non", "null", "and", "which", "be", "the", "inner", "one", "and", "then", "handle", "these", "by", "looking", "at", "both", "at", "the", "same", "time", "NUMBER", "I", "d", "much", "have", "preferred", "a", "semantics", "where", "I", "could", "have", "handle", "non", "null", "and", "list", "separately", "in", "the", "execution", "engine", "NUMBER", "But", "perhaps", "my", "semantics", "be", "just", "off", "Question", "Am", "I", "right", "or", "completely", "off", "track", "here", "Can", "I", "help", "improving", "the", "specification", "in", "any", "way", "Note", "I", "m", "not", "a", "native", "English", "speaker", "this", "may", "have", "an", "effect", "But", "before", "I", "can", "submit", "a", "request", "on", "the", "specification", "I", "would", "need", "to", "know", "the", "logic", "behind", "the", "dynamic", "execution", "semantics", "of", "the", "above", "queries", "in", "question", "NUMBER", "Thanks", "in", "Advance", "I", "read", "Stats", "as", "preventing", "the", "list", "from", "be", "null", "but", "allowing", "elements", "of", "the", "list", "to", "be", "null", "so", "I", "would", "expect", "Q", "NUMBER", "to", "behave", "identically", "to", "Q", "NUMBER", "Q", "NUMBER", "Since", "the", "rule", "be", "that", "null", "entries", "be", "remove", "from", "the", "list", "at", "least", "that", "be", "how", "I", "read", "NUMBER", "in", "this", "case", "NUMBER", "That", "s", "not", "how", "I", "read", "NUMBER", "but", "I", "could", "be", "wrong", "NUMBER", "My", "interpretation", "of", "Stats", "be", "that", "the", "list", "itself", "may", "be", "null", "but", "that", "it", "may", "not", "contain", "null", "elements", "NUMBER", "I", "don", "t", "have", "any", "spec", "to", "back", "this", "up", "but", "I", "would", "assume", "that", "resolution", "would", "behave", "the", "same", "way", "as", "when", "a", "non", "null", "field", "returns", "null", "so", "the", "end", "result", "would", "be", "data", "monster", "statsV", "NUMBER", "null", "The", "element", "of", "the", "list", "cannot", "be", "null", "so", "the", "null", "propagates", "to", "the", "list", "field", "as", "a", "whole", "which", "can", "NUMBER", "Q", "NUMBER", "Either", "disallowed", "by", "the", "static", "semantics", "or", "it", "essentially", "behaves", "as", "Q", "NUMBER", "This", "definitely", "behaves", "as", "you", "describe", "Q", "NUMBER", "The", "null", "propagates", "until", "it", "reaches", "monster", "which", "be", "nullable", "NUMBER", "Hi", "Evan", "Lee", "Thank", "you", "both", "for", "your", "comments", "NUMBER", "I", "m", "somewhat", "offline", "with", "a", "cold", "at", "the", "moment", "but", "I", "just", "wanted", "to", "give", "you", "a", "heads", "up", "and", "thanks", "NUMBER", "I", "ll", "come", "back", "to", "this", "with", "a", "vengeance", "later", "on", "once", "I", "have", "a", "better", "understanding", "and", "my", "brain", "be", "back", "on", "line", "Having", "read", "through", "it", "all", "In", "your", "example", "there", "be", "a", "case", "I", "m", "not", "sure", "I", "understand", "fully", "NUMBER", "The", "case", "be", "Int", "and", "the", "other", "value", "cases", "the", "result", "you", "write", "be", "a", "b", "null", "but", "as", "int", "be", "non", "nullable", "I", "would", "have", "expected", "that", "to", "propagate", "to", "the", "wrapper", "a", "null", "NUMBER", "But", "perhaps", "I", "m", "mistaken", "What", "ultimately", "led", "me", "astray", "was", "the", "NUMBER", "section", "NUMBER", "If", "the", "modify", "type", "of", "a", "List", "be", "Non", "Null", "then", "that", "List", "may", "not", "contain", "any", "null", "items", "NUMBER", "I", "read", "this", "as", "T", "for", "some", "type", "T", "NUMBER", "But", "this", "outright", "contradicts", "what", "you", "write", "above", "NUMBER", "If", "the", "modify", "type", "of", "a", "Non", "Null", "be", "List", "then", "null", "be", "not", "accepted", "however", "an", "empty", "list", "be", "accepted", "NUMBER", "I", "read", "this", "as", "T", "for", "some", "type", "T", "NUMBER", "Also", "in", "direct", "contradiction", "NUMBER", "I", "see", "how", "I", "flipped", "the", "designators", "by", "accident", "NUMBER", "Perhaps", "because", "there", "be", "a", "subtlety", "pick", "up", "naturally", "by", "native", "English", "speakers", "I", "fail", "to", "pick", "up", "Maybe", "one", "could", "add", "the", "type", "scheme", "explicitly", "so", "the", "mistake", "isn", "t", "made", "NUMBER", "Once", "I", "read", "through", "your", "examples", "it", "becomes", "quite", "clear", "how", "this", "be", "to", "be", "resolve", "and", "the", "documentation", "be", "actually", "pretty", "precise", "around", "CompleteValue", "NUMBER", "NUMBER", "You", "resolve", "the", "inner", "type", "of", "the", "non", "null", "field", "and", "then", "complete", "that", "field", "NUMBER", "One", "thing", "I", "would", "have", "write", "different", "in", "section", "NUMBER", "on", "value", "completion", "be", "point", "NUMBER", "c", "on", "how", "to", "complete", "a", "list", "of", "values", "NUMBER", "Specifically", "how", "do", "you", "work", "yourself", "through", "the", "list", "NUMBER", "If", "we", "have", "a", "list", "and", "we", "have", "an", "error", "at", "completing", "the", "element", "with", "a", "given", "index", "i", "do", "we", "still", "try", "to", "complete", "elements", "j", "i", "in", "the", "list", "or", "do", "we", "abort", "completion", "at", "index", "i", "without", "ever", "looking", "at", "the", "remaining", "elements", "In", "particular", "I", "d", "make", "it", "explicit", "how", "the", "presence", "of", "field", "error", "which", "be", "throw", "propagates", "NUMBER", "Mostly", "because", "some", "languages", "be", "less", "likely", "to", "use", "exception", "for", "handle", "the", "control", "flow", "NUMBER", "NUMBER", "I", "can", "somewhat", "guess", "that", "a", "single", "field", "error", "in", "a", "list", "propagates", "that", "error", "upwards", "but", "I", "don", "t", "like", "guessing", "in", "specifications", "Also", "in", "section", "NUMBER", "point", "NUMBER", "tells", "me", "how", "to", "handle", "a", "non", "null", "value", "but", "it", "doesn", "t", "say", "how", "to", "handle", "the", "presence", "of", "an", "error", "explicitly", "NUMBER", "Specifically", "in", "your", "case", "above", "we", "have", "Int", "Error", "whooops", "NUMBER", "This", "be", "clearly", "a", "non", "null", "Integer", "type", "NUMBER", "So", "we", "recurse", "on", "the", "inner", "type", "use", "point", "NUMBER", "to", "resolve", "the", "Int", "scalar", "NUMBER", "This", "point", "says", "nothing", "about", "the", "resolution", "of", "an", "error", "NUMBER", "But", "we", "can", "argue", "that", "Error", "whooops", "be", "not", "a", "valid", "so", "it", "resolve", "to", "null", "which", "point", "NUMBER", "knows", "how", "to", "handle", "by", "throw", "a", "field", "error", "NUMBER", "But", "if", "we", "have", "Int", "whoops", "then", "the", "non", "null", "handler", "in", "point", "NUMBER", "would", "recurse", "to", "point", "NUMBER", "a", "and", "get", "back", "a", "throw", "field", "error", "which", "it", "says", "nothing", "about", "how", "to", "handle", "NUMBER", "In", "point", "NUMBER", "c", "and", "point", "NUMBER", "a", "we", "can", "throw", "a", "field", "error", "NUMBER", "What", "do", "this", "mean", "How", "do", "throw", "error", "propagate", "the", "recursion", "stack", "Are", "they", "handle", "at", "some", "level", "of", "the", "recursion", "or", "do", "they", "bleed", "through", "to", "the", "top", "level", "Perhaps", "my", "query", "becomes", "more", "coherent", "over", "the", "come", "days", "once", "I", "start", "implement", "the", "code", "paths", "of", "value", "completion", "as", "precisely", "as", "possible", "but", "right", "now", "the", "above", "question", "be", "the", "ones", "I", "have", "w", "NUMBER", "r", "NUMBER", "t", "CompleteValue", "NUMBER", "call", "NUMBER", "The", "crux", "be", "the", "interaction", "of", "error", "and", "values", "and", "the", "propagation", "of", "error", "in", "the", "recursion", "stack", "NUMBER", "I", "d", "make", "the", "word", "very", "boring", "and", "nitpicky", "if", "_completedResult_", "be", "an", "error", "then", "NUMBER", "and", "NUMBER", "otherwise", "return", "the", "_completedResult_", "NUMBER", "In", "short", "I", "would", "treat", "exception", "as", "were", "they", "values", "NUMBER", "That", "way", "you", "can", "give", "them", "exception", "semantics", "if", "you", "want", "by", "be", "explicit", "about", "their", "propagation", "NUMBER", "NUMBER", "In", "a", "mechanized", "formalization", "in", "e", "NUMBER", "g", "NUMBER", "Agda", "Coq", "or", "Twelf", "you", "would", "need", "to", "be", "extremely", "specific", "in", "how", "you", "complete", "the", "list", "here", "NUMBER", "The", "interaction", "of", "completion", "with", "error", "would", "need", "to", "be", "nailed", "down", "NUMBER", "NUMBER", "At", "least", "Haskell", "Erlang", "and", "Go", "would", "be", "likely", "to", "avoid", "use", "exception", "as", "control", "flow", "operators", "and", "many", "OCaml", "and", "Standard", "ML", "implementations", "would", "too", "NUMBER", "Hi", "Just", "FYI", "I", "managed", "to", "get", "this", "work", "as", "expected", "in", "the", "code", "I", "have", "so", "there", "be", "no", "reason", "to", "keep", "this", "issue", "open", "unless", "you", "want", "to", "improve", "the", "word", "around", "the", "parts", "where", "I", "went", "astray", "NUMBER", "For", "example", "I", "have", "several", "app", "pages", "with", "several", "graphqls", "which", "have", "lots", "of", "common", "code", "NUMBER", "So", "how", "can", "I", "reuse", "common", "graphql", "code", "between", "several", "graphqls", "like", "the", "_", "include_", "in", "the", "C", "C", "language", "or", "the", "_import_", "in", "the", "Java", "language", "You", "mean", "between", "different", "queries", "That", "s", "what", "fragment", "be", "for", "lizherui", "try", "this", "LINK", "fragment", "Thanks", "Not", "sure", "if", "it", "be", "worth", "change", "this", "NUMBER", "It", "would", "complicate", "the", "grammar", "and", "force", "all", "implementations", "to", "make", "change", "to", "their", "parser", "to", "fix", "something", "that", "probably", "isn", "t", "a", "real", "issue", "for", "anyone", "NUMBER", "Plus", "I", "ve", "actually", "grown", "fond", "of", "this", "little", "quirk", "NUMBER", "If", "we", "ever", "release", "a", "TCK", "I", "suggest", "we", "include", "a", "rule", "that", "makes", "sure", "a", "spec", "compliant", "implementation", "allows", "these", "form", "NUMBER", "Without", "this", "be", "in", "the", "spec", "then", "a", "linter", "be", "just", "a", "perspective", "and", "tool", "would", "need", "to", "support", "whatever", "the", "spec", "said", "otherwise", "it", "would", "be", "a", "bug", "NUMBER", "So", "while", "a", "linter", "would", "help", "a", "query", "writer", "it", "do", "not", "help", "those", "write", "the", "tool", "NUMBER", "Interesting", "I", "would", "expect", "that", "NUMBER", "fragmentName", "should", "be", "allow", "NUMBER", "I", "can", "imagine", "a", "style", "preference", "where", "you", "would", "write", "NUMBER", "myFragment", "to", "match", "NUMBER", "on", "MyType", "NUMBER", "I", "was", "focused", "on", "the", "variable", "use", "case", "title", "of", "the", "issue", "NUMBER", "For", "the", "fragment", "style", "having", "a", "space", "do", "allow", "for", "easier", "readability", "NUMBER", "So", "make", "this", "scoped", "to", "variable", "be", "perfect", "NUMBER", "Looks", "like", "a", "great", "change", "to", "me", "perhaps", "it", "could", "be", "merge", "Or", "we", "could", "make", "a", "branch", "for", "the", "next", "version", "of", "the", "spec", "April", "I", "suppose", "and", "merge", "it", "there", "This", "might", "be", "controversial", "but", "after", "a", "few", "more", "months", "of", "experience", "with", "GraphQL", "I", "still", "believe", "this", "be", "a", "good", "change", "NUMBER", "wincent", "any", "reason", "this", "was", "close", "No", "worries", "I", "agree", "it", "s", "not", "a", "high", "priority", "item", "Let", "s", "say", "I", "m", "work", "on", "my", "BCaaS", "app", "bean", "counter", "as", "a", "service", "NUMBER", "My", "only", "inputs", "be", "Int", "s", "and", "my", "only", "return", "values", "be", "Int", "s", "NUMBER", "Should", "my", "schema", "still", "contain", "GraphQL", "scalars", "like", "String", "and", "Float", "Or", "be", "it", "appropriate", "to", "leave", "those", "types", "out", "since", "they", "aren", "t", "use", "It", "looks", "like", "graphql", "js", "leaves", "out", "unuse", "scalars", "NUMBER", "This", "approach", "makes", "sense", "to", "me", "NUMBER", "GraphQL", "s", "predefined", "scalars", "aren", "t", "universals", "instead", "they", "re", "saving", "the", "user", "a", "step", "of", "defining", "their", "own", "NUMBER", "In", "that", "way", "like", "an", "unuse", "custom", "scalar", "if", "a", "predefined", "scalar", "isn", "t", "use", "it", "s", "not", "present", "in", "the", "schema", "NUMBER", "Is", "that", "intended", "Or", "should", "all", "GraphQL", "schemas", "contain", "the", "predefined", "scalar", "types", "I", "wonder", "if", "GraphQL", "lets", "you", "override", "the", "default", "scalars", "NUMBER", "I", "would", "guess", "no", "since", "they", "be", "use", "in", "introspection", "which", "should", "be", "consistent", "across", "all", "servers", "Same", "PR", "than", "LINK", "js", "pull", "NUMBER", "See", "LINK", "ci", "NUMBER", "com", "user", "notifications", "IRC", "notification", "for", "more", "information", "NUMBER", "Note", "that", "this", "requires", "remove", "the", "n", "flag", "on", "the", "IRC", "channel", "NUMBER", "See", "LINK", "n", "prevent", "external", "send", "Users", "outside", "the", "channel", "may", "not", "send", "message", "to", "it", "NUMBER", "Keep", "in", "mind", "that", "bans", "and", "quiets", "will", "not", "apply", "to", "external", "users", "NUMBER", "In", "Appendix", "B", "Punctuator", "include", "but", "it", "was", "miss", "here", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Currently", "a", "GraphQL", "document", "be", "only", "allows", "a", "SourceCharacter", "u", "NUMBER", "u", "NUMBER", "A", "u", "NUMBER", "D", "u", "NUMBER", "uFFFF", "LINK", "sec", "Source", "Text", "and", "EscapedUnicode", "NUMBER", "NUMBER", "A", "Fa", "f", "NUMBER", "LINK", "EscapedUnicode", "also", "prevents", "unicode", "characters", "above", "U", "FFFF", "from", "be", "include", "into", "a", "GraphQL", "string", "NUMBER", "Unicode", "code", "points", "be", "actually", "in", "the", "range", "NUMBER", "to", "NUMBER", "x", "NUMBER", "FFFF", "NUMBER", "For", "example", "unicode", "emoji", "characters", "LINK", "emoji", "list", "NUMBER", "html", "like", "U", "NUMBER", "F", "NUMBER", "have", "code", "points", "above", "U", "FFFF", "NUMBER", "Is", "there", "any", "reason", "why", "the", "source", "document", "doesn", "t", "allow", "unicode", "characters", "above", "U", "FFFF", "Or", "can", "we", "remove", "that", "restriction", "Without", "that", "restriction", "the", "limitation", "of", "the", "unicode", "escape", "doesn", "t", "seem", "problematic", "NUMBER", "If", "support", "a", "unicode", "escape", "for", "all", "unicode", "characters", "be", "desired", "then", "one", "way", "of", "handle", "that", "be", "the", "way", "swift", "support", "unicode", "escapes", "LINK", "_Programming_Language", "StringsAndCharacters", "NUMBER", "html", "An", "arbitrary", "Unicode", "scalar", "write", "as", "u", "n", "where", "n", "be", "a", "NUMBER", "NUMBER", "digit", "hexadecimal", "number", "with", "a", "value", "equal", "to", "a", "valid", "Unicode", "code", "point", "I", "also", "was", "reading", "the", "spec", "and", "realised", "this", "NUMBER", "Given", "the", "paragraph", "around", "it", "GraphQL", "documents", "be", "expressed", "as", "a", "sequence", "of", "Unicode", "characters", "NUMBER", "However", "with", "few", "exception", "most", "of", "GraphQL", "be", "expressed", "only", "in", "the", "original", "non", "control", "ASCII", "range", "so", "as", "to", "be", "as", "widely", "compatible", "with", "as", "many", "exist", "tool", "languages", "and", "serialization", "formats", "as", "possible", "and", "avoid", "display", "issue", "in", "text", "editors", "and", "source", "control", "NUMBER", "It", "sounds", "to", "me", "an", "error", "of", "ignorance", "rather", "than", "intent", "NUMBER", "Rust", "formerly", "had", "uXXXX", "and", "UXXXXXXXX", "but", "change", "to", "u", "x", "the", "same", "as", "Swift", "do", "some", "time", "before", "Rust", "NUMBER", "JSON", "which", "be", "probably", "the", "main", "inspiration", "for", "the", "GraphQL", "syntax", "do", "uXXXX", "and", "uses", "the", "abomination", "that", "be", "UTF", "NUMBER", "surrogate", "pairs", "LINK", "NUMBER", "U", "NUMBER", "B", "NUMBER", "_to_U", "NUMBER", "B", "NUMBER", "FFFF", "as", "a", "way", "of", "representing", "higher", "order", "characters", "e", "NUMBER", "g", "NUMBER", "U", "NUMBER", "F", "NUMBER", "be", "escaped", "as", "ud", "NUMBER", "d", "ude", "NUMBER", "in", "JSON", "NUMBER", "Fortunately", "you", "can", "avoid", "that", "insanity", "by", "simply", "expressing", "values", "literally", "NUMBER", "There", "s", "no", "real", "need", "for", "the", "escapes", "anyway", "once", "you", "get", "past", "U", "NUMBER", "F", "u", "NUMBER", "XX", "and", "U", "NUMBER", "NUMBER", "Unless", "you", "deal", "with", "combining", "characters", "that", "will", "attach", "to", "a", "string", "s", "quotation", "marks", "which", "be", "fearfully", "ugly", "and", "points", "out", "the", "grammatical", "problem", "of", "parsing", "by", "codepoint", "rather", "than", "grapheme", "cluster", "but", "this", "be", "all", "more", "advance", "stuff", "that", "we", "wish", "wouldn", "t", "happen", "in", "real", "life", "anyway", "NUMBER", "Also", "currently", "the", "escapes", "listed", "EscapedCharacter", "match", "those", "of", "JSON", "NUMBER", "I", "think", "NUMBER", "As", "to", "the", "interpretation", "what", "the", "GraphQL", "spec", "actually", "_says_", "be", "that", "f", "would", "be", "U", "NUMBER", "f", "rather", "than", "U", "NUMBER", "C", "which", "be", "what", "we", "all", "know", "it", "s", "supposed", "to", "be", "NUMBER", "It", "s", "really", "badly", "write", "NUMBER", "Given", "that", "general", "tie", "support", "uXXXX", "might", "not", "be", "a", "terrible", "idea", "with", "or", "without", "u", "X", "NUMBER", "The", "definition", "of", "the", "handle", "of", "EscapedUnicode", "be", "also", "extremely", "tacky", "with", "spelling", "error", "poorly", "defined", "terms", "_", "c", "NUMBER", "_", "Return", "the", "character", "value", "represented", "by", "the", "UTF", "NUMBER", "hexidecimal", "identifier", "EscapedUnicode", "NUMBER", "What", "do", "that", "even", "_mean_", "Seriously", "that", "doesn", "t", "make", "sense", "NUMBER", "This", "stuff", "all", "suggests", "to", "me", "that", "it", "was", "write", "by", "someone", "with", "a", "poor", "understanding", "of", "Unicode", "NUMBER", "This", "spec", "gravely", "needs", "both", "editorial", "and", "technical", "review", "NUMBER", "I", "want", "to", "see", "how", "different", "implementations", "parse", "ud", "NUMBER", "d", "ude", "NUMBER", "nonsensical", "in", "the", "current", "specification", "NUMBER", "If", "GraphQL", "wants", "to", "be", "like", "JSON", "handle", "it", "as", "UTF", "NUMBER", "surrogate", "pairs", "be", "probably", "a", "good", "idea", "NUMBER", "If", "not", "please", "don", "t", "go", "for", "surrogate", "pairs", "the", "grammar", "needs", "to", "be", "change", "to", "allow", "for", "the", "supplemental", "planes", "such", "as", "via", "u", "NUMBER", "F", "NUMBER", "NUMBER", "illegal", "in", "the", "current", "specification", "shouldn", "t", "tokenise", "NUMBER", "However", "I", "hope", "that", "implementations", "accept", "it", "and", "treat", "it", "as", "a", "string", "containing", "the", "code", "point", "U", "NUMBER", "F", "NUMBER", "This", "would", "allow", "chaining", "the", "result", "of", "a", "query", "into", "the", "input", "of", "a", "mutation", "and", "therefore", "atomic", "operations", "from", "the", "point", "of", "view", "of", "the", "client", "NUMBER", "A", "query", "containing", "a", "variable", "assignment", "would", "be", "considered", "a", "pseudo", "mutation", "and", "would", "therefore", "run", "serially", "with", "the", "other", "mutation", "s", "NUMBER", "It", "may", "be", "useful", "to", "be", "able", "to", "retrieve", "the", "value", "of", "variables", "from", "a", "pseudo", "schema", "object", "in", "the", "result", "of", "a", "mutation", "NUMBER", "Related", "to", "NUMBER", "leebyron", "the", "kind", "of", "combined", "query", "mutation", "I", "have", "in", "mind", "would", "simply", "obviate", "the", "need", "for", "a", "second", "round", "trip", "to", "the", "server", "in", "a", "case", "such", "as", "this", "where", "an", "input", "to", "the", "mutation", "be", "required", "which", "can", "only", "be", "obtained", "as", "the", "result", "of", "an", "earlier", "query", "graphql", "repository", "owner", "Mermade", "name", "openapi_specifications", "issue", "last", "NUMBER", "edges", "node", "id", "id", "mutation", "comment", "cmid", "String", "id", "ID", "body", "String", "addComment", "input", "clientMutationId", "cmid", "subjectId", "id", "body", "body", "clientMutationId", "commentEdge", "node", "databaseId", "__variables", "id", "Variables", "json", "cmid", "NUMBER", "body", "New", "comment", "body", "The", "query", "and", "mutation", "may", "have", "to", "be", "wrapped", "together", "or", "the", "query", "be", "performed", "nested", "within", "the", "mutation", "syntax", "be", "unimportant", "at", "this", "stage", "NUMBER", "I", "don", "t", "know", "if", "the", "export", "feature", "describe", "in", "this", "issue", "LINK", "js", "issue", "NUMBER", "be", "be", "propose", "as", "a", "part", "of", "the", "GraphQL", "language", "This", "issue", "would", "require", "another", "capability", "and", "that", "be", "the", "ability", "to", "run", "NUMBER", "operations", "at", "once", "which", "the", "spec", "do", "not", "yet", "allow", "NUMBER", "Variable", "assigment", "via", "say", "export", "would", "only", "be", "available", "if", "multiple", "operations", "be", "allow", "We", "actually", "have", "a", "use", "for", "this", "feature", "for", "A", "B", "test", "NUMBER", "Right", "now", "we", "have", "the", "following", "problem", "we", "have", "the", "feature", "flags", "expose", "as", "graphql", "type", "and", "we", "want", "to", "exclude", "part", "of", "the", "query", "based", "on", "the", "pick", "variant", "NUMBER", "In", "the", "end", "we", "want", "to", "have", "something", "like", "this", "graphql", "query", "Q", "article", "NUMBER", "WidgetA", "query", "this", "only", "feature", "flag", "be", "active", "NUMBER", "WidgetB", "query", "this", "only", "feature", "flag", "be", "inactive", "Right", "now", "our", "options", "be", "NUMBER", "Overfetching", "graphql", "query", "Q", "featureFlags", "isFeatureActive", "article", "NUMBER", "WidgetA", "NUMBER", "WidgetB", "In", "this", "case", "we", "always", "fetch", "all", "necessary", "data", "for", "both", "WidgetA", "and", "WidgetB", "and", "decide", "which", "one", "to", "show", "on", "the", "frontend", "NUMBER", "NUMBER", "Moving", "feature", "flag", "outside", "of", "graphql", "graphql", "query", "Q", "isFeatureActive", "Boolean", "article", "NUMBER", "WidgetA", "include", "if", "isFeatureActive", "NUMBER", "WidgetB", "skip", "if", "isFeatureActive", "With", "export", "directive", "we", "could", "ve", "still", "had", "our", "feature", "flags", "inside", "of", "GraphQL", "schema", "and", "avoid", "overfetching", "graphql", "query", "Flags", "featureFlags", "isFeatureActive", "export", "as", "isFeatureActive", "query", "Q", "isFeatureActive", "Boolean", "article", "NUMBER", "WidgetA", "include", "if", "isFeatureActive", "NUMBER", "WidgetB", "skip", "if", "isFeatureActive", "Right", "now", "we", "be", "trying", "to", "implement", "this", "variant", "on", "top", "of", "exist", "server", "and", "client", "libraries", "but", "would", "be", "nice", "to", "see", "it", "standardized", "NUMBER", "The", "spec", "state", "that", "a", "schema", "requires", "a", "query", "type", "NUMBER", "This", "however", "has", "be", "a", "minor", "source", "of", "frustration", "for", "me", "NUMBER", "For", "example", "Some", "services", "do", "not", "need", "query", "functionality", "NUMBER", "Writing", "test", "for", "mutation", "functionality", "of", "a", "GraphQL", "implementation", "there", "be", "no", "query", "NUMBER", "In", "such", "cases", "a", "dummy", "query", "must", "be", "set", "up", "in", "the", "schema", "NUMBER", "Does", "anyone", "know", "the", "reason", "for", "this", "requirement", "Thank", "you", "Thank", "you", "for", "your", "time", "Curiosity", "sated", "NUMBER", "gitter", "be", "more", "accessible", "If", "we", "look", "for", "accesibleness", "in", "spite", "of", "usability", "IRC", "NUMBER", "IRC", "be", "open", "support", "in", "every", "platform", "and", "you", "do", "not", "even", "have", "to", "register", "anywhere", "NUMBER", "This", "just", "came", "up", "again", "at", "LINK", "NUMBER", "efe", "NUMBER", "df", "NUMBER", "a", "NUMBER", "ec", "NUMBER", "e", "LINK", "be", "relate", "NUMBER", "Turning", "that", "around", "would", "people", "show", "up", "to", "that", "room", "expecting", "in", "depth", "discussion", "and", "help", "and", "then", "be", "disappointed", "with", "GraphQL", "as", "a", "technology", "if", "they", "didn", "t", "receive", "it", "I", "think", "perhaps", "they", "would", "which", "will", "put", "pressure", "on", "GraphQL", "maintainers", "and", "project", "leaders", "to", "spend", "time", "there", "NUMBER", "I", "think", "the", "problem", "lies", "with", "gitter", "not", "allowing", "communities", "to", "appreciate", "it", "s", "platform", "since", "the", "gate", "be", "outright", "close", "NUMBER", "There", "be", "a", "billion", "channels", "on", "the", "web", "for", "discussing", "things", "even", "where", "there", "be", "likely", "no", "maintainers", "NUMBER", "Googling", "graphql", "forum", "brings", "up", "loads", "of", "results", "NUMBER", "The", "github", "integration", "in", "gitter", "be", "second", "to", "none", "NUMBER", "You", "have", "a", "sidebar", "with", "a", "list", "of", "repository", "activity", "with", "popovers", "for", "previewing", "issue", "commit", "comments", "etc", "NUMBER", "Even", "if", "people", "aren", "t", "in", "there", "it", "s", "nice", "to", "see", "a", "list", "of", "activity", "I", "think", "it", "sucks", "that", "I", "ve", "registered", "about", "NUMBER", "Slack", "accounts", "one", "for", "each", "tech", "and", "they", "don", "t", "even", "have", "syntax", "highlight", "NUMBER", "but", "I", "ll", "continue", "doing", "it", "to", "get", "where", "I", "ll", "find", "support", "Perhaps", "the", "room", "could", "be", "opened", "with", "a", "MOTD", "point", "to", "the", "Slack", "channel", "How", "about", "a", "Microsoft", "Teams", "room", "NUMBER", "joking", "Maybe", "LINK", "or", "similar", "could", "be", "use", "to", "bring", "various", "chat", "services", "like", "Slack", "IRC", "and", "Gitter", "together", "for", "the", "GraphQL", "community", "NUMBER", "Sux", "when", "ur", "asked", "for", "help", "and", "have", "to", "make", "another", "room", "I", "disagree", "and", "decided", "to", "do", "just", "that", "last", "night", "NUMBER", "Its", "call", "THE", "DEW", "DROP", "INN", "NUMBER", "Point", "taken", "and", "will", "abide", "men", "NUMBER", "Thannks", "for", "the", "input", "NUMBER", "Hello", "I", "m", "the", "original", "creator", "and", "maintainer", "of", "the", "GraphQL", "for", "NUMBER", "NET", "LINK", "dotnet", "graphql", "dotnet", "project", "NUMBER", "I", "have", "originally", "setup", "the", "project", "to", "serialize", "all", "field", "as", "camelCase", "since", "that", "be", "my", "preference", "and", "seemingly", "idiomatic", "JavaScript", "GraphQL", "NUMBER", "In", "the", "NUMBER", "NET", "world", "however", "there", "can", "be", "strong", "preference", "for", "PascalCase", "even", "in", "your", "returned", "JSON", "structure", "NUMBER", "That", "be", "said", "I", "know", "the", "spec", "specifically", "points", "out", "that", "a", "Name", "be", "case", "sensitive", "LINK", "Name", "NUMBER", "My", "question", "be", "if", "I", "change", "my", "project", "to", "allow", "case", "sensitive", "field", "which", "field", "still", "need", "to", "be", "camelCase", "to", "conform", "to", "the", "spec", "These", "seem", "to", "be", "required", "to", "be", "camelCase", "data", "error", "with", "a", "lowercase", "message", "locations", "line", "and", "column", "Ones", "I", "m", "unsure", "about", "all", "the", "field", "relate", "to", "introspection", "and", "that", "be", "on", "introspection", "types", "such", "as", "name", "description", "args", "type", "isDeprecated", "deprecationReason", "defaultValue", "etc", "NUMBER", "__schema", "__typename", "__type", "etc", "NUMBER", "Are", "there", "others", "that", "I", "m", "miss", "What", "do", "I", "need", "to", "ensure", "be", "camelCase", "to", "conform", "to", "the", "spec", "Thanks", "I", "have", "an", "input", "type", "CreateUser", "NUMBER", "graphql", "input", "CreateUser", "firstName", "String", "I", "be", "use", "it", "to", "define", "a", "mutation", "operation", "createUser", "NUMBER", "graphql", "type", "Mutation", "createUser", "user", "CreateUser", "User", "The", "problem", "use", "this", "approach", "I", "need", "to", "execute", "the", "createUser", "operation", "with", "a", "superfluous", "blog", "object", "e", "NUMBER", "g", "NUMBER", "graphql", "createUser", "user", "firstName", "Gajus", "It", "would", "be", "nice", "if", "I", "were", "able", "to", "execute", "it", "use", "just", "the", "properties", "of", "the", "input", "type", "e", "NUMBER", "g", "NUMBER", "graphql", "createUser", "firstName", "gajus", "Is", "there", "a", "way", "to", "destructure", "the", "input", "type", "in", "the", "definition", "of", "the", "operation", "parameter", "e", "NUMBER", "g", "NUMBER", "graphql", "type", "Mutation", "createUser", "NUMBER", "CreateUser", "User", "Using", "this", "declaration", "I", "be", "get", "an", "error", "GraphQLError", "Syntax", "Error", "GraphQL", "NUMBER", "NUMBER", "Expected", "Name", "find", "NUMBER", "NUMBER", "type", "Mutation", "NUMBER", "createUser", "NUMBER", "CreateUser", "User", "The", "semantics", "of", "EscapedCharacter", "be", "defined", "as", "StringCharacter", "EscapedCharacter", "Return", "the", "character", "value", "of", "EscapedCharacter", "NUMBER", "I", "m", "not", "sure", "what", "this", "actually", "means", "but", "it", "seems", "to", "imply", "that", "you", "would", "return", "the", "same", "sort", "of", "thing", "if", "EscapedCharacter", "be", "and", "if", "it", "be", "n", "NUMBER", "Presumably", "this", "line", "should", "actually", "describe", "how", "b", "f", "n", "r", "and", "t", "map", "to", "other", "characters", "It", "be", "possible", "to", "deprecate", "field", "and", "enum", "values", "but", "not", "input", "values", "or", "argument", "NUMBER", "I", "think", "it", "should", "be", "possible", "to", "deprecate", "optional", "argument", "and", "input", "field", "NUMBER", "A", "natural", "way", "of", "evolving", "the", "schema", "in", "this", "case", "would", "be", "to", "make", "an", "input", "field", "optional", "if", "it", "be", "required", "deprecate", "it", "then", "remove", "it", "once", "clients", "stop", "explicitly", "setting", "the", "value", "NUMBER", "We", "can", "add", "support", "for", "that", "into", "the", "server", "to", "detect", "when", "the", "input", "field", "be", "still", "use", "but", "we", "would", "like", "deprecation", "warnings", "on", "the", "client", "so", "we", "can", "easily", "remove", "usage", "of", "these", "deprecate", "input", "field", "NUMBER", "One", "possible", "workaround", "be", "to", "create", "a", "new", "field", "with", "different", "input", "but", "that", "be", "a", "more", "disruptive", "way", "of", "evolving", "the", "schema", "NUMBER", "Note", "that", "if", "__InputValue", "was", "just", "given", "isDeprecated", "and", "deprecationReason", "field", "then", "that", "would", "mean", "that", "an", "input", "object", "type", "could", "be", "deprecate", "would", "that", "be", "undesirable", "Right", "now", "an", "__Type", "object", "interface", "or", "union", "also", "can", "t", "be", "deprecate", "so", "would", "we", "want", "that", "to", "be", "consistent", "with", "an", "input", "object", "type", "Also", "should", "the", "spec", "disallow", "an", "argument", "to", "be", "deprecate", "if", "it", "be", "non", "null", "i", "NUMBER", "e", "NUMBER", "required", "Otherwise", "that", "effectively", "makes", "the", "field", "it", "be", "on", "deprecate", "NUMBER", "leebyron", "any", "thoughts", "on", "this", "Perhaps", "that", "means", "also", "be", "able", "to", "mark", "argument", "as", "deprecate", "NUMBER", "If", "input", "obj", "field", "can", "be", "transitioned", "from", "required", "to", "optional", "to", "deprecate", "then", "argument", "should", "be", "the", "same", "NUMBER", "I", "d", "be", "very", "supportive", "and", "a", "huge", "fan", "of", "this", "change", "NUMBER", "We", "ve", "already", "run", "into", "a", "few", "scenarios", "in", "our", "implementation", "where", "this", "would", "be", "valuable", "and", "I", "can", "foresee", "it", "becoming", "even", "more", "important", "in", "the", "future", "NUMBER", "I", "d", "be", "happy", "to", "collaborate", "with", "anyone", "who", "wants", "to", "begin", "work", "on", "this", "NUMBER", "few", "places", "that", "be", "useful", "args", "of", "connections", "field", "args", "of", "mutations", "The", "next", "steps", "for", "an", "idea", "like", "this", "would", "be", "to", "draft", "an", "RFC", "probably", "in", "the", "form", "of", "a", "PR", "against", "the", "spec", "along", "with", "a", "good", "description", "of", "how", "deprecation", "best", "practice", "should", "work", "and", "any", "potential", "caveats", "NUMBER", "Short", "of", "digging", "through", "old", "PRs", "what", "be", "the", "process", "for", "proposing", "an", "RFC", "leebyron", "I", "m", "looking", "for", "something", "akin", "to", "Rust", "s", "RFC", "process", "LINK", "lang", "rfcs", "but", "outside", "of", "Subscriptions", "there", "don", "t", "seem", "to", "be", "many", "guidelines", "on", "write", "these", "NUMBER", "gjtorikian", "a", "rough", "outline", "of", "the", "contribution", "process", "can", "be", "find", "here", "LINK", "Yeah", "it", "was", "actually", "news", "to", "me", "that", "this", "was", "_not_", "support", "NUMBER", "I", "would", "ve", "sworn", "we", "ve", "already", "put", "deprecationReaon", "s", "on", "argument", "in", "our", "codebase", "without", "realizing", "that", "it", "wasn", "t", "actually", "sending", "deprecation", "notices", "Anyone", "work", "on", "a", "PR", "for", "this", "Is", "there", "any", "update", "on", "this", "Are", "there", "new", "ways", "of", "accomplishing", "this", "now", "If", "someone", "just", "want", "to", "get", "all", "the", "data", "then", "there", "be", "much", "cumbersome", "to", "write", "do", "all", "the", "field", "NUMBER", "a", "better", "way", "I", "think", "be", "make", "the", "sub", "selection", "optional", "if", "there", "be", "sub", "selections", "we", "return", "an", "subset", "of", "the", "original", "data", "otherwise", "we", "return", "a", "full", "set", "NUMBER", "That", "would", "result", "in", "a", "lot", "of", "problem", "More", "data", "would", "be", "returned", "than", "necessary", "It", "would", "be", "hard", "to", "detect", "when", "clients", "be", "no", "longer", "use", "a", "deprecate", "field", "Would", "it", "recursively", "return", "all", "data", "for", "object", "type", "field", "If", "so", "then", "that", "could", "cause", "infinite", "recursion", "if", "there", "be", "circular", "reference", "NUMBER", "dylanahsmith", "Anyway", "I", "have", "implement", "in", "that", "way", "and", "circular", "reference", "could", "be", "fix", "if", "you", "use", "the", "right", "configuration", "NUMBER", "Another", "thing", "be", "that", "currently", "we", "be", "use", "static", "query", "which", "means", "the", "query", "string", "be", "not", "write", "directly", "by", "the", "client", "side", "devs", "NUMBER", "I", "heard", "from", "josephsavona", "that", "leebyron", "had", "a", "proposal", "to", "add", "a", "global", "__id", "field", "to", "the", "specification", "similar", "to", "Relay", "s", "Node", "id", "field", "NUMBER", "See", "here", "LINK", "issuecomment", "NUMBER", "What", "s", "the", "status", "on", "such", "a", "field", "get", "add", "to", "the", "specification", "and", "how", "can", "we", "speed", "that", "process", "up", "The", "larger", "context", "be", "that", "a", "small", "number", "of", "Relay", "users", "have", "designed", "their", "schema", "such", "that", "the", "id", "field", "be", "a", "type", "specific", "identifier", "e", "NUMBER", "g", "NUMBER", "the", "database", "primary", "key", "NUMBER", "For", "a", "cache", "however", "it", "be", "substantially", "simpler", "to", "use", "global", "ids", "for", "object", "identification", "and", "having", "a", "standardized", "id", "field", "name", "as", "part", "of", "the", "spec", "would", "help", "developers", "to", "design", "a", "schema", "that", "could", "be", "use", "with", "multiple", "clients", "without", "forcing", "every", "client", "to", "deal", "with", "customizable", "id", "names", "NUMBER", "Yep", "I", "completely", "understand", "all", "the", "benefits", "and", "as", "I", "ve", "be", "looking", "into", "Relay", "alternatives", "a", "global", "identification", "spec", "for", "the", "entire", "ecosystem", "seems", "like", "a", "great", "idea", "blush", "NUMBER", "So", "I", "m", "really", "excited", "for", "an", "__id", "specification", "for", "two", "reasons", "NUMBER", "I", "be", "one", "such", "Relay", "user", "who", "has", "naming", "clashes", "with", "id", "__id", "be", "an", "exciting", "solution", "NUMBER", "NUMBER", "I", "be", "a", "GraphQL", "user", "interested", "in", "build", "Relay", "alternatives", "and", "request", "a", "blessed", "specification", "from", "the", "GraphQL", "team", "endorsing", "__id", "blush", "Last", "I", "heard", "here", "LINK", "issuecomment", "NUMBER", "you", "josephsavona", "and", "leebyron", "said", "that", "an", "__id", "addition", "to", "the", "language", "be", "be", "considered", "NUMBER", "What", "be", "some", "factors", "under", "consideration", "and", "how", "can", "we", "make", "the", "specification", "definite", "Yeah", "we", "re", "work", "on", "this", "and", "I", "ll", "have", "an", "RFC", "pull", "request", "set", "up", "shortly", "where", "we", "can", "talk", "about", "it", "in", "more", "detail", "NUMBER", "What", "s", "the", "status", "on", "this", "leebyron", "This", "change", "would", "be", "amazing", "for", "our", "production", "GraphQL", "API", "NUMBER", "Can", "t", "wait", "to", "make", "it", "Relay", "compatible", "Any", "update", "would", "be", "greatly", "appreciated", "NUMBER", "leebyron", "be", "you", "looking", "for", "someone", "to", "write", "up", "the", "__id", "RFC", "I", "could", "take", "a", "pass", "at", "it", "NUMBER", "Just", "an", "idea", "for", "discussion", "add", "the", "path", "to", "the", "response", "like", "this", "implementation", "in", "graphql", "js", "LINK", "js", "blob", "NUMBER", "ed", "NUMBER", "fed", "NUMBER", "e", "NUMBER", "ca", "NUMBER", "d", "NUMBER", "b", "NUMBER", "c", "NUMBER", "c", "src", "test", "starWarsQuery", "test", "NUMBER", "js", "L", "NUMBER", "L", "NUMBER", "js", "path", "hero", "friends", "NUMBER", "secretBackstory", "Just", "like", "it", "be", "helpful", "to", "know", "the", "location", "in", "the", "query", "associated", "with", "an", "error", "it", "s", "helpful", "to", "know", "the", "location", "in", "the", "response", "NUMBER", "This", "be", "already", "implement", "in", "error", "throw", "from", "resolvers", "in", "graphql", "js", "so", "it", "would", "just", "be", "a", "matter", "of", "having", "the", "right", "error", "format", "to", "include", "that", "information", "NUMBER", "This", "would", "be", "extremely", "helpful", "to", "differentiate", "when", "a", "field", "be", "null", "in", "the", "result", "because", "the", "result", "was", "actually", "null", "and", "when", "it", "be", "because", "of", "a", "runtime", "error", "in", "the", "resolver", "NUMBER", "This", "would", "be", "extremely", "helpful", "to", "differentiate", "when", "a", "field", "be", "null", "in", "the", "result", "because", "the", "result", "was", "actually", "null", "and", "when", "it", "be", "because", "of", "a", "runtime", "error", "in", "the", "resolver", "NUMBER", "I", "think", "the", "simpler", "way", "of", "addressing", "that", "concern", "would", "be", "to", "omit", "the", "field", "in", "the", "result", "if", "there", "was", "an", "error", "rather", "NUMBER", "Also", "error", "in", "non", "null", "type", "field", "could", "just", "not", "be", "propagated", "such", "that", "miss", "data", "could", "be", "use", "as", "an", "indicator", "of", "where", "the", "error", "occur", "NUMBER", "However", "even", "with", "that", "change", "your", "proposal", "would", "be", "useful", "to", "associate", "error", "with", "specific", "elements", "in", "an", "array", "NUMBER", "There", "be", "a", "few", "reasons", "this", "be", "better", "than", "just", "returning", "undefined", "in", "this", "case", "NUMBER", "Being", "able", "to", "identify", "specific", "array", "elements", "that", "had", "error", "NUMBER", "Being", "able", "to", "associate", "specific", "error", "message", "with", "specific", "parts", "of", "the", "result", "You", "can", "imagine", "if", "you", "be", "rendering", "a", "huge", "page", "with", "one", "GraphQL", "query", "it", "would", "be", "nice", "to", "show", "any", "relevant", "error", "in", "the", "correct", "part", "of", "the", "UI", "rather", "than", "at", "the", "top", "level", "NUMBER", "Of", "course", "it", "be", "possible", "to", "build", "a", "custom", "error", "tagging", "system", "for", "this", "but", "it", "would", "be", "much", "nicer", "if", "there", "was", "this", "relatively", "small", "build", "in", "thing", "especially", "since", "we", "already", "have", "line", "and", "column", "position", "for", "the", "error", "NUMBER", "You", "can", "imagine", "if", "you", "be", "rendering", "a", "huge", "page", "with", "one", "GraphQL", "query", "it", "would", "be", "nice", "to", "show", "any", "relevant", "error", "in", "the", "correct", "part", "of", "the", "UI", "rather", "than", "at", "the", "top", "level", "NUMBER", "It", "sounds", "like", "you", "be", "use", "top", "level", "error", "as", "a", "way", "to", "display", "user", "input", "error", "which", "isn", "t", "the", "intended", "purpose", "for", "those", "error", "NUMBER", "The", "top", "level", "error", "entry", "was", "meant", "to", "have", "error", "message", "that", "be", "intended", "for", "the", "developer", "NUMBER", "This", "be", "mention", "in", "the", "graphql", "spec", "in", "the", "Errors", "section", "LINK", "sec", "Errors", "Every", "error", "must", "contain", "an", "entry", "with", "the", "key", "message", "with", "a", "string", "description", "of", "the", "error", "intended", "for", "the", "developer", "as", "a", "guide", "to", "understand", "and", "correct", "the", "error", "NUMBER", "This", "has", "be", "further", "clarified", "in", "a", "graphql", "spec", "issue", "LINK", "issuecomment", "NUMBER", "It", "sounds", "like", "you", "be", "use", "top", "level", "error", "as", "a", "way", "to", "display", "user", "input", "error", "which", "isn", "t", "the", "intended", "purpose", "for", "those", "error", "NUMBER", "No", "I", "m", "talking", "about", "a", "situation", "where", "a", "fetch", "to", "a", "backend", "API", "fail", "cause", "that", "part", "of", "the", "GraphQL", "query", "to", "return", "null", "NUMBER", "It", "doesn", "t", "have", "anything", "to", "do", "with", "user", "input", "and", "could", "happen", "on", "basically", "any", "fetch", "from", "a", "database", "or", "other", "API", "NUMBER", "If", "the", "GraphQL", "error", "field", "be", "intended", "to", "be", "use", "for", "runtime", "error", "which", "seems", "to", "match", "leebyron", "s", "statement", "that", "it", "s", "for", "exceptional", "situations", "then", "I", "d", "say", "this", "use", "case", "certainly", "falls", "into", "that", "category", "NUMBER", "The", "only", "other", "option", "I", "see", "be", "for", "basically", "every", "single", "type", "to", "be", "a", "union", "type", "with", "Error", "which", "seems", "undesirable", "since", "it", "will", "clutter", "the", "schema", "and", "there", "be", "already", "an", "official", "place", "to", "put", "error", "in", "the", "query", "result", "NUMBER", "Going", "to", "close", "and", "reopen", "this", "to", "have", "a", "better", "branch", "name", "than", "patch", "NUMBER", "NUMBER", "Currently", "subselections", "be", "_disallowed_", "on", "scalars", "and", "_required_", "on", "object", "types", "NUMBER", "However", "if", "the", "API", "provides", "a", "mutation", "with", "an", "object", "return", "type", "but", "the", "user", "be", "not", "interested", "in", "the", "result", "they", "must", "still", "query", "at", "least", "one", "field", "chosen", "at", "random", "NUMBER", "That", "means", "the", "user", "be", "forced", "to", "query", "data", "they", "didn", "t", "want", "in", "the", "first", "place", "kind", "of", "contrary", "to", "the", "idea", "behind", "graphql", "NUMBER", "We", "could", "instead", "distinguish", "between", "correct", "object", "type", "vs", "NUMBER", "scalar", "usage", "by", "requiring", "existence", "of", "a", "subselection", "on", "an", "object", "type", "instead", "of", "non", "emptiness", "NUMBER", "Look", "at", "those", "mutations", "graphql", "mutation", "foo", "mutateSomething", "withArg", "NUMBER", "bad", "mutateSomething", "withArg", "NUMBER", "good", "This", "could", "also", "work", "on", "queries", "one", "might", "want", "to", "know", "whether", "some", "object", "exists", "but", "none", "of", "its", "contents", "NUMBER", "graphql", "query", "bar", "myObjectField", "bad", "myObjectField", "good", "In", "the", "query", "example", "myObjectField", "would", "resolve", "to", "one", "of", "or", "null", "depending", "on", "whether", "the", "field", "resolve", "to", "an", "object", "or", "not", "NUMBER", "And", "be", "a", "truthy", "value", "while", "null", "be", "falsy", "NUMBER", "PS", "I", "be", "guessing", "this", "was", "already", "discussed", "somewhere", "if", "so", "please", "point", "me", "at", "it", "I", "cannot", "find", "the", "reasoning", "behind", "the", "design", "decision", "NUMBER", "or", "we", "could", "implement", "a", "new", "directive", "like", "omit", "for", "ignore", "the", "result", "NUMBER", "Thanks", "for", "bringing", "this", "up", "again", "NUMBER", "The", "spec", "describes", "this", "as", "it", "do", "to", "avoid", "mistakes", "in", "queries", "but", "I", "think", "it", "s", "worth", "further", "discussion", "NUMBER", "The", "few", "times", "this", "has", "come", "up", "before", "it", "s", "always", "be", "in", "the", "context", "of", "mutations", "and", "not", "caring", "about", "the", "response", "of", "the", "mutation", "NUMBER", "In", "those", "cases", "you", "work", "around", "by", "write", "__typename", "if", "you", "truly", "don", "t", "care", "about", "the", "result", "but", "more", "often", "than", "not", "we", "find", "that", "this", "was", "a", "theoretical", "concern", "and", "in", "practice", "you", "almost", "always", "want", "_something_", "from", "the", "mutation", "even", "if", "it", "s", "just", "the", "id", "of", "the", "thing", "that", "was", "mutated", "NUMBER", "I", "m", "curious", "if", "there", "be", "real", "cases", "that", "have", "come", "up", "in", "the", "context", "of", "queries", "where", "you", "only", "want", "to", "know", "of", "an", "object", "field", "existance", "but", "not", "know", "anything", "else", "about", "it", "NUMBER", "One", "maybe", "nice", "thing", "about", "disallowing", "be", "that", "if", "you", "re", "maintaining", "or", "refactoring", "a", "query", "and", "notice", "that", "the", "last", "field", "in", "a", "NUMBER", "should", "be", "remove", "then", "you", "know", "that", "you", "can", "also", "remove", "the", "parent", "field", "as", "well", "NUMBER", "I", "m", "curious", "for", "more", "opinions", "on", "this", "topic", "NUMBER", "I", "like", "the", "idea", "of", "having", "an", "omit", "directive", "NUMBER", "In", "fact", "I", "find", "this", "convo", "by", "searching", "for", "whether", "this", "directive", "existed", "NUMBER", "Would", "love", "to", "see", "this", "If", "you", "only", "care", "about", "the", "presence", "of", "something", "the", "wouldn", "t", "better", "semantics", "be", "add", "a", "_hasFoo_", "field", "to", "the", "object", "File", "name", "change", "but", "documentation", "link", "to", "it", "didn", "t", "NUMBER", "Thanks", "Thanks", "Lone", "means", "lone", "NUMBER", "Set", "of", "ALL", "operations", "must", "be", "set", "of", "one", "NUMBER", "Thanks", "for", "highlight", "this", "I", "m", "not", "sure", "your", "propose", "change", "be", "correct", "though", "NUMBER", "It", "seems", "to", "read", "that", "only", "one", "operation", "of", "any", "kind", "may", "exist", "within", "a", "document", "but", "this", "rule", "seeks", "to", "only", "ensure", "that", "be", "the", "case", "if", "the", "one", "query", "be", "_anonymous_", "NUMBER", "Good", "point", "NUMBER", "I", "was", "thinking", "of", "the", "spec", "in", "isolation", "rather", "than", "globally", "NUMBER", "Awesome", "thanks", "Clarify", "that", "null", "descriptions", "aren", "t", "OK", "NUMBER", "Metadata", "be", "very", "important", "NUMBER", "I", "think", "it", "maybe", "makes", "more", "sense", "to", "say", "that", "some", "things", "be", "trivially", "describe", "such", "as", "self", "explanatory", "types", "that", "can", "be", "marked", "as", "such", "easily", "or", "as", "types", "with", "inner", "types", "where", "the", "description", "just", "wraps", "the", "inner", "type", "NUMBER", "But", "as", "this", "be", "now", "implement", "in", "the", "code", "so", "that", "getDescription", "be", "not", "nullable", "update", "the", "docs", "makes", "sense", "in", "any", "case", "NUMBER", "It", "s", "currently", "implement", "as", "allowing", "descriptions", "to", "be", "nullable", "LINK", "js", "blob", "master", "src", "type", "introspection", "NUMBER", "js", "L", "NUMBER", "This", "was", "one", "of", "the", "things", "we", "intentionally", "loosened", "from", "FB", "s", "earlier", "version", "NUMBER", "When", "write", "the", "spec", "for", "this", "version", "of", "graphql", "we", "decided", "it", "would", "be", "too", "burdensome", "to", "always", "require", "descriptions", "at", "the", "introspection", "layer", "but", "leave", "the", "decision", "on", "requiring", "descriptions", "as", "an", "implementation", "or", "lint", "rule", "decision", "for", "individual", "users", "NUMBER", "Mostly", "tweaking", "the", "defined", "type", "system", "to", "include", "everything", "referenced", "plus", "a", "few", "typo", "Saw", "this", "idea", "referenced", "in", "a", "Relay", "ticket", "LINK", "issuecomment", "NUMBER", "Per", "offline", "discussion", "with", "leebyron", "and", "dschafer", "we", "ll", "probably", "have", "to", "add", "support", "for", "fragment", "aliases", "in", "the", "language", "to", "make", "this", "seamless", "NUMBER", "This", "would", "use", "your", "earlier", "proposal", "fson", "Relay", "products", "fragment", "on", "User", "foo", "Child", "NUMBER", "getFragment", "foo", "Raw", "GraphQL", "fragment", "on", "User", "foo", "NUMBER", "sub_", "NUMBER", "name", "generate", "by", "relay", "babel", "plugin", "Thought", "it", "might", "be", "useful", "to", "open", "a", "ticket", "here", "as", "a", "reminder", "or", "for", "more", "discussion", "NUMBER", "Right", "now", "when", "some", "error", "happens", "inside", "GraphQL", "schema", "or", "in", "the", "syntax", "wise", "we", "get", "error", "as", "whole", "NUMBER", "Then", "it", "s", "our", "job", "to", "decide", "what", "to", "do", "with", "it", "NUMBER", "But", "it", "would", "be", "great", "if", "we", "can", "have", "a", "set", "of", "GraphQL", "error", "types", "in", "the", "spec", "which", "deals", "with", "different", "use", "cases", "NUMBER", "NUMBER", "Syntax", "Type", "Errors", "These", "error", "be", "for", "the", "error", "in", "client", "provides", "query", "NUMBER", "Runtime", "Errors", "These", "be", "the", "error", "occur", "in", "runtime", "specially", "with", "syntax", "error", "and", "network", "relate", "error", "NUMBER", "NUMBER", "User", "Errors", "These", "be", "the", "error", "we", "need", "to", "pass", "to", "the", "user", "NUMBER", "Right", "now", "in", "the", "graphql", "js", "implementation", "we", "get", "all", "these", "error", "as", "one", "type", "NUMBER", "But", "it", "ll", "be", "useful", "if", "we", "ve", "some", "mechanism", "to", "differentiate", "them", "NUMBER", "So", "it", "would", "be", "great", "GraphQL", "spec", "to", "define", "these", "error", "NUMBER", "So", "the", "implementations", "can", "use", "them", "NUMBER", "Also", "the", "people", "who", "write", "GraphQL", "schemas", "can", "use", "them", "to", "define", "User", "Errors", "NUMBER", "Then", "in", "the", "transport", "layers", "we", "can", "check", "for", "these", "three", "types", "of", "error", "and", "do", "necessary", "actions", "NUMBER", "Is", "there", "any", "plan", "to", "have", "these", "in", "spec", "NUMBER", "If", "so", "I", "d", "like", "to", "work", "on", "them", "NUMBER", "Awesome", "NUMBER", "Here", "s", "one", "of", "our", "member", "mnmtanish", "s", "writeup", "LINK", "graphql", "error", "b", "NUMBER", "b", "NUMBER", "f", "NUMBER", "c", "NUMBER", "NUMBER", "d", "NUMBER", "pw", "NUMBER", "p", "NUMBER", "j", "on", "this", "NUMBER", "Here", "s", "our", "idea", "for", "the", "spec", "NUMBER", "We", "ve", "a", "type", "call", "GraphQLUserError", "It", "s", "a", "custom", "error", "type", "NUMBER", "Schema", "creators", "can", "import", "and", "throw", "that", "if", "needed", "NUMBER", "This", "will", "do", "nothing", "much", "special", "but", "it", "will", "allow", "us", "to", "filter", "these", "error", "from", "the", "rest", "in", "the", "transport", "level", "NUMBER", "What", "do", "you", "think", "I", "get", "it", "NUMBER", "It", "s", "hard", "to", "formalize", "a", "common", "error", "type", "NUMBER", "What", "we", "mean", "by", "the", "NUMBER", "be", "we", "should", "not", "send", "programming", "error", "to", "the", "client", "side", "NUMBER", "But", "anyway", "it", "s", "an", "application", "level", "decision", "not", "something", "GraphQL", "should", "decide", "NUMBER", "So", "we", "like", "the", "graphql", "js", "s", "implementation", "of", "sending", "all", "the", "error", "and", "let", "the", "transport", "app", "layer", "to", "do", "whatever", "it", "needs", "NUMBER", "Now", "we", "need", "to", "find", "a", "way", "to", "differentiate", "these", "syntax", "error", "and", "what", "the", "schema", "really", "need", "to", "send", "to", "the", "client", "NUMBER", "For", "an", "example", "if", "there", "be", "a", "credit", "card", "relate", "issue", "NUMBER", "we", "don", "t", "wanna", "send", "the", "original", "message", "to", "the", "client", "NUMBER", "This", "be", "based", "on", "the", "never", "trust", "the", "client", "principle", "NUMBER", "So", "instead", "schema", "will", "send", "a", "error", "of", "GraphQLUserError", "NUMBER", "Why", "we", "need", "this", "in", "the", "schema", "even", "some", "mentioning", "We", "may", "be", "use", "schemas", "write", "by", "different", "people", "NUMBER", "If", "everyone", "following", "the", "same", "then", "it", "s", "easy", "for", "app", "transport", "layer", "to", "decide", "on", "error", "NUMBER", "But", "I", "m", "not", "sure", "where", "it", "should", "goes", "in", "the", "spec", "NUMBER", "I", "don", "t", "have", "anything", "useful", "to", "add", "but", "wanted", "to", "give", "an", "example", "of", "how", "I", "m", "use", "arunoda", "and", "mnmtanish", "s", "graphql", "error", "LINK", "error", "package", "pre", "spec", "as", "a", "quick", "interim", "hack", "in", "case", "there", "be", "others", "following", "the", "thread", "NUMBER", "Example", "here", "NUMBER", "LINK", "js", "issue", "NUMBER", "issuecomment", "NUMBER", "Graphql", "do", "solve", "version", "problem", "by", "allow", "server", "add", "field", "dynamically", "without", "client", "change", "their", "endpoint", "NUMBER", "That", "s", "great", "however", "with", "an", "exist", "backend", "with", "version", "api", "which", "be", "a", "proper", "way", "to", "support", "version", "change", "NUMBER", "For", "example", "with", "exist", "version", "backend", "api", "endpoint", "api", "v", "NUMBER", "foo", "response", "key", "value", "endpoint", "api", "v", "NUMBER", "foo", "response", "key", "value", "NUMBER", "value", "additional", "wow", "There", "be", "two", "problem", "NUMBER", "Given", "an", "frontend", "app", "NUMBER", "currently", "use", "api", "api", "v", "NUMBER", "foo", "how", "to", "setup", "a", "graphql", "server", "allow", "app", "NUMBER", "s", "future", "requirement", "to", "additional", "data", "and", "use", "the", "old", "version", "of", "key", "NUMBER", "Given", "another", "frontend", "app", "NUMBER", "use", "api", "api", "v", "NUMBER", "foo", "be", "that", "possible", "to", "allow", "both", "app", "NUMBER", "and", "app", "NUMBER", "use", "the", "same", "graphql", "server", "without", "overhead", "such", "as", "introduce", "version", "inside", "graphql", "server", "See", "my", "conversation", "with", "leebyron", "about", "version", "here", "LINK", "First", "notice", "here", "LINK", "and", "also", "seen", "in", "the", "Markdown", "source", "NUMBER", "Sections", "NUMBER", "and", "NUMBER", "have", "the", "same", "name", "Operations", "under", "Validation", "at", "the", "same", "depth", "cause", "TOC", "link", "to", "fail", "NUMBER", "Consider", "re", "titling", "NUMBER", "Variables", "and", "remove", "a", "level", "of", "depth", "NUMBER", "Section", "NUMBER", "be", "the", "only", "child", "of", "NUMBER", "and", "NUMBER", "doesn", "t", "contain", "any", "overview", "text", "before", "NUMBER", "starts", "NUMBER", "Worth", "noting", "that", "this", "issue", "make", "deep", "link", "to", "this", "section", "from", "implementation", "documentation", "difficult", "NUMBER", "LINK", "connections", "NUMBER", "html", "content", "leebyron", "I", "don", "t", "know", "if", "this", "be", "my", "unique", "experience", "but", "too", "often", "I", "end", "up", "having", "to", "explain", "to", "newcomers", "that", "these", "be", "not", "_just_", "for", "Relay", "but", "instead", "a", "convention", "that", "s", "indeed", "a", "good", "idea", "in", "general", "NUMBER", "While", "I", "personally", "love", "Relay", "the", "connection", "to", "Relay", "no", "pun", "intended", "really", "seems", "to", "ruffle", "people", "s", "feathers", "in", "such", "a", "way", "that", "they", "actively", "decide", "to", "_not_", "use", "connections", "without", "apparently", "understanding", "the", "full", "benefits", "NUMBER", "Instead", "what", "I", "usually", "hear", "be", "a", "lament", "about", "having", "to", "do", "more", "work", "_for_", "Relay", "when", "creating", "their", "schemas", "NUMBER", "While", "I", "understand", "that", "the", "GraphQL", "spec", "may", "not", "be", "the", "right", "place", "to", "describe", "conventions", "I", "would", "_really_", "like", "to", "see", "such", "convention", "specs", "be", "detached", "from", "Relay", "and", "where", "possible", "move", "closer", "to", "where", "the", "GraphQL", "spec", "lives", "NUMBER", "The", "same", "applies", "to", "the", "Global", "Object", "Identification", "specification", "btw", "NUMBER", "Fixes", "a", "few", "grammar", "issue", "NUMBER", "Currently", "in", "the", "validation", "section", "there", "be", "two", "subsections", "named", "Operations", "numbered", "NUMBER", "and", "NUMBER", "NUMBER", "This", "naming", "collision", "means", "the", "skiplink", "in", "the", "TOC", "for", "NUMBER", "sends", "you", "to", "NUMBER", "I", "believe", "the", "intention", "was", "to", "have", "the", "Variables", "section", "as", "NUMBER", "so", "I", "remove", "the", "second", "Operations", "section", "and", "adjusted", "the", "child", "sections", "accordingly", "NUMBER", "If", "this", "isn", "t", "what", "was", "intended", "let", "me", "know", "and", "I", "can", "rebase", "this", "out", "of", "the", "PR", "NUMBER", "Three", "small", "nits", "NUMBER", "Fixes", "NUMBER", "Thanks", "_It", "was", "bound", "to", "come", "up", "NUMBER", "boom", "_", "What", "s", "the", "outlook", "from", "the", "GraphQL", "team", "on", "this", "Whenever", "I", "ve", "seen", "it", "brought", "up", "to", "the", "Falcor", "team", "they", "say", "it", "s", "not", "their", "focus", "NUMBER", "With", "the", "capabilities", "provide", "by", "Service", "Workers", "and", "newer", "smarter", "caching", "techniques", "emerging", "be", "it", "out", "of", "the", "realm", "of", "possibilities", "to", "consider", "GraphQL", "queries", "results", "be", "cached", "offline", "Wouldn", "t", "you", "want", "caching", "on", "whatever", "backend", "more", "than", "in", "the", "frontend", "that", "I", "understand", "be", "the", "primary", "focus", "of", "this", "project", "I", "have", "implement", "caching", "especially", "with", "long", "poll", "or", "websocket", "update", "from", "backend", "in", "frontends", "but", "it", "seems", "more", "like", "a", "separate", "project", "from", "the", "goal", "of", "this", "one", "as", "I", "understand", "it", "NUMBER", "But", "I", "do", "see", "the", "point", "when", "combined", "with", "frontend", "local", "storage", "NUMBER", "Very", "cool", "NUMBER", "Thanks", "leebyron", "NUMBER", "Will", "approach", "the", "Relay", "team", "NUMBER", "This", "looks", "good", "NUMBER", "If", "we", "introduce", "union", "interface", "types", "into", "the", "input", "system", "we", "ll", "want", "to", "be", "careful", "since", "the", "input", "type", "system", "should", "probably", "be", "contravariant", "and", "not", "covariant", "but", "for", "the", "output", "type", "system", "this", "looks", "exactly", "right", "NUMBER", "Yeah", "currently", "the", "only", "possible", "pseudo", "contravariance", "in", "input", "types", "in", "required", "non", "null", "vs", "optional", "nullable", "but", "support", "that", "causes", "other", "issue", "NUMBER", "I", "think", "we", "ll", "need", "to", "divorce", "argument", "requirement", "from", "argument", "type", "nullability", "to", "support", "argument", "contravariance", "in", "the", "future", "NUMBER", "Yep", "I", "don", "t", "think", "we", "should", "do", "anything", "differently", "right", "now", "just", "make", "a", "mental", "note", "if", "we", "ever", "do", "NUMBER", "Remove", "duplicate", "be", "the", "result", "in", "_Evaluating", "a", "grouped", "field", "set_", "_Field", "entries_", "NUMBER", "I", "was", "thinking", "through", "build", "a", "documentation", "explorer", "and", "something", "that", "d", "be", "very", "useful", "be", "if", "you", "could", "define", "example", "queries", "alongside", "your", "type", "or", "field", "definition", "NUMBER", "These", "could", "then", "be", "auto", "expanded", "into", "embedded", "graphiql", "instances", "NUMBER", "per", "offline", "discussion", "Let", "s", "say", "you", "have", "a", "uniqueness", "constraint", "on", "a", "field", "in", "a", "mutation", "NUMBER", "For", "example", "the", "email", "field", "must", "not", "match", "any", "exist", "email", "in", "the", "database", "NUMBER", "In", "LINK", "js", "issue", "NUMBER", "it", "s", "be", "suggested", "that", "we", "shouldn", "t", "use", "the", "server", "to", "validate", "our", "form", "NUMBER", "But", "in", "the", "case", "of", "our", "uniqueness", "constraint", "the", "server", "be", "the", "only", "place", "with", "enough", "information", "to", "determine", "if", "our", "form", "be", "valid", "NUMBER", "The", "format", "of", "the", "error", "response", "appears", "to", "be", "aimed", "at", "debugging", "NUMBER", "Specifically", "a", "line", "number", "be", "given", "as", "the", "only", "context", "for", "the", "error", "NUMBER", "Presumably", "this", "be", "so", "that", "a", "programmer", "can", "then", "use", "that", "line", "number", "to", "find", "the", "issue", "in", "their", "query", "mutation", "NUMBER", "So", "to", "me", "the", "current", "error", "array", "looks", "more", "analogous", "to", "a", "stack", "trace", "then", "an", "error", "object", "like", "we", "d", "traditionally", "expect", "in", "a", "RESTful", "API", "eg", "NUMBER", "error", "email", "this", "email", "has", "be", "taken", "NUMBER", "The", "advantage", "of", "the", "error", "object", "be", "that", "we", "can", "easily", "match", "the", "keys", "in", "the", "error", "to", "the", "names", "of", "the", "field", "in", "our", "form", "to", "add", "an", "error", "message", "for", "our", "users", "next", "to", "the", "offending", "field", "NUMBER", "I", "propose", "that", "change", "the", "error", "array", "to", "an", "error", "object", "would", "give", "developers", "access", "to", "field", "names", "and", "error", "message", "in", "a", "format", "that", "be", "easy", "to", "map", "on", "to", "their", "form", "and", "display", "to", "users", "NUMBER", "Eg", "json", "error", "email", "message", "The", "email", "address", "zuckerberg", "facebook", "NUMBER", "com", "has", "already", "be", "taken", "locations", "Relevant", "Spec", "Section", "LINK", "sec", "Errors", "NUMBER", "NUMBER", "I", "was", "wondering", "how", "facebook", "handle", "error", "and", "display", "relate", "error", "information", "for", "user", "with", "graphql", "leebyron", "Thanks", "leebyron", "NUMBER", "didSucceed", "and", "userError", "should", "work", "for", "my", "usage", "NUMBER", "It", "might", "be", "useful", "to", "spec", "out", "userErrors", "somewhere", "similar", "to", "how", "Relay", "specifies", "connections", "and", "edges", "without", "necessarily", "including", "them", "in", "the", "GraphQL", "language", "spec", "NUMBER", "I", "feel", "like", "user", "input", "error", "handle", "be", "as", "common", "a", "concern", "as", "pagination", "in", "my", "code", "NUMBER", "Would", "it", "make", "any", "sense", "to", "consider", "this", "for", "a", "future", "version", "of", "Relay", "Input", "validation", "and", "user", "friendly", "error", "message", "in", "GraphQL", "mutations", "LINK", "tarkus", "validation", "and", "user", "error", "in", "graphql", "mutations", "NUMBER", "ca", "NUMBER", "cd", "NUMBER", "bf", "on", "Medium", "NUMBER", "com", "Let", "s", "say", "I", "have", "a", "schema", "for", "some", "translated", "content", "with", "a", "common", "interface", "for", "entries", "interface", "Entry", "id", "ID", "slug", "String", "translations", "Entry", "type", "Page", "implement", "Entry", "id", "ID", "slug", "String", "translations", "Page", "Page", "implement", "Entry", "this", "should", "be", "ok", "In", "graphql", "js", "this", "error", "saying", "the", "translations", "on", "Page", "should", "be", "of", "type", "Entry", "NUMBER", "Since", "Page", "implement", "Entry", "and", "translations", "of", "a", "Page", "will", "only", "ever", "be", "Page", "s", "this", "seems", "ok", "to", "me", "NUMBER", "Tried", "the", "same", "with", "union", "types", "with", "the", "same", "result", "NUMBER", "It", "s", "not", "a", "disaster", "I", "can", "widen", "it", "to", "the", "interface", "type", "and", "use", "a", "type", "fragment", "in", "queries", "but", "it", "seems", "a", "little", "unwieldy", "NUMBER", "Am", "I", "miss", "a", "reason", "why", "it", "s", "not", "valid", "to", "narrow", "down", "an", "interface", "type", "when", "implement", "an", "interface", "which", "specifies", "a", "field", "of", "an", "interface", "type", "uh", "sorry", "can", "t", "make", "that", "sentence", "any", "simpler", "Yay", "awesome", "This", "just", "feels", "like", "SQL", "all", "over", "again", "where", "you", "have", "to", "do", "string", "concatenation", "rather", "than", "build", "real", "data", "structures", "to", "talk", "to", "a", "server", "NUMBER", "Using", "a", "data", "format", "or", "formats", "would", "be", "far", "friendlier", "and", "less", "error", "prone", "to", "implement", "in", "the", "long", "run", "NUMBER", "For", "example", "I", "was", "work", "with", "a", "NUMBER", "NET", "implementation", "recently", "that", "didn", "t", "quite", "have", "the", "grammar", "implement", "correctly", "and", "allow", "for", "strings", "to", "be", "provide", "to", "the", "server", "that", "didn", "t", "have", "correctly", "closing", "curly", "braces", "NUMBER", "Data", "structure", "formats", "basically", "prevent", "this", "kind", "of", "thing", "and", "many", "other", "easy", "to", "create", "problem", "with", "custom", "grammars", "NUMBER", "If", "the", "syntax", "could", "be", "defined", "in", "terms", "of", "data", "structures", "rather", "than", "a", "custom", "grammar", "it", "would", "make", "implementations", "on", "both", "client", "and", "server", "simpler", "and", "more", "flexible", "NUMBER", "Versioning", "the", "spec", "would", "likely", "also", "be", "simpler", "NUMBER", "Testing", "be", "definitely", "simpler", "on", "both", "ends", "as", "well", "since", "you", "can", "use", "the", "native", "data", "structures", "of", "your", "environment", "with", "a", "little", "conversion", "to", "json", "or", "EDN", "or", "whatever", "you", "want", "for", "the", "wire", "format", "s", "NUMBER", "kylewilt", "just", "out", "of", "curiosity", "be", "you", "talking", "about", "implement", "queries", "like", "in", "mongodb", "or", "elasticsearch", "e", "NUMBER", "g", "NUMBER", "db", "NUMBER", "inventory", "NUMBER", "find", "type", "food", "or", "qty", "gt", "NUMBER", "price", "lt", "NUMBER", "instead", "of", "use", "a", "SQL", "like", "syntax", "Yes", "that", "s", "the", "basic", "idea", "of", "course", "that", "s", "a", "language", "specific", "implementation", "in", "your", "example", "NUMBER", "Ideally", "GraphQL", "would", "be", "defined", "in", "terms", "of", "pure", "conceptual", "data", "structures", "like", "maps", "arrays", "vectors", "sets", "etc", "with", "basic", "rules", "expectations", "so", "that", "any", "language", "can", "fairly", "easily", "implement", "GraphQL", "use", "its", "native", "data", "structures", "rather", "than", "the", "string", "concatenation", "parsing", "noise", "NUMBER", "You", "can", "always", "define", "a", "standard", "textual", "representation", "over", "top", "of", "data", "structures", "but", "going", "the", "other", "direction", "be", "unpleasant", "and", "often", "harder", "to", "do", "because", "the", "grammars", "can", "start", "to", "deviate", "from", "something", "that", "be", "sensibly", "convertible", "to", "standard", "data", "structures", "in", "a", "consistent", "way", "NUMBER", "I", "can", "see", "a", "future", "world", "of", "GraphQL", "Mappers", "that", "turn", "your", "nice", "friendly", "language", "specific", "data", "structures", "that", "you", "normally", "prefer", "to", "work", "with", "into", "GraphQL", "text", "which", "be", "not", "really", "the", "world", "I", "d", "prefer", "personally", "NUMBER", "Having", "a", "non", "textual", "interface", "as", "the", "spec", "will", "simplify", "test", "scenarios", "since", "you", "don", "t", "have", "to", "test", "for", "structured", "strings", "and", "enable", "faster", "throughput", "since", "you", "can", "pick", "more", "terse", "binary", "transport", "protocols", "or", "even", "direct", "function", "calls", "NUMBER", "We", "have", "an", "interface", "Customization", "and", "around", "NUMBER", "types", "implement", "this", "interface", "NUMBER", "The", "number", "of", "subtypes", "of", "Customization", "will", "grow", "over", "time", "we", "be", "even", "considering", "add", "subtypes", "dinamically", "NUMBER", "Each", "concrete", "type", "has", "it", "own", "set", "of", "attributes", "NUMBER", "On", "the", "query", "side", "this", "be", "easy", "to", "represent", "NUMBER", "The", "problem", "be", "at", "the", "mutation", "side", "NUMBER", "We", "want", "to", "have", "a", "mutation", "method", "to", "add", "a", "customization", "to", "another", "object", "addCustomizationToNode", "nodeId", "ID", "customizationInput", "CustomizationInput", "but", "this", "be", "not", "currently", "possible", "to", "express", "since", "Input", "Objects", "cannot", "have", "interfaces", "we", "would", "rather", "not", "have", "one", "mutation", "field", "per", "subtype", "specially", "since", "those", "can", "change", "dynamically", "potentially", "NUMBER", "Do", "you", "have", "any", "suggestions", "Would", "make", "sense", "to", "have", "InputObjects", "take", "interfaces", "Thank", "you", "Maybe", "some", "way", "of", "escaping", "the", "type", "system", "on", "input", "Accepting", "a", "map", "os", "string", "to", "anything", "as", "far", "as", "I", "can", "tell", "everything", "in", "the", "input", "has", "to", "be", "type", "checked", "be", "I", "miss", "something", "I", "also", "think", "that", "this", "feature", "would", "be", "a", "valuable", "addition", "to", "GraphQL", "NUMBER", "I", "have", "similar", "feature", "in", "our", "API", "NUMBER", "We", "model", "our", "mutations", "as", "UpdateAction", "s", "NUMBER", "So", "for", "instance", "we", "have", "a", "Product", "type", "NUMBER", "One", "can", "use", "update", "actions", "like", "SetName", "newName", "SetDescription", "newDescription", "AddPrice", "price", "currency", "etc", "NUMBER", "to", "update", "the", "product", "NUMBER", "So", "Ideally", "I", "would", "like", "to", "do", "it", "with", "following", "mutation", "js", "mutation", "UpdateProduct", "updateProduct", "id", "NUMBER", "version", "NUMBER", "actions", "type", "SetName", "newName", "foo", "type", "AddPrice", "price", "NUMBER", "currency", "USD", "It", "be", "also", "important", "in", "our", "case", "that", "all", "these", "update", "actions", "come", "in", "one", "list", "since", "we", "guarantee", "that", "they", "all", "would", "be", "applied", "atomically", "NUMBER", "An", "ability", "to", "define", "an", "input", "Interface", "type", "would", "allow", "us", "to", "define", "ProductUpdateAction", "which", "then", "will", "have", "ObjectType", "children", "like", "SetName", "and", "AddPrice", "NUMBER", "I", "guess", "union", "type", "would", "also", "work", "here", "but", "I", "would", "prefer", "to", "have", "an", "interface", "type", "in", "this", "particular", "case", "NUMBER", "There", "be", "also", "a", "discussion", "around", "input", "UnionType", "s", "LINK", "js", "issue", "NUMBER", "NUMBER", "NUMBER", "I", "would", "think", "support", "for", "polymorphic", "types", "would", "be", "desired", "as", "a", "first", "class", "feature", "NUMBER", "I", "m", "guessing", "from", "this", "issue", "and", "the", "comments", "that", "it", "isn", "t", "yet", "NUMBER", "You", "could", "think", "of", "a", "union", "input", "type", "as", "an", "Input", "Object", "type", "which", "only", "allows", "a", "single", "field", "to", "be", "specified", "per", "input", "object", "value", "NUMBER", "Unfortunately", "that", "would", "need", "to", "be", "enforced", "with", "runtime", "checks", "rather", "than", "static", "validation", "NUMBER", "A", "union", "input", "type", "could", "be", "represented", "in", "a", "similar", "way", "where", "a", "possible", "type", "be", "use", "in", "place", "of", "a", "field", "and", "static", "validation", "can", "ensure", "that", "only", "a", "single", "type", "be", "specified", "NUMBER", "E", "NUMBER", "g", "NUMBER", "MyInputObject", "foo", "bar", "could", "be", "use", "to", "represent", "the", "input", "object", "value", "use", "JSON", "or", "maybe", "MyInputObject", "foo", "bar", "if", "you", "think", "about", "it", "as", "a", "tuple", "NUMBER", "A", "GraphQL", "literal", "would", "have", "more", "options", "for", "how", "to", "represent", "the", "union", "type", "e", "NUMBER", "g", "NUMBER", "MyInputObject", "foo", "bar", "could", "be", "one", "option", "NUMBER", "There", "be", "another", "pretty", "simple", "use", "case", "for", "this", "feature", "a", "required", "input", "parameter", "that", "can", "have", "one", "of", "two", "possible", "scalar", "values", "NUMBER", "We", "could", "use", "this", "to", "retrieve", "a", "node", "from", "a", "tree", "either", "by", "it", "s", "path", "or", "by", "a", "unique", "identifier", "NUMBER", "Right", "now", "we", "need", "to", "use", "a", "string", "type", "and", "do", "the", "conversion", "in", "the", "resolving", "part", "or", "have", "two", "_optional_", "scalar", "parameters", "and", "return", "an", "error", "at", "runtime", "if", "both", "be", "miss", "NUMBER", "I", "ve", "seen", "that", "the", "SWAPI", "Example", "LINK", "swapi", "NUMBER", "parseapp", "NUMBER", "com", "query", "NUMBER", "B", "NUMBER", "A", "NUMBER", "NUMBER", "film", "NUMBER", "NUMBER", "B", "NUMBER", "A", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "title", "NUMBER", "A", "NUMBER", "NUMBER", "NUMBER", "D", "NUMBER", "A", "NUMBER", "D", "suffers", "from", "the", "same", "issue", "with", "id", "vs", "filmId", "Same", "use", "case", "as", "bwaidelich", "for", "me", "I", "m", "retrieving", "an", "entity", "from", "either", "one", "of", "its", "alternate", "identifiers", "NUMBER", "Currently", "the", "eid", "argument", "be", "declared", "as", "a", "GraphQLID", "a", "string", "merely", "and", "I", "m", "identifying", "the", "type", "of", "the", "entity", "identifier", "in", "the", "resolving", "part", "NUMBER", "But", "I", "d", "like", "to", "use", "a", "GraphQLUnionInputType", "for", "these", "eid", "argument", "that", "would", "have", "a", "resolveType", "function", "to", "identify", "the", "type", "which", "GraphQL", "could", "use", "to", "cast", "and", "validate", "the", "input", "value", "accordingly", "NUMBER", "It", "would", "allow", "to", "catch", "the", "cases", "where", "the", "_entity", "id_", "was", "not", "valid", "NUMBER", "Current", "schema", "coffeescript", "NUMBER", "product", "type", "productType", "description", "Retrieves", "product", "details", "given", "either", "a", "Portfolio", "or", "Produit", "entity", "id", "NUMBER", "args", "eid", "type", "new", "GraphQLNonNull", "GraphQLID", "description", "Product", "entity", "identifier", "or", "entity", "identifier", "of", "one", "of", "its", "constitutive", "portfolios", "NUMBER", "Query", "coffeescript", "query", "productByCanonicalEID", "product", "eid", "ENTITY", "ID", "IN", "CANONICAL", "FORM", "NUMBER", "ProductFull", "query", "productByAlternateEID", "product", "eid", "ENTITY", "ID", "IN", "ALTERNATE", "FORM", "NUMBER", "ProductFull", "Desired", "schema", "coffeescript", "NUMBER", "ProductEntityIDType", "new", "GraphQLScalarType", "NUMBER", "PortfolioEntityIDType", "new", "GraphQLScalarType", "NUMBER", "entityIDUnionInputType", "new", "GraphQLUnionInputType", "name", "EntityID", "types", "ProductEntityIDType", "PortfolioEntityIDType", "resolveType", "value", "Lets", "assume", "the", "entity", "identifiers", "obey", "a", "naming", "convention", "they", "start", "with", "specific", "letters", "which", "we", "can", "derive", "the", "type", "from", "if", "value", "NUMBER", "artsWith", "PO", "return", "PortfolioEntityIDType", "if", "value", "NUMBER", "artsWith", "PR", "return", "ProductEntityIDType", "NUMBER", "product", "type", "productType", "description", "Retrieves", "product", "details", "given", "either", "a", "Portfolio", "or", "Produit", "entity", "id", "NUMBER", "args", "eid", "type", "new", "GraphQLNonNull", "entityIDUnionInputType", "TAG", "id", "globalIdField", "Food", "obj", "obj", "NUMBER", "id", "bar", "type", "new", "GraphQLList", "BarType", "resolve", "obj", "getBarsForFoo", "obj", "NUMBER", "id", "resolveCost", "n", "n", "NUMBER", "In", "this", "example", "n", "be", "the", "number", "of", "times", "this", "field", "be", "request", "across", "all", "Foos", "within", "the", "query", "NUMBER", "This", "may", "not", "be", "possible", "in", "pure", "GraphQL", "since", "the", "number", "of", "results", "request", "be", "dependent", "on", "how", "the", "schema", "be", "configured", "but", "with", "a", "standardised", "API", "for", "connections", "like", "in", "Relay", "it", "might", "be", "possible", "NUMBER", "The", "NUMBER", "be", "arbitrary", "cheap", "field", "would", "probably", "have", "a", "NUMBER", "or", "NUMBER", "The", "end", "result", "would", "be", "the", "ability", "to", "reject", "queries", "over", "a", "certain", "cost", "but", "also", "allow", "IDEs", "to", "warn", "developers", "that", "a", "particular", "query", "be", "risky", "NUMBER", "I", "just", "find", "out", "that", "this", "has", "be", "implement", "in", "Sangria", "LINK", "graphql", "NUMBER", "org", "learn", "query", "complexity", "analysis", "To", "that", "end", "it", "might", "not", "be", "necessary", "to", "define", "it", "in", "the", "spec", "and", "leave", "it", "up", "to", "implementations", "instead", "NUMBER", "I", "think", "this", "provides", "too", "narrow", "a", "view", "of", "how", "the", "cost", "might", "be", "calculated", "NUMBER", "For", "instance", "the", "cost", "would", "at", "least", "depend", "on", "the", "argument", "in", "a", "lot", "of", "cases", "like", "of", "a", "paginated", "field", "e", "NUMBER", "g", "NUMBER", "users", "first", "count", "NUMBER", "The", "cost", "might", "also", "depend", "on", "other", "similar", "selections", "which", "might", "even", "re", "use", "the", "same", "data", "e", "NUMBER", "g", "NUMBER", "when", "use", "dataloader", "to", "batch", "load", "and", "cache", "datastore", "queries", "NUMBER", "Trying", "to", "calculate", "the", "cost", "of", "a", "query", "before", "it", "be", "made", "can", "actually", "be", "quite", "difficult", "so", "another", "possible", "approach", "would", "be", "to", "use", "time", "as", "the", "unit", "of", "cost", "where", "a", "timeout", "would", "be", "use", "to", "abort", "expensive", "queries", "NUMBER", "I", "think", "it", "should", "just", "be", "an", "implementation", "detail", "NUMBER", "One", "can", "provide", "reasonably", "faithful", "cost", "estimations", "for", "evaluating", "a", "graph", "query", "if", "the", "average", "branch", "factors", "of", "edge", "types", "i", "NUMBER", "e", "NUMBER", "field", "can", "be", "calculated", "from", "the", "contents", "of", "the", "data", "store", "NUMBER", "In", "case", "of", "the", "Star", "Wars", "example", "if", "you", "have", "a", "query", "like", "hero", "name", "friends", "name", "then", "you", "can", "estimate", "the", "number", "of", "_friends_", "expected", "to", "be", "retrieved", "by", "calculating", "the", "average", "branch", "factor", "for", "_friends_", "which", "be", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "in", "case", "of", "the", "Star", "Wars", "knowledge", "base", "LINK", "js", "blob", "master", "src", "test", "starWarsData", "NUMBER", "js", "NUMBER", "One", "can", "further", "customize", "this", "estimate", "for", "_friends_", "edges", "run", "between", "specific", "types", "of", "nodes", "NUMBER", "In", "case", "of", "nested", "queries", "like", "hero", "name", "friends", "name", "appearsIn", "friends", "name", "one", "can", "estimate", "the", "size", "of", "the", "expected", "result", "set", "by", "a", "sum", "product", "NUMBER", "The", "result", "set", "be", "expected", "to", "contain", "H", "nodes", "for", "heros", "plus", "H", "F", "nodes", "by", "navigating", "along", "_friends_", "from", "each", "hero", "where", "F", "NUMBER", "above", "plus", "H", "F", "A", "nodes", "by", "further", "navigating", "along", "_appearsIn_", "from", "each", "of", "the", "previous", "nodes", "NUMBER", "We", "describe", "this", "estimate", "NUMBER", "years", "ago", "in", "an", "academic", "paper", "LINK", "_vvf", "NUMBER", "pdf", "so", "better", "estimates", "be", "likely", "to", "exist", "since", "then", "NUMBER", "I", "be", "new", "to", "GraphQL", "as", "a", "language", "sorry", "if", "I", "misused", "its", "terminology", "or", "gave", "a", "far", "too", "academic", "answer", "NUMBER", "This", "be", "great", "additional", "context", "and", "insight", "thanks", "I", "wouldn", "t", "put", "faith", "in", "cost", "estimations", "that", "rely", "on", "averages", "with", "respect", "to", "branch", "factors", "NUMBER", "The", "average", "might", "be", "very", "low", "but", "if", "you", "be", "trying", "to", "protect", "against", "abuse", "then", "you", "really", "want", "to", "pay", "attention", "the", "upper", "bound", "on", "the", "branch", "factor", "NUMBER", "Also", "be", "careful", "about", "calculating", "the", "cost", "of", "queries", "that", "require", "server", "side", "filtering", "since", "they", "could", "scan", "a", "large", "number", "of", "objects", "and", "return", "very", "few", "results", "NUMBER", "The", "cost", "of", "a", "request", "isn", "t", "always", "about", "the", "amount", "of", "data", "that", "be", "returned", "NUMBER", "Maybe", "this", "discussion", "can", "be", "moved", "to", "the", "graphql", "js", "repo", "since", "it", "doesn", "t", "seem", "like", "something", "to", "standardize", "in", "the", "graphql", "spec", "NUMBER", "Here", "s", "an", "interesting", "package", "that", "do", "a", "pretty", "good", "cost", "analysis", "for", "graphql", "queries", "LINK", "bru", "graphql", "cost", "analysis", "I", "m", "trying", "to", "implement", "pagination", "algorithm", "for", "my", "data", "and", "I", "don", "t", "know", "how", "to", "handle", "cases", "when", "first", "and", "last", "be", "negative", "NUMBER", "What", "be", "your", "opinion", "about", "this", "ref", "LINK", "sec", "Pagination", "algorithm", "Should", "this", "issue", "be", "on", "Relay", "instead", "Pagination", "be", "a", "Relay", "feature", "not", "GraphQL", "For", "an", "example", "have", "a", "look", "at", "following", "query", "js", "query", "postAndComments", "postCount", "Int", "getRecentPosts", "count", "postCount", "title", "content", "NUMBER", "comments", "fragment", "comments", "on", "Post", "comments", "limit", "commentLimit", "content", "timestamp", "Now", "this", "throw", "an", "error", "json", "error", "message", "Variable", "commentLimit", "be", "not", "defined", "by", "operation", "postAndComments", "NUMBER", "If", "we", "allow", "to", "this", "I", "think", "it", "d", "be", "great", "NUMBER", "Here", "s", "the", "use", "case", "NUMBER", "With", "this", "I", "can", "use", "comments", "fragment", "in", "queries", "where", "commentLimit", "query", "variable", "do", "not", "exists", "as", "well", "NUMBER", "What", "you", "guys", "think", "about", "this", "Yeah", "NUMBER", "I", "get", "it", "NUMBER", "We", "can", "always", "define", "it", "and", "send", "a", "null", "a", "value", "NUMBER", "I", "be", "gonna", "close", "this", "NUMBER", "scala", "NUMBER", "js", "emits", "constructor", "names", "with", "chars", "react", "relay", "takes", "constructor", "name", "as", "mutation", "query", "name", "and", "resulting", "in", "fail", "transactions", "NUMBER", "i", "report", "this", "in", "scala", "NUMBER", "js", "channel", "sjrd", "be", "it", "possible", "to", "remove", "in", "generate", "constructor", "class", "names", "for", "scalajsdefined", "classes", "graphql", "support", "names", "set", "_A", "Za", "z", "_", "NUMBER", "NUMBER", "A", "Za", "z", "with", "current", "constructor", "names", "graphql", "api", "request", "be", "fail", "in", "fastOptJS", "mode", "response", "from", "scala", "NUMBER", "js", "author", "chandu", "NUMBER", "No", "it", "be", "not", "possible", "NUMBER", "graphql", "most", "be", "fix", "to", "support", "all", "valid", "Javascript", "identifiers", "NUMBER", "so", "be", "it", "possible", "to", "accept", "names", "that", "comply", "with", "javascript", "identifiers", "NUMBER", "Should", "there", "be", "a", "map", "type", "I", "have", "a", "structure", "that", "looks", "like", "this", "Item", "title", "de_DE", "fr", "pa", "NUMBER", "The", "point", "here", "be", "that", "the", "number", "of", "language", "strings", "might", "be", "arbitrary", "NUMBER", "I", "find", "this", "hard", "to", "model", "use", "GraphQLObject", "because", "NUMBER", "The", "number", "of", "locales", "be", "undefined", "NUMBER", "While", "the", "resolver", "could", "handle", "this", "dynamically", "I", "think", "it", "s", "a", "problem", "in", "Relay", "that", "the", "schema", "cannot", "reflect", "these", "dynamic", "field", "NUMBER", "NUMBER", "I", "would", "like", "to", "query", "all", "the", "exist", "locales", "which", "isn", "t", "allow", "it", "seems", "must", "have", "a", "sub", "selection", "NUMBER", "If", "I", "make", "my", "GraphQL", "server", "return", "a", "JSON", "object", "for", "title", "the", "Relay", "client", "doesn", "t", "complain", "although", "maybe", "shouldComponentUpdate", "breaks", "but", "I", "think", "I", "m", "skirting", "by", "here", "NUMBER", "At", "the", "very", "least", "I", "think", "I", "couldn", "t", "generate", "a", "schema", "that", "confirms", "to", "the", "spec", "NUMBER", "I", "think", "this", "be", "a", "valid", "concern", "as", "well", "NUMBER", "I", "currently", "thinking", "of", "ways", "to", "add", "GraphQL", "endpoint", "for", "our", "API", "NUMBER", "We", "be", "build", "project", "based", "multi", "tenant", "service", "NUMBER", "For", "example", "every", "project", "has", "a", "list", "of", "products", "which", "have", "name", "and", "description", "NUMBER", "Just", "like", "in", "your", "case", "these", "be", "localized", "strings", "as", "well", "NUMBER", "One", "way", "one", "can", "approach", "this", "problem", "be", "to", "parametrize", "the", "field", "js", "query", "ProductNames", "products", "nameEn", "name", "locale", "en", "nameDe", "name", "locale", "de_DE", "Another", "approach", "as", "you", "mention", "would", "be", "to", "generate", "a", "schema", "of", "the", "fly", "NUMBER", "In", "our", "case", "it", "would", "be", "possible", "since", "every", "project", "has", "a", "limited", "set", "of", "locales", "which", "be", "defined", "in", "the", "config", "of", "this", "project", "NUMBER", "Where", "it", "becomes", "more", "tricky", "be", "an", "addition", "user", "defined", "data", "types", "NUMBER", "Users", "of", "our", "API", "can", "define", "new", "attributes", "for", "products", "visually", "through", "the", "merchant", "center", "application", "NUMBER", "These", "attributes", "be", "also", "typed", "so", "it", "s", "possible", "to", "generate", "GraphQL", "schema", "for", "this", "project", "but", "it", "has", "some", "implications", "Generating", "schema", "on", "every", "request", "comes", "with", "big", "performance", "penalty", "since", "we", "need", "to", "load", "config", "from", "a", "DB", "in", "order", "to", "do", "so", "to", "compensate", "for", "this", "performance", "penalty", "we", "need", "to", "implement", "some", "schema", "caching", "and", "cache", "invalidation", "logic", "Schema", "now", "becomes", "tenant", "specific", "NUMBER", "This", "means", "that", "it", "becomes", "much", "harder", "to", "integrate", "with", "generic", "tool", "like", "GraphiQL", "and", "do", "introspection", "in", "general", "You", "can", "t", "even", "do", "an", "introspection", "queries", "without", "the", "auth", "anymore", "NUMBER", "I", "guess", "one", "can", "just", "put", "all", "custom", "attribute", "JSON", "in", "a", "string", "scalar", "but", "I", "don", "t", "think", "that", "other", "developers", "will", "appreciate", "JSON", "inside", "of", "string", "inside", "of", "another", "JSON", "I", "feel", "that", "generic", "JSON", "Map", "like", "type", "can", "provide", "a", "very", "useful", "middle", "ground", "for", "these", "use", "cases", "NUMBER", "It", "can", "also", "help", "a", "lot", "with", "a", "migration", "to", "the", "GraphQL", "NUMBER", "One", "can", "quickly", "start", "with", "Map", "like", "structure", "and", "after", "some", "time", "develop", "schema", "generation", "and", "caching", "mechanisms", "NUMBER", "Hello", "I", "agree", "about", "this", "and", "as", "OlegIlyenko", "said", "JSON", "string", "inside", "JSON", "string", "seems", "awkward", "NUMBER", "I", "think", "Map", "be", "one", "portion", "of", "what", "JSON", "can", "provide", "and", "I", "have", "expose", "my", "point", "of", "view", "in", "LINK", "js", "issue", "NUMBER", "So", "NUMBER", "to", "include", "specs", "for", "a", "JSON", "or", "RawObject", "or", "however", "you", "want", "to", "call", "it", "type", "NUMBER", "NUMBER", "Hi", "I", "have", "a", "use", "case", "where", "I", "have", "server", "based", "schema", "and", "client", "based", "schema", "NUMBER", "The", "server", "based", "schema", "be", "pretty", "much", "static", "and", "will", "follow", "normal", "project", "application", "change", "through", "time", "NUMBER", "However", "the", "client", "based", "schema", "be", "specific", "to", "client", "side", "and", "generate", "on", "the", "fly", "for", "exclusive", "use", "by", "the", "client", "user", "NUMBER", "It", "s", "shape", "be", "not", "ideal", "for", "a", "generic", "map", "type", "as", "it", "can", "become", "deeply", "hierarchical", "NUMBER", "What", "I", "need", "to", "do", "be", "store", "the", "resulting", "client", "side", "JSON", "blob", "against", "the", "user", "on", "the", "server", "side", "NUMBER", "I", "specifically", "do", "not", "want", "any", "validation", "or", "type", "checking", "do", "on", "this", "JSON", "blob", "server", "side", "except", "for", "checking", "for", "valid", "JSON", "NUMBER", "At", "the", "moment", "I", "m", "storing", "it", "as", "stringified", "JSON", "against", "an", "attribute", "in", "server", "side", "schema", "which", "do", "not", "seem", "ideal", "NUMBER", "So", "I", "m", "very", "much", "in", "favor", "of", "JSONObject", "RawObject", "UncheckedObject", "or", "whatever", "as", "simple", "JSON", "object", "as", "propose", "here", "LINK", "js", "pull", "NUMBER", "It", "looks", "like", "the", "use", "case", "of", "miracle", "NUMBER", "k", "can", "be", "solve", "by", "just", "use", "a", "list", "NUMBER", "So", "something", "like", "Item", "titles", "language", "text", "wherein", "titles", "be", "an", "array", "NUMBER", "One", "can", "always", "create", "an", "input", "argument", "if", "you", "want", "to", "select", "a", "subset", "NUMBER", "clintwood", "s", "use", "case", "however", "looks", "different", "since", "there", "s", "no", "know", "schema", "and", "may", "be", "hierarchical", "NUMBER", "IMO", "as", "long", "as", "there", "s", "a", "know", "structure", "a", "list", "type", "could", "replace", "a", "map", "NUMBER", "jvliwanag", "correct", "me", "if", "I", "be", "wrong", "but", "this", "would", "mean", "that", "the", "values", "in", "the", "list", "would", "have", "to", "return", "as", "an", "array", "NUMBER", "This", "be", "OK", "if", "someone", "be", "developing", "an", "API", "from", "scratch", "and", "has", "control", "over", "defining", "the", "response", "payload", "NUMBER", "But", "if", "an", "exist", "API", "be", "be", "moved", "over", "to", "use", "GraphQL", "which", "already", "has", "a", "defined", "contract", "returning", "a", "map", "of", "key", "value", "pairs", "even", "if", "the", "values", "be", "always", "of", "a", "defined", "object", "type", "structure", "then", "it", "appears", "this", "be", "unavoidable", "NUMBER", "I", "be", "interested", "to", "know", "how", "it", "would", "be", "possible", "to", "use", "a", "list", "unfortunately", "the", "the", "list", "type", "do", "not", "seem", "to", "accept", "anything", "except", "an", "array", "graphql", "graphql", "js", "blob", "master", "src", "execution", "execute", "NUMBER", "js", "L", "NUMBER", "L", "NUMBER", "LINK", "js", "blob", "master", "src", "execution", "execute", "NUMBER", "js", "L", "NUMBER", "L", "NUMBER", "NUMBER", "Interestingly", "the", "error", "User", "Error", "expected", "iterable", "but", "did", "not", "find", "one", "NUMBER", "Suggests", "it", "could", "be", "possible", "to", "supply", "a", "Map", "or", "Set", "but", "of", "course", "the", "code", "says", "otherwise", "crying_cat_face", "NUMBER", "Maps", "would", "be", "useful", "in", "mutations", "for", "sending", "arbitrary", "key", "value", "pairs", "NUMBER", "NUMBER", "as", "well", "imagine", "this", "can", "also", "allow", "for", "embedded", "documents", "in", "query", "responses", "if", "use", "a", "record", "store", "on", "the", "backend", "Please", "try", "to", "use", "JSON", "LD", "language", "maps", "LINK", "ld", "index", "maps", "I", "agree", "with", "leebyron", "about", "the", "solution", "to", "the", "original", "problem", "NUMBER", "In", "the", "case", "of", "user", "defined", "JSON", "data", "can", "we", "just", "make", "it", "clear", "that", "custom", "scalars", "aren", "t", "restricted", "to", "how", "they", "can", "be", "serialized", "NUMBER", "E", "NUMBER", "g", "NUMBER", "with", "graphql", "js", "you", "can", "serialize", "a", "custom", "JSON", "scalar", "use", "arrays", "objects", "etc", "NUMBER", "alternatively", "item", "titles", "languages", "en", "fr", "result", "item", "titles", "Hello", "Bonjour", "You", "can", "specify", "the", "list", "of", "language", "in", "a", "variable", "Advantage", "of", "this", "approach", "NUMBER", "static", "query", "no", "need", "to", "specify", "languages", "before", "write", "the", "fragment", "versus", "approach", "NUMBER", "in", "leebyron", "s", "comment", "NUMBER", "didn", "t", "create", "a", "new", "Object", "type", "NUMBER", "versus", "approach", "NUMBER", "in", "leebyron", "s", "comment", "NUMBER", "for", "map", "support", "NUMBER", "This", "anti", "pattern", "logic", "seems", "like", "over", "thinking", "it", "to", "me", "NUMBER", "Sure", "some", "people", "will", "abuse", "it", "but", "that", "be", "true", "for", "anything", "NUMBER", "NUMBER", "map", "support", "be", "useful", "for", "some", "situations", "that", "the", "system", "always", "return", "less", "data", "than", "expect", "I", "think", "NUMBER", "NUMBER", "Currently", "I", "m", "dealing", "with", "an", "API", "that", "data", "be", "arbitrary", "as", "users", "can", "create", "their", "own", "contentTypes", "on", "the", "CMS", "so", "there", "be", "no", "way", "I", "can", "create", "an", "entryType", "as", "I", "have", "no", "idea", "what", "field", "be", "in", "there", "NUMBER", "Having", "a", "mapType", "will", "be", "super", "useful", "for", "these", "cases", "NUMBER", "Update", "Just", "tried", "this", "and", "be", "work", "great", "so", "far", "LINK", "type", "json", "thank", "you", "taion", "NUMBER", "I", "have", "the", "same", "use", "case", "as", "juancabrera", "NUMBER", "Our", "API", "delivers", "content", "defined", "and", "managed", "through", "a", "custom", "CMS", "and", "a", "main", "feature", "be", "be", "flexible", "and", "dynamic", "NUMBER", "In", "the", "application", "we", "model", "the", "objects", "as", "a", "base", "set", "of", "common", "field", "and", "then", "a", "field", "map", "with", "all", "of", "the", "dynamic", "properties", "that", "we", "don", "t", "know", "about", "on", "the", "server", "NUMBER", "contentId", "NUMBER", "type", "video", "field", "title", "fake", "video", "NUMBER", "releaseDate", "NUMBER", "NUMBER", "We", "d", "like", "to", "give", "our", "client", "app", "devs", "the", "ability", "to", "query", "and", "transform", "the", "content", "in", "the", "way", "they", "want", "but", "without", "having", "to", "create", "a", "strict", "schema", "on", "the", "server", "NUMBER", "NUMBER", "for", "maps", "NUMBER", "In", "my", "use", "case", "I", "have", "objects", "of", "this", "shape", "in", "typescript", "typescript", "interface", "GenericObject", "id", "string", "label", "string", "types", "string", "objectProps", "key", "string", "GenericObject", "dataProps", "key", "string", "string", "Using", "the", "list", "of", "key", "values", "would", "mean", "I", "be", "doing", "a", "transformation", "on", "the", "server", "to", "send", "the", "data", "and", "then", "do", "the", "reverse", "transformation", "on", "the", "client", "to", "build", "up", "that", "map", "again", "NUMBER", "Using", "the", "JSON", "value", "type", "would", "mean", "I", "can", "not", "fetch", "relate", "objs", "via", "objectProps", "with", "their", "respective", "field", "NUMBER", "Using", "argument", "would", "mean", "I", "need", "to", "know", "all", "the", "properties", "in", "advance", "which", "be", "not", "possible", "NUMBER", "Also", "the", "size", "of", "data", "we", "talk", "about", "here", "be", "rather", "small", "NUMBER", "So", "paging", "be", "not", "an", "issue", "NUMBER", "We", "have", "the", "exact", "same", "need", "as", "jarwol", "I", "be", "in", "agreement", "with", "leebyron", "after", "watching", "what", "has", "happened", "in", "other", "JSON", "type", "apis", "at", "my", "company", "NUMBER", "The", "path", "of", "least", "resistance", "be", "the", "path", "most", "often", "traveled", "NUMBER", "This", "means", "that", "if", "there", "be", "a", "choice", "of", "creating", "a", "new", "type", "that", "has", "more", "semantic", "meaning", "to", "the", "UI", "or", "creating", "a", "map", "that", "has", "no", "tooling", "support", "or", "contract", "but", "be", "quick", "to", "create", "on", "the", "server", "then", "a", "map", "be", "going", "to", "be", "use", "NUMBER", "I", "would", "personally", "opt", "for", "NUMBER", "seperated", "types", "NUMBER", "As", "I", "see", "it", "there", "be", "NUMBER", "use", "cases", "of", "the", "data", "NUMBER", "view", "the", "data", "be", "shown", "to", "a", "user", "in", "his", "her", "s", "preferred", "language", "NUMBER", "admin", "the", "data", "be", "to", "be", "edit", "translations", "add", "change", "remove", "by", "an", "administrative", "user", "This", "might", "come", "across", "as", "perhaps", "anti", "pattern", "though", "in", "my", "opinion", "it", "be", "not", "NUMBER", "Since", "these", "be", "NUMBER", "completely", "separated", "concerns", "representations", "even", "if", "the", "source", "for", "both", "be", "the", "same", "in", "your", "db", "NUMBER", "Thus", "NUMBER", "VIEW", "Type", "be", "the", "minimal", "set", "language", "be", "given", "as", "a", "variable", "and", "resolver", "be", "responsible", "of", "choosing", "the", "correct", "one", "to", "return", "NUMBER", "Changes", "be", "high", "that", "you", "want", "localised", "data", "for", "more", "types", "then", "just", "Item", "therefore", "use", "a", "variable", "be", "also", "reusable", "across", "your", "schema", "queries", "mutations", "NUMBER", "type", "Item", "title", "String", "Selected", "by", "query", "language", "String", "Item", "language", "language", "title", "variables", "language", "en", "US", "NUMBER", "ADMIN", "Type", "be", "extensive", "administrative", "set", "NUMBER", "Here", "you", "can", "choose", "your", "own", "preferred", "medicine", "_Array", "based_", "type", "Language", "code", "String", "text", "String", "type", "Item", "title", "Language", "_Unified", "languages", "type_", "listing", "all", "possible", "type", "Languages", "nl", "BE", "String", "en", "US", "String", "fr", "FR", "String", "nl", "FR", "String", "type", "Item", "title", "Languages", "_Plain", "object_", "scalar", "Object", "type", "Item", "title", "Object", "We", "have", "the", "same", "issue", "as", "OlegIlyenko", "user", "defined", "data", "types", "NUMBER", "Would", "be", "interested", "to", "hear", "how", "other", "users", "be", "tackling", "this", "NUMBER", "I", "have", "a", "similar", "use", "case", "NUMBER", "Instead", "of", "the", "value", "of", "the", "Map", "be", "a", "simple", "string", "I", "d", "need", "GraphQL", "types", "as", "I", "d", "like", "to", "use", "field", "resolvers", "there", "NUMBER", "Consider", "a", "schema", "like", "this", "type", "Book", "id", "ID", "name", "String", "type", "User", "name", "String", "This", "be", "invalid", "but", "roughly", "what", "I", "d", "need", "favouriteBooks", "Map", "TAG", "A", "response", "should", "look", "like", "this", "name", "Jane", "Doe", "favouriteBooks", "science", "id", "NUMBER", "novel", "id", "NUMBER", "NUMBER", "The", "book", "category", "names", "be", "dynamic", "and", "change", "often", "therefore", "I", "d", "like", "to", "not", "specify", "them", "in", "the", "GraphQL", "response", "NUMBER", "Note", "that", "this", "be", "just", "a", "contrived", "example", "NUMBER", "I", "m", "not", "looking", "for", "a", "solution", "to", "this", "particular", "problem", "NUMBER", "I", "understand", "the", "value", "of", "use", "a", "list", "instead", "but", "it", "would", "be", "great", "to", "use", "this", "to", "work", "with", "clients", "server", "responses", "that", "were", "designed", "before", "the", "GraphQL", "layer", "was", "in", "place", "NUMBER", "I", "would", "like", "to", "support", "ES", "NUMBER", "Map", "construction", "directly", "from", "json", "NUMBER", "The", "ES", "NUMBER", "Map", "constructor", "accepts", "and", "array", "of", "Entries", "where", "the", "Entry", "type", "be", "a", "two", "element", "array", "where", "the", "elements", "be", "of", "different", "underlying", "types", "one", "for", "the", "key", "and", "one", "for", "the", "value", "e", "NUMBER", "g", "NUMBER", "string", "object", "NUMBER", "I", "can", "t", "do", "this", "currently", "in", "GraphQL", "NUMBER", "amannn", "Even", "with", "clients", "server", "responses", "that", "were", "designed", "before", "the", "GraphQL", "layer", "was", "in", "place", "isn", "t", "a", "schema", "like", "the", "following", "similarly", "easy", "to", "produce", "consume", "type", "Book", "id", "ID", "name", "String", "type", "User", "name", "String", "favouriteBooks", "FavoriteBook", "type", "FavoriteBook", "category", "String", "book", "Book", "The", "obvious", "use", "case", "for", "having", "favouriteBooks", "be", "a", "map", "would", "be", "to", "do", "O", "NUMBER", "look", "up", "by", "category", "name", "but", "if", "that", "s", "what", "I", "care", "about", "I", "can", "create", "a", "look", "up", "structure", "easily", "enough", "NUMBER", "const", "booksByCategory", "books", "NUMBER", "forEach", "category", "book", "booksByCategory", "category", "book", "wincent", "Thanks", "for", "your", "reply", "Sure", "the", "consumption", "of", "a", "list", "be", "no", "problem", "NUMBER", "But", "to", "use", "this", "with", "exist", "infrastructure", "I", "d", "need", "to", "do", "the", "following", "this", "In", "my", "case", "my", "GraphQL", "layer", "wraps", "exist", "REST", "endpoints", "NUMBER", "I", "d", "have", "to", "transform", "favouriteBooks", "in", "REST", "responses", "into", "a", "list", "so", "they", "match", "the", "schema", "NUMBER", "Either", "I", "rewrite", "the", "parts", "of", "my", "UI", "code", "that", "consume", "favouriteBooks", "to", "work", "with", "the", "new", "data", "structure", "or", "I", "have", "to", "transform", "them", "back", "into", "a", "map", "in", "a", "wrapper", "component", "NUMBER", "If", "I", "do", "the", "latter", "and", "the", "UI", "components", "have", "a", "callback", "to", "update", "the", "data", "I", "have", "to", "transform", "them", "back", "into", "a", "list", "before", "calling", "a", "mutation", "given", "a", "similar", "input", "type", "as", "outlined", "above", "NUMBER", "When", "the", "GraphQL", "layer", "receives", "the", "mutation", "it", "has", "to", "transform", "the", "list", "back", "into", "a", "map", "in", "order", "to", "pass", "it", "on", "to", "a", "REST", "endpoint", "NUMBER", "So", "it", "could", "work", "but", "what", "I", "m", "trying", "to", "say", "be", "that", "it", "will", "probably", "end", "up", "in", "quite", "a", "bit", "of", "back", "and", "forth", "transformation", "which", "increases", "complexity", "NUMBER", "It", "would", "be", "great", "if", "the", "GraphQL", "and", "the", "UI", "layer", "could", "use", "the", "same", "data", "structure", "as", "they", "be", "already", "know", "to", "REST", "endpoints", "NUMBER", "wincent", "NUMBER", "If", "we", "ignore", "the", "fact", "that", "we", "can", "treat", "as", "a", "map", "of", "sorts", "and", "use", "the", "new", "ES", "NUMBER", "Map", "object", "my", "current", "code", "avoids", "things", "like", "books", "NUMBER", "forEach", "category", "book", "booksByCategory", "category", "book", "in", "favor", "of", "map", "new", "Map", "entry", "NUMBER", "entry", "NUMBER", "NUMBER", "where", "each", "entry", "be", "key", "string", "value", "object", "that", "way", "I", "get", "the", "underlying", "library", "to", "do", "all", "the", "looping", "for", "me", "NUMBER", "Since", "this", "be", "now", "part", "of", "the", "language", "and", "many", "languages", "have", "a", "map", "construct", "surely", "graphql", "schema", "should", "support", "a", "construct", "like", "this", "more", "directly", "NUMBER", "If", "we", "can", "achieve", "the", "Entry", "construct", "then", "a", "map", "be", "just", "a", "list", "of", "Entries", "however", "this", "be", "very", "JavaScript", "specific", "If", "we", "can", "achieve", "the", "Entry", "construct", "then", "a", "map", "be", "just", "a", "list", "of", "Entries", "however", "this", "be", "very", "JavaScript", "specific", "NUMBER", "True", "serle", "NUMBER", "GraphQL", "be", "very", "intentionally", "language", "agnostic", "so", "it", "s", "good", "to", "point", "that", "out", "NUMBER", "There", "s", "nothing", "JS", "specific", "about", "build", "maps", "from", "lists", "of", "key", "value", "pairs", "though", "NUMBER", "That", "s", "the", "standard", "map", "constructor", "in", "a", "huge", "number", "of", "programming", "languages", "from", "C", "down", "to", "Python", "NUMBER", "That", "said", "though", "it", "do", "feel", "really", "awkward", "to", "represent", "maps", "as", "key", "value", "pairs", "NUMBER", "To", "the", "extent", "we", "re", "interfacing", "with", "e", "NUMBER", "g", "NUMBER", "REST", "APIs", "it", "s", "an", "extra", "step", "in", "marshalling", "and", "unmarshalling", "data", "in", "the", "GraphQL", "layer", "and", "it", "feels", "clunky", "NUMBER", "If", "you", "want", "maps", "or", "other", "interesting", "GraphQL", "transforms", "then", "I", "recommend", "you", "look", "at", "graphql", "lodash", "LINK", "guru", "graphql", "lodash", "NUMBER", "I", "don", "t", "think", "there", "s", "a", "strong", "argument", "yet", "for", "maps", "in", "the", "GraphQL", "specification", "but", "client", "tooling", "can", "definitely", "fill", "the", "gaps", "wincent", "s", "example", "could", "become", "a", "map", "with", "GraphQL", "Lodash", "with", "this", "query", "assuming", "User", "be", "the", "root", "query", "type", "graphql", "favoriteBooks", "_", "keyBy", "category", "mapValues", "book", "category", "book", "name", "Exactly", "the", "shape", "you", "want", "without", "having", "to", "change", "your", "UI", "code", "If", "it", "turns", "out", "a", "lot", "of", "people", "use", "GraphQL", "Lodash", "for", "maps", "then", "maybe", "we", "should", "consider", "add", "maps", "to", "the", "specification", "NUMBER", "I", "think", "the", "issue", "be", "more", "having", "seamless", "serialization", "deserialization", "support", "on", "the", "client", "NUMBER", "Not", "sure", "Relay", "be", "quite", "there", "NUMBER", "Given", "that", "GraphQL", "fundamentally", "serves", "out", "data", "structures", "and", "most", "of", "them", "be", "now", "fundamentally", "baked", "into", "each", "language", "in", "order", "to", "promote", "standardization", "I", "feel", "that", "GraphQL", "should", "have", "a", "rich", "type", "system", "to", "promote", "API", "clarity", "and", "eliminated", "unnecessary", "workarounds", "and", "transformations", "NUMBER", "With", "regard", "to", "maps", "maybe", "a", "more", "general", "approach", "be", "to", "introduce", "a", "Tuple", "type", "i", "NUMBER", "e", "NUMBER", "a", "fix", "size", "array", "where", "each", "element", "has", "a", "predefined", "type", "which", "can", "either", "be", "a", "primitive", "or", "custom", "type", "NUMBER", "In", "this", "way", "we", "could", "achieve", "both", "the", "Entry", "concept", "and", "thus", "a", "Map", "as", "well", "as", "other", "more", "general", "use", "cases", "NUMBER", "However", "I", "still", "feel", "that", "it", "be", "cleaner", "to", "explicitly", "have", "a", "Map", "type", "with", "standard", "language", "mappings", "NUMBER", "A", "tuple", "type", "isn", "t", "really", "relevant", "here", "because", "there", "s", "no", "particular", "relevant", "_ordering_", "between", "the", "key", "and", "the", "value", "in", "an", "entry", "struct", "NUMBER", "taion", "for", "the", "ES", "NUMBER", "map", "the", "key", "be", "always", "Entry", "NUMBER", "and", "the", "value", "be", "always", "Entry", "NUMBER", "As", "a", "huge", "fan", "of", "Typescript", "I", "be", "really", "enjoying", "trying", "to", "get", "a", "nascent", "GraphQL", "version", "of", "our", "API", "start", "NUMBER", "But", "as", "many", "others", "have", "mention", "the", "lack", "of", "a", "basic", "Map", "type", "be", "a", "huge", "hinderance", "NUMBER", "We", "don", "t", "always", "know", "what", "we", "re", "going", "to", "receive", "especially", "in", "the", "case", "of", "user", "generate", "content", "NUMBER", "And", "unlike", "the", "JSONType", "mention", "above", "or", "the", "list", "of", "tuples", "idea", "I", "would", "prefer", "a", "fully", "typed", "solution", "as", "well", "NUMBER", "Something", "like", "Map", "TAG", "I", "see", "this", "as", "a", "massive", "handicap", "for", "an", "API", "that", "deals", "with", "non", "deterministic", "data", "NUMBER", "I", "don", "t", "think", "anybody", "s", "recommending", "the", "use", "of", "the", "JSON", "scalar", "type", "for", "typed", "data", "BTW", "for", "now", "the", "best", "workaround", "be", "to", "serialize", "as", "a", "set", "of", "entries", "NUMBER", "I", "still", "agree", "that", "it", "would", "be", "better", "if", "GraphQL", "had", "first", "class", "support", "for", "mapping", "types", "like", "Flow", "TypeScript", "c", "NUMBER", "Note", "that", "in", "practical", "terms", "I", "was", "able", "to", "define", "a", "custom", "scalar", "and", "just", "output", "the", "map", "as", "a", "JSON", "structure", "NUMBER", "This", "worked", "fine", "with", "relay", "classic", "but", "doesn", "t", "with", "relay", "modern", "since", "the", "code", "try", "to", "process", "these", "nested", "objects", "here", "LINK", "runtime", "util", "recycleNodesInto", "NUMBER", "js", "L", "NUMBER", "I", "have", "a", "use", "case", "with", "a", "slight", "wrinkle", "NUMBER", "My", "back", "end", "be", "run", "Django", "graphene", "NUMBER", "The", "backend", "has", "a", "model", "with", "a", "field", "that", "be", "stored", "in", "the", "database", "as", "JSON", "NUMBER", "The", "front", "end", "be", "Angular", "NUMBER", "It", "constructs", "a", "JSON", "map", "representing", "what", "amounts", "to", "a", "parse", "tree", "for", "a", "small", "expression", "language", "and", "then", "wants", "to", "pass", "the", "tree", "to", "the", "back", "end", "NUMBER", "Obviously", "it", "can", "be", "stringified", "before", "the", "GraphQL", "call", "and", "destringified", "on", "the", "back", "end", "but", "it", "would", "be", "very", "nice", "to", "avoid", "that", "with", "the", "add", "benefit", "of", "letting", "the", "platform", "ensure", "that", "the", "front", "end", "be", "really", "passing", "a", "valid", "JSON", "map", "to", "the", "back", "end", "NUMBER", "I", "just", "stumbled", "upon", "another", "use", "case", "highlights", "in", "elastic", "search", "responses", "LINK", "request", "highlight", "NUMBER", "html", "_fragmenter", "NUMBER", "They", "look", "like", "this", "json", "source", "message", "Hi", "Jane", "recipient", "name", "Jane", "highlight", "message", "Hi", "TAG", "Jane", "TAG", "recipient", "NUMBER", "name", "TAG", "Jane", "TAG", "Here", "message", "and", "recipient", "NUMBER", "name", "be", "paths", "to", "field", "in", "the", "source", "that", "was", "find", "NUMBER", "You", "could", "try", "to", "create", "a", "SearchResponseHighlight", "type", "that", "contains", "all", "the", "field", "but", "I", "can", "think", "of", "the", "following", "issue", "I", "guess", "it", "s", "easy", "for", "this", "to", "get", "out", "of", "sync", "as", "at", "least", "in", "my", "case", "the", "type", "of", "the", "source", "be", "defined", "somewhere", "else", "as", "the", "types", "relate", "to", "search", "NUMBER", "Queries", "for", "retrieving", "such", "data", "would", "look", "a", "bit", "redundant", "and", "the", "user", "has", "to", "make", "sure", "that", "highlight", "be", "always", "in", "sync", "with", "the", "request", "field", "NUMBER", "GraphQL", "doesn", "t", "support", "field", "names", "with", "dots", "in", "them", "currently", "NUMBER", "I", "think", "a", "map", "type", "can", "be", "quite", "useful", "to", "replace", "something", "like", "map", "key", "value", "fieldOnValue", "Into", "map", "fieldOnValue", "I", "think", "this", "might", "also", "make", "some", "kinds", "of", "connections", "simpler", "since", "the", "edge", "cursor", "could", "maybe", "just", "be", "a", "key", "on", "the", "object", "One", "question", "to", "answer", "would", "be", "if", "the", "map", "be", "ordered", "or", "unordered", "NUMBER", "Not", "all", "languages", "support", "ordered", "maps", "so", "some", "cases", "would", "still", "have", "to", "use", "the", "first", "approach", "NUMBER", "I", "was", "initially", "shocked", "at", "the", "lack", "of", "a", "native", "map", "type", "in", "GraphQL", "NUMBER", "It", "really", "kind", "of", "defeats", "the", "concept", "of", "GraphQL", "serving", "data", "in", "_exactly_", "the", "format", "in", "which", "clients", "need", "it", "NUMBER", "Now", "I", "feel", "differently", "NUMBER", "As", "be", "aside", "from", "type", "recursion", "there", "be", "only", "one", "unbounded", "type", "in", "GraphQL", "which", "be", "List", "NUMBER", "This", "actually", "makes", "it", "a", "lot", "more", "tractable", "to", "think", "about", "how", "to", "build", "abstractions", "on", "top", "of", "GraphQL", "NUMBER", "The", "cost", "of", "this", "be", "that", "clients", "have", "to", "manage", "their", "own", "data", "NUMBER", "But", "maybe", "this", "be", "as", "it", "should", "be", "NUMBER", "After", "all", "while", "GraphQL", "be", "meant", "to", "reproduce", "_graphs_", "of", "data", "in", "fact", "queries", "be", "_trees_", "NUMBER", "You", "bring", "your", "own", "graphification", "NUMBER", "Maybe", "maps", "and", "other", "higher", "level", "structures", "should", "similarly", "be", "deserialized", "out", "of", "more", "elemental", "pieces", "NUMBER", "Then", "something", "like", "a", "directive", "could", "be", "use", "in", "the", "schema", "to", "specify", "that", "a", "given", "list", "field", "should", "be", "interpreted", "as", "a", "map", "either", "by", "pulling", "out", "a", "given", "field", "as", "the", "key", "or", "identifying", "key", "and", "value", "field", "of", "entries", "NUMBER", "I", "don", "t", "think", "this", "change", "the", "fact", "that", "be", "able", "to", "limit", "values", "in", "a", "map", "would", "be", "a", "huge", "benefit", "NUMBER", "If", "the", "argument", "be", "that", "maps", "be", "harder", "to", "reason", "about", "I", "don", "t", "buy", "it", "NUMBER", "Think", "of", "maps", "as", "keys", "not", "with", "simple", "values", "but", "with", "huge", "objects", "underneath", "NUMBER", "If", "you", "re", "only", "interested", "in", "the", "name", "of", "each", "person", "Map", "TAG", "it", "would", "be", "more", "efficient", "to", "simply", "ask", "for", "the", "name", "NUMBER", "graphql", "mapOfPeople", "name", "photo", "small", "But", "it", "s", "impossible", "to", "model", "the", "data", "THROUGH", "the", "map", "NUMBER", "So", "anything", "that", "has", "a", "set", "of", "dynamic", "keys", "has", "to", "be", "emitted", "as", "json", "data", "and", "be", "opaque", "to", "the", "client", "NUMBER", "I", "wonder", "if", "there", "s", "a", "way", "to", "get", "best", "of", "both", "worlds", "as", "in", "protobuf", "LINK", "buffers", "docs", "proto", "maps", "NUMBER", "I", "was", "really", "surprized", "that", "there", "be", "no", "way", "to", "produce", "a", "hashMap", "with", "graphQL", "NUMBER", "I", "really", "loved", "graphQL", "and", "I", "was", "ready", "to", "convince", "my", "colleagues", "to", "migrate", "from", "Rest", "to", "GraphQL", "NUMBER", "But", "the", "absence", "of", "maps", "would", "make", "my", "argument", "imposible", "NUMBER", "We", "would", "have", "to", "massively", "refactor", "our", "frontend", "application", "NUMBER", "I", "appreciate", "the", "people", "who", "claim", "that", "this", "be", "an", "antipattern", "NUMBER", "But", "I", "personally", "belive", "that", "there", "be", "a", "reason", "why", "we", "use", "both", "in", "computer", "science", "NUMBER", "Some", "times", "the", "right", "thing", "do", "be", "use", "an", "array", "and", "some", "times", "be", "use", "a", "hashmap", "NUMBER", "There", "be", "not", "one", "answer", "here", "NUMBER", "So", "I", "really", "believe", "that", "be", "should", "be", "up", "to", "the", "users", "to", "decide", "NUMBER", "Some", "people", "like", "us", "have", "already", "frontend", "applications", "that", "use", "Maps", "all", "over", "the", "place", "NUMBER", "Some", "people", "simply", "like", "it", "NUMBER", "Sometimes", "accessing", "stuff", "like", "userGroups", "myUser", "NUMBER", "groupId", "be", "easier", "and", "cleaner", "than", "doing", "the", "more", "manual", "version", "userGroups", "NUMBER", "find", "g", "g", "NUMBER", "id", "myUser", "NUMBER", "groupId", "It", "seems", "much", "more", "performent", "too", "in", "js", "at", "least", "And", "after", "all", "the", "idea", "behind", "graphQL", "be", "that", "the", "client", "asks", "the", "structure", "that", "it", "needs", "NUMBER", "I", "really", "encourage", "the", "graphql", "people", "to", "consider", "this", "NUMBER", "I", "don", "t", "see", "this", "as", "an", "anti", "pattern", "NUMBER", "Map", "Dict", "Object", "KeyValue", "Stores", "be", "ubiquitous", "NUMBER", "Why", "Because", "they", "makes", "our", "life", "easier", "NUMBER", "And", "access", "faster", "NUMBER", "I", "just", "experimenting", "with", "GQL", "in", "an", "app", "which", "use", "map", "like", "structures", "NUMBER", "of", "course", "we", "can", "represent", "a", "map", "with", "a", "tuple", "and", "convert", "it", "in", "both", "directions", "but", "well", "why", "It", "s", "so", "painful", "And", "after", "all", "the", "idea", "behind", "graphQL", "be", "that", "the", "client", "asks", "the", "structure", "that", "it", "needs", "NUMBER", "A", "big", "NUMBER", "If", "a", "car", "be", "designed", "to", "get", "you", "from", "A", "to", "B", "then", "to", "push", "the", "car", "seems", "very", "strange", "NUMBER", "You", "often", "want", "to", "work", "with", "normalized", "data", "on", "the", "client", "NUMBER", "It", "can", "be", "easier", "and", "more", "performant", "NUMBER", "Something", "like", "get", "a", "few", "users", "and", "merge", "them", "into", "a", "redux", "store", "be", "simpler", "if", "they", "be", "returned", "as", "Map", "TAG", "NUMBER", "These", "be", "still", "well", "defined", "types", "NUMBER", "DylanVann", "But", "that", "s", "also", "an", "argument", "for", "not", "having", "a", "formal", "Map", "type", "NUMBER", "We", "use", "Redux", "too", "at", "my", "company", "NUMBER", "We", "ingest", "data", "from", "the", "network", "via", "our", "reducer", "layer", "into", "a", "normalized", "representation", "in", "the", "Redux", "store", "and", "then", "use", "a", "selector", "layer", "to", "present", "a", "more", "convenient", "denormalized", "view", "of", "the", "data", "to", "our", "React", "view", "layer", "NUMBER", "From", "that", "perspective", "it", "s", "only", "very", "slightly", "more", "difficult", "to", "ingest", "an", "array", "of", "entities", "by", "add", "them", "to", "Redux", "s", "key", "value", "representation", "than", "it", "be", "to", "merge", "a", "map", "of", "entities", "NUMBER", "It", "s", "basically", "something", "like", "Object", "NUMBER", "assign", "prevState", "NUMBER", "inputArray", "NUMBER", "map", "obj", "obj", "NUMBER", "id", "obj", "which", "be", "only", "slightly", "more", "difficult", "than", "Object", "NUMBER", "assign", "prevState", "inputMap", "NUMBER", "My", "point", "be", "either", "way", "you", "usually", "have", "to", "have", "_some", "sort_", "of", "ingestion", "of", "the", "raw", "data", "from", "GraphQL", "NUMBER", "Adding", "a", "native", "Map", "type", "to", "GraphQL", "makes", "ingestion", "slightly", "mildly", "easier", "but", "multiplies", "by", "some", "small", "constant", "factor", "the", "complexity", "of", "all", "tooling", "while", "not", "actually", "reducing", "complexity", "of", "GraphQL", "schemas", "themseleves", "field", "of", "type", "map", "TAG", "vs", "field", "of", "type", "Entity", "NUMBER", "I", "would", "posit", "that", "the", "best", "extensions", "to", "GraphQL", "be", "the", "things", "that", "significantly", "impact", "that", "last", "point", "NUMBER", "acjay", "Sure", "I", "could", "convert", "the", "data", "myself", "from", "a", "list", "to", "a", "map", "NUMBER", "You", "be", "right", "on", "this", "NUMBER", "Likewise", "I", "could", "survive", "if", "there", "were", "no", "aliases", "in", "graphQL", "NUMBER", "I", "could", "convert", "the", "field", "keys", "myself", "on", "the", "client", "to", "match", "my", "needs", "NUMBER", "But", "I", "cannot", "imagine", "anyone", "who", "would", "prefer", "write", "JS", "code", "to", "apply", "aliases", "instead", "of", "defining", "them", "in", "the", "graphql", "query", "NUMBER", "The", "second", "be", "much", "simpler", "more", "clear", "and", "more", "straight", "forward", "NUMBER", "Same", "be", "true", "for", "maps", "NUMBER", "Yes", "we", "can", "do", "it", "ourselves", "but", "it", "would", "be", "great", "if", "we", "didn", "t", "have", "to", "NUMBER", "You", "can", "use", "something", "like", "normalizr", "LINK", "on", "the", "client", "to", "deal", "with", "arrays", "be", "returned", "but", "it", "would", "be", "nicer", "in", "some", "cases", "if", "the", "API", "could", "just", "represent", "a", "Map", "NUMBER", "The", "existence", "of", "a", "workaround", "for", "not", "having", "a", "feature", "isn", "t", "an", "argument", "for", "not", "having", "the", "feature", "NUMBER", "edit", "It", "actually", "could", "be", "an", "argument", "but", "in", "this", "case", "I", "think", "the", "workaround", "be", "overly", "complex", "NUMBER", "Tricky", "without", "something", "like", "generic", "types", "or", "extensions", "of", "lists", "in", "GraphQL", "though", "NUMBER", "How", "do", "you", "know", "if", "a", "list", "be", "supposed", "to", "be", "a", "map", "This", "miss", "Map", "type", "be", "a", "problem", "for", "me", "as", "well", "NUMBER", "I", "recognize", "that", "any", "fundamental", "change", "to", "the", "GraphQL", "spec", "be", "difficult", "but", "the", "lack", "of", "this", "feature", "be", "particularly", "problematic", "because", "it", "s", "support", "in", "many", "of", "the", "type", "systems", "and", "services", "that", "GraphQL", "interfaces", "with", "NUMBER", "This", "leads", "to", "implement", "custom", "resolvers", "on", "the", "server", "followed", "by", "custom", "transforms", "on", "the", "client", "to", "deal", "with", "situations", "where", "my", "server", "be", "sending", "a", "Map", "and", "my", "client", "wants", "a", "Map", "and", "GraphQL", "be", "in", "the", "middle", "with", "no", "support", "for", "Maps", "NUMBER", "Yes", "it", "be", "possible", "and", "I", "have", "do", "it", "but", "it", "be", "fair", "bit", "of", "boilerplate", "and", "abstraction", "that", "seems", "to", "defeat", "the", "purpose", "of", "_writing", "the", "API", "spec", "in", "GraphQL_", "NUMBER", "Note", "that", "storing", "data", "in", "this", "way", "be", "actually", "recommended", "by", "services", "such", "as", "Firebase", "LINK", "solution_a_map_of_values", "it", "be", "amenable", "to", "mutations", "or", "referencing", "of", "subsets", "of", "items", "in", "the", "collection", "NUMBER", "You", "don", "t", "need", "to", "ensure", "consistency", "of", "the", "index", "location", "over", "time", "as", "other", "elements", "be", "add", "or", "remove", "NUMBER", "This", "be", "a", "common", "pattern", "in", "APIs", "where", "pagination", "be", "not", "required", "and", "or", "element", "ordering", "be", "not", "important", "to", "the", "spec", "NUMBER", "This", "be", "the", "case", "I", "be", "facing", "as", "well", "I", "be", "returning", "a", "set", "of", "objects", "from", "which", "I", "individually", "reference", "items", "for", "further", "update", "meaning", "that", "with", "an", "array", "I", "must", "re", "index", "the", "payload", "into", "a", "map", "on", "the", "client", "to", "avoid", "an", "O", "N", "search", "for", "each", "update", "NUMBER", "Here", "be", "some", "examples", "of", "how", "this", "type", "be", "handle", "in", "specifications", "that", "have", "close", "adjacency", "to", "GraphQL", "NUMBER", "This", "be", "a", "hypothetical", "object", "Apple", "with", "a", "field", "seeds", "containing", "one", "or", "more", "objects", "indexed", "by", "a", "string", "key", "NUMBER", "Apologies", "in", "advance", "for", "any", "minor", "typo", "NUMBER", "json", "Example", "Apple", "Payload", "JSON", "seeds", "alpha", "weight", "NUMBER", "beta", "weight", "NUMBER", "gamma", "weight", "NUMBER", "Typescript", "LINK", "indexable", "types", "typescript", "interface", "Apple", "seeds", "key", "string", "weight", "number", "Javascript", "Flow", "LINK", "toc", "objects", "as", "maps", "javascript", "type", "Apple", "seeds", "string", "weight", "number", "Python", "via", "typings", "LINK", "NUMBER", "the", "typing", "module", "python", "class", "AppleSeed", "weight", "int", "class", "Apple", "seeds", "Dict", "str", "AppleSeed", "JSONSchema", "Used", "by", "MongoDB", "LINK", "json", "schema", "reference", "object", "NUMBER", "html", "pattern", "properties", "json", "type", "object", "properties", "seeds", "type", "object", "patternProperties", "NUMBER", "type", "object", "properties", "weight", "integer", "I", "do", "not", "think", "that", "map", "be", "an", "anti", "pattern", "NUMBER", "It", "be", "rather", "an", "extension", "or", "even", "a", "functional", "superset", "of", "an", "array", "NUMBER", "Given", "that", "a", "map", "structure", "when", "serialised", "to", "JSON", "looks", "like", "JSON", "mapStruct", "key", "NUMBER", "value", "NUMBER", "key", "NUMBER", "value", "NUMBER", "It", "can", "then", "be", "viewed", "as", "an", "ordered", "list", "of", "values", "with", "explicit", "string", "indices", "basically", "a", "LinkedHashMap", "in", "Java", "if", "you", "will", "which", "in", "turn", "be", "based", "on", "a", "HashMap", "and", "LinkedList", "NUMBER", "In", "contrast", "an", "array", "uses", "implicit", "numeric", "indices", "NUMBER", "If", "need", "be", "in", "most", "of", "the", "languages", "one", "can", "retrieve", "a", "_list_", "of", "keys", "available", "in", "a", "map", "which", "can", "then", "be", "use", "to", "mimic", "array", "access", "either", "by", "use", "the", "literal", "string", "value", "or", "the", "numeric", "position", "thereof", "NUMBER", "Therefore", "when", "serialised", "to", "JSON", "a", "map", "be", "an", "ordered", "structure", "NUMBER", "Deserialised", "it", "that", "can", "be", "accessed", "as", "both", "a", "map", "and", "an", "array", "NUMBER", "Having", "said", "the", "above", "I", "do", "not", "see", "an", "issue", "with", "the", "pagination", "either", "NUMBER", "Pagination", "depends", "not", "only", "on", "the", "ordered", "data", "structure", "but", "also", "on", "the", "backend", "NUMBER", "If", "the", "backend", "guarantees", "the", "ordering", "of", "the", "result", "fine", "if", "it", "returns", "values", "in", "arbitrary", "positions", "pagination", "will", "not", "make", "sense", "regardless", "of", "the", "data", "structure", "use", "NUMBER", "Thus", "the", "behaviour", "here", "be", "identical", "for", "both", "arrays", "and", "maps", "NUMBER", "I", "like", "the", "suggestion", "to", "use", "typed", "Map", "TAG", "mapStruct", "NUMBER", "Consider", "the", "following", "property", "declaration", "mapStruct", "Map", "Value", "that", "would", "translate", "to", "something", "like", "mapStruct", "key", "NUMBER", "Value", "key", "NUMBER", "Value", "NUMBER", "There", "s", "a", "GraphQL", "WG", "meeting", "come", "up", "soon", "NUMBER", "Perhaps", "the", "right", "thing", "to", "do", "be", "to", "put", "together", "some", "sort", "of", "formal", "proposal", "discuss", "it", "at", "the", "WG", "meeting", "and", "finally", "put", "this", "issue", "to", "rest", "once", "and", "for", "all", "in", "whichever", "manner", "works", "best", "I", "ve", "composed", "this", "document", "LINK", "_proposal_map", "blob", "master", "graphql_wg_map", "NUMBER", "md", "that", "could", "hopefully", "serve", "as", "a", "starting", "point", "for", "the", "proposal", "NUMBER", "The", "document", "has", "three", "main", "parts", "motivation", "specification", "and", "other", "considerations", "NUMBER", "Any", "feedback", "discussion", "and", "edits", "be", "greatly", "appreciated", "NUMBER", "Of", "course", "do", "not", "leave", "out", "the", "text", "clarity", "style", "and", "grammar", "especially", "the", "articles", "PS", "NUMBER", "I", "understand", "that", "the", "propose", "solution", "will", "not", "satisfy", "everyone", "but", "we", "have", "to", "start", "somewhere", "NUMBER", "gintautassulskus", "taion", "We", "have", "the", "standard", "checklist", "for", "add", "new", "features", "Are", "we", "solving", "a", "real", "problem", "Does", "this", "enable", "new", "use", "cases", "How", "common", "be", "this", "use", "case", "Can", "we", "enable", "it", "without", "a", "change", "to", "GraphQL", "Is", "so", "just", "how", "awkward", "be", "it", "Here", "be", "relevant", "part", "from", "leebyron", "talk", "LINK", "NUMBER", "m", "NUMBER", "s", "I", "ve", "composed", "this", "document", "that", "could", "hopefully", "serve", "as", "a", "starting", "point", "for", "the", "proposal", "NUMBER", "gintautassulskus", "I", "couldn", "t", "find", "example", "query", "that", "do", "subselection", "on", "map", "value", "NUMBER", "I", "personaly", "think", "that", "this", "feature", "shouldn", "t", "brake", "current", "assumption", "that", "shape", "of", "query", "should", "match", "shape", "of", "result", "NUMBER", "So", "query", "shouldn", "t", "be", "like", "that", "mapField", "fieldOnValue", "Because", "responce", "will", "look", "like", "that", "json", "mapField", "foo", "fieldOnValue", "bar", "I", "think", "it", "s", "one", "of", "the", "most", "critical", "parts", "of", "this", "proposal", "NUMBER", "IvanGoncharov", "To", "be", "clear", "I", "don", "t", "care", "one", "way", "or", "another", "how", "this", "turns", "out", "so", "long", "as", "it", "do", "get", "resolve", "NUMBER", "This", "issue", "has", "be", "open", "for", "NUMBER", "years", "now", "unless", "we", "think", "the", "issue", "be", "that", "we", "re", "miss", "the", "right", "proposal", "we", "should", "accept", "or", "reject", "what", "s", "here", "one", "way", "or", "another", "NUMBER", "I", "have", "an", "idea", "on", "oh", "this", "could", "look", "like", "NUMBER", "Lets", "assume", "that", "we", "have", "a", "User", "type", "that", "we", "want", "to", "create", "the", "Map", "with", "it", "in", "Query", "type", "NUMBER", "Schema", "would", "be", "like", "type", "User", "id", "Int", "name", "String", "favoriteColor", "String", "NUMBER", "type", "Query", "userMap", "Int", "User", "or", "userMap", "Int", "User", "so", "that", "it", "looks", "more", "like", "JSON", "The", "query", "would", "look", "exactly", "like", "the", "ones", "for", "arrays", "query", "userMap", "id", "name", "And", "the", "result", "would", "be", "data", "userMap", "NUMBER", "id", "NUMBER", "name", "Linus", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Depending", "on", "the", "serializer", "that", "one", "uses", "there", "will", "be", "limitations", "in", "place", "for", "the", "type", "of", "the", "map", "keys", "NUMBER", "For", "example", "if", "we", "serialize", "to", "JSON", "it", "would", "have", "sense", "that", "we", "use", "types", "that", "can", "be", "converted", "to", "Strings", "strings", "integers", "or", "even", "custom", "scalars", "that", "can", "be", "converted", "into", "strings", "NUMBER", "In", "my", "oppinion", "graphQL", "itself", "should", "not", "bother", "with", "this", "type", "restriction", "the", "serializer", "that", "one", "uses", "will", "handle", "it", "NUMBER", "But", "if", "we", "decide", "that", "this", "be", "an", "important", "issue", "we", "could", "simply", "whitelist", "a", "number", "of", "scalars", "that", "be", "allow", "to", "be", "use", "as", "map", "keys", "NUMBER", "On", "Thu", "May", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Jimmy", "Jia", "TAG", "write", "IvanGoncharov", "TAG", "To", "be", "clear", "I", "don", "t", "care", "one", "way", "or", "another", "how", "this", "turns", "out", "so", "long", "as", "it", "do", "get", "resolve", "NUMBER", "This", "issue", "has", "be", "open", "for", "NUMBER", "years", "now", "unless", "we", "think", "the", "issue", "be", "that", "we", "re", "miss", "the", "right", "proposal", "we", "should", "accept", "or", "reject", "what", "s", "here", "one", "way", "or", "another", "NUMBER", "You", "be", "receiving", "this", "because", "you", "commented", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "I", "agree", "with", "IvanGoncharov", "about", "not", "breaking", "assumptions", "NUMBER", "GraphQL", "be", "all", "about", "specify", "which", "keys", "of", "data", "be", "important", "to", "you", "and", "add", "implicit", "keys", "to", "the", "response", "breaks", "that", "NUMBER", "When", "integrating", "different", "systems", "this", "might", "not", "be", "always", "feasible", "but", "nothing", "prevents", "you", "of", "handle", "it", "with", "a", "wrapper", "type", "as", "mention", "before", "type", "MyHashMap", "key", "string", "value", "User", "type", "User", "firstname", "string", "lastname", "string", "type", "Query", "users", "MyHashMap", "query", "users", "key", "value", "firstname", "This", "be", "no", "different", "from", "pagination", "or", "any", "other", "complex", "data", "structure", "NUMBER", "It", "just", "needs", "to", "be", "documented", "since", "it", "s", "no", "obvious", "for", "a", "newcomer", "how", "to", "achieve", "it", "NUMBER", "A", "change", "in", "the", "spec", "might", "look", "convenient", "at", "first", "glance", "but", "doesn", "t", "enable", "new", "use", "cases", "and", "will", "require", "a", "lot", "of", "effort", "on", "every", "graphql", "implementation", "and", "relate", "tooling", "to", "catch", "up", "NUMBER", "Also", "there", "will", "be", "some", "edge", "cases", "that", "be", "not", "easy", "to", "capture", "in", "the", "spec", "eg", "What", "should", "happen", "if", "the", "map", "has", "too", "many", "keys", "and", "a", "client", "needs", "to", "paginate", "the", "returned", "result", "What", "if", "they", "keys", "don", "t", "have", "a", "single", "type", "like", "some", "systems", "allow", "I", "completely", "appreciate", "the", "issue", "it", "happened", "to", "me", "many", "times", "but", "having", "some", "recommendations", "on", "how", "to", "do", "it", "and", "perhaps", "some", "helper", "code", "should", "be", "enough", "NUMBER", "IvanGoncharov", "thanks", "these", "be", "very", "good", "points", "NUMBER", "The", "presentation", "mentions", "production", "test", "NUMBER", "The", "proposal", "could", "at", "least", "validate", "the", "acceptance", "of", "the", "concept", "NUMBER", "The", "implementation", "and", "test", "would", "follow", "if", "need", "be", "NUMBER", "alkismavridis", "That", "looks", "like", "a", "neat", "solution", "NUMBER", "The", "only", "quirk", "I", "see", "be", "that", "Int", "User", "requires", "a", "hardcoded", "id", "field", "NUMBER", "Maybe", "a", "meta", "field", "__key", "would", "do", "NUMBER", "Gotusso", "I", "see", "your", "point", "NUMBER", "You", "think", "standardising", "the", "approach", "to", "avoid", "custom", "solutions", "be", "a", "bit", "of", "a", "stretch", "No", "I", "think", "it", "would", "be", "fair", "enough", "to", "have", "a", "separate", "spec", "and", "a", "reference", "implementation", "in", "the", "spirit", "of", "Relay", "s", "pagination", "NUMBER", "That", "can", "cover", "most", "of", "the", "cases", "and", "the", "community", "could", "use", "it", "or", "not", "depending", "on", "their", "particular", "needs", "NUMBER", "I", "think", "that", "the", "solution", "about", "the", "wrapper", "object", "be", "not", "helping", "much", "NUMBER", "The", "real", "benefit", "would", "be", "to", "get", "ready", "to", "use", "map", "types", "on", "the", "client", "without", "the", "need", "of", "converting", "some", "other", "data", "type", "o", "map", "every", "time", "NUMBER", "If", "we", "embrace", "the", "idea", "that", "client", "side", "proccessing", "be", "required", "we", "could", "forget", "the", "map", "support", "completely", "and", "use", "lists", "which", "would", "be", "converted", "on", "the", "client", "to", "maps", "by", "choosing", "a", "property", "as", "key", "or", "something", "like", "that", "NUMBER", "In", "fact", "we", "write", "in", "our", "project", "our", "own", "ListToMap", "list", "propToUseAsKey", "function", "to", "handle", "this", "NUMBER", "And", "we", "call", "this", "every", "time", "we", "need", "to", "use", "a", "map", "NUMBER", "I", "think", "the", "whole", "idea", "for", "map", "type", "support", "in", "graphQL", "be", "not", "having", "to", "do", "that", "whicg", "I", "personally", "would", "find", "extremely", "handy", "and", "helpful", "NUMBER", "As", "for", "Gotusso", "s", "comment", "yes", "that", "be", "correct", "NUMBER", "The", "implementation", "method", "would", "choose", "what", "property", "to", "use", "as", "key", "NUMBER", "But", "I", "think", "this", "be", "fair", "enough", "since", "most", "of", "the", "times", "the", "key", "that", "has", "sense", "be", "application", "specific", "NUMBER", "Some", "times", "this", "be", "could", "be", "a", "DB", "id", "some", "times", "it", "be", "a", "timestamp", "etc", "NUMBER", "In", "any", "case", "the", "application", "knows", "that", "and", "can", "specify", "that", "NUMBER", "So", "I", "think", "giving", "this", "responsibility", "to", "the", "implementation", "method", "be", "a", "fair", "choice", "NUMBER", "The", "client", "then", "would", "choose", "what", "field", "to", "fetch", "from", "the", "value", "object", "but", "not", "what", "key", "to", "use", "NUMBER", "This", "be", "definatelly", "a", "tradeoff", "but", "I", "think", "not", "so", "significant", "NUMBER", "On", "Thu", "May", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Franco", "Gotusso", "TAG", "write", "No", "I", "think", "it", "would", "be", "fair", "enough", "to", "have", "a", "separate", "spec", "and", "a", "reference", "implementation", "in", "the", "spirit", "of", "Relay", "s", "pagination", "NUMBER", "That", "can", "cover", "most", "of", "the", "cases", "and", "the", "community", "could", "use", "it", "or", "not", "depending", "on", "their", "particular", "needs", "NUMBER", "You", "be", "receiving", "this", "because", "you", "were", "mention", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "TAG", "or", "mute", "the", "thread", "TAG", "NUMBER", "In", "Apollo", "the", "GraphQL", "API", "be", "cached", "and", "can", "be", "use", "sort", "of", "like", "a", "redux", "store", "NUMBER", "Ideally", "you", "d", "want", "it", "to", "be", "normalized", "but", "that", "doesn", "t", "seem", "possible", "currently", "NUMBER", "In", "one", "case", "if", "I", "m", "use", "the", "cache", "I", "have", "to", "loop", "over", "a", "bunch", "of", "items", "instead", "of", "just", "checking", "an", "ID", "NUMBER", "It", "s", "not", "insurmountable", "to", "work", "around", "this", "but", "it", "definitely", "doesn", "t", "seem", "ideal", "NUMBER", "ship", "it", "I", "like", "it", "NUMBER", "Ship", "it", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Use", "ImplementsInterfaces", "syntax", "from", "GraphQL", "IDL", "in", "the", "examples", "NUMBER", "Suppose", "we", "have", "a", "forum", "where", "users", "can", "reply", "to", "comments", "recursively", "graphql", "type", "RootQuery", "message", "id", "String", "Message", "message", "Message", "type", "Message", "id", "String", "content", "String", "comments", "Message", "How", "could", "the", "client", "query", "for", "the", "nested", "comments", "This", "only", "goes", "three", "levels", "deep", "graphql", "message", "comments", "id", "content", "comments", "id", "content", "comments", "id", "content", "Would", "a", "consecutive", "query", "starting", "at", "the", "last", "comment", "be", "the", "right", "solution", "graphql", "message", "as", "comment", "commentId", "comments", "id", "content", "comments", "NUMBER", "Original", "SO", "post", "LINK", "graphql", "types", "NUMBER", "NUMBER", "Saw", "similar", "question", "in", "Relay", "repo", "LINK", "Yeah", "that", "s", "what", "I", "d", "thought", "NUMBER", "petrbela", "Can", "we", "re", "open", "this", "issue", "as", "that", "issue", "only", "talks", "about", "the", "relay", "side", "of", "things", "NUMBER", "I", "would", "like", "to", "know", "how", "to", "accomplish", "recursive", "object", "types", "while", "creating", "a", "graphQL", "server", "NUMBER", "nmn", "NUMBER", "nmn", "You", "can", "define", "recursive", "object", "types", "by", "passing", "a", "thunk", "a", "function", "without", "argument", "that", "returns", "the", "field", "js", "const", "Message", "new", "GraphQLObjectType", "name", "Message", "field", "comments", "type", "new", "GraphQLList", "Message", "resolve", "message", "return", "getComments", "message", "NUMBER", "id", "content", "type", "GraphQLString", "You", "can", "even", "define", "mutually", "recursive", "objects", "and", "GraphQL", "schema", "be", "smart", "enough", "to", "lazily", "call", "the", "field", "function", "to", "resolve", "them", "when", "needed", "NUMBER", "fson", "In", "other", "words", "in", "the", "query", "you", "only", "ask", "for", "one", "level", "of", "message", "s", "comments", "message", "NUMBER", "id", "comments", "content", "And", "the", "comments", "field", "could", "return", "all", "nested", "comments", "js", "message", "id", "NUMBER", "comments", "content", "First", "comment", "comments", "content", "Nested", "comment", "Is", "that", "so", "It", "seems", "to", "be", "against", "logic", "since", "the", "reply", "structure", "doesn", "t", "exactly", "mirror", "the", "query", "NUMBER", "Does", "the", "getComments", "method", "return", "the", "whole", "nested", "tree", "How", "would", "the", "GraphQL", "executor", "know", "to", "expand", "the", "comments", "field", "once", "it", "steps", "into", "resolving", "the", "first", "comment", "The", "query", "only", "tells", "the", "executor", "to", "ask", "for", "the", "content", "field", "NUMBER", "petrbela", "Only", "ask", "for", "one", "level", "of", "nested", "comments", "would", "return", "one", "level", "of", "nested", "comments", "NUMBER", "So", "you", "would", "explicitly", "make", "a", "query", "that", "fetches", "comments", "as", "deep", "as", "you", "need", "to", "go", "NUMBER", "The", "GraphQL", "executor", "resolve", "the", "field", "recursively", "from", "top", "to", "bottom", "so", "getComments", "message", "NUMBER", "id", "would", "simply", "return", "the", "list", "of", "comment", "message", "for", "the", "given", "message", "NUMBER", "In", "other", "words", "there", "isn", "t", "anything", "specific", "needed", "on", "the", "server", "to", "support", "these", "nested", "queries", "NUMBER", "The", "only", "trick", "be", "to", "define", "the", "field", "with", "a", "thunk", "to", "avoid", "problem", "with", "the", "execution", "order", "of", "the", "type", "definitions", "NUMBER", "I", "made", "a", "gist", "with", "a", "work", "example", "of", "the", "recursive", "message", "comments", "schema", "if", "you", "want", "to", "play", "with", "it", "LINK", "Thanks", "for", "the", "comments", "NUMBER", "The", "main", "question", "was", "if", "you", "could", "return", "a", "recursively", "nested", "object", "without", "knowing", "the", "depth", "in", "a", "single", "query", "NUMBER", "Seems", "the", "only", "way", "would", "be", "to", "send", "a", "query", "with", "a", "lot", "of", "nesting", "at", "least", "as", "much", "as", "the", "deepest", "reply", "tree", "and", "GraphQL", "would", "expand", "each", "branch", "until", "it", "reaches", "a", "null", "object", "leaf", "in", "each", "of", "the", "branch", "NUMBER", "This", "should", "theoretically", "work", "with", "Relay", "too", "if", "I", "m", "not", "mistaken", "NUMBER", "Or", "do", "you", "have", "any", "other", "idea", "Yeah", "as", "far", "as", "I", "know", "it", "s", "not", "possible", "to", "write", "a", "recursive", "query", "of", "unlimited", "depth", "NUMBER", "Trying", "to", "do", "so", "use", "fragment", "will", "result", "in", "an", "error", "Cannot", "spread", "fragment", "MessageFragment", "within", "itself", "NUMBER", "graphql", "fragment", "MessageFragment", "on", "Message", "content", "comments", "NUMBER", "MessageFragment", "This", "be", "because", "fragment", "be", "fully", "expanded", "before", "execution", "and", "this", "fragment", "would", "result", "in", "infinite", "expansion", "NUMBER", "I", "think", "a", "query", "with", "deep", "but", "finite", "nesting", "would", "be", "the", "only", "way", "to", "query", "a", "hierarchy", "like", "that", "NUMBER", "You", "can", "make", "that", "query", "use", "conditional", "fragment", "like", "josephsavona", "suggested", "in", "the", "relate", "Relay", "issue", "LINK", "issuecomment", "NUMBER", "and", "Relay", "will", "expand", "it", "to", "a", "such", "deeply", "nested", "query", "NUMBER", "I", "also", "think", "this", "be", "rarely", "a", "problem", "for", "real", "life", "UIs", "because", "you", "wouldn", "t", "want", "to", "fetch", "_infinite_", "layers", "of", "comments", "anyway", "but", "instead", "fetch", "some", "number", "of", "levels", "first", "and", "then", "have", "a", "way", "for", "the", "user", "to", "load", "more", "comments", "from", "a", "nested", "tree", "like", "Reddit", "do", "NUMBER", "it", "s", "not", "possible", "to", "write", "a", "recursive", "query", "of", "unlimited", "depth", "It", "s", "even", "explicitly", "_forbidden_", "by", "the", "spec", "The", "graph", "of", "fragment", "spreads", "must", "not", "form", "any", "cycles", "including", "spreading", "itself", "NUMBER", "Otherwise", "an", "operation", "could", "infinitely", "spread", "or", "infinitely", "execute", "on", "cycles", "in", "the", "underlying", "data", "NUMBER", "LINK", "sec", "Fragment", "spreads", "must", "not", "form", "cycles", "Closing", "this", "issue", "since", "I", "believe", "it", "be", "answered", "NUMBER", "We", "explicitly", "do", "not", "allow", "fragment", "recursion", "or", "the", "querying", "of", "recursive", "structured", "since", "it", "can", "result", "in", "un", "bound", "results", "NUMBER", "Typically", "you", "also", "never", "really", "want", "to", "require", "something", "of", "infinite", "depth", "anyhow", "so", "it", "s", "good", "to", "put", "a", "bound", "on", "these", "things", "NUMBER", "A", "pattern", "I", "often", "see", "use", "fragment", "message", "NUMBER", "CommentsRecursive", "fragment", "CommentsRecursive", "on", "Message", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "comments", "NUMBER", "CommentFields", "fragment", "CommentFields", "on", "Comment", "id", "content", "this", "lets", "you", "define", "the", "field", "you", "want", "at", "each", "depth", "level", "in", "one", "place", "and", "then", "also", "explicitly", "state", "the", "recursive", "structure", "you", "want", "in", "the", "above", "example", "it", "s", "NUMBER", "levels", "deep", "but", "you", "can", "see", "how", "you", "could", "easily", "add", "more", "NUMBER", "be", "really", "there", "no", "other", "option", "here", "for", "fetching", "nested", "data", "where", "the", "depth", "be", "unknown", "There", "be", "plenty", "of", "normal", "situations", "where", "data", "be", "nested", "but", "definitely", "_not_", "infinitely", "recursive", "such", "as", "the", "the", "comment", "case", "NUMBER", "Are", "we", "just", "supposed", "to", "tell", "users", "that", "they", "can", "t", "comment", "past", "a", "depth", "of", "NUMBER", "Without", "an", "ability", "to", "make", "this", "guarantee", "allowing", "for", "cyclic", "queries", "could", "in", "fact", "expose", "infinite", "execution", "queries", "which", "could", "be", "use", "as", "an", "attack", "vector", "NUMBER", "sure", "I", "understand", "why", "it", "would", "be", "a", "problem", "I", "m", "suggesting", "that", "be", "able", "to", "tell", "GraphQL", "that", "it", "has", "that", "guarantee", "would", "be", "a", "great", "feature", "NUMBER", "The", "alternative", "of", "copy", "pasting", "a", "fragment", "nth", "times", "be", "not", "the", "best", "or", "even", "feasible", "in", "some", "cases", "NUMBER", "I", "also", "appreciate", "the", "concern", "handle", "by", "show", "more", "comments", "but", "I", "don", "t", "know", "that", "that", "its", "a", "good", "idea", "for", "GraphQL", "to", "make", "that", "choice", "for", "our", "app", "in", "the", "same", "way", "it", "doesn", "t", "require", "I", "paginate", "all", "lists", "above", "a", "certain", "length", "NUMBER", "Commenting", "for", "any", "further", "Bingers", "Jeevers", "const", "recursiveType", "new", "GraphQLScalarType", "name", "MyFunAntiGraphQLRecursiveType", "description", "Bails", "out", "of", "GraphQL", "conventions", "and", "just", "returns", "the", "straight", "JSON", "Object", "NUMBER", "serialize", "_", "return", "_", "Of", "course", "I", "d", "highly", "highly", "highly", "very", "highly", "recommend", "not", "doing", "as", "such", "NUMBER", "But", "if", "you", "need", "an", "escape", "hatch", "welcome", "to", "LOST", "strawman", "would", "be", "useful", "to", "have", "the", "recursion", "expanded", "and", "limited", "by", "the", "query", "language", "message", "NUMBER", "Comments", "fragment", "Comments", "on", "Message", "id", "content", "comments", "NUMBER", "Comments", "NUMBER", "The", "NUMBER", "expands", "it", "three", "levels", "deep", "or", "some", "other", "bikeshedded", "syntax", "NUMBER", "Probably", "hard", "to", "implemen", "NUMBER", "If", "there", "be", "multiple", "recursions", "or", "anything", "else", "in", "the", "spec", "who", "knows", "NUMBER", "The", "parser", "could", "read", "the", "fragment", "and", "the", "count", "NUMBER", "Once", "it", "has", "build", "out", "the", "fragment", "ignoring", "the", "recursion", "it", "could", "copy", "and", "stamp", "the", "nodes", "down", "the", "tree", "NUMBER", "Haven", "t", "really", "looked", "much", "into", "the", "GraphQL", "parser", "to", "figure", "out", "if", "how", "it", "d", "be", "implement", "This", "may", "be", "a", "silly", "counter", "argument", "but", "such", "a", "syntax", "would", "encourage", "a", "ridiculous", "level", "of", "recursion", "Currently", "I", "d", "have", "to", "copy", "paste", "a", "selection", "NUMBER", "times", "so", "I", "m", "bound", "to", "think", "twice", "about", "doing", "it", "whereas", "typing", "NUMBER", "would", "be", "far", "easier", "NUMBER", "The", "current", "syntax", "or", "lack", "of", "one", "almost", "serves", "as", "a", "natural", "deterrent", "NUMBER", "If", "one", "has", "need", "for", "that", "level", "of", "recursion", "then", "batched", "resolution", "becomes", "really", "important", "to", "work", "around", "the", "N", "NUMBER", "query", "proliferation", "problem", "see", "graphql", "resolve", "batch", "on", "github", "npm", "NUMBER", "As", "a", "note", "to", "others", "that", "may", "be", "doing", "nested", "recursions", "like", "use", "the", "example", "per", "leebyron", "Make", "sure", "that", "each", "level", "has", "a", "unique", "ID", "including", "unique", "against", "any", "copy", "objects", "that", "use", "the", "same", "structure", "NUMBER", "Eg", "NUMBER", "if", "you", "copy", "an", "object", "that", "be", "constructed", "use", "this", "and", "you", "don", "t", "change", "each", "ID", "Apollo", "Client", "cache", "can", "get", "the", "sub", "elements", "mix", "up", "because", "the", "typename", "on", "all", "be", "the", "same", "NUMBER", "This", "be", "not", "a", "bug", "of", "course", "but", "it", "can", "be", "quite", "perplexing", "to", "unravel", "NUMBER", "I", "have", "implement", "some", "graphql", "alternative", "parsers", "a", "few", "years", "ago", "and", "have", "be", "pondering", "recently", "about", "this", "again", "NUMBER", "leebyron", "You", "be", "probably", "aware", "that", "Datomic", "Pull", "Query", "do", "support", "a", "syntax", "for", "recursive", "querying", "and", "I", "do", "find", "it", "useful", "for", "some", "graph", "entity", "domains", "NUMBER", "Do", "you", "still", "maintain", "the", "position", "that", "it", "s", "dangerous", "enough", "that", "GraphQL", "spec", "should", "not", "really", "support", "at", "all", "not", "even", "a", "N", "depth", "limited", "recursion", "It", "still", "do", "not", "seem", "like", "an", "elegant", "solution", "to", "repeat", "a", "query", "fragment", "N", "times", "NUMBER", "it", "s", "just", "that", "in", "real", "business", "applications", "a", "bug", "introduce", "by", "miss", "data", "be", "more", "likely", "to", "occur", "than", "security", "issue", "specially", "inside", "VPNs", "NUMBER", "Perhaps", "the", "way", "to", "go", "in", "GraphQL", "would", "be", "something", "like", "comments", "recurse", "true", "right", "With", "no", "special", "syntax", "needed", "NUMBER", "Just", "commenting", "here", "in", "case", "there", "be", "news", "about", "this", "topic", "NUMBER", "thanks", "for", "sharing", "your", "thoughts", "and", "great", "work", "Just", "point", "out", "that", "there", "be", "a", "scalar", "JsonType", "LINK", "type", "json", "available", "NUMBER", "For", "dynamic", "and", "very", "app", "specific", "data", "I", "find", "it", "very", "useful", "you", "could", "use", "it", "for", "recursive", "comments", "but", "I", "wouldn", "t", "NUMBER", "Should", "this", "also", "include", "directives", "Something", "like", "DirectiveDefinition", "directive", "Name", "ArgumentsDefinition", "This", "doesn", "t", "capture", "scope", "validation", "rules", "so", "perhaps", "it", "should", "include", "an", "on", "clause", "DirectiveDefinition", "directive", "Name", "ArgumentsDefinition", "DirectiveScopes", "DirectiveScopes", "on", "DirectiveScope", "DirectiveScope", "field", "fragment", "operation", "So", "include", "would", "be", "defined", "like", "directive", "include", "if", "Boolean", "on", "field", "fragment", "Is", "there", "any", "movement", "on", "this", "This", "be", "a", "pretty", "compelling", "piece", "of", "the", "GraphQL", "puzzle", "and", "opens", "up", "the", "possibility", "of", "tooling", "around", "schema", "design", "and", "also", "allows", "the", "creation", "of", "a", "cross", "language", "test", "suite", "NUMBER", "I", "ended", "up", "implement", "most", "of", "this", "grammar", "in", "a", "project", "I", "m", "work", "on", "NUMBER", "Here", "s", "the", "relevant", "lines", "from", "a", "PEG", "grammar", "just", "the", "type", "parsing", "stuff", "TypeDefinition", "TAG", "it", "s", "hard", "to", "ignore", "the", "better", "developer", "ergonomics", "Can", "you", "elaborate", "on", "how", "the", "developer", "ergonomics", "be", "better", "I", "m", "just", "a", "bystander", "use", "GraphQL", "for", "hobby", "projects", "but", "I", "have", "to", "admit", "I", "m", "disappointed", "to", "see", "a", "future", "where", "comments", "be", "officially", "use", "to", "embed", "directives", "like", "this", "NUMBER", "I", "was", "hoping", "for", "something", "like", "description", "NUMBER", "When", "you", "re", "in", "a", "position", "to", "update", "the", "GraphQL", "spec", "itself", "why", "not", "just", "use", "a", "different", "syntax", "and", "remove", "all", "possible", "ambiguity", "Even", "just", "a", "single", "different", "leading", "character", "instead", "of", "I", "know", "people", "widely", "complain", "about", "JSON", "s", "lack", "of", "comments", "given", "it", "s", "now", "popularly", "adopted", "for", "config", "file", "but", "I", "think", "the", "reasoning", "was", "quite", "prescient", "if", "they", "were", "support", "comment", "directives", "would", "have", "sprung", "up", "in", "every", "JSON", "parser", "and", "hurt", "interoperability", "NUMBER", "Sure", "this", "discussion", "would", "effectively", "make", "comments", "as", "descriptions", "in", "GraphQL", "official", "but", "still", "why", "not", "introduce", "a", "new", "syntax", "remove", "ambiguity", "and", "let", "comments", "be", "comments", "Just", "to", "give", "another", "less", "frequent", "but", "possibly", "important", "use", "case", "for", "the", "type", "definition", "language", "I", "m", "work", "on", "a", "specification", "at", "OASIS", "that", "be", "interested", "in", "use", "GraphQL", "as", "part", "of", "the", "transport", "language", "but", "for", "that", "we", "would", "need", "the", "type", "language", "to", "be", "specified", "and", "relatively", "stable", "NUMBER", "So", "this", "be", "a", "case", "where", "we", "cannot", "use", "any", "programming", "language", "specification", "NUMBER", "I", "ve", "grown", "accustomed", "to", "the", "comment", "approach", "but", "it", "would", "be", "nice", "to", "also", "add", "a", "way", "to", "have", "non", "visible", "comments", "NUMBER", "I", "think", "the", "main", "issue", "for", "me", "be", "you", "can", "t", "add", "internal", "comments", "like", "TODO", "add", "a", "limit", "to", "this", "field", "later", "or", "similar", "NUMBER", "I", "kind", "of", "like", "the", "idea", "since", "it", "reminds", "me", "of", "in", "javadoc", "NUMBER", "I", "would", "vote", "for", "parser", "friendly", "solution", "NUMBER", "It", "be", "easy", "to", "support", "description", "in", "parser", "if", "it", "be", "defined", "use", "something", "like", "or", "NUMBER", "It", "harder", "to", "support", "description", "with", "exist", "comment", "format", "NUMBER", "It", "takes", "multiple", "pass", "to", "identify", "which", "comment", "be", "description", "NUMBER", "I", "really", "like", "the", "Python", "like", "docstring", "approach", "and", "was", "thinking", "of", "suggesting", "exactly", "the", "same", "thing", "it", "s", "easy", "for", "those", "less", "familiar", "with", "the", "language", "to", "misinterpret", "the", "strings", "a", "important", "to", "runtime", "behavior", "and", "become", "confused", "NUMBER", "Aren", "t", "they", "indeed", "important", "to", "runtime", "behavior", "and", "thus", "this", "isn", "t", "a", "misinterpretation", "One", "of", "the", "major", "reasons", "I", "don", "t", "like", "the", "comment", "approach", "be", "because", "we", "don", "t", "expect", "things", "that", "look", "like", "comments", "to", "affect", "nor", "be", "available", "at", "runtime", "NUMBER", "But", "descriptions", "be", "available", "at", "runtime", "and", "be", "use", "in", "the", "GraphiQL", "Docs", "browser", "via", "introspection", "and", "such", "NUMBER", "Maybe", "I", "m", "misunderstanding", "what", "you", "mean", "by", "runtime", "behavior", "though", "NUMBER", "As", "a", "concrete", "example", "how", "can", "I", "do", "this", "LINK", "API", "blob", "NUMBER", "f", "NUMBER", "f", "NUMBER", "c", "NUMBER", "eaf", "NUMBER", "ca", "NUMBER", "e", "NUMBER", "f", "NUMBER", "df", "NUMBER", "d", "NUMBER", "f", "NUMBER", "b", "api", "sql", "schema", "NUMBER", "js", "L", "NUMBER", "The", "SQL", "ID", "of", "this", "entry", "id", "Int", "XXX", "to", "be", "change", "vote", "Vote", "This", "be", "a", "real", "comment", "in", "the", "sense", "that", "it", "s", "an", "internal", "note", "in", "the", "code", "NUMBER", "Would", "that", "need", "to", "be", "write", "with", "a", "blank", "line", "in", "between", "XXX", "to", "be", "change", "vote", "Vote", "That", "kind", "of", "seems", "to", "ruin", "the", "idea", "of", "ignoring", "whitespace", "NUMBER", "I", "d", "vote", "for", "letting", "comments", "be", "comments", "not", "descriptions", "NUMBER", "As", "mention", "above", "docstrings", "have", "worked", "out", "well", "in", "Clojure", "NUMBER", "It", "be", "reasonable", "for", "some", "people", "to", "be", "confused", "by", "new", "syntax", "the", "first", "time", "they", "see", "the", "syntax", "NUMBER", "However", "use", "comments", "as", "descriptions", "be", "confusing", "regardless", "of", "familiarity", "with", "syntax", "NUMBER", "It", "conflates", "developer", "targeted", "documentation", "with", "user", "targeted", "documentation", "NUMBER", "Please", "don", "t", "use", "comments", "to", "provide", "descriptions", "NUMBER", "Any", "alternative", "metadata", "directives", "totally", "new", "syntax", "etc", "NUMBER", "be", "better", "NUMBER", "Perhaps", "descriptions", "could", "be", "directives", "graphql", "myField", "String", "description", "text", "Get", "the", "content", "of", "myField", "Also", "be", "there", "any", "reason", "not", "to", "have", "be", "a", "multiline", "string", "I", "don", "t", "know", "if", "there", "be", "value", "in", "having", "separate", "syntax", "for", "single", "line", "and", "multiline", "strings", "but", "I", "could", "be", "miss", "something", "NUMBER", "Now", "I", "may", "be", "a", "little", "late", "to", "the", "discussion", "but", "I", "would", "like", "to", "weigh", "in", "with", "my", "NUMBER", "cents", "on", "the", "topic", "of", "description", "syntax", "NUMBER", "I", "would", "greatly", "prefer", "the", "double", "quoted", "string", "syntax", "over", "any", "other", "proposal", "NUMBER", "Furthermore", "I", "would", "make", "strings", "multiline", "by", "default", "NUMBER", "That", "be", "Docstrings", "would", "be", "terminated", "by", "a", "next", "matching", "unescaped", "double", "quote", "NUMBER", "Even", "if", "the", "matching", "quote", "character", "be", "on", "another", "line", "NUMBER", "Escaping", "double", "quote", "character", "would", "be", "achieved", "by", "prefixing", "it", "with", "with", "a", "backslash", "NUMBER", "Common", "escape", "sequences", "n", "t", "would", "be", "accepted", "and", "replaced", "with", "appropriate", "characters", "NUMBER", "I", "would", "reserve", "triple", "quoted", "strings", "for", "verbatim", "string", "syntax", "NUMBER", "This", "means", "anything", "you", "write", "within", "triple", "quotes", "will", "be", "taken", "as", "a", "verbatim", "value", "no", "escape", "sequences", "needed", "NUMBER", "Only", "thing", "that", "terminates", "a", "verbatim", "string", "be", "a", "matching", "triple", "quotes", "pair", "NUMBER", "See", "how", "string", "literals", "have", "be", "defined", "in", "Ceylon", "language", "LINK", "lang", "NUMBER", "org", "documentation", "NUMBER", "tour", "basics", "string_literals", "for", "example", "NUMBER", "graphql", "Long", "description", "of", "what", "the", "Foo", "type", "be", "all", "about", "that", "spans", "multiple", "lines", "NUMBER", "type", "Foo", "Definition", "of", "the", "bar", "attribute", "NUMBER", "I", "want", "to", "have", "code", "sample", "here", "with", "embedded", "HTML", "snippet", "so", "I", "should", "use", "triple", "quoted", "doc", "string", "to", "make", "my", "life", "easier", "TAG", "query", "foo", "bar", "some", "argument", "value", "TAG", "bar", "this", "be", "an", "argument", "NUMBER", "arg", "String", "String", "leebyron", "Whats", "the", "status", "on", "this", "I", "m", "really", "waiting", "to", "get", "directives", "to", "be", "allow", "on", "any", "location", "NUMBER", "Can", "we", "maybe", "split", "it", "in", "the", "multi", "line", "comments", "and", "the", "allow", "directives", "on", "everything", "to", "be", "merge", "first", "Why", "do", "interface", "field", "have", "to", "all", "be", "the", "same", "type", "sbussard", "This", "be", "probably", "the", "wrong", "issue", "to", "discuss", "that", "but", "implementation", "of", "interface", "field", "do", "not", "have", "to", "be", "the", "same", "type", "they", "do", "however", "have", "to", "be", "covariant", "LINK", "sec", "Object", "type", "validation", "leebyron", "I", "think", "it", "should", "be", "forbidden", "to", "add", "directives", "on", "argument", "definitions", "of", "directives", "and", "on", "type", "definitions", "use", "by", "directives", "argument", "NUMBER", "When", "I", "tried", "to", "implement", "parsing", "of", "applied", "directives", "from", "IDL", "the", "first", "version", "of", "LINK", "js", "pull", "NUMBER", "it", "proved", "to", "be", "very", "complex", "NUMBER", "Part", "of", "the", "complexity", "was", "cause", "by", "the", "fact", "that", "directive", "argument", "and", "also", "types", "of", "those", "argument", "could", "have", "directives", "applied", "on", "them", "NUMBER", "E", "NUMBER", "g", "NUMBER", "graphql", "directive", "testDirective", "arg", "SomeScalar", "testDirective", "arg", "test", "here", "on", "ARGUMENT_DEFINITION", "SCALAR", "scalar", "SomeScalar", "testDirective", "arg", "test", "NUMBER", "and", "here", "And", "here", "be", "circular", "dependency", "between", "two", "directives", "graphql", "directive", "testA", "arg", "SomeScalar", "testB", "arg", "test", "on", "ARGUMENT_DEFINITION", "directive", "testB", "arg", "SomeScalar", "testA", "arg", "test", "on", "ARGUMENT_DEFINITION", "Without", "such", "restriction", "in", "place", "it", "will", "be", "hard", "to", "implement", "full", "support", "of", "directives", "in", "tool", "and", "libraries", "NUMBER", "That", "s", "why", "I", "think", "it", "s", "important", "to", "add", "it", "into", "this", "release", "NUMBER", "IvanGoncharov", "I", "m", "curious", "to", "what", "that", "complexity", "be", "specifically", "so", "we", "can", "address", "it", "NUMBER", "This", "be", "a", "fairly", "sensitive", "balance", "between", "simplifying", "the", "schema", "grammar", "in", "which", "currently", "argument", "on", "directives", "be", "no", "different", "from", "argument", "anywhere", "else", "and", "be", "restrictive", "as", "to", "where", "directives", "can", "be", "placed", "NUMBER", "This", "be", "a", "fairly", "sensitive", "balance", "between", "simplifying", "the", "schema", "grammar", "in", "which", "currently", "argument", "on", "directives", "be", "no", "different", "from", "argument", "anywhere", "else", "and", "be", "restrictive", "as", "to", "where", "directives", "can", "be", "placed", "NUMBER", "leebyron", "Instead", "of", "forbidding", "to", "apply", "directives", "on", "directives", "argument", "the", "spec", "can", "forbid", "any", "recursion", "in", "directive", "definition", "similar", "to", "how", "it", "s", "do", "for", "the", "Fragments", "The", "graph", "of", "fragment", "spreads", "must", "not", "form", "any", "cycles", "including", "spreading", "itself", "NUMBER", "I", "m", "curious", "to", "what", "that", "complexity", "be", "specifically", "so", "we", "can", "address", "it", "NUMBER", "According", "to", "this", "PR", "a", "directive", "on", "argument", "be", "an", "indicator", "that", "they", "should", "be", "evaluated", "differently", "by", "a", "validator", "executor", "NUMBER", "That", "allows", "directive", "to", "change", "parsing", "coercion", "and", "validation", "of", "argument", "NUMBER", "That", "means", "that", "to", "build", "directive", "object", "e", "NUMBER", "g", "NUMBER", "GraphQLDirective", "you", "need", "to", "figure", "out", "if", "the", "same", "directive", "be", "correctly", "applied", "on", "its", "own", "argument", "NUMBER", "For", "example", "graphql", "directive", "coerceDifferently", "arg", "String", "coerceDifferently", "arg", "invalidValueAccordingToChangedCoertion", "on", "ARGUMENT_DEFINITION", "Are", "we", "planning", "to", "include", "some", "frequently", "use", "directives", "in", "the", "spec", "For", "example", "unique", "can", "be", "use", "for", "Scalar", "typed", "field", "whenever", "we", "want", "to", "say", "that", "the", "value", "of", "the", "field", "be", "unique", "NUMBER", "Investigate", "impact", "on", "validation", "rules", "I", "do", "not", "understand", "what", "exactly", "this", "means", "NUMBER", "Can", "anyone", "explain", "it", "a", "little", "bit", "Just", "out", "of", "curiosity", "be", "EBNF", "or", "ABNF", "notation", "available", "It", "would", "make", "the", "creation", "of", "a", "parser", "for", "other", "third", "party", "libraries", "easier", "NUMBER", "foomip", "I", "m", "actually", "very", "close", "to", "finishing", "a", "parser", "implementation", "like", "that", "within", "the", "next", "week", "or", "so", "I", "d", "say", "NUMBER", "I", "don", "t", "want", "to", "spam", "this", "thread", "but", "I", "can", "post", "it", "here", "if", "you", "like", "I", "ll", "for", "sure", "tweet", "about", "it", "when", "it", "s", "do", "NUMBER", "foomip", "maybe", "this", "can", "help", "you", "LINK", "java", "graphql", "java", "blob", "master", "src", "main", "antlr", "Graphql", "NUMBER", "g", "NUMBER", "This", "be", "a", "grammar", "for", "graphql", "including", "IDL", "NUMBER", "foomip", "or", "this", "LINK", "only", "IDL", "including", "some", "proposes", "Thanks", "andimarek", "SerafimArts", "will", "have", "a", "look", "NUMBER", "gjtorikian", "would", "be", "great", "to", "have", "a", "look", "at", "your", "implementation", "once", "you", "be", "ready", "Just", "to", "give", "you", "guys", "some", "background", "into", "what", "trying", "to", "do", "NUMBER", "I", "be", "looking", "at", "creating", "a", "parser", "that", "takes", "a", "GraphQL", "SDL", "file", "and", "converts", "it", "to", "an", "equivalent", "EDN", "definition", "for", "Clojure", "s", "Lacinia", "GraphQL", "implementation", "LINK", "Not", "sure", "if", "it", "be", "NUMBER", "compatible", "but", "I", "think", "most", "of", "the", "SDL", "structure", "should", "be", "portable", "to", "the", "equivalent", "EDN", "notation", "NUMBER", "foomip", "souns", "good", "NUMBER", "But", "NUMBER", "the", "current", "standard", "be", "a", "draft", "and", "contain", "a", "little", "flaws", "NUMBER", "Take", "it", "into", "account", "NUMBER", "SerafimArts", "will", "do", "thanks", "NUMBER", "Gotta", "start", "somewhere", "would", "be", "great", "to", "have", "a", "look", "at", "your", "implementation", "once", "you", "be", "ready", "foomip", "Finally", "get", "around", "to", "write", "about", "LINK", "rust", "in", "ruby", "to", "parse", "gql", "and", "release", "the", "lib", "NUMBER", "foomip", "Another", "possibility", "use", "Pegex", "LINK", "perl", "graphql", "perl", "blob", "master", "graphql", "NUMBER", "pgx", "leebyron", "would", "be", "great", "if", "this", "PR", "could", "be", "renamed", "to", "RFC", "GraphQL", "SDL", "additions", "as", "discussed", "in", "the", "work", "group", "meeting", "NUMBER", "Yeah", "totally", "agree", "lots", "of", "documents", "will", "include", "both", "type", "info", "and", "queries", "in", "one", "so", "it", "would", "be", "great", "to", "have", "a", "well", "defined", "way", "for", "them", "to", "live", "side", "by", "side", "NUMBER", "After", "release", "most", "recent", "SDL", "spec", "change", "in", "sangria", "I", "get", "some", "user", "feedback", "LINK", "graphql", "sangria", "issue", "NUMBER", "I", "would", "like", "to", "make", "a", "suggestion", "regard", "these", "grammar", "change", "ObjectTypeDefinition", "Description", "type", "Name", "ImplementsInterfaces", "Directives", "Const", "FieldDefinitions", "FieldDefinitions", "FieldDefinition", "InterfaceTypeDefinition", "Description", "interface", "Name", "Directives", "Const", "FieldDefinitions", "EnumTypeDefinition", "Description", "enum", "Name", "Directives", "Const", "EnumValueDefinition", "InputObjectTypeDefinition", "Description", "input", "Name", "Directives", "Const", "InputValueDefinition", "At", "the", "moment", "the", "parser", "defines", "that", "the", "field", "list", "must", "contain", "at", "least", "one", "field", "or", "enum", "value", "in", "case", "of", "the", "enum", "NUMBER", "My", "suggestion", "be", "to", "implement", "this", "restriction", "as", "a", "validation", "rule", "and", "allow", "field", "list", "to", "be", "empty", "at", "the", "parsing", "stage", "NUMBER", "Effectively", "this", "approach", "yields", "very", "similar", "results", "but", "also", "provides", "following", "advantages", "Since", "the", "field", "list", "verification", "takes", "place", "at", "the", "semantic", "validation", "stage", "it", "might", "produce", "better", "validation", "error", "with", "deeper", "semantic", "insights", "Validation", "provides", "a", "very", "robust", "mechanism", "for", "semantic", "analysis", "NUMBER", "If", "the", "field", "list", "of", "generate", "based", "on", "let", "s", "say", "directive", "information", "then", "more", "complex", "validation", "and", "overarching", "workflow", "can", "be", "implement", "NUMBER", "Right", "now", "the", "validation", "be", "baked", "into", "the", "parser", "and", "provides", "very", "little", "flexibility", "in", "this", "regard", "It", "might", "provide", "a", "smooth", "migration", "path", "for", "people", "who", "be", "use", "types", "with", "empty", "field", "lists", "right", "now", "NUMBER", "Would", "love", "to", "hear", "your", "thoughts", "on", "this", "It", "s", "good", "that", "you", "mention", "this", "particular", "use", "case", "I", "also", "encountered", "on", "a", "few", "occasions", "NUMBER", "I", "think", "it", "often", "desired", "when", "the", "schema", "definition", "be", "split", "between", "different", "file", "NUMBER", "I", "think", "I", "also", "would", "prefer", "to", "keep", "it", "consistent", "with", "other", "language", "constructs", "NUMBER", "I", "wonder", "whether", "we", "can", "also", "skip", "the", "curly", "braces", "and", "define", "the", "syntax", "like", "this", "assuming", "that", "we", "will", "decide", "to", "implement", "it", "corresponding", "validation", "rules", "InputObjectTypeDefinition", "Description", "input", "Name", "Directives", "Const", "InputValueDefinitions", "ObjectTypeDefinition", "Description", "type", "Name", "ImplementsInterfaces", "Directives", "Const", "FieldDefinitions", "InterfaceTypeDefinition", "Description", "interface", "Name", "Directives", "Const", "FieldDefinitions", "EnumTypeDefinition", "Description", "enum", "Name", "Directives", "Const", "EnumValueDefinitions", "EnumValueDefinitions", "EnumValueDefinition", "InputValueDefinitions", "InputValueDefinition", "FieldDefinitions", "FieldDefinition", "Indeed", "this", "be", "a", "concern", "NUMBER", "I", "think", "it", "should", "not", "be", "a", "big", "problem", "if", "people", "just", "need", "to", "search", "and", "replace", "the", "codebase", "NUMBER", "On", "the", "other", "hand", "of", "SDL", "be", "stored", "in", "the", "external", "DB", "then", "it", "might", "involve", "multi", "staged", "migration", "NUMBER", "BjRo", "would", "be", "interesting", "to", "hear", "your", "thoughts", "on", "this", "matter", "NUMBER", "stubailo", "It", "would", "be", "also", "interesting", "to", "hear", "your", "thoughts", "on", "this", "suggestion", "NUMBER", "Do", "you", "think", "that", "propose", "parser", "validation", "separation", "might", "provide", "value", "beyond", "the", "ease", "of", "migration", "OlegIlyenko", "leebyron", "First", "of", "all", "thx", "for", "discussing", "this", "NUMBER", "I", "like", "your", "ideas", "NUMBER", "It", "would", "definitely", "make", "things", "a", "bit", "easier", "to", "manage", "and", "also", "a", "bit", "tidier", "in", "our", "SDL", "schema", "NUMBER", "We", "have", "both", "cases", "multiple", "file", "and", "empty", "field", "definitions", "NUMBER", "Regarding", "the", "migration", "aspects", "I", "think", "it", "depends", "on", "the", "setup", "NUMBER", "For", "us", "it", "s", "relatively", "easy", "to", "adopt", "such", "change", "since", "we", "have", "the", "SDL", "file", "the", "application", "code", "our", "project", "documentation", "and", "how", "to", "guide", "in", "a", "single", "source", "code", "repository", "NUMBER", "A", "pull", "request", "on", "our", "side", "be", "able", "to", "change", "all", "affected", "portions", "at", "once", "and", "we", "can", "do", "this", "more", "or", "less", "manually", "NUMBER", "A", "strict", "behaviour", "of", "the", "parser", "and", "the", "GraphQL", "framework", "can", "be", "handle", "in", "this", "scenario", "NUMBER", "SDL", "stored", "in", "an", "external", "DB", "looks", "like", "an", "entirely", "different", "beast", "to", "me", "since", "you", "can", "t", "change", "all", "portions", "at", "once", "NUMBER", "One", "way", "to", "address", "this", "be", "to", "have", "the", "GraphQL", "server", "run", "in", "a", "compatibility", "mode", "that", "allows", "both", "formats", "and", "then", "doing", "the", "schema", "update", "separately", "NUMBER", "If", "I", "m", "not", "mistaken", "this", "be", "also", "what", "Sangria", "allows", "you", "currently", "to", "do", "though", "it", "needs", "to", "be", "specifically", "enable", "NUMBER", "I", "think", "the", "community", "would", "benefit", "from", "a", "schema", "migration", "tool", "for", "such", "breaking", "change", "so", "that", "the", "schema", "update", "behave", "fairly", "consistent", "and", "can", "be", "mostly", "automate", "NUMBER", "It", "would", "be", "interesting", "to", "hear", "schickling", "thoughts", "on", "this", "given", "that", "Graphcool", "has", "externally", "stored", "SDL", "schemas", "NUMBER", "I", "agree", "with", "acjay", "I", "was", "under", "the", "impression", "that", "directives", "wouldn", "t", "be", "available", "through", "introspection", "Although", "I", "think", "there", "s", "tons", "of", "potential", "for", "allowing", "directives", "to", "be", "available", "through", "introspection", "and", "allowing", "developers", "better", "ways", "to", "grow", "their", "use", "of", "the", "language", "in", "a", "dynamic", "way", "without", "requiring", "change", "to", "the", "spec", "for", "every", "new", "concept", "NUMBER", "Anyways", "in", "the", "case", "that", "they", "be", "available", "for", "introspection", "I", "think", "either", "the", "ability", "to", "add", "directives", "to", "directive", "definitions", "needs", "to", "be", "add", "back", "or", "there", "needs", "to", "be", "a", "visibility", "concept", "for", "directives", "NUMBER", "For", "example", "a", "cost", "directive", "use", "for", "declaring", "rough", "cost", "of", "a", "field", "likely", "has", "the", "purpose", "of", "be", "pass", "along", "to", "users", "of", "the", "schema", "so", "it", "should", "be", "available", "through", "introspection", "NUMBER", "However", "a", "cache", "maxAge", "NUMBER", "directive", "be", "likely", "use", "more", "as", "config", "into", "the", "implement", "framework", "so", "it", "shouldn", "t", "be", "available", "through", "introspection", "or", "else", "implementation", "details", "bleed", "out", "NUMBER", "This", "means", "there", "s", "a", "visibility", "requirement", "and", "I", "see", "two", "possible", "solutions", "NUMBER", "NUMBER", "Directives", "need", "a", "visibility", "concept", "and", "the", "SDL", "add", "a", "public", "private", "keyword", "for", "DirectiveDefinition", "NUMBER", "Frameworks", "can", "then", "use", "the", "visibility", "to", "resolve", "introspection", "queries", "NUMBER", "NUMBER", "The", "DirectiveDefinition", "allows", "other", "directives", "be", "use", "on", "it", "which", "isn", "t", "allow", "right", "now", "and", "then", "frameworks", "be", "responsible", "for", "looking", "for", "something", "like", "a", "private", "directive", "filtering", "things", "appropriately", "eg", "directive", "private", "cache", "maxAge", "Int", "on", "FIELD_DEFINITION", "I", "like", "NUMBER", "better", "but", "in", "another", "scenario", "where", "I", "m", "stitching", "schemas", "automatically", "through", "a", "proxy", "service", "passing", "on", "that", "cache", "directive", "could", "be", "very", "useful", "NUMBER", "Although", "I", "wouldn", "t", "want", "it", "to", "bleed", "past", "the", "proxy", "even", "though", "I", "may", "want", "other", "directives", "to", "be", "allow", "through", "so", "I", "d", "need", "a", "custom", "directive", "anyways", "NUMBER", "Then", "all", "of", "my", "services", "have", "to", "look", "for", "something", "like", "a", "private", "hops", "NUMBER", "directive", "or", "just", "pass", "something", "like", "namespaced_for_proxy_private", "directive", "through", "so", "eventually", "the", "field", "will", "be", "marked", "private", "NUMBER", "So", "if", "I", "need", "a", "custom", "directive", "here", "and", "to", "rely", "on", "the", "frameworks", "anyways", "NUMBER", "as", "a", "general", "approach", "may", "be", "better", "NUMBER", "leebyron", "why", "be", "the", "spec", "still", "dated", "October", "NUMBER", "at", "LINK", "LINK", "ermik", "Because", "it", "s", "the", "last", "official", "release", "NUMBER", "You", "can", "find", "the", "draft", "of", "the", "next", "release", "including", "SDL", "here", "LINK", "I", "m", "not", "sure", "if", "the", "semicolons", "were", "deliberate", "NUMBER", "But", "the", "way", "I", "understand", "semicolons", "be", "that", "they", "be", "use", "to", "separate", "complete", "sentences", "NUMBER", "Let", "me", "know", "your", "thoughts", "on", "this", "NUMBER", "Thanks", "NUMBER", "I", "m", "fairly", "certain", "this", "be", "not", "currently", "possible", "and", "I", "m", "not", "even", "sure", "it", "be", "desirable", "NUMBER", "That", "said", "be", "there", "some", "way", "to", "specify", "an", "argument", "variable", "based", "on", "previously", "fetched", "data", "For", "example", "lets", "assume", "we", "have", "a", "contentItem", "type", "NUMBER", "That", "contentItem", "has", "two", "field", "isLive", "and", "liveData", "NUMBER", "liveData", "include", "a", "bunch", "of", "information", "about", "who", "set", "the", "contentItem", "to", "be", "live", "and", "when", "NUMBER", "We", "want", "that", "information", "but", "only", "if", "the", "contentItem", "be", "actually", "live", "NUMBER", "query", "content", "contentItem", "isLive", "liveData", "include", "if", "isLive", "liveTime", "user", "username", "If", "it", "be", "not", "possible", "be", "this", "a", "feature", "worth", "considering", "I", "see", "three", "big", "downsides", "NUMBER", "First", "it", "add", "some", "complexity", "to", "the", "resolution", "of", "field", "NUMBER", "Second", "we", "lose", "some", "parallel", "execution", "in", "the", "query", "though", "not", "all", "NUMBER", "Third", "there", "be", "many", "use", "cases", "for", "such", "a", "variable", "that", "be", "really", "bad", "design", "NUMBER", "I", "be", "going", "to", "admit", "that", "the", "original", "reason", "I", "write", "this", "issue", "was", "one", "of", "those", "_mildly_", "bad", "design", "decisions", "NUMBER", "Fortunately", "I", "realized", "it", "was", "really", "bad", "design", "as", "I", "start", "write", "it", "down", "NUMBER", "However", "the", "isLive", "liveData", "example", "stuck", "with", "me", "as", "useful", "NUMBER", "Granted", "right", "now", "it", "would", "just", "return", "undefined", "or", "null", "which", "be", "probably", "just", "as", "good", "NUMBER", "Still", "something", "to", "think", "about", "NUMBER", "NUMBER", "Use", "case", "mutations", "based", "on", "prior", "payloads", "NUMBER", "For", "example", "say", "we", "want", "to", "create", "some", "content", "for", "a", "user", "after", "they", "register", "based", "on", "preferences", "they", "give", "us", "mutation", "M", "createUser", "firstName", "bob", "id", "createPreferences", "user_id", "createUser", "NUMBER", "id", "preferences", "doesn", "t", "appreciate", "purple", "success", "I", "don", "t", "think", "there", "s", "a", "way", "to", "achieve", "the", "above", "without", "two", "request", "at", "the", "moment", "NUMBER", "What", "do", "you", "think", "leebyron", "However", "the", "isLive", "liveData", "example", "stuck", "with", "me", "as", "useful", "NUMBER", "Granted", "right", "now", "it", "would", "just", "return", "undefined", "or", "null", "which", "be", "probably", "just", "as", "good", "Yes", "that", "isn", "t", "really", "a", "concrete", "example", "of", "an", "actual", "problem", "NUMBER", "I", "can", "kind", "of", "see", "where", "you", "be", "going", "with", "that", "though", "since", "you", "might", "just", "need", "one", "field", "but", "need", "a", "fallback", "to", "other", "field", "if", "it", "doesn", "t", "exist", "NUMBER", "For", "example", "if", "a", "user", "hasn", "t", "uploaded", "their", "photo", "you", "might", "want", "to", "show", "a", "stock", "picture", "that", "be", "derived", "based", "on", "their", "country", "initials", "and", "or", "some", "other", "field", "NUMBER", "If", "you", "be", "use", "your", "own", "API", "the", "solution", "there", "be", "probably", "to", "let", "the", "server", "compute", "the", "fallback", "which", "could", "be", "request", "through", "another", "field", "or", "argument", "to", "specify", "that", "you", "want", "a", "fallback", "image", "NUMBER", "That", "way", "you", "can", "simplify", "the", "client", "code", "reduce", "the", "response", "size", "and", "provide", "consistency", "across", "client", "apps", "NUMBER", "The", "propose", "feature", "might", "be", "more", "useful", "for", "a", "third", "party", "apps", "which", "don", "t", "have", "control", "over", "the", "API", "although", "there", "will", "probably", "always", "be", "more", "complex", "conditions", "in", "the", "client", "side", "code", "that", "won", "t", "be", "representable", "in", "GraphQL", "to", "capture", "the", "differences", "in", "data", "requirements", "between", "those", "code", "paths", "NUMBER", "jtmarmon", "what", "if", "you", "move", "your", "mutations", "on", "some", "other", "object", "out", "of", "the", "top", "level", "field", "on", "the", "mutation", "root", "NUMBER", "E", "NUMBER", "g", "NUMBER", "normally", "you", "could", "use", "a", "user", "field", "on", "the", "mutation", "root", "of", "type", "UserMutation", "in", "order", "to", "create", "preferences", "as", "follows", "graphql", "mutation", "M", "userId", "ID", "user", "id", "userId", "createPreferences", "preferences", "doesn", "t", "appreciate", "purple", "success", "then", "you", "just", "need", "to", "expose", "that", "UserMutation", "on", "the", "payload", "of", "the", "createUser", "mutation", "so", "the", "GraphQL", "for", "your", "two", "mutations", "might", "look", "like", "graphql", "mutation", "M", "createUser", "firstName", "bob", "user", "id", "mutation", "createPreferences", "preferences", "doesn", "t", "appreciate", "purple", "success", "that", "way", "you", "be", "basically", "use", "GraphQL", "in", "an", "object", "oriented", "way", "similar", "to", "method", "chaining", "in", "a", "programming", "language", "NUMBER", "You", "can", "just", "write", "one", "mutation", "createUserWithPreferences", "NUMBER", "I", "think", "we", "might", "be", "open", "a", "can", "of", "worms", "if", "we", "add", "non", "pure", "operations", "inside", "GraphQL", "body", "there", "be", "question", "of", "eg", "ordering", "NUMBER", "As", "for", "original", "question", "one", "way", "to", "do", "it", "would", "be", "to", "create", "an", "interface", "with", "two", "implementations", "NUMBER", "One", "will", "include", "liveData", "another", "will", "not", "NUMBER", "Then", "you", "could", "query", "them", "as", "following", "query", "content", "contentItem", "isLive", "NUMBER", "onLive", "liveData", "liveTime", "user", "username", "I", "think", "we", "might", "be", "open", "a", "can", "of", "worms", "if", "we", "add", "non", "pure", "operations", "inside", "GraphQL", "body", "there", "be", "question", "of", "e", "NUMBER", "g", "NUMBER", "ordering", "NUMBER", "The", "ordering", "be", "specified", "as", "be", "serial", "for", "mutations", "including", "for", "the", "sub", "selections", "LINK", "sec", "Serial", "execution", "It", "s", "only", "serial", "on", "the", "top", "level", "subselections", "be", "executed", "in", "parallel", "NUMBER", "There", "be", "many", "other", "question", "can", "you", "execute", "mutations", "only", "inside", "other", "mutations", "What", "be", "the", "type", "of", "mutations", "Do", "mutation", "payloads", "need", "to", "include", "what", "mutations", "be", "going", "to", "be", "possible", "inside", "them", "Also", "what", "be", "going", "to", "be", "the", "result", "of", "the", "above", "query", "Oh", "I", "see", "NUMBER", "It", "be", "use", "normally", "to", "mean", "unordered", "NUMBER", "The", "previous", "section", "explains", "that", "clearer", "and", "also", "says", "that", "non", "top", "level", "mutation", "field", "must", "be", "side", "effect", "free", "NUMBER", "So", "yes", "it", "do", "look", "like", "a", "createUserWithPreferences", "would", "be", "needed", "to", "do", "that", "right", "now", "but", "that", "might", "be", "heading", "towards", "designing", "the", "schema", "for", "a", "specific", "client", "which", "GraphQL", "allows", "us", "to", "avoid", "in", "most", "cases", "NUMBER", "If", "we", "wanted", "to", "support", "that", "type", "of", "non", "top", "level", "mutation", "then", "we", "would", "want", "to", "distinguish", "between", "a", "mutation", "object", "type", "and", "a", "query", "object", "type", "to", "specify", "that", "selections", "in", "a", "mutation", "object", "type", "be", "executed", "serially", "NUMBER", "You", "could", "create", "a", "mutation", "that", "knows", "how", "to", "handle", "any", "kind", "of", "relate", "object", "but", "I", "realize", "that", "it", "s", "a", "lot", "of", "work", "NUMBER", "We", "at", "taobao", "have", "implement", "it", "in", "this", "way", "and", "it", "works", "great", "NUMBER", "We", "need", "a", "way", "to", "listen", "to", "change", "performed", "by", "someone", "else", "than", "the", "local", "client", "in", "order", "to", "build", "true", "real", "time", "apps", "based", "on", "GraphQL", "NUMBER", "Similar", "to", "how", "Firebase", "and", "Meteor", "work", "NUMBER", "I", "know", "this", "be", "be", "discussed", "on", "Slack", "but", "a", "proper", "ticket", "be", "miss", "NUMBER", "I", "made", "a", "small", "write", "up", "about", "my", "thought", "on", "a", "GraphQL", "subscription", "mechanism", "LINK", "Any", "comments", "and", "thoughts", "on", "this", "idea", "be", "appreciated", "NUMBER", "Closing", "this", "aging", "issue", "since", "Subscriptions", "be", "captured", "in", "spec", "Should", "input", "objects", "return", "a", "keyed", "set", "when", "introspecting", "for", "inputFields", "the", "way", "object", "do", "for", "field", "Currently", "the", "spec", "on", "introspection", "says", "that", "input", "objects", "have", "an", "inputFields", "query", "that", "returns", "a", "list", "NUMBER", "Object", "on", "the", "other", "hand", "have", "a", "field", "query", "that", "returns", "a", "keyed", "set", "NUMBER", "Both", "input", "objects", "and", "objects", "take", "maps", "even", "if", "the", "keys", "be", "just", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Is", "there", "a", "reason", "that", "introspection", "do", "not", "return", "a", "keyed", "set", "of", "field", "for", "input", "objects", "In", "a", "similar", "vein", "why", "not", "just", "have", "the", "introspection", "query", "be", "field", "for", "both", "Apologies", "I", "think", "I", "was", "confused", "NUMBER", "No", "I", "was", "definitely", "confused", "NUMBER", "There", "be", "not", "a", "lot", "of", "literature", "on", "mutations", "in", "GraphQL", "and", "therefore", "not", "a", "lot", "of", "literature", "on", "really", "big", "blobs", "of", "data", "in", "Input", "Objects", "NUMBER", "I", "was", "trying", "to", "tease", "out", "the", "implementation", "of", "GraphQL", "JS", "vs", "the", "actual", "spec", "and", "Object", "vs", "Input", "Object", "NUMBER", "I", "went", "back", "and", "run", "the", "introspections", "again", "now", "that", "I", "have", "significantly", "more", "experience", "with", "Input", "Object", "I", "think", "perhaps", "I", "was", "leaving", "out", "the", "name", "field", "which", "made", "the", "two", "seem", "different", "NUMBER", "Also", "defining", "field", "on", "the", "GraphQL", "JS", "GraphQLInputObject", "but", "introspecting", "on", "inputFields", "was", "cause", "some", "confusion", "I", "created", "a", "separate", "ticket", "for", "that", "issue", "on", "that", "project", "graphql", "graphql", "js", "NUMBER", "NUMBER", "Sorry", "for", "wasting", "your", "time", "on", "this", "NUMBER", "in", "section", "NUMBER", "Field", "Selections", "on", "Objects", "Interfaces", "and", "Unions", "Types", "Because", "field", "be", "not", "declared", "on", "unions", "direct", "field", "selection", "on", "union", "typed", "selection", "set", "NUMBER", "This", "be", "true", "even", "if", "concrete", "implementors", "of", "the", "union", "define", "the", "fieldName", "NUMBER", "what", "do", "direct", "field", "selection", "on", "union", "typed", "selection", "set", "NUMBER", "mean", "leebyron", "NUMBER", "why", "the", "following", "be", "invalid", "NUMBER", "it", "be", "indirectly", "queried", "through", "a", "fragment", "the", "union", "concrete", "implementors", "instead", "of", "the", "union", "itself", "NUMBER", "your", "original", "words", "be", "Fields", "from", "a", "union", "typed", "selection", "set", "must", "only", "be", "queried", "indirectly", "via", "a", "fragment", "graphql", "fragment", "directFieldSelectionOnUnion", "on", "CatOrDog", "name", "barkVolume", "This", "looks", "good", "to", "me", "NUMBER", "this", "will", "definitely", "simplify", "the", "transition", "from", "REST", "to", "GraphQL", "for", "mutations", "otherwise", "a", "boolean", "field", "would", "need", "to", "be", "provide", "to", "distinguish", "between", "setting", "a", "field", "to", "be", "null", "and", "not", "change", "the", "field", "NUMBER", "NUMBER", "Seems", "like", "it", "has", "be", "some", "time", "NUMBER", "Is", "this", "still", "on", "roadmap", "I", "created", "a", "fork", "a", "short", "while", "ago", "that", "allows", "for", "this", "NUMBER", "I", "ve", "not", "merge", "in", "the", "most", "recent", "commit", "yet", "but", "it", "s", "work", "in", "production", "NUMBER", "LINK", "nullable", "NUMBER", "Looks", "like", "this", "PR", "was", "open", "for", "quite", "a", "while", "now", "NUMBER", "Just", "wanted", "to", "give", "my", "option", "on", "this", "change", "NUMBER", "I", "m", "come", "from", "scala", "background", "NUMBER", "I", "don", "t", "see", "an", "addition", "of", "null", "as", "a", "problem", "NUMBER", "It", "opens", "up", "quite", "a", "few", "interesting", "possibilities", "NUMBER", "In", "general", "statically", "typed", "languages", "still", "make", "it", "possible", "to", "distinguish", "between", "undefined", "property", "be", "not", "defined", "on", "object", "and", "null", "for", "example", "all", "scala", "JSON", "libraries", "have", "JNull", "or", "JsNull", "AST", "nodes", "NUMBER", "I", "tried", "to", "implement", "this", "proposal", "in", "the", "sangria", "LINK", "graphql", "sangria", "and", "it", "looks", "good", "so", "far", "NUMBER", "If", "one", "do", "not", "care", "about", "distinction", "between", "null", "and", "undefined", "then", "they", "can", "be", "just", "treated", "the", "same", "it", "happens", "pretty", "often", "NUMBER", "But", "on", "the", "other", "hand", "if", "you", "need", "to", "distinguish", "between", "them", "then", "this", "addition", "be", "very", "helpful", "NUMBER", "Note", "there", "be", "a", "potential", "semantic", "difference", "between", "the", "input", "value", "explicitly", "declaring", "an", "input", "field", "s", "value", "as", "the", "value", "null", "vs", "having", "not", "declared", "the", "input", "field", "at", "all", "NUMBER", "GraphQL", "services", "may", "optionally", "interpret", "these", "two", "cases", "differently", "if", "it", "be", "advantageous", "NUMBER", "I", "like", "this", "part", "and", "would", "keep", "it", "like", "this", "NUMBER", "So", "that", "it", "s", "up", "to", "the", "server", "implementation", "to", "decide", "whether", "to", "treat", "them", "differently", "or", "not", "NUMBER", "This", "would", "also", "mean", "that", "standard", "protocols", "like", "introspection", "API", "or", "relay", "connection", "can", "t", "relay", "on", "this", "mechanism", "if", "I", "understand", "it", "correctly", "NUMBER", "Any", "reason", "why", "this", "RFC", "be", "restricted", "to", "mutations", "Could", "it", "be", "applied", "to", "explicit", "input", "field", "argument", "E", "NUMBER", "g", "NUMBER", "a", "query", "be", "interpreted", "to", "a", "SQL", "clause", "where", "table", "NUMBER", "field", "be", "NULL", "NUMBER", "It", "doesn", "t", "look", "like", "this", "RFC", "be", "specific", "to", "mutations", "NUMBER", "Mutations", "be", "just", "the", "prominent", "example", "NUMBER", "The", "only", "change", "to", "the", "spec", "that", "mentions", "mutations", "be", "this", "add", "line", "For", "example", "to", "represent", "deleting", "a", "field", "vs", "not", "altering", "a", "field", "during", "a", "mutation", "respectively", "NUMBER", "LGTM", "NUMBER", "Coming", "from", "a", "ruby", "background", "not", "be", "able", "to", "send", "null", "to", "set", "an", "attribute", "to", "a", "nil", "value", "be", "certainly", "surprising", "NUMBER", "I", "d", "be", "very", "happy", "to", "see", "this", "change", "land", "NUMBER", "We", "have", "a", "number", "of", "places", "where", "our", "GraphQL", "layer", "bridges", "to", "REST", "services", "that", "have", "special", "handle", "for", "explicit", "nulls", "in", "e", "NUMBER", "g", "NUMBER", "PATCH", "operations", "and", "it", "would", "be", "much", "easier", "to", "bridge", "to", "those", "services", "if", "we", "have", "the", "option", "of", "use", "a", "null", "literal", "NUMBER", "We", "often", "have", "NULLs", "in", "our", "database", "represent", "default", "values", "i", "NUMBER", "e", "NUMBER", "a", "localizer", "with", "a", "NULL", "locale", "be", "the", "default", "translation", "NUMBER", "We", "ve", "had", "to", "hack", "around", "this", "but", "would", "be", "great", "for", "GraphQL", "to", "support", "natively", "NUMBER", "Not", "to", "be", "a", "bother", "but", "what", "s", "the", "status", "on", "this", "Are", "there", "still", "open", "question", "There", "be", "still", "open", "question", "on", "how", "to", "resolve", "nullability", "with", "optionality", "once", "a", "value", "can", "be", "explicitly", "provide", "and", "be", "the", "value", "null", "NUMBER", "That", "also", "has", "implications", "on", "whether", "the", "value", "null", "should", "be", "replaced", "with", "a", "default", "value", "or", "not", "NUMBER", "This", "be", "still", "open", "but", "it", "s", "be", "lower", "priority", "relative", "to", "some", "of", "the", "other", "proposals", "we", "ve", "be", "work", "the", "kinks", "out", "of", "NUMBER", "Thanks", "for", "the", "quick", "response", "leebyron", "that", "s", "good", "to", "hear", "NUMBER", "Default", "values", "mean", "well", "but", "my", "current", "practical", "problem", "unless", "I", "m", "doing", "it", "wrong", "be", "that", "database", "update", "happen", "based", "on", "changesets", "and", "so", "right", "now", "it", "s", "impossible", "to", "know", "whether", "the", "client", "wanted", "a", "field", "nulled", "or", "simply", "left", "unchanged", "NUMBER", "I", "m", "probably", "beating", "one", "rotten", "carcass", "of", "a", "horse", "here", "but", "since", "this", "be", "marked", "RFC", "I", "wanted", "to", "throw", "another", "vote", "in", "the", "hat", "for", "bona", "fide", "nulls", "NUMBER", "BTW", "I", "think", "in", "most", "other", "contexts", "that", "I", "ve", "seen", "value", "be", "required", "may", "not", "be", "undefined", "and", "null", "be", "permitted", "be", "treated", "as", "orthogonal", "concepts", "NUMBER", "One", "place", "this", "comes", "up", "the", "most", "strongly", "be", "for", "e", "NUMBER", "g", "NUMBER", "a", "PATCH", "update", "for", "a", "partial", "update", "of", "an", "object", "NUMBER", "In", "such", "a", "case", "certain", "non", "nullable", "field", "may", "still", "not", "be", "required", "i", "NUMBER", "e", "NUMBER", "to", "have", "their", "values", "not", "be", "change", "NUMBER", "Yeah", "to", "be", "clear", "here", "the", "question", "isn", "t", "be", "it", "a", "good", "idea", "to", "introduce", "a", "null", "value", "the", "question", "be", "be", "it", "worth", "the", "additional", "introduce", "complexity", "Splitting", "the", "concepts", "of", "optionality", "and", "nullability", "actually", "add", "a", "lot", "of", "cascading", "change", "to", "GraphQL", "so", "while", "in", "isolation", "it", "s", "perfectly", "easy", "to", "make", "a", "case", "for", "why", "having", "them", "separate", "be", "fine", "what", "we", "actually", "want", "to", "be", "doing", "here", "be", "striving", "to", "maintain", "GraphQL", "s", "simplicity", "whenever", "possible", "NUMBER", "The", "costs", "of", "maintaining", "simplicity", "be", "that", "there", "be", "often", "corner", "cases", "where", "GraphQL", "feels", "awkward", "but", "the", "value", "be", "that", "the", "primary", "cases", "feel", "simple", "NUMBER", "I", "understand", "that", "may", "feel", "like", "a", "slight", "it", "certainly", "doesn", "t", "feel", "like", "a", "corner", "case", "when", "you", "re", "the", "one", "experience", "it", "but", "it", "be", "the", "reality", "that", "most", "mutations", "in", "GraphQL", "use", "the", "action", "pattern", "rather", "than", "the", "CRUD", "pattern", "so", "setting", "a", "field", "to", "null", "be", "actually", "a", "case", "we", "haven", "t", "had", "to", "deal", "with", "in", "production", "yet", "NUMBER", "And", "also", "to", "be", "clear", "I", "do", "think", "having", "a", "null", "literal", "be", "a", "good", "idea", "I", "do", "want", "to", "make", "enabling", "CRUD", "style", "operations", "more", "reasonable", "I", "would", "just", "like", "to", "do", "so", "with", "as", "little", "collateral", "damage", "to", "simplicity", "as", "possible", "NUMBER", "That", "was", "thoughtfully", "write", "NUMBER", "Thanks", "NUMBER", "Not", "sure", "if", "it", "s", "be", "discussed", "elsewhere", "could", "you", "sidestep", "those", "issue", "if", "you", "defined", "some", "Relay", "NUMBER", "NULL", "constant", "for", "us", "to", "use", "instead", "of", "messing", "with", "the", "JS", "null", "literal", "I", "don", "t", "think", "Relay", "NUMBER", "NULL", "can", "be", "the", "answer", "since", "input", "types", "can", "t", "be", "union", "types", "NUMBER", "The", "CRUD", "stuff", "just", "comes", "up", "when", "migrating", "exist", "systems", "to", "GraphQL", "I", "guess", "NUMBER", "Ah", "forgot", "about", "that", "NUMBER", "Never", "mind", "then", "NUMBER", "I", "might", "be", "the", "first", "person", "to", "say", "that", "I", "d", "like", "to", "see", "more", "work", "on", "this", "RFC", "before", "it", "be", "part", "of", "the", "spec", "NUMBER", "Don", "t", "get", "me", "wrong", "I", "do", "want", "to", "see", "implicit", "explicit", "nulls", "NUMBER", "NUMBER", "things", "It", "be", "my", "opinion", "that", "there", "ought", "not", "to", "be", "multiple", "interpretations", "of", "what", "happens", "for", "implicit", "or", "explicit", "null", "depending", "on", "which", "GraphQL", "service", "be", "be", "use", "NUMBER", "But", "that", "s", "what", "NUMBER", "different", "sections", "say", "A", "GraphQL", "service", "may", "interpret", "the", "two", "form", "differently", "if", "it", "be", "advantageous", "NUMBER", "Note", "there", "be", "a", "potential", "semantic", "difference", "between", "the", "input", "value", "explicitly", "declaring", "an", "input", "field", "s", "value", "as", "the", "value", "null", "vs", "having", "not", "declared", "the", "input", "field", "at", "all", "NUMBER", "GraphQL", "services", "may", "optionally", "interpret", "these", "two", "cases", "differently", "if", "it", "be", "advantageous", "NUMBER", "In", "practical", "terms", "there", "s", "a", "high", "chance", "of", "my", "company", "going", "from", "graphql", "java", "to", "graphql", "go", "and", "I", "don", "t", "want", "to", "get", "bitten", "NUMBER", "It", "s", "pretty", "easy", "to", "let", "seemingly", "minor", "things", "make", "major", "impact", "down", "the", "line", "like", "change", "the", "ordering", "of", "a", "contractually", "unordered", "collection", "I", "refer", "to", "Java", "NUMBER", "HashMaps", "LINK", "java", "util", "hashmap", "hashmap", "change", "in", "java", "NUMBER", "and", "the", "NUMBER", "of", "PRD", "issue", "attributable", "to", "this", "even", "though", "I", "love", "how", "Java", "NUMBER", "HashMap", "be", "now", "NUMBER", "In", "theoretical", "terms", "the", "first", "comment", "says", "there", "be", "NUMBER", "distinct", "semantical", "interpretations", "of", "variables", "in", "a", "query", "so", "why", "should", "the", "semantics", "of", "the", "GraphQL", "service", "be", "a", "black", "box", "to", "the", "querier", "Besides", "that", "I", "d", "also", "like", "some", "more", "clarity", "on", "null", "lists", "NUMBER", "Consider", "this", "with", "the", "value", "after", "coercion", "be", "left", "as", "an", "exercise", "for", "the", "reader", "NUMBER", "Spec", "imp", "exp", "Null", "Input", "Type", "Coerced", "Value", "Current", "N", "A", "String", "null", "Current", "N", "A", "String", "Current", "N", "A", "String", "Current", "N", "A", "String", "Proposed", "Implicit", "String", "null", "Proposed", "Implicit", "String", "Proposed", "Implicit", "String", "Proposed", "Implicit", "String", "Proposed", "Explicit", "String", "null", "Proposed", "Explicit", "String", "Proposed", "Explicit", "String", "Proposed", "Explicit", "String", "Take", "the", "case", "of", "String", "from", "graphql", "java", "LINK", "java", "graphql", "java", "issue", "NUMBER", "NUMBER", "An", "implicit", "null", "was", "input", "to", "String", "yielding", "the", "unexpect", "value", "of", "a", "list", "object", "with", "NUMBER", "null", "element", "NUMBER", "So", "in", "the", "case", "of", "null", "input", "coercion", "we", "might", "do", "something", "different", "for", "implicit", "or", "explicit", "NUMBER", "My", "first", "thoughts", "be", "to", "word", "things", "in", "such", "as", "way", "that", "explicit", "nulls", "be", "always", "coerced", "into", "the", "input", "thus", "potentially", "yielding", "list", "of", "list", "of", "null", "while", "implicit", "nulls", "be", "never", "coerced", "but", "substituted", "directly", "for", "the", "null", "value", "thus", "yielding", "null", "with", "the", "chance", "of", "NPE", "NUMBER", "Last", "and", "least", "typo", "on", "spec", "Section", "NUMBER", "Type", "System", "NUMBER", "md", "line", "NUMBER", "it", "has", "NUMBER", "then", "s", "Is", "there", "any", "update", "on", "this", "branch", "Our", "CRUD", "API", "be", "a", "bit", "inconvenient", "because", "you", "can", "t", "set", "values", "to", "null", "without", "use", "replace", "NUMBER", "I", "be", "considering", "add", "some", "other", "way", "of", "nullifying", "field", "but", "if", "null", "literal", "be", "about", "to", "land", "I", "d", "rather", "wait", "for", "it", "to", "happen", "NUMBER", "I", "can", "help", "landing", "this", "in", "graphql", "js", "if", "some", "work", "there", "be", "needed", "NUMBER", "If", "I", "may", "put", "my", "two", "cents", "in", "based", "on", "the", "SQL", "design", "we", "have", "to", "distinguish", "creation", "mutation", "from", "update", "mutation", "NUMBER", "NUMBER", "On", "INSERT", "when", "you", "don", "t", "specify", "a", "column", "value", "it", "s", "considered", "as", "NULL", "NUMBER", "NUMBER", "On", "UPDATE", "when", "you", "don", "t", "specify", "a", "column", "value", "it", "s", "considered", "unchanged", "and", "you", "have", "to", "explicitly", "set", "the", "column", "to", "NULL", "if", "you", "want", "to", "reset", "the", "corresponding", "value", "NUMBER", "IMO", "GraphQL", "have", "to", "keep", "this", "policy", "NUMBER", "Indeed", "when", "an", "update", "action", "be", "do", "on", "a", "table", "row", "user", "isn", "t", "always", "aware", "of", "the", "whole", "table", "schema", "despite", "of", "introspection", "and", "therefor", "should", "be", "able", "to", "omit", "column", "NUMBER", "There", "be", "two", "ways", "to", "reset", "a", "column", "in", "that", "situation", "Allow", "the", "use", "of", "null", "or", "any", "dedicated", "keyword", "in", "the", "request", "as", "a", "column", "value", "mutation", "editThing", "foo", "stuff", "bar", "null", "NUMBER", "Explicitly", "define", "a", "keyword", "attribute", "to", "reset", "columns", "mutation", "editThing", "change", "foo", "stuff", "reset", "bar", "NUMBER", "First", "solution", "seems", "more", "standard", "and", "be", "pretty", "straightforward", "to", "every", "readers", "NUMBER", "Second", "be", "also", "a", "valuable", "design", "but", "can", "lead", "to", "a", "lot", "of", "different", "implementation", "NUMBER", "If", "preferred", "it", "may", "be", "a", "good", "thing", "to", "define", "common", "keywords", "in", "the", "spec", "and", "stick", "to", "it", "to", "keep", "code", "understandable", "to", "everyone", "at", "first", "sight", "NUMBER", "Second", "solution", "be", "for", "now", "the", "only", "one", "to", "really", "work", "in", "production", "but", "I", "personally", "find", "that", "the", "code", "write", "be", "more", "complex", "to", "maintain", "compared", "to", "the", "first", "one", "cause", "it", "requires", "a", "special", "format", "in", "the", "front", "and", "back", "end", "NUMBER", "I", "certainly", "understand", "the", "argument", "around", "complexity", "that", "miss", "vs", "NUMBER", "specified", "null", "semantics", "introduces", "NUMBER", "I", "think", "a", "counter", "argument", "could", "also", "be", "made", "that", "enabling", "the", "CRUD", "model", "and", "be", "able", "to", "push", "null", "values", "be", "simpler", "for", "some", "scenarios", "since", "it", "presents", "a", "more", "direct", "migration", "path", "from", "REST", "style", "web", "services", "NUMBER", "We", "ve", "actually", "add", "support", "to", "our", "own", "GraphQL", "library", "for", "a", "null", "literal", "since", "supplying", "separate", "mutations", "for", "clearing", "values", "was", "not", "a", "good", "option", "in", "our", "case", "NUMBER", "I", "d", "like", "to", "add", "to", "danielkwinsor", "table", "more", "kind", "of", "types", "Int", "Int", "etc", "NUMBER", "How", "should", "input", "coercion", "work", "in", "this", "cases", "Int", "can", "be", "null", "or", "null", "NUMBER", "Int", "can", "be", "null", "null", "or", "invalid", "NUMBER", "Int", "can", "be", "null", "null", "null", "or", "invalid", "NUMBER", "Int", "can", "be", "null", "null", "or", "null", "NUMBER", "IMO", "it", "s", "very", "surprising", "that", "explicit", "null", "will", "be", "proper", "no", "list", "but", "implicit", "no", "value", "will", "be", "list", "s", "of", "single", "null", "or", "even", "invalid", "input", "NUMBER", "So", "I", "think", "it", "s", "a", "bad", "idea", "to", "coerce", "both", "explicit", "and", "implicit", "null", "to", "list", "NUMBER", "Same", "goes", "with", "nested", "nulls", "null", "won", "t", "silently", "coerce", "to", "null", "for", "Int", "it", "will", "stay", "null", "and", "for", "Int", "it", "will", "get", "rejected", "as", "invalid", "value", "NUMBER", "Thanks", "for", "the", "discussion", "I", "m", "still", "interested", "in", "furthering", "this", "and", "really", "happy", "to", "have", "some", "additional", "concerns", "tossed", "in", "that", "will", "help", "define", "clear", "behavior", "in", "the", "spec", "NUMBER", "I", "think", "the", "next", "step", "be", "prototyping", "this", "so", "the", "coercion", "rules", "can", "be", "toyed", "with", "until", "we", "have", "something", "that", "be", "both", "easy", "to", "explain", "and", "predict", "but", "be", "also", "valuable", "to", "solve", "the", "problem", "at", "hand", "Per", "danielkwinsor", "s", "comment", "I", "do", "think", "it", "d", "be", "good", "to", "eliminate", "the", "odd", "behavior", "that", "lists", "have", "when", "null", "be", "the", "input", "value", "even", "though", "this", "be", "probably", "tangential", "NUMBER", "Currently", "per", "the", "spec", "LINK", "sec", "Lists", "If", "the", "value", "pass", "as", "an", "input", "to", "a", "list", "type", "be", "not", "as", "list", "it", "should", "be", "coerced", "as", "though", "the", "input", "was", "a", "list", "of", "size", "one", "where", "the", "value", "pass", "be", "the", "only", "item", "in", "the", "list", "NUMBER", "This", "be", "to", "allow", "inputs", "that", "accept", "a", "var", "args", "to", "declare", "their", "input", "type", "as", "a", "list", "if", "only", "one", "argument", "be", "pass", "a", "common", "case", "the", "client", "can", "just", "pass", "that", "value", "rather", "than", "constructing", "the", "list", "NUMBER", "So", "if", "the", "input", "type", "be", "String", "and", "the", "provide", "value", "be", "null", "it", "seems", "that", "this", "would", "require", "that", "input", "to", "be", "interpreted", "as", "null", "and", "then", "subsequently", "reject", "it", "NUMBER", "I", "think", "this", "behavior", "would", "surprise", "most", "people", "and", "in", "fact", "I", "don", "t", "even", "think", "most", "implementations", "behave", "like", "this", "NUMBER", "As", "a", "side", "effect", "it", "also", "means", "that", "String", "be", "not", "really", "distinct", "from", "String", "NUMBER", "Perhaps", "we", "could", "add", "to", "the", "spec", "some", "language", "like", "this", "If", "the", "value", "pass", "as", "an", "input", "to", "a", "list", "type", "be", "not", "a", "list", "and", "be", "not", "null", "it", "should", "be", "coerced", "as", "though", "the", "input", "was", "a", "list", "of", "size", "one", "NUMBER", "That", "way", "if", "you", "really", "did", "want", "a", "list", "that", "has", "a", "single", "null", "value", "inside", "it", "you", "have", "to", "be", "explicit", "NUMBER", "In", "the", "far", "more", "likely", "case", "that", "you", "just", "wanted", "to", "ignore", "that", "argument", "input", "field", "you", "wouldn", "t", "get", "the", "curious", "null", "value", "instead", "NUMBER", "null", "as", "explicitly", "pass", "be", "not", "ambiguous", "NUMBER", "Coercion", "be", "NUMBER", "So", "if", "list", "may", "be", "coerced", "from", "single", "value", "I", "expect", "error", "instead", "NUMBER", "We", "be", "solving", "there", "same", "problem", "that", "be", "solve", "in", "SQL", "NUMBER", "Required", "list", "of", "required", "value", "be", "clear", "error", "for", "null", "Required", "list", "should", "be", "coerced", "to", "empty", "list", "NUMBER", "Backend", "then", "handle", "it", "as", "desired", "NUMBER", "Not", "required", "list", "should", "be", "treated", "as", "null", "NUMBER", "Is", "the", "change", "in", "LINK", "i", "NUMBER", "e", "NUMBER", "clarifying", "the", "spec", "re", "the", "non", "nullable", "input", "list", "just", "a", "proposal", "Can", "we", "expect", "to", "see", "this", "in", "graphql", "js", "any", "time", "soon", "String", "be", "not", "really", "distinct", "from", "String", "This", "be", "the", "problem", "I", "m", "hitting", "NUMBER", "I", "would", "like", "to", "have", "lists", "as", "optional", "input", "argument", "String", "but", "now", "clients", "must", "provide", "an", "empty", "list", "or", "I", "must", "remove", "the", "non", "null", "requirement", "on", "the", "Strings", "themselves", "NUMBER", "String", "should", "be", "coerced", "to", "null", "String", "should", "be", "coerced", "to", "empty", "list", "Party", "today", "null", "be", "in", "On", "Wed", "Oct", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "Lee", "Byron", "notifications", "github", "NUMBER", "com", "write", "Just", "get", "a", "careful", "review", "from", "dschafer", "LINK", "offline", "so", "merge", "this", "now", "NUMBER", "You", "be", "receiving", "this", "because", "you", "commented", "NUMBER", "Reply", "to", "this", "email", "directly", "view", "it", "on", "GitHub", "LINK", "issuecomment", "NUMBER", "or", "mute", "the", "thread", "LINK", "auth", "AAKjiN", "NUMBER", "CpvY", "NUMBER", "QhBukOMUHXsxbmnSTuDks", "NUMBER", "q", "NUMBER", "KTgaJpZM", "NUMBER", "FuxB", "NUMBER", "NUMBER", "Work", "in", "progress", "in", "LINK", "js", "pull", "NUMBER", "Thank", "you", "for", "this", "great", "work", "The", "idea", "be", "awesome", "and", "README", "NUMBER", "md", "itself", "was", "interesting", "to", "me", "NUMBER", "Is", "there", "any", "plan", "to", "write", "additional", "documentation", "for", "mutation", "on", "README", "NUMBER", "md", "Any", "progress", "on", "this", "The", "spec", "makes", "hardly", "any", "mention", "of", "mutations", "there", "s", "not", "even", "a", "section", "for", "it", "it", "s", "only", "mention", "in", "passing", "a", "few", "times", "NUMBER", "I", "can", "t", "seem", "to", "find", "much", "information", "about", "mutations", "beyond", "very", "basic", "examples", "on", "the", "web", "either", "NUMBER", "in", "section", "NUMBER", "md", "Take", "an", "example", "query", "for", "a", "trivial", "app", "NUMBER", "In", "this", "case", "there", "be", "a", "User", "type", "with", "three", "field", "id", "user", "and", "birthday", "NUMBER", "user", "should", "be", "name", "Take", "an", "example", "query", "for", "a", "trivial", "app", "NUMBER", "In", "this", "case", "there", "be", "a", "User", "type", "with", "three", "field", "id", "name", "and", "birthday", "NUMBER", "leebyron", "sir", "be", "there", "a", "skype", "channel", "or", "slack", "we", "can", "discuss", "some", "confusing", "in", "current", "spec", "take", "NUMBER", "for", "Atom", "LINK", "graphql", "syntax", "only", "looking", "forward", "to", "trying", "autocomplete", "Since", "I", "guess", "lots", "of", "people", "be", "use", "GraphGL", "for", "Android", "projects", "be", "it", "a", "good", "idea", "to", "make", "an", "IntelliJ", "plugin", "On", "my", "way", "I", "finished", "a", "basic", "version", "LINK", "intellij", "plugin", "leebyron", "Is", "it", "possible", "that", "the", "spec", "be", "a", "bit", "incomplete", "in", "respect", "to", "type", "definitions", "starting", "with", "input", "But", "the", "grammar", "at", "the", "end", "was", "extremly", "helpful", "thanks", "for", "that", "Looks", "like", "devknoll", "be", "on", "it", "NUMBER", "LINK", "LINK", "image", "LINK", "NUMBER", "f", "NUMBER", "NUMBER", "e", "NUMBER", "NUMBER", "cc", "d", "NUMBER", "d", "NUMBER", "c", "NUMBER", "b", "NUMBER", "png", "I", "ve", "created", "a", "GraphQL", "plugin", "for", "IntelliJ", "IDEA", "and", "WebStorm", "that", "relies", "on", "the", "JavaScript", "reference", "implementation", "NUMBER", "It", "provides", "roughly", "the", "same", "features", "as", "Graph_i_QL", "including", "schema", "aware", "completion", "error", "highlight", "and", "in", "editor", "schema", "documentation", "LINK", "graphql", "intellij", "plugin", "The", "integration", "between", "the", "Java", "based", "plugin", "and", "the", "reference", "implementation", "JavaScript", "parser", "be", "available", "as", "a", "Node", "NUMBER", "js", "based", "language", "service", "LINK", "graphql", "language", "service", "It", "might", "prove", "useful", "for", "enabling", "GraphQL", "language", "features", "in", "other", "IDEs", "much", "like", "the", "TypeScript", "language", "service", "did", "for", "Sublime", "and", "Atom", "NUMBER", "Awesome", "that", "looks", "way", "better", "than", "what", "I", "did", "I", "ll", "try", "it", "as", "soon", "as", "it", "be", "approved", "NUMBER", "Any", "idea", "how", "I", "can", "help", "the", "NUMBER", "downloaders", "of", "my", "plugin", "migrate", "to", "your", "plugin", "Edit", "I", "think", "I", "ll", "just", "put", "up", "a", "notification", "NUMBER", "Gregoor", "A", "notification", "should", "do", "the", "trick", "How", "long", "did", "it", "take", "to", "get", "your", "plugin", "approved", "In", "case", "you", "want", "early", "access", "to", "the", "plugin", "it", "can", "be", "downloaded", "from", "LINK", "graphql", "intellij", "plugin", "NUMBER", "js", "graphql", "intellij", "plugin", "NUMBER", "jar", "Just", "add", "it", "use", "Install", "plugin", "from", "disk", "NUMBER", "I", "think", "the", "approval", "process", "be", "bound", "to", "their", "NUMBER", "NUMBER", "work", "cycle", "in", "the", "czech", "republic", "NUMBER", "At", "least", "that", "s", "the", "feeling", "I", "get", "NUMBER", "Thanks", "for", "the", "direct", "link", "NUMBER", "I", "start", "on", "a", "Vim", "plugin", "LINK", "graphql", "It", "still", "needs", "work", "but", "handles", "file", "detection", "syntax", "highlight", "and", "folding", "pretty", "well", "so", "far", "NUMBER", "Can", "some", "one", "make", "a", "graphql", "package", "for", "lovely", "sublime", "text", "smile", "abdulhannanali", "I", "just", "release", "a", "GraphQL", "package", "for", "Sublime", "Text", "NUMBER", "LINK", "Right", "now", "be", "just", "a", "syntax", "highlighter", "but", "we", "plan", "to", "add", "autocompletion", "and", "almost", "all", "the", "capabilities", "we", "have", "with", "GraphiQL", "NUMBER", "Source", "code", "LINK", "python", "GraphQL", "SublimeText", "Autocomplete", "and", "lint", "from", "a", "GraphQL", "endpoint", "in", "atom", "NUMBER", "LINK", "graphql", "autocomplete", "TAG", "nicolaslopezj", "That", "s", "great", "news", "NUMBER", "Would", "you", "consider", "use", "LINK", "config", "method", "NUMBER", "configuration", "via", "graphqlrc", "file", "to", "configure", "the", "endpoint", "Yes", "I", "will", "nicolaslopezj", "that", "looks", "cool", "D", "I", "ve", "be", "work", "to", "provide", "a", "language", "service", "interface", "for", "GraphQL", "that", "could", "be", "use", "across", "common", "IDEs", "NUMBER", "It", "ll", "also", "support", "firing", "up", "the", "GraphQL", "server", "to", "cache", "schema", "fragment", "definitions", "etc", "to", "be", "use", "for", "validation", "autocomplete", "suggestions", "NUMBER", "The", "interface", "has", "methods", "to", "bring", "other", "common", "IDE", "features", "such", "as", "hyperlink", "outline", "views", "and", "etc", "NUMBER", "It", "s", "be", "developed", "and", "test", "with", "Nuclide", "but", "I", "thought", "this", "could", "be", "useful", "for", "Atom", "users", "as", "well", "it", "d", "be", "awesome", "if", "we", "can", "collaborate", "on", "make", "that", "happen", "For", "abdulhannanali", "and", "anyone", "else", "sad", "about", "the", "Sublime", "Text", "highlighter", "not", "work", "I", "just", "release", "one", "that", "do", "NUMBER", "LINK", "dncrews", "Thanks", "a", "lot", "dncrews", "will", "surely", "help", "people", "use", "Sublime", "but", "I", "have", "long", "moved", "to", "Visual", "Studio", "Code", "LINK", "heart", "Derailing", "this", "thread", "a", "bit", "because", "these", "be", "not", "IDEs", "but", "since", "we", "re", "talking", "syntax", "highlight", "some", "highlight", "libraries", "as", "of", "NUMBER", "March", "NUMBER", "Prism", "LINK", "JS", "do", "support", "GraphQL", "LINK", "Highlight", "NUMBER", "js", "LINK", "JS", "do", "not", "support", "GraphQL", "LINK", "Linguist", "LINK", "Ruby", "do", "support", "GraphQL", "LINK", "Pygments", "LINK", "Python", "do", "not", "support", "GraphQL", "LINK", "support", "languages", "but", "one", "might", "look", "into", "this", "LINK", "Let", "me", "know", "if", "you", "be", "aware", "of", "other", "ones", "NUMBER", "A", "port", "of", "jimkyndemeyer", "s", "GraphQL", "plugin", "for", "IntelliJ", "IDEA", "to", "work", "with", "Python", "file", "in", "the", "JetBrains", "IDE", "would", "be", "amazing", "as", "well", "NUMBER", "Currently", "the", "Python", "client", "toolset", "be", "very", "lacking", "and", "that", "be", "a", "pain", "that", "will", "interfere", "with", "GraphQL", "s", "growth", "NUMBER", "Could", "be", "awesome", "to", "see", "a", "plugin", "for", "PHPStorm", "jimkyndemeyer", "Awesome", "work", "Your", "plugin", "change", "my", "life", "in", "Javascript", "NUMBER", "Wondering", "though", "do", "you", "think", "it", "would", "be", "hard", "work", "to", "make", "it", "also", "autocomplete", "queries", "in", "PHP", "Heredoc", "Example", "php", "private", "function", "getQuery", "query", "TAG", "The", "GraphQL", "spec", "do", "not", "specify", "a", "maximum", "byte", "width", "or", "storage", "size", "for", "its", "Int", "and", "Float", "type", "This", "surprises", "me", "because", "as", "far", "as", "I", "understood", "from", "the", "spec", "Int", "GraphQL", "scalar", "type", "be", "NUMBER", "bit", "integer", "value", "The", "Int", "scalar", "type", "represents", "a", "sign", "NUMBER", "bit", "numeric", "non", "fractional", "values", "NUMBER", "Response", "formats", "that", "support", "a", "NUMBER", "bit", "integer", "or", "a", "number", "type", "should", "use", "that", "type", "to", "represent", "this", "scalar", "NUMBER", "LINK", "sec", "Int", "The", "same", "be", "for", "the", "float", "The", "Float", "scalar", "type", "represents", "sign", "double", "precision", "fractional", "values", "as", "specified", "by", "IEEE", "NUMBER", "Which", "means", "NUMBER", "bits", "according", "to", "the", "standard", "LINK", "precision_floating", "point_format", "Did", "I", "misunderstood", "the", "spec", "Since", "spec", "explicitly", "state", "that", "If", "the", "integer", "input", "value", "represents", "a", "value", "less", "than", "NUMBER", "or", "greater", "than", "or", "equal", "to", "NUMBER", "a", "query", "error", "should", "be", "raise", "NUMBER", "Does", "this", "mean", "that", "reference", "implementation", "do", "not", "conform", "to", "this", "part", "of", "the", "spec", "leebyron", "The", "spec", "doesn", "t", "limit", "the", "size", "of", "int", "tokens", "LINK", "sec", "Int", "Value", "The", "reference", "impl", "also", "doesn", "t", "check", "the", "size", "so", "it", "be", "possible", "to", "create", "a", "custom", "long", "scalar", "which", "allows", "the", "usage", "of", "int", "tokens", "literals", "as", "input", "NUMBER", "See", "LINK", "java", "pull", "NUMBER", "issuecomment", "NUMBER", "Is", "this", "intended", "or", "just", "a", "gap", "in", "the", "spec", "and", "the", "size", "of", "the", "int", "token", "should", "be", "limited", "Thanks", "Thanks", "for", "the", "quick", "response", "NUMBER", "After", "creating", "scala", "GraphQL", "implementation", "LINK", "graphql", "NUMBER", "org", "I", "must", "admit", "that", "the", "test", "quality", "and", "coverage", "of", "nodejs", "reference", "implemention", "LINK", "js", "be", "very", "good", "NUMBER", "In", "fact", "it", "helped", "me", "a", "lot", "during", "the", "development", "as", "well", "as", "the", "reference", "implementation", "itself", "of", "course", "NUMBER", "After", "re", "implement", "most", "of", "the", "test", "in", "scala", "I", "now", "pretty", "confident", "that", "most", "of", "the", "functionality", "be", "test", "NUMBER", "After", "seeing", "all", "these", "test", "it", "become", "apparent", "to", "me", "that", "there", "be", "a", "lot", "of", "edge", "cases", "and", "things", "that", "GraphQL", "library", "can", "get", "wrong", "especially", "in", "terms", "of", "semantics", "validation", "execution", "error", "handle", "etc", "NUMBER", "People", "be", "already", "created", "implementations", "in", "many", "different", "languages", "LINK", "graphql", "NUMBER", "I", "feel", "that", "it", "be", "important", "to", "create", "a", "TCK", "Technology", "Compatibility", "Kit", "for", "GraphQL", "specification", "in", "order", "to", "ensure", "success", "of", "GraphQL", "itself", "higher", "adoption", "and", "growth", "of", "the", "ecosystem", "NUMBER", "Having", "implement", "other", "specifications", "in", "the", "past", "I", "must", "admit", "that", "a", "TCK", "makes", "specification", "implementation", "much", "easier", "and", "faster", "process", "NUMBER", "It", "also", "helps", "to", "adopt", "an", "implementation", "as", "specification", "evolves", "NUMBER", "With", "TCK", "I", "mean", "a", "set", "of", "acceptance", "test", "that", "be", "distributed", "in", "some", "form", "as", "a", "library", "for", "instance", "and", "can", "be", "use", "by", "library", "authors", "to", "verify", "that", "their", "implementation", "confirms", "to", "the", "spec", "NUMBER", "Of", "course", "TCK", "can", "t", "cover", "all", "of", "the", "cases", "but", "at", "least", "it", "gives", "a", "good", "baseline", "and", "as", "ecosystem", "grows", "it", "ensures", "that", "all", "parts", "of", "it", "remain", "compatible", "with", "each", "other", "or", "at", "least", "minimizes", "risk", "of", "incompatibility", "NUMBER", "At", "the", "react", "europe", "conference", "I", "had", "a", "short", "conversation", "with", "schrockn", "about", "this", "topic", "NUMBER", "He", "said", "that", "there", "be", "plan", "for", "something", "like", "this", "so", "I", "wanted", "to", "follow", "up", "here", "and", "ask", "for", "more", "information", "NUMBER", "Do", "you", "still", "have", "plan", "to", "create", "something", "like", "a", "TCK", "for", "GraphQL", "spec", "If", "yes", "do", "you", "already", "have", "an", "idea", "which", "form", "it", "will", "take", "I", "guess", "implement", "something", "like", "this", "can", "be", "a", "challenging", "task", "considering", "that", "it", "suppose", "to", "test", "implementations", "write", "in", "different", "languages", "NUMBER", "As", "far", "as", "I", "saw", "test", "in", "the", "reference", "implementation", "be", "pretty", "generic", "many", "of", "them", "take", "some", "query", "execute", "it", "and", "then", "verify", "resulting", "JS", "object", "NUMBER", "At", "the", "moment", "they", "all", "implement", "in", "terms", "of", "the", "nodejs", "implementation", "but", "maybe", "they", "can", "be", "reused", "or", "extracted", "in", "the", "TCK", "somehow", "Thanks", "for", "the", "reply", "Glad", "to", "hear", "that", "you", "already", "thought", "about", "it", "NUMBER", "The", "approach", "you", "describe", "sounds", "good", "to", "me", "NUMBER", "I", "was", "also", "thinking", "about", "something", "like", "this", "NUMBER", "About", "the", "schema", "reference", "implementation", "now", "has", "a", "schema", "materialiser", "which", "also", "can", "be", "implement", "in", "other", "languages", "NUMBER", "Resulting", "schema", "do", "not", "contain", "the", "resolve", "method", "but", "even", "in", "this", "form", "it", "can", "be", "use", "for", "many", "test", "that", "do", "not", "require", "execution", "like", "query", "validation", "and", "parsing", "or", "introspection", "NUMBER", "As", "far", "as", "I", "saw", "even", "execution", "test", "have", "very", "similar", "resolve", "implementations", "which", "be", "in", "most", "cases", "fall", "in", "one", "of", "these", "categories", "successful", "resolve", "with", "null", "successful", "resolve", "with", "not", "null", "value", "successful", "resolve", "of", "promise", "with", "null", "successful", "resolve", "of", "promise", "with", "not", "null", "value", "exception", "be", "throw", "promise", "was", "resolve", "with", "failure", "Maybe", "we", "can", "create", "an", "enum", "of", "possible", "implementation", "behaviours", "and", "then", "enhance", "textual", "schema", "representation", "to", "include", "this", "information", "in", "some", "form", "NUMBER", "This", "will", "allow", "schema", "materialiser", "to", "create", "simple", "implementations", "of", "resolve", "method", "NUMBER", "This", "means", "that", "a", "test", "schema", "can", "be", "completely", "generate", "from", "textual", "description", "just", "like", "test", "cases", "NUMBER", "What", "do", "you", "think", "about", "this", "idea", "We", "start", "to", "work", "on", "compatibility", "acceptance", "test", "here", "LINK", "cats", "graphql", "cats", "If", "you", "be", "work", "on", "a", "GraphQL", "implementation", "it", "would", "be", "great", "if", "you", "could", "share", "your", "opinion", "and", "join", "us", "NUMBER", "Hello", "everybody", "there", "At", "first", "I", "want", "to", "say", "thanks", "to", "you", "guys", "who", "invent", "this", "small", "but", "powerful", "query", "language", "NUMBER", "But", "the", "main", "article", "of", "this", "issue", "that", "the", "license", "that", "apply", "to", "this", "specification", "be", "not", "fit", "this", "kind", "of", "things", "I", "think", "that", "BSD", "NUMBER", "Clause", "license", "better", "to", "apply", "to", "the", "source", "code", "but", "the", "specification", "should", "be", "licensed", "with", "Creative", "Common", "License", "NUMBER", "Creative", "Common", "License", "Attribution", "NUMBER", "Internation", "LINK", "I", "think", "be", "better", "NUMBER", "Thanks", "Closing", "this", "after", "discussing", "with", "folks", "in", "the", "know", "they", "decided", "it", "was", "best", "to", "continue", "to", "use", "a", "software", "license", "for", "this", "even", "though", "it", "s", "a", "little", "bit", "weird", "NUMBER", "This", "be", "a", "totally", "stylistic", "bikeshedding", "comment", "NUMBER", "but", "maybe", "worth", "considering", "if", "I", "m", "not", "miss", "something", "obvious", "NUMBER", "It", "seems", "like", "both", "the", "informal", "schema", "format", "and", "query", "variables", "could", "be", "simplified", "by", "eliminating", "the", "colon", "from", "type", "definitions", "and", "dollar", "sign", "from", "variables", "NUMBER", "Right", "now", "the", "colon", "be", "use", "in", "so", "many", "different", "contexts", "variables", "types", "interfaces", "aliases", "NUMBER", "The", "similarity", "between", "type", "definitions", "and", "passing", "argument", "in", "particular", "be", "mildly", "confusing", "NUMBER", "Why", "not", "change", "type", "Person", "NamedEntity", "name", "String", "gravatar", "height", "Int", "width", "Int", "Gravatar", "to", "type", "Person", "NamedEntity", "name", "String", "gravatar", "height", "Int", "width", "Int", "Gravatar", "The", "same", "with", "queries", "NUMBER", "Why", "not", "change", "query", "myQuery", "someTest", "Boolean", "size", "Boolean", "gravatar", "size", "size", "experimentalField", "include", "if", "someTest", "to", "query", "myQuery", "someTest", "Boolean", "size", "Boolean", "gravatar", "size", "size", "experimentalField", "include", "if", "someTest", "so", "that", "outer", "type", "definitions", "and", "inner", "argument", "don", "t", "look", "so", "similar", "NUMBER", "Finally", "be", "the", "dollar", "sign", "really", "required", "Why", "not", "just", "query", "myQuery", "someTest", "Boolean", "size", "Boolean", "gravatar", "size", "size", "experimentalField", "include", "if", "someTest", "Makes", "sense", "thanks", "NUMBER", "NUMBER", "I", "can", "understand", "why", "make", "types", "nullable", "by", "default", "might", "be", "a", "reasonable", "decision", "for", "growing", "systems", "add", "new", "features", "but", "I", "think", "there", "be", "reasons", "why", "this", "might", "not", "be", "ideal", "NUMBER", "This", "conflates", "the", "idea", "of", "nullability", "with", "provide", "reasonable", "default", "values", "NUMBER", "By", "allowing", "new", "features", "to", "be", "nullable", "by", "default", "we", "push", "more", "responsibility", "to", "the", "application", "logic", "for", "determining", "what", "might", "be", "the", "right", "behavior", "NUMBER", "NUMBER", "Because", "make", "types", "nullable", "be", "so", "easy", "in", "practice", "it", "promotes", "not", "considering", "if", "data", "should", "even", "be", "nullable", "or", "not", "NUMBER", "This", "could", "escalate", "the", "system", "s", "entropy", "more", "quickly", "make", "it", "hard", "to", "reason", "about", "the", "system", "s", "intended", "behaviour", "NUMBER", "I", "d", "love", "to", "hear", "other", "thoughts", "or", "ideas", "on", "this", "Just", "wanted", "to", "add", "my", "NUMBER", "cents", "NUMBER", "This", "topic", "also", "concerned", "me", "quite", "a", "bit", "so", "I", "glad", "that", "matthewcheok", "start", "this", "discussion", "NUMBER", "I", "definitely", "can", "see", "the", "advantages", "of", "nullable", "as", "a", "default", "NUMBER", "Backwards", "compatibility", "and", "error", "handle", "be", "good", "and", "valid", "argument", "in", "favor", "of", "it", "NUMBER", "Still", "I", "feel", "that", "in", "many", "cases", "not", "null", "default", "can", "be", "advantageous", "NUMBER", "In", "addition", "to", "matthewcheok", "argument", "which", "I", "agree", "with", "I", "also", "would", "like", "to", "point", "out", "these", "two", "aspects", "of", "it", "NUMBER", "In", "many", "programming", "languages", "this", "concept", "be", "implement", "as", "not", "null", "by", "default", "NUMBER", "I", "m", "come", "from", "scala", "background", "where", "nullable", "values", "be", "represented", "with", "Option", "type", "which", "serves", "as", "a", "container", "for", "nullable", "value", "NUMBER", "But", "scala", "be", "not", "the", "only", "example", "of", "it", "languages", "like", "kotlin", "groovy", "c", "haskell", "java", "etc", "NUMBER", "all", "share", "the", "same", "approach", "to", "this", "issue", "NUMBER", "Even", "the", "flow", "type", "checker", "which", "be", "heavily", "use", "in", "graphql", "js", "itself", "also", "takes", "this", "approach", "NUMBER", "I", "feel", "that", "nullable", "as", "a", "default", "can", "potentially", "confuse", "developers", "work", "with", "these", "languages", "which", "on", "itself", "can", "case", "frustration", "or", "even", "hard", "to", "find", "bug", "because", "of", "this", "mismatch", "NUMBER", "As", "a", "consequence", "of", "the", "first", "point", "I", "notice", "that", "it", "can", "be", "pretty", "challenging", "to", "implement", "this", "concept", "in", "statically", "typed", "languages", "which", "natively", "support", "maybe", "types", "like", "scala", "NUMBER", "I", "currently", "work", "on", "scala", "implementation", "of", "graphql", "NUMBER", "First", "I", "tried", "to", "implement", "not", "null", "type", "for", "schema", "definition", "DSL", "but", "at", "some", "point", "I", "gave", "up", "on", "this", "idea", "and", "decided", "to", "introduce", "OptionType", "LINK", "L", "NUMBER", "which", "replaces", "NotNullType", "in", "schema", "DSL", "it", "still", "work", "in", "progress", "so", "things", "can", "change", "dramatically", "in", "future", "but", "this", "what", "current", "state", "of", "implementation", "be", "NUMBER", "Of", "course", "it", "still", "will", "produce", "correct", "introspection", "results", "with", "nullable", "default", "and", "not", "null", "type", "according", "to", "the", "spec", "In", "addition", "to", "dschafer", "s", "points", "another", "fairly", "significant", "reason", "we", "chose", "to", "default", "to", "nullable", "values", "be", "the", "relative", "cost", "of", "change", "from", "one", "to", "the", "other", "once", "you", "have", "deployed", "a", "schema", "and", "have", "shipped", "clients", "which", "be", "consuming", "that", "schema", "NUMBER", "Consider", "the", "case", "that", "non", "null", "be", "the", "default", "and", "you", "set", "up", "a", "schema", "for", "a", "comment", "discussion", "feature", "type", "Comment", "author", "User", "message", "String", "Then", "you", "build", "Android", "and", "iOS", "apps", "and", "launch", "them", "NUMBER", "A", "week", "later", "you", "get", "bug", "report", "that", "comments", "be", "not", "work", "for", "some", "users", "NUMBER", "You", "dig", "in", "and", "realize", "that", "if", "a", "user", "delete", "their", "account", "the", "comments", "they", "left", "behind", "be", "still", "there", "but", "there", "be", "no", "longer", "an", "author", "to", "load", "so", "your", "servers", "be", "returning", "an", "error", "and", "as", "a", "consequence", "entire", "comments", "views", "don", "t", "load", "if", "they", "include", "a", "comment", "from", "a", "delete", "user", "NUMBER", "Let", "s", "fix", "this", "by", "change", "the", "schema", "so", "author", "can", "return", "null", "NUMBER", "type", "Comment", "author", "User", "message", "String", "This", "gets", "deployed", "and", "you", "check", "back", "in", "with", "your", "users", "who", "be", "report", "this", "issue", "NUMBER", "They", "should", "see", "comments", "now", "just", "without", "the", "author", "right", "Nope", "NUMBER", "Your", "users", "be", "now", "report", "that", "when", "they", "load", "a", "comment", "view", "their", "app", "crashes", "NUMBER", "What", "Null", "pointer", "exception", "NUMBER", "You", "were", "indexing", "directly", "into", "that", "comment", "NUMBER", "author", "NUMBER", "picture", "NUMBER", "url", "in", "your", "app", "code", "and", "at", "the", "time", "author", "was", "non", "nullable", "so", "that", "was", "safe", "NUMBER", "The", "server", "change", "you", "made", "was", "a", "breaking", "change", "NUMBER", "Yikes", "If", "the", "default", "had", "be", "nullable", "then", "your", "original", "schema", "as", "defined", "would", "have", "Just", "Worked", "NUMBER", "For", "clients", "that", "understand", "nullability", "Swift", "recent", "Java", "and", "ObjC", "to", "a", "degree", "they", "will", "warn", "you", "about", "accessing", "values", "without", "first", "checking", "for", "null", "NUMBER", "If", "you", "re", "checking", "null", "for", "something", "that", "you", "think", "should", "never", "be", "null", "then", "you", "can", "have", "that", "conversation", "and", "go", "alter", "the", "schema", "NUMBER", "Perhaps", "you", "decide", "that", "there", "s", "_always_", "a", "message", "an", "empty", "string", "can", "always", "suffice", "so", "you", "change", "the", "schema", "to", "improve", "developer", "ergonomics", "on", "the", "client", "type", "Comment", "author", "User", "message", "String", "Now", "we", "ve", "ended", "up", "at", "the", "same", "result", "but", "via", "the", "incremental", "application", "of", "_becoming", "more", "specific_", "rather", "than", "the", "late", "realization", "that", "you", "were", "_too", "specific", "from", "the", "start_", "and", "had", "to", "add", "breaking", "change", "to", "correct", "NUMBER", "In", "fact", "this", "change", "be", "totally", "safe", "NUMBER", "Any", "client", "that", "was", "previously", "checking", "for", "null", "will", "continue", "to", "work", "just", "fine", "NUMBER", "This", "tale", "be", "slightly", "contrived", "but", "we", "ve", "suffered", "through", "version", "of", "it", "at", "Facebook", "and", "it", "s", "a", "big", "part", "of", "why", "the", "default", "be", "nullable", "NUMBER", "As", "dschafer", "point", "out", "the", "probability", "that", "_something_", "will", "go", "wrong", "in", "the", "backend", "be", "more", "than", "NUMBER", "when", "loading", "data", "from", "storage", "which", "be", "what", "GraphQL", "be", "designed", "to", "help", "you", "do", "NUMBER", "In", "practice", "perhaps", "unfortunately", "most", "people", "do", "not", "think", "about", "nullability", "when", "designing", "their", "type", "systems", "NUMBER", "It", "s", "why", "most", "languages", "with", "strong", "types", "have", "no", "concept", "of", "non", "null", "vs", "nullable", "with", "the", "obvious", "exception", "of", "those", "inspired", "by", "functional", "programming", "NUMBER", "And", "of", "course", "nearly", "all", "dynamically", "typed", "languages", "have", "no", "concept", "of", "this", "either", "NUMBER", "If", "most", "people", "do", "not", "think", "about", "nullability", "we", "wanted", "to", "define", "the", "one", "that", "required", "less", "typing", "to", "be", "the", "safer", "of", "the", "two", "options", "and", "let", "the", "incremental", "application", "of", "knowledge", "to", "allow", "for", "improvement", "from", "that", "position", "NUMBER", "In", "many", "programming", "languages", "this", "concept", "be", "implement", "as", "not", "null", "by", "default", "NUMBER", "NUMBER", "I", "feel", "that", "nullable", "as", "a", "default", "can", "potentially", "confuse", "developers", "work", "with", "these", "languages", "Many", "but", "not", "the", "majority", "NUMBER", "I", "would", "contend", "that", "a", "non", "null", "default", "would", "cause", "more", "confusion", "from", "programmers", "of", "more", "mainstream", "imperative", "languages", "and", "not", "use", "to", "thinking", "about", "this", "concept", "at", "all", "than", "a", "nullable", "default", "would", "cause", "confusion", "from", "those", "who", "use", "languages", "where", "they", "must", "think", "about", "nullability", "when", "defining", "types", "all", "the", "type", "because", "they", "have", "access", "to", "Option", "Either", "Maybe", "NUMBER", "As", "a", "consequence", "of", "the", "first", "point", "I", "notice", "that", "it", "can", "be", "pretty", "challenging", "to", "implement", "this", "concept", "in", "statically", "typed", "languages", "which", "natively", "support", "maybe", "types", "like", "Scala", "NUMBER", "NUMBER", "and", "decided", "to", "introduce", "OptionType", "which", "replaces", "NotNullType", "in", "schema", "DSL", "NUMBER", "Of", "course", "it", "still", "will", "produce", "correct", "introspection", "results", "I", "strongly", "support", "this", "approach", "NUMBER", "Ultimately", "the", "default", "for", "nullability", "be", "a", "moot", "point", "when", "you", "have", "good", "GraphQL", "core", "libraries", "which", "respect", "the", "ergonomics", "of", "the", "particular", "language", "or", "environment", "NUMBER", "For", "strong", "typed", "languages", "that", "replace", "the", "concept", "of", "null", "with", "Maybe", "Option", "Either", "I", "would", "expect", "to", "use", "a", "GraphQL", "library", "in", "exactly", "the", "way", "you", "define", "NUMBER", "NUMBER", "For", "example", "LINK", "sec", "NUMBER", "html", "One", "place", "inconsistency", "NUMBER", "rotating_light", "Thanks", "for", "your", "work", "so", "far", "Looking", "forward", "to", "the", "final", "spec", "NUMBER", "Most", "likely", "a", "copy", "paste", "error", "from", "possibleTypes", "in", "Union", "right", "above", "NUMBER", "I", "think", "this", "example", "be", "valid", "because", "nickname", "be", "defined", "in", "Pet", "interface", "too", "NUMBER", "So", "I", "change", "it", "to", "barkVolume", "which", "be", "the", "field", "of", "a", "concrete", "implementor", "Dog", "NUMBER", "I", "didn", "t", "know", "about", "test", "in", "graphqh", "js", "NUMBER", "I", "replace", "my", "commit", "NUMBER", "If", "we", "have", "a", "simple", "query", "with", "only", "a", "SelectionSet", "hero", "name", "which", "be", "the", "same", "as", "query", "HeroNameQuery", "hero", "name", "The", "test", "in", "graphql", "NUMBER", "js", "show", "this", "expected", "answer", "data", "hero", "name", "R", "NUMBER", "D", "NUMBER", "I", "know", "we", "can", "have", "many", "root", "in", "one", "query", "query", "FetchLukeAndLeiaAliased", "luke", "human", "id", "NUMBER", "name", "leia", "human", "id", "NUMBER", "name", "Resulting", "in", "this", "answer", "data", "luke", "name", "Luke", "Skywalker", "leia", "name", "Leia", "Organa", "But", "and", "it", "s", "my", "main", "concern", "what", "if", "we", "have", "more", "that", "one", "operation", "in", "one", "query", "which", "seems", "to", "be", "valid", "in", "the", "specifications", "examples", "in", "LINK", "sec", "All", "Variable", "Uses", "Defined", "and", "LINK", "sec", "All", "Variables", "Used", "NUMBER", "For", "example", "what", "be", "the", "expected", "answer", "for", "this", "graphql", "query", "dumb", "query", "just", "for", "the", "example", "query", "LukeAndLeiaNames", "luke", "human", "id", "NUMBER", "name", "leia", "human", "id", "NUMBER", "name", "query", "LukeAndLeiaHomePlanet", "luke", "human", "id", "NUMBER", "homePlanet", "leia", "human", "id", "NUMBER", "homePlanet", "I", "currently", "have", "no", "idea", "except", "that", "there", "should", "be", "one", "more", "level", "between", "data", "and", "a", "query", "result", "use", "the", "name", "of", "the", "operation", "which", "must", "be", "unique", "in", "the", "document", "as", "said", "in", "the", "specification", "NUMBER", "Or", "each", "query", "have", "its", "own", "object", "response", "with", "data", "error", "NUMBER", "But", "in", "this", "case", "how", "be", "they", "encapsulated", "In", "a", "main", "object", "with", "the", "operation", "names", "use", "as", "keys", "I", "could", "not", "find", "anything", "about", "this", "in", "the", "specification", "or", "the", "graphql", "NUMBER", "js", "test", "NUMBER", "Thanks", "for", "your", "answer", "I", "m", "currently", "write", "a", "python", "graphql", "server", "and", "it", "will", "help", "me", "to", "know", "that", "dschafer", "thanks", "for", "your", "answer", "but", "it", "doesn", "t", "help", "me", "a", "lot", "NUMBER", "I", "understand", "how", "it", "be", "supposed", "to", "work", "internally", "NUMBER", "But", "let", "s", "forget", "the", "server", "consider", "it", "a", "black", "box", "and", "imagine", "I", "be", "a", "client", "NUMBER", "If", "I", "send", "this", "document", "query", "LukeAndLeiaNames", "luke", "human", "id", "NUMBER", "name", "leia", "human", "id", "NUMBER", "name", "query", "LukeAndLeiaHomePlanet", "luke", "human", "id", "NUMBER", "homePlanet", "leia", "human", "id", "NUMBER", "homePlanet", "What", "do", "I", "get", "in", "response", "from", "the", "server", "Ok", "I", "understand", "thank", "you", "NUMBER", "I", "understood", "that", "the", "executor", "could", "only", "handle", "one", "operation", "at", "a", "time", "but", "maybe", "it", "could", "have", "be", "call", "many", "times", "one", "operation", "after", "the", "other", "NUMBER", "So", "now", "what", "wonder", "me", "be", "NUMBER", "what", "s", "the", "point", "of", "having", "a", "document", "that", "can", "contains", "many", "operations", "And", "to", "finish", "how", "the", "client", "be", "supposed", "to", "send", "which", "operation", "to", "run", "if", "there", "be", "many", "operations", "in", "the", "document", "Until", "now", "I", "imagined", "graphql", "as", "a", "simple", "GraphQLQuery", "Server", "Response", "behavior", "NUMBER", "The", "client", "sending", "its", "query", "in", "string", "at", "a", "server", "endpoint", "NUMBER", "So", "I", "m", "a", "bit", "disappointed", "by", "this", "many", "operations", "document", "Ok", "thanks", "a", "lot", "for", "your", "answers", "NUMBER", "I", "start", "to", "think", "like", "that", "about", "the", "argument", "for", "the", "operation", "to", "run", "and", "for", "the", "storage", "of", "queries", "on", "the", "server", "like", "redis", "do", "for", "lua", "scripts", "NUMBER", "I", "now", "have", "a", "better", "understanding", "of", "the", "whole", "thing", "and", "can", "go", "back", "to", "my", "graphql", "server", "in", "python", "NUMBER", "Thanks", "a", "lot", "NUMBER", "Cheer", "up", "NUMBER", "Very", "fascinating", "read", "Thank", "you", "for", "open", "sourcing", "Looks", "like", "the", "_Input", "Coercion_", "paragraph", "of", "Non", "Null", "types", "in", "Section", "NUMBER", "Type", "System", "LINK", "NUMBER", "NUMBER", "NUMBER", "Type", "NUMBER", "System", "NUMBER", "md", "non", "null", "has", "incorrectly", "be", "copied", "from", "the", "section", "right", "above", "about", "Lists", "NUMBER", "Thank", "you", "for", "your", "pull", "request", "and", "welcome", "to", "our", "community", "NUMBER", "We", "require", "contributors", "to", "sign", "our", "Contributor", "License", "Agreement", "and", "we", "don", "t", "seem", "to", "have", "you", "on", "file", "NUMBER", "In", "order", "for", "us", "to", "review", "and", "merge", "your", "code", "please", "sign", "up", "at", "LINK", "and", "if", "you", "have", "received", "this", "in", "error", "or", "have", "any", "question", "please", "drop", "us", "a", "line", "at", "cla", "fb", "NUMBER", "com", "NUMBER", "Thanks", "Thank", "you", "for", "signing", "our", "Contributor", "License", "Agreement", "NUMBER", "We", "can", "now", "accept", "your", "code", "for", "this", "and", "any", "Facebook", "open", "source", "project", "NUMBER", "Thanks", "Hey", "facebook", "First", "of", "all", "thanks", "for", "open", "sourcing", "this", "I", "m", "so", "excited", "I", "forgot", "how", "to", "even", "NUMBER", "With", "that", "out", "of", "the", "way", "I", "have", "a", "question", "how", "be", "pagination", "implement", "in", "the", "facebook", "schema", "There", "be", "no", "mention", "of", "pagination", "in", "the", "spec", "so", "I", "assume", "be", "implement", "adhoc", "use", "the", "primitives", "provide", "by", "the", "spec", "NUMBER", "A", "hint", "on", "how", "to", "model", "this", "common", "use", "case", "would", "be", "really", "appreciated", "NUMBER", "What", "I", "have", "in", "mind", "be", "some", "be", "some", "Page", "type", "NUMBER", "Which", "yields", "the", "following", "question", "be", "it", "possible", "to", "define", "generic", "types", "the", "same", "way", "that", "List", "be", "defined", "Asking", "because", "ideally", "such", "Page", "type", "would", "be", "Page", "TAG", "Also", "I", "d", "also", "appreciate", "some", "advice", "on", "how", "to", "model", "querying", "for", "the", "count", "of", "a", "list", "property", "or", "a", "paginated", "property", "NUMBER", "In", "NUMBER", "Types", "of", "fragment", "LINK", "sec", "Types", "on", "fragment", "there", "be", "the", "following", "example", "query", "FragmentTyping", "profiles", "handles", "zuck", "cocacola", "handle", "NUMBER", "userFragment", "NUMBER", "pageFragment", "fragment", "userFragment", "on", "User", "friends", "count", "fragment", "pageFragment", "on", "Page", "likers", "count", "There", "be", "no", "schema", "attached", "for", "that", "example", "but", "as", "far", "as", "I", "understand", "those", "fragment", "be", "trying", "to", "get", "the", "total", "number", "of", "friends", "of", "a", "user", "and", "the", "total", "number", "of", "likes", "of", "a", "Page", "NUMBER", "It", "be", "hard", "to", "say", "without", "the", "schema", "but", "if", "we", "assume", "that", "a", "User", "has", "a", "List", "of", "Users", "the", "fist", "fragment", "be", "really", "querying", "for", "the", "property", "count", "in", "each", "individual", "User", "of", "said", "list", "and", "not", "the", "property", "count", "in", "the", "list", "itself", "which", "be", "the", "intention", "arguably", "NUMBER", "Any", "light", "in", "this", "topic", "would", "be", "very", "much", "appreciated", "NUMBER", "Thanks", "for", "open", "sourcing", "this", "and", "for", "your", "time", "NUMBER", "As", "far", "as", "what", "I", "ve", "seen", "in", "the", "past", "on", "GraphQL", "if", "you", "wanted", "pagination", "one", "schema", "you", "could", "use", "to", "achieve", "that", "would", "be", "type", "FriendList", "count", "Int", "edges", "User", "type", "User", "friends", "first", "Int", "after", "ID", "FriendList", "This", "should", "hopefully", "answer", "both", "of", "your", "question", "NUMBER", "Pagination", "would", "be", "implement", "by", "use", "the", "first", "and", "after", "field", "argument", "on", "friends", "and", "the", "count", "accessed", "would", "be", "on", "the", "type", "FriendList", "a", "wrapper", "over", "the", "list", "of", "User", "s", "NUMBER", "I", "m", "not", "entirely", "sure", "if", "this", "has", "be", "change", "so", "I", "would", "love", "to", "see", "leebyron", "pitch", "in", "too", "smile", "devknoll", "thanks", "for", "your", "response", "NUMBER", "Yup", "I", "guess", "something", "among", "those", "lines", "be", "always", "possible", "NUMBER", "There", "be", "some", "caveats", "with", "an", "approach", "be", "that", "you", "d", "have", "to", "duplicate", "the", "FriendList", "type", "for", "every", "type", "you", "want", "to", "paginate", "over", "PostList", "etc", "NUMBER", "This", "relate", "to", "the", "question", "I", "mention", "whether", "or", "not", "be", "possible", "to", "create", "generic", "types", "just", "like", "the", "native", "List", "NUMBER", "We", "don", "t", "support", "generic", "types", "like", "Page", "TAG", "as", "representing", "them", "client", "side", "can", "be", "really", "tricky", "NUMBER", "Is", "it", "a", "template", "type", "Is", "it", "a", "generic", "interface", "Lots", "of", "question", "and", "complexity", "we", "chose", "to", "avoid", "at", "least", "for", "now", "NUMBER", "devknoll", "you", "re", "pretty", "much", "on", "the", "money", "with", "that", "answer", "NUMBER", "We", "have", "a", "convention", "that", "we", "use", "at", "Facebook", "that", "we", "call", "Connection", "NUMBER", "We", "have", "some", "helper", "function", "on", "the", "server", "side", "that", "keep", "us", "from", "duplicating", "the", "work", "of", "implement", "this", "convention", "and", "avoids", "mistakes", "NUMBER", "That", "gets", "you", "most", "of", "the", "value", "you", "would", "get", "from", "having", "some", "kind", "of", "template", "type", "or", "generics", "NUMBER", "At", "Facebook", "it", "looks", "like", "this", "type", "UserConnection", "count", "Int", "nodes", "User", "edges", "UserConnectionEdge", "type", "UserConnectionEdge", "node", "User", "cursor", "String", "You", "can", "imagine", "replacing", "User", "with", "any", "type", "here", "and", "the", "type", "model", "still", "works", "NUMBER", "The", "nodes", "field", "be", "a", "shorthand", "for", "edges", "node", "NUMBER", "when", "all", "you", "want", "be", "the", "nodes", "at", "the", "end", "of", "the", "connection", "NUMBER", "edges", "also", "has", "cursor", "as", "a", "utility", "for", "performing", "pagination", "NUMBER", "Pagination", "in", "GraphQL", "at", "Facebook", "looks", "something", "like", "type", "User", "NUMBER", "friends", "after", "String", "first", "Int", "before", "String", "last", "Int", "UserConnection", "NUMBER", "So", "here", "the", "friends", "field", "on", "a", "User", "accepts", "a", "couple", "argument", "NUMBER", "after", "accepts", "a", "value", "that", "cursor", "gave", "you", "in", "a", "prior", "query", "and", "first", "limits", "how", "many", "items", "be", "returned", "NUMBER", "before", "and", "last", "be", "the", "same", "ideas", "but", "for", "paginating", "from", "the", "back", "of", "a", "list", "towards", "the", "front", "NUMBER", "So", "again", "_this", "be", "just", "a", "convention", "that", "Facebook", "uses_", "NUMBER", "GraphQL", "itself", "doesn", "t", "know", "what", "pagination", "be", "it", "just", "enable", "patterns", "like", "these", "NUMBER", "Underlying", "code", "be", "responsible", "for", "actually", "reading", "these", "argument", "and", "applying", "them", "in", "a", "sensible", "way", "NUMBER", "You", "could", "also", "imagine", "a", "much", "simpler", "pagination", "model", "that", "just", "do", "offset", "limit", "NUMBER", "There", "be", "some", "issue", "with", "this", "approach", "for", "example", "if", "the", "front", "of", "the", "list", "change", "often", "or", "when", "deep", "into", "a", "very", "long", "list", "but", "it", "s", "simplicity", "be", "compelling", "NUMBER", "In", "this", "model", "you", "might", "instead", "type", "things", "as", "type", "User", "NUMBER", "friends", "offset", "Int", "limit", "Int", "User", "NUMBER", "Now", "there", "s", "no", "additional", "Connection", "type", "at", "all", "I", "would", "suggest", "that", "offset", "and", "limit", "work", "here", "just", "as", "they", "do", "in", "SQL", "NUMBER", "dancer", "leebyron", "thanks", "I", "ll", "play", "around", "with", "this", "ideas", "NUMBER", "Thank", "you", "leebyron", "What", "do", "you", "think", "about", "documenting", "that", "pattern", "somewhere", "more", "visible", "than", "this", "issue", "leebyron", "I", "ve", "be", "playing", "with", "this", "and", "it", "works", "great", "NUMBER", "The", "duplication", "in", "the", "server", "be", "not", "a", "problem", "as", "you", "mention", "a", "function", "to", "define", "a", "connection", "type", "for", "a", "given", "types", "solves", "the", "problem", "just", "fine", "NUMBER", "I", "have", "a", "couple", "of", "follow", "up", "question", "and", "I", "was", "hoping", "you", "could", "shed", "some", "light", "type", "UserConnectionEdge", "node", "User", "cursor", "String", "why", "do", "you", "guys", "put", "the", "cursor", "of", "every", "node", "along", "with", "that", "node", "What", "s", "the", "use", "case", "behind", "this", "decision", "Wouldn", "t", "it", "be", "enough", "to", "have", "a", "before", "and", "after", "first", "and", "last", "item", "cursor", "at", "the", "connection", "level", "why", "do", "you", "call", "it", "connection", "I", "m", "just", "trying", "to", "understand", "the", "abstraction", "properly", "NUMBER", "I", "ve", "be", "thinking", "about", "it", "in", "terms", "of", "pages", "NUMBER", "I", "m", "wondering", "if", "there", "be", "any", "caveats", "NUMBER", "I", "m", "thinking", "to", "implement", "pagination", "like", "this", "NUMBER", "I", "d", "love", "feedback", "NUMBER", "type", "UserPage", "count", "Int", "nodes", "User", "after", "String", "before", "String", "and", "the", "entry", "point", "would", "be", "the", "same", "type", "User", "NUMBER", "friends", "offset", "Int", "limit", "Int", "User", "NUMBER", "Thank", "you", "so", "much", "in", "advance", "NUMBER", "leebyron", "Thanks", "for", "your", "informational", "reply", "NUMBER", "It", "s", "helped", "a", "lot", "So", "sorry", "to", "revive", "this", "old", "thread", "NUMBER", "but", "I", "m", "completely", "lost", "as", "to", "how", "to", "implement", "one", "piece", "of", "what", "you", "said", "after", "accepts", "a", "value", "that", "cursor", "gave", "you", "in", "a", "prior", "query", "Ok", "NUMBER", "and", "I", "ve", "definitely", "gotten", "that", "to", "work", "by", "taking", "a", "look", "at", "the", "edge", "cursors", "on", "the", "graphql", "response", "in", "my", "browser", "NUMBER", "Problem", "be", "NUMBER", "how", "do", "I", "make", "this", "work", "for", "the", "_first_", "page", "of", "items", "when", "I", "have", "no", "prior", "query", "to", "work", "from", "I", "tried", "leaving", "after", "as", "undefined", "in", "my", "query", "but", "I", "only", "get", "the", "following", "error", "Uncaught", "Invariant", "Violation", "callsFromGraphQL", "Expected", "a", "declared", "value", "for", "variable", "curs", "NUMBER", "It", "seems", "if", "you", "define", "first", "and", "after", "in", "your", "container", "s", "fragment", "then", "they", "re", "required", "parameters", "NUMBER", "But", "I", "have", "no", "value", "for", "after", "so", "how", "in", "the", "world", "do", "one", "initialize", "this", "Thanks", "RavenHursT", "ensure", "that", "your", "variable", "be", "not", "required", "NUMBER", "For", "example", "this", "query", "should", "error", "if", "no", "value", "be", "provide", "for", "after", "since", "it", "s", "required", "to", "be", "a", "non", "null", "string", "String", "NUMBER", "query", "Example", "after", "String", "someConnection", "after", "after", "count", "Where", "this", "example", "which", "accepts", "null", "just", "String", "should", "not", "error", "if", "no", "value", "be", "provide", "for", "after", "NUMBER", "This", "be", "considered", "best", "practice", "for", "use", "variables", "with", "pagination", "NUMBER", "query", "Example", "after", "String", "someConnection", "after", "after", "count", "leebyron", "yeah", "NUMBER", "turns", "out", "that", "you", "have", "to", "explicitly", "set", "default", "variables", "w", "null", "not", "just", "allow", "them", "to", "be", "undefined", "LINK", "pagination", "how", "to", "initialize", "after", "value", "NUMBER", "NUMBER", "Thanks", "NUMBER", "That", "sounds", "like", "a", "bug", "actually", "NUMBER", "What", "GraphQL", "library", "be", "you", "use", "graph", "js", "We", "re", "use", "express", "graphql", "We", "don", "t", "support", "generic", "types", "like", "Page", "TAG", "well", "it", "s", "work", "LINK", "With", "this", "Page", "template", "type", "for", "example", "js", "function", "Page", "Type", "return", "new", "ObjectType", "name", "Page", "Type", "description", "A", "simple", "pagination", "method", "nodes", "contains", "the", "actual", "list", "of", "data", "cursor", "be", "the", "end", "cursor", "or", "falsy", "if", "there", "be", "no", "more", "pages", "field", "nodes", "type", "new", "NonNull", "new", "List", "new", "NonNull", "Type", "cursor", "type", "String", "const", "QueryType", "new", "ObjectType", "name", "Query", "field", "foos", "type", "Page", "Foo", "args", "listArgs", "resolve", "_", "args", "getFoos", "args", "I", "m", "a", "developer", "of", "LoopBack", "LINK", "an", "open", "source", "Node", "NUMBER", "js", "framework", "for", "build", "APIs", "with", "rich", "data", "integrations", "NUMBER", "I", "m", "open", "this", "issue", "to", "explore", "the", "possibility", "of", "collaboration", "as", "both", "projects", "try", "to", "solve", "similar", "problem", "NUMBER", "LoopBack", "already", "provides", "a", "lot", "of", "capabilities", "as", "you", "outline", "in", "the", "GraphQL", "spec", "including", "NUMBER", "A", "JSON", "based", "definition", "language", "for", "data", "models", "types", "and", "validations", "LINK", "definition", "JSON", "file", "NUMBER", "Relations", "that", "connect", "models", "BelongsTo", "HasMany", "HasOne", "HasMany", "Through", "EmbedsMany", "ReferencesMany", "Polymorphic", "to", "form", "data", "graphs", "LINK", "model", "relations", "NUMBER", "A", "JSON", "based", "query", "language", "LINK", "data", "NUMBER", "A", "large", "list", "of", "connectors", "that", "implement", "the", "CRUD", "operations", "based", "on", "the", "specs", "LINK", "models", "to", "data", "sources", "What", "do", "you", "think", "PS", "I", "m", "not", "sure", "if", "this", "be", "a", "good", "way", "to", "reach", "out", "NUMBER", "Please", "let", "me", "know", "if", "we", "should", "take", "it", "offline", "NUMBER", "Thanks", "in", "advance", "NUMBER", "This", "be", "interesting", "feel", "free", "to", "drop", "me", "an", "email", "to", "talk", "more", "in", "depth", "NUMBER", "I", "m", "curious", "to", "know", "what", "you", "imagine", "a", "collaboration", "looking", "like", "in", "this", "case", "NUMBER", "Closing", "this", "NUMBER", "Looking", "forward", "to", "following", "up", "over", "email", "I", "would", "certainly", "be", "interested", "to", "know", "if", "anything", "came", "out", "of", "this", "exchange", "NUMBER", "I", "just", "read", "Start", "use", "GraphQL", "with", "Graffiti", "LINK", "use", "graphql", "with", "graffiti", "Graffiti", "provides", "an", "express", "middleware", "a", "hapi", "plugin", "and", "a", "koa", "middleware", "to", "convert", "your", "exist", "models", "into", "a", "GraphQL", "schema", "and", "exposes", "it", "over", "HTTP", "NUMBER", "This", "made", "me", "wonder", "if", "similarly", "a", "REST", "API", "designed", "with", "Loopback", "could", "also", "be", "automagically", "expose", "as", "a", "GraphQL", "endpoint", "NUMBER", "I", "m", "evaluating", "both", "hapi", "vs", "NUMBER", "loopback", "at", "this", "point", "NUMBER", "hi", "leebyron", "and", "sebastienbarre", "sorry", "for", "the", "late", "reply", "I", "m", "back", "from", "my", "vacation", "NUMBER", "coincidentally", "we", "re", "actually", "in", "the", "process", "of", "kickstarting", "a", "React", "SDK", "with", "another", "community", "member", "LucaColonnello", "NUMBER", "I", "can", "make", "some", "introductions", "via", "email", "NUMBER", "leebyron", "I", "have", "your", "thread", "from", "raymondfeng", "NUMBER", "sebastienbarre", "if", "your", "e", "interested", "please", "ping", "me", "at", "al", "at", "strongloop", "NUMBER", "com", "NUMBER", "LucaColonnello", "has", "put", "together", "a", "set", "of", "options", "in", "a", "proposal", "that", "you", "guys", "can", "review", "NUMBER", "Here", "at", "SL", "we", "re", "going", "take", "isomorphic", "LB", "in", "the", "browser", "strip", "it", "down", "to", "be", "more", "lightweight", "so", "that", "a", "React", "based", "MVC", "like", "Flux", "can", "bind", "to", "the", "JS", "objects", "directly", "to", "implement", "objects", "like", "Store", "NUMBER", "Yeah", "guys", "integrate", "GraphQL", "and", "Relay", "with", "Loopback", "with", "the", "in", "browser", "implementation", "could", "be", "great", "Now", "I", "m", "work", "on", "a", "demo", "made", "in", "React", "as", "a", "porting", "of", "the", "Angular", "once", "of", "the", "ToDo", "example", "NUMBER", "LucaColonnello", "do", "you", "mind", "posting", "the", "Gist", "and", "the", "slides", "so", "folks", "can", "get", "on", "the", "same", "page", "thx", "Oh", "Yeah", "these", "were", "only", "Draft", "but", "I", "think", "that", "work", "together", "we", "can", "create", "something", "really", "cool", "Example", "gist", "LINK", "Slides", "NUMBER", "com", "presentation", "of", "some", "ideas", "LINK", "sdk", "for", "loopback", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "ball", "NUMBER", "NUMBER", "NUMBER", "NUMBER", "wait", "I", "mean", "NUMBER", "NUMBER"], "text_count": [0, 42115, 9151, 3470, 1564, 590, 1877, 24, 386, 5670, 6594, 11213, 7029, 4197, 4526, 1518, 0, 0, 0, 0, 13386, 3803, 2472, 1614, 2477, 2085, 0, 0, 0, 0, 23149, 13757, 9626, 456, 6020, 1393, 0, 0, 0, 0, 27510, 199, 10014, 9516, 8775, 0, 0, 0, 0, 0, 8669, 4408, 4366, 2368, 3470, 1556, 3054, 0, 0, 0, 19345, 1245, 15131, 1704, 0, 0, 0, 0, 0, 0, 15652, 1888, 9881, 5255, 1995, 0, 0, 0, 0, 0, 26779, 11715, 2217, 11691, 1438, 996, 0, 0, 0, 0, 1308, 8939, 874, 0, 0, 0, 0, 0, 0, 0, 19709, 4242, 11019, 4481, 0, 0, 0, 0, 0, 0, 43235, 80630, 1040, 2801, 930, 1311, 0, 0, 0, 0, 107521, 593, 80262, 1306, 19680, 23873]}]